{"id": "sha256:16bc6f1252818cb1e4f51bd85fd8dc77cad7809756bc65e4bc57cb8dc24f989b", "content": "[[authentication]]\n\nSpring Security provides comprehensive support for https://en.wikipedia.org/wiki/Authentication[authentication].\nAuthentication is how we verify the identity of who is trying to access a particular resource.\nA common way to authenticate users is by requiring the user to enter a username and password.\nOnce authentication is performed we know the identity and can perform authorization.\n\nSpring Security provides built-in support for authenticating users.\nThis section is dedicated to generic authentication support that applies in both Servlet and WebFlux environments.\nRefer to the sections on authentication for xref:servlet/authentication/index.adoc[Servlet] and xref:reactive/authentication/index.adoc[WebFlux] for details on what is supported for each stack.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 0, "section_index": 0, "content_hash": "16bc6f1252818cb1e4f51bd85fd8dc77cad7809756bc65e4bc57cb8dc24f989b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/index.adoc"}}
{"id": "sha256:a2a4e7434009a10b574b52d0a8a86faa1dca70ed6ac32307dc2876f54a81d320", "content": "[[authentication-password-storage]]\n\nSpring Security's `PasswordEncoder` interface is used to perform a one-way transformation of a password to let the password be stored securely.\nGiven `PasswordEncoder` is a one-way transformation, it is not useful when the password transformation needs to be two-way (such as storing credentials used to authenticate to a database).\nTypically, `PasswordEncoder` is used for storing a password that needs to be compared to a user-provided password at the time of authentication.\n\n[[authentication-password-storage-history]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "password-storage", "heading_level": 1, "file_order": 1, "section_index": 0, "content_hash": "a2a4e7434009a10b574b52d0a8a86faa1dca70ed6ac32307dc2876f54a81d320", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:bb025816296fb7587a8261c57ba7acbc2d2bc1ddf31914a8e52a2294a5bde0b4", "content": "Throughout the years, the standard mechanism for storing passwords has evolved.\nIn the beginning, passwords were stored in plaintext.\nThe passwords were assumed to be safe because the data store the passwords were saved in required credentials to access it.\nHowever, malicious users were able to find ways to get large \"`data dumps`\" of usernames and passwords by using attacks such as SQL Injection.\nAs more and more user credentials became public, security experts realized that we needed to do more to protect users' passwords.\n\nDevelopers were then encouraged to store passwords after running them through a one way hash, such as SHA-256.\nWhen a user tried to authenticate, the hashed password would be compared to the hash of the password that they typed.\nThis meant that the system only needed to store the one-way hash of the password.\nIf a breach occurred, only the one-way hashes of the passwords were exposed.\nSince the hashes were one-way and it was computationally difficult to guess the passwords given the hash, it would not be worth the effort to figure out each password in the system.\nTo defeat this new system, malicious users decided to create lookup tables known as https://en.wikipedia.org/wiki/Rainbow_table[Rainbow Tables].\nRather than doing the work of guessing each password every time, they computed the password once and stored it in a lookup table.\n\nTo mitigate the effectiveness of Rainbow Tables, developers were encouraged to use salted passwords.\nInstead of using just the password as input to the hash function, random bytes (known as salt) would be generated for every user's password.\nThe salt and the user's password would be run through the hash function to produce a unique hash.\nThe salt would be stored alongside the user's password in clear text.\nThen when a user tried to authenticate, the hashed password would be compared to the hash of the stored salt and the password that they typed.\nThe unique salt meant that Rainbow Tables were no longer effective because the hash was different for every salt and password combination.\n\nIn modern times, we realize that cryptographic hashes (like SHA-256) are no longer secure.\nThe reason is that with modern hardware we can perform billions of hash calculations a second.\nThis means that we can crack each password individually with ease.\n\nDevelopers are now encouraged to leverage adaptive one-way functions to store a password.\nValidation of passwords with adaptive one-way functions are intentionally resource-intensive (they intentionally use a lot of CPU, memory, or other resources).\nAn adaptive one-way function allows configuring a \"`work factor`\" that can grow as hardware gets better.\nWe recommend that the \"`work factor`\" be tuned to take about one second to verify a password on your system.\nThis trade off is to make it difficult for attackers to crack the password, but not so costly that it puts excessive burden on your own system or irritates users.\nSpring Security has attempted to provide a good starting point for the \"`work factor`\", but we encourage users to customize the \"`work factor`\" for their own system, since the performance varies drastically from system to system.\nExamples of adaptive one-way functions that should be used include <<authentication-password-storage-bcrypt,bcrypt>>, <<authentication-password-storage-pbkdf2,PBKDF2>>, <<authentication-password-storage-scrypt,scrypt>>, and <<authentication-password-storage-argon2,argon2>>.\n\nBecause adaptive one-way functions are intentionally resource intensive, validating a username and password for every request can significantly degrade the performance of an application.\nThere is nothing Spring Security (or any other library) can do to speed up the validation of the password, since security is gained by making the validation resource intensive.\nUsers are encouraged to exchange the long term credentials (that is, username and password) for a short term credential (such as a session, and OAuth Token, and so on).\nThe short term credential can be validated quickly without any loss in security.\n\n[[authentication-password-storage-dpe]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Password Storage History", "heading_level": 2, "file_order": 1, "section_index": 1, "content_hash": "bb025816296fb7587a8261c57ba7acbc2d2bc1ddf31914a8e52a2294a5bde0b4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:e6c5c265af4d2ec8a5597e559fbe03999a9f84ca8300cf7c139d9c6d480aaf33", "content": "Prior to Spring Security 5.0, the default `PasswordEncoder` was `NoOpPasswordEncoder`, which required plain-text passwords.\nBased on the <<authentication-password-storage-history,Password History>> section, you might expect that the default `PasswordEncoder` would now be something like `BCryptPasswordEncoder`.\nHowever, this ignores three real world problems:\n\n- Many applications use old password encodings that cannot easily migrate.\n- The best practice for password storage will change again.\n- As a framework, Spring Security cannot make breaking changes frequently.\n\nInstead Spring Security introduces `DelegatingPasswordEncoder`, which solves all of the problems by:\n\n- Ensuring that passwords are encoded by using the current password storage recommendations\n- Allowing for validating passwords in modern and legacy formats\n- Allowing for upgrading the encoding in the future\n\nYou can easily construct an instance of `DelegatingPasswordEncoder` by using `PasswordEncoderFactories`:\n\n.Create Default DelegatingPasswordEncoder\ninclude-code::./DelegatingPasswordEncoderUsage[tag=createDefaultPasswordEncoder,indent=0]\n\nAlternatively, you can create your own custom instance:\n\n.Create Custom DelegatingPasswordEncoder\ninclude-code::./DelegatingPasswordEncoderUsage[tag=createCustomPasswordEncoder,indent=0]\n\n[[authentication-password-storage-dpe-format]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "DelegatingPasswordEncoder", "heading_level": 2, "file_order": 1, "section_index": 2, "content_hash": "e6c5c265af4d2ec8a5597e559fbe03999a9f84ca8300cf7c139d9c6d480aaf33", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:d6da8b5b981f8a9c6acf2f6c60e4f156176754bc119503280c629f73c465992b", "content": "The general format for a password is:\n\n.DelegatingPasswordEncoder Storage Format\n[source,text,attrs=\"-attributes\"]\n----\n{id}encodedPassword\n----\n\n`id` is an identifier that is used to look up which `PasswordEncoder` should be used and `encodedPassword` is the original encoded password for the selected `PasswordEncoder`.\nThe `id` must be at the beginning of the password, start with `{`, and end with `}`.\nIf the `id` cannot be found, the `id` is set to null.\nFor example, the following might be a list of passwords encoded using different `id` values.\nAll of the original passwords are `password`.\n\n.DelegatingPasswordEncoder Encoded Passwords Example\n[source,text,attrs=\"-attributes\"]\n----\n{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG // <1>\n{noop}password // <2>\n{pbkdf2}5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc // <3>\n{scrypt}$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc= // <4>\n{sha256}97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0 // <5>\n----\n\n<1> The first password has a `PasswordEncoder` id of `bcrypt` and an `encodedPassword` value of `$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG`.\nWhen matching, it would delegate to `BCryptPasswordEncoder`\n<2> The second password has a `PasswordEncoder` id of `noop` and `encodedPassword` value of `password`.\nWhen matching, it would delegate to `NoOpPasswordEncoder`\n<3> The third password has a `PasswordEncoder` id of `pbkdf2` and `encodedPassword` value of `5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc`.\nWhen matching, it would delegate to `Pbkdf2PasswordEncoder`\n<4> The fourth password has a `PasswordEncoder` id of `scrypt` and `encodedPassword` value of `$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc=`\nWhen matching, it would delegate to `SCryptPasswordEncoder`\n<5> The final password has a `PasswordEncoder` id of `sha256` and `encodedPassword` value of `97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0`.\nWhen matching, it would delegate to `StandardPasswordEncoder`\n\n[NOTE]\n====\nSome users might be concerned that the storage format is provided for a potential hacker.\nThis is not a concern because the storage of the password does not rely on the algorithm being a secret.\nAdditionally, most formats are easy for an attacker to figure out without the prefix.\nFor example, BCrypt passwords often start with `$2a$`.\n====\n\n[[authentication-password-storage-dpe-encoding]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Password Storage Format", "heading_level": 3, "file_order": 1, "section_index": 3, "content_hash": "d6da8b5b981f8a9c6acf2f6c60e4f156176754bc119503280c629f73c465992b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:7fec7fe97ca8a17bb4a59789e193a258d7f911e7a3065077f05557dd02d638ab", "content": "The `idForEncode` passed into the constructor determines which `PasswordEncoder` is used for encoding passwords.\nIn the `DelegatingPasswordEncoder` we constructed earlier, that means that the result of encoding `password` is delegated to `BCryptPasswordEncoder` and be prefixed with `+{bcrypt}+`.\nThe end result looks like the following example:\n\n.DelegatingPasswordEncoder Encode Example\n[source,text,attrs=\"-attributes\"]\n----\n{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG\n----\n\n[[authentication-password-storage-dpe-matching]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Password Encoding", "heading_level": 3, "file_order": 1, "section_index": 4, "content_hash": "7fec7fe97ca8a17bb4a59789e193a258d7f911e7a3065077f05557dd02d638ab", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:35d3fae2a8585e90f06e2bb6c7b6e0cd571ae1f607bfcbfde140e593821d54e1", "content": "Matching is based upon the `+{id}+` and the mapping of the `id` to the `PasswordEncoder` provided in the constructor.\nOur example in <<authentication-password-storage-dpe-format,Password Storage Format>> provides a working example of how this is done.\nBy default, the result of invoking `matches(CharSequence, String)` with a password and an `id` that is not mapped (including a null id) results in an `IllegalArgumentException`.\nThis behavior can be customized by using `DelegatingPasswordEncoder.setDefaultPasswordEncoderForMatches(PasswordEncoder)`.\n\nBy using the `id`, we can match on any password encoding but encode passwords by using the most modern password encoding.\nThis is important, because unlike encryption, password hashes are designed so that there is no simple way to recover the plaintext.\nSince there is no way to recover the plaintext, it is difficult to migrate the passwords.\nWhile it is simple for users to migrate `NoOpPasswordEncoder`, we chose to include it by default to make it simple for the getting-started experience.\n\n[[authentication-password-storage-dep-getting-started]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Password Matching", "heading_level": 3, "file_order": 1, "section_index": 5, "content_hash": "35d3fae2a8585e90f06e2bb6c7b6e0cd571ae1f607bfcbfde140e593821d54e1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:76117306c132bd031f23e741e644d5a9064f3861edc06d8f3d282334e7aea4af", "content": "If you are putting together a demo or a sample, it is a bit cumbersome to take time to hash the passwords of your users.\nThere are convenience mechanisms to make this easier, but this is still not intended for production.\n\n.withDefaultPasswordEncoder Example\ninclude-code::./WithDefaultPasswordEncoderUsage[tag=createSingleUser,indent=0]\n\nIf you are creating multiple users, you can also reuse the builder:\n\n.withDefaultPasswordEncoder Reusing the Builder\ninclude-code::./WithDefaultPasswordEncoderUsage[tag=createMultipleUsers,indent=0]\n\nThis does hash the password that is stored, but the passwords are still exposed in memory and in the compiled source code.\nTherefore, it is still not considered secure for a production environment.\nFor production, you should <<authentication-password-storage-boot-cli,hash your passwords externally>>.\n\n[[authentication-password-storage-boot-cli]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Getting Started Experience", "heading_level": 3, "file_order": 1, "section_index": 6, "content_hash": "76117306c132bd031f23e741e644d5a9064f3861edc06d8f3d282334e7aea4af", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:c7366f15c4d584254c8bfa4906231a67dbeff4f001c1c711cd8756cec94f8bd4", "content": "The easiest way to properly encode your password is to use the https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-cli.html[Spring Boot CLI].\n\nFor example, the following example encodes the password of `password` for use with <<authentication-password-storage-dpe>>:\n\n.Spring Boot CLI encodepassword Example\n[source,attrs=\"-attributes\"]\n----\nspring encodepassword password\n{bcrypt}$2a$10$X5wFBtLrL/kHcmrOGGTrGufsBX8CJ0WpQpF3pgeuxBB/H73BK1DW6\n----\n\n[[authentication-password-storage-dpe-troubleshoot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Encode with Spring Boot CLI", "heading_level": 3, "file_order": 1, "section_index": 7, "content_hash": "c7366f15c4d584254c8bfa4906231a67dbeff4f001c1c711cd8756cec94f8bd4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:94f1c2b682b66c783d04897a43dd6e09bd47de9835d73708dd5cc8fe5c912255", "content": "The following error occurs when one of the passwords that are stored has no `id`, as described in <<authentication-password-storage-dpe-format>>.\n\n----\njava.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id \"null\"\n\tat org.springframework.security.crypto.password.DelegatingPasswordEncoder$UnmappedIdPasswordEncoder.matches(DelegatingPasswordEncoder.java:233)\n\tat org.springframework.security.crypto.password.DelegatingPasswordEncoder.matches(DelegatingPasswordEncoder.java:196)\n----\n\nThe easiest way to resolve it is to figure out how your passwords are currently being stored and explicitly provide the correct `PasswordEncoder`.\n\nIf you are migrating from Spring Security 4.2.x, you can revert to the previous behavior by <<authentication-password-storage-configuration,exposing a `NoOpPasswordEncoder` bean>>.\n\nAlternatively, you can prefix all of your passwords with the correct `id` and continue to use `DelegatingPasswordEncoder`.\nFor example, if you are using BCrypt, you would migrate your password from something like:\n\n----\n$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG\n----\n\nto\n\n[source,attrs=\"-attributes\"]\n----\n{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG\n----\n\nFor a complete listing of the mappings, see the Javadoc for javadoc:org.springframework.security.crypto.factory.PasswordEncoderFactories[].\n\n[[authentication-password-storage-bcrypt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Troubleshooting", "heading_level": 3, "file_order": 1, "section_index": 8, "content_hash": "94f1c2b682b66c783d04897a43dd6e09bd47de9835d73708dd5cc8fe5c912255", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:ff7872371ad9c372f1a32c8a0afded79f07f9ae0643c23fa15af078f36b9615d", "content": "The `BCryptPasswordEncoder` implementation uses the widely supported https://en.wikipedia.org/wiki/Bcrypt[bcrypt] algorithm to hash the passwords.\nTo make it more resistant to password cracking, bcrypt is deliberately slow.\nLike other adaptive one-way functions, it should be tuned to take about 1 second to verify a password on your system.\nThe default implementation of `BCryptPasswordEncoder` uses strength 10 as mentioned in the Javadoc of javadoc:org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder[]. You are encouraged to\ntune and test the strength parameter on your own system so that it takes roughly 1 second to verify a password.\n\n.BCryptPasswordEncoder\ninclude-code::./BCryptPasswordEncoderUsage[tag=bcryptPasswordEncoder,indent=0]\n\n[[authentication-password-storage-argon2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "BCryptPasswordEncoder", "heading_level": 2, "file_order": 1, "section_index": 9, "content_hash": "ff7872371ad9c372f1a32c8a0afded79f07f9ae0643c23fa15af078f36b9615d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:ae6d562b348c837de97c326cbadfedb3cc3ecf574911292fcd885dcf06c14c02", "content": "The `Argon2PasswordEncoder` implementation uses the https://en.wikipedia.org/wiki/Argon2[Argon2] algorithm to hash the passwords.\nArgon2 is the winner of the https://en.wikipedia.org/wiki/Password_Hashing_Competition[Password Hashing Competition].\nTo defeat password cracking on custom hardware, Argon2 is a deliberately slow algorithm that requires large amounts of memory.\nLike other adaptive one-way functions, it should be tuned to take about 1 second to verify a password on your system.\nThe current implementation of the `Argon2PasswordEncoder` requires BouncyCastle.\n\n.Argon2PasswordEncoder\ninclude-code::./Argon2PasswordEncoderUsage[tag=argon2PasswordEncoder,indent=0]\n\n[[authentication-password-storage-pbkdf2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Argon2PasswordEncoder", "heading_level": 2, "file_order": 1, "section_index": 10, "content_hash": "ae6d562b348c837de97c326cbadfedb3cc3ecf574911292fcd885dcf06c14c02", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:daf9687729a2b05835ce91b49f564e6a578be396f4494282c85318a45f8e977a", "content": "The `Pbkdf2PasswordEncoder` implementation uses the https://en.wikipedia.org/wiki/PBKDF2[PBKDF2] algorithm to hash the passwords.\nTo defeat password cracking PBKDF2 is a deliberately slow algorithm.\nLike other adaptive one-way functions, it should be tuned to take about 1 second to verify a password on your system.\nThis algorithm is a good choice when FIPS certification is required.\n\n.Pbkdf2PasswordEncoder\ninclude-code::./Pbkdf2PasswordEncoderUsage[tag=pbkdf2PasswordEncoder,indent=0]\n\n[[authentication-password-storage-scrypt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Pbkdf2PasswordEncoder", "heading_level": 2, "file_order": 1, "section_index": 11, "content_hash": "daf9687729a2b05835ce91b49f564e6a578be396f4494282c85318a45f8e977a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:ca30581795362672a580aab83662e7a0432fc253161290059208f3310a065b0c", "content": "The `SCryptPasswordEncoder` implementation uses the https://en.wikipedia.org/wiki/Scrypt[scrypt] algorithm to hash the passwords.\nTo defeat password cracking on custom hardware, scrypt is a deliberately slow algorithm that requires large amounts of memory.\nLike other adaptive one-way functions, it should be tuned to take about 1 second to verify a password on your system.\n\n.SCryptPasswordEncoder\ninclude-code::./SCryptPasswordEncoderUsage[tag=sCryptPasswordEncoder,indent=0]\n\n[[authentication-password-storage-other]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "SCryptPasswordEncoder", "heading_level": 2, "file_order": 1, "section_index": 12, "content_hash": "ca30581795362672a580aab83662e7a0432fc253161290059208f3310a065b0c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:5a8f1380660a0bc46d00e6f994d0b88ebbc40bd479a8e896820608188c317014", "content": "There are a significant number of other `PasswordEncoder` implementations that exist entirely for backward compatibility.\nThey are all deprecated to indicate that they are no longer considered secure.\nHowever, there are no plans to remove them, since it is difficult to migrate existing legacy systems.\n\n[[password4j]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Other ``PasswordEncoder``s", "heading_level": 2, "file_order": 1, "section_index": 13, "content_hash": "5a8f1380660a0bc46d00e6f994d0b88ebbc40bd479a8e896820608188c317014", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:bf7ed100f786ac58dc084d54c9c4e795830d0c477f528931f27a4ad94a8c2dd3", "content": "Spring Security 7.0 introduces alternative password encoder implementations based on the https://github.com/Password4j/password4j[Password4j] library.\nThese encoders provide additional options for popular hashing algorithms and can be used as alternatives to the existing Spring Security implementations.\n\nThe Password4j library is a Java cryptographic library that focuses on password hashing with support for multiple algorithms.\nThese encoders are particularly useful when you need specific algorithm configurations or want to leverage Password4j's optimizations.\n\nAll Password4j-based encoders are thread-safe and can be shared across multiple threads.\n\n[[password4j-argon2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Password4j-based Password Encoders", "heading_level": 2, "file_order": 1, "section_index": 14, "content_hash": "bf7ed100f786ac58dc084d54c9c4e795830d0c477f528931f27a4ad94a8c2dd3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:2c0d9d038c9f6682b8f838ef46fe805670f44b6b811a02ac07faca5ab40abe47", "content": "The `Argon2Password4jPasswordEncoder` implementation uses the https://en.wikipedia.org/wiki/Argon2[Argon2] algorithm via the Password4j library to hash passwords.\nThis provides an alternative to Spring Security's built-in `Argon2PasswordEncoder` with different configuration options and potential performance characteristics.\n\nArgon2 is the winner of the https://en.wikipedia.org/wiki/Password_Hashing_Competition[Password Hashing Competition] and is recommended for new applications.\nThis implementation leverages Password4j's Argon2 support which properly includes the salt in the output hash.\n\nCreate an encoder with default settings:\n\n.Argon2Password4jPasswordEncoder\ninclude-code::./Argon2UsageTests[tag=default-params,indent=0]\n\nCreate an encoder with custom Argon2 parameters:\n\n.Argon2Password4jPasswordEncoder Custom\ninclude-code::./Argon2UsageTests[tag=custom-params,indent=0]\n\n[[password4j-bcrypt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Argon2Password4jPasswordEncoder", "heading_level": 3, "file_order": 1, "section_index": 15, "content_hash": "2c0d9d038c9f6682b8f838ef46fe805670f44b6b811a02ac07faca5ab40abe47", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:f3172a3adcb951fb58f0e1f51e7e9fa0feee13d3b4b814ef5eea07821b6f9dbe", "content": "The `BcryptPassword4jPasswordEncoder` implementation uses the https://en.wikipedia.org/wiki/Bcrypt[BCrypt] algorithm via the Password4j library to hash passwords.\nThis provides an alternative to Spring Security's built-in `BCryptPasswordEncoder` with Password4j's implementation characteristics.\n\nBCrypt is a well-established password hashing algorithm that includes built-in salt generation and is resistant to rainbow table attacks.\nThis implementation leverages Password4j's BCrypt support which properly includes the salt in the output hash.\n\nCreate an encoder with default settings:\n\n.BcryptPassword4jPasswordEncoder\ninclude-code::./BcryptUsageTests[tag=default-params,indent=0]\n\nCreate an encoder with custom bcrypt parameters:\n\n.BcryptPassword4jPasswordEncoder Custom\ninclude-code::./BcryptUsageTests[tag=custom-params,indent=0]\n\n[[password4j-scrypt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "BcryptPassword4jPasswordEncoder", "heading_level": 3, "file_order": 1, "section_index": 16, "content_hash": "f3172a3adcb951fb58f0e1f51e7e9fa0feee13d3b4b814ef5eea07821b6f9dbe", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:6a0aea49bfce7c19eede8723f25606d546a089a2d8f3e6d7dad159cd57ec67c5", "content": "The `ScryptPassword4jPasswordEncoder` implementation uses the https://en.wikipedia.org/wiki/Scrypt[SCrypt] algorithm via the Password4j library to hash passwords.\nThis provides an alternative to Spring Security's built-in `SCryptPasswordEncoder` with Password4j's implementation characteristics.\n\nSCrypt is a memory-hard password hashing algorithm designed to be resistant to hardware brute-force attacks.\nThis implementation leverages Password4j's SCrypt support which properly includes the salt in the output hash.\n\nCreate an encoder with default settings:\n\n.ScryptPassword4jPasswordEncoder\ninclude-code::./ScryptUsageTests[tag=default-params,indent=0]\n\nCreate an encoder with custom scrypt parameters:\n\n.ScryptPassword4jPasswordEncoder Custom\ninclude-code::./ScryptUsageTests[tag=custom-params,indent=0]\n\n[[password4j-pbkdf2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "ScryptPassword4jPasswordEncoder", "heading_level": 3, "file_order": 1, "section_index": 17, "content_hash": "6a0aea49bfce7c19eede8723f25606d546a089a2d8f3e6d7dad159cd57ec67c5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:4e5ca4f07ef7a1b5c4269cf6fcac96fb5e91eef9918dc571c6f8fb5dd79df227", "content": "The `Pbkdf2Password4jPasswordEncoder` implementation uses the https://en.wikipedia.org/wiki/PBKDF2[PBKDF2] algorithm via the Password4j library to hash passwords.\nThis provides an alternative to Spring Security's built-in `Pbkdf2PasswordEncoder` with explicit salt management.\n\nPBKDF2 is a key derivation function designed to be computationally expensive to thwart dictionary and brute force attacks.\nThis implementation handles salt management explicitly since Password4j's PBKDF2 implementation does not include the salt in the output hash.\nThe encoded password format is: `+{salt}:{hash}+` where both salt and hash are Base64 encoded.\n\nCreate an encoder with default settings:\n\n.Pbkdf2Password4jPasswordEncoder\ninclude-code::./Pbkdf2UsageTests[tag=default-params,indent=0]\n\nCreate an encoder with custom PBKDF2 parameters:\n\n.Pbkdf2Password4jPasswordEncoder Custom\ninclude-code::./Pbkdf2UsageTests[tag=custom-params,indent=0]\n\n[[password4j-ballooning]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Pbkdf2Password4jPasswordEncoder", "heading_level": 3, "file_order": 1, "section_index": 18, "content_hash": "4e5ca4f07ef7a1b5c4269cf6fcac96fb5e91eef9918dc571c6f8fb5dd79df227", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:e400206301ac57d6091d77ffda3dfbab282419b30bbfedeb6c97b72fe3cdcc59", "content": "The `BalloonHashingPassword4jPasswordEncoder` implementation uses the Balloon hashing algorithm via the Password4j library to hash passwords.\nBalloon hashing is a memory-hard password hashing algorithm designed to be resistant to both time-memory trade-off attacks and side-channel attacks.\n\nThis implementation handles salt management explicitly since Password4j's Balloon hashing implementation does not include the salt in the output hash.\nThe encoded password format is: `+{salt}:{hash}+` where both salt and hash are Base64 encoded.\n\nCreate an encoder with default settings:\n\n.BalloonHashingPassword4jPasswordEncoder\ninclude-code::./BallooningHashingUsageTests[tag=default-params,indent=0]\n\nCreate an encoder with custom parameters:\n\n.BalloonHashingPassword4jPasswordEncoder Custom\ninclude-code::./BallooningHashingUsageTests[tag=custom-params,indent=0]\n\n[[authentication-password-storage-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "BalloonHashingPassword4jPasswordEncoder", "heading_level": 3, "file_order": 1, "section_index": 19, "content_hash": "e400206301ac57d6091d77ffda3dfbab282419b30bbfedeb6c97b72fe3cdcc59", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:5d65745078fb6653b42545d5a89b98608a1c82358ae60322348710ab4e8466c7", "content": "Spring Security uses <<authentication-password-storage-dpe>> by default.\nHowever, you can customize this by exposing a `PasswordEncoder` as a Spring bean.\n\nIf you are migrating from Spring Security 4.2.x, you can revert to the previous behavior by exposing a `NoOpPasswordEncoder` bean.\n\n[WARNING]\n====\nReverting to `NoOpPasswordEncoder` is not considered to be secure.\nYou should instead migrate to using `DelegatingPasswordEncoder` to support secure password encoding.\n====\n\n.NoOpPasswordEncoder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic static NoOpPasswordEncoder passwordEncoder() {\n return NoOpPasswordEncoder.getInstance();\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<b:bean id=\"passwordEncoder\"\n class=\"org.springframework.security.crypto.password.NoOpPasswordEncoder\" factory-method=\"getInstance\"/>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun passwordEncoder(): PasswordEncoder {\n return NoOpPasswordEncoder.getInstance();\n}\n----\n======\n\n[NOTE]\n====\nXML Configuration requires the `NoOpPasswordEncoder` bean name to be `passwordEncoder`.\n====\n\n[[authentication-change-password-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Password Storage Configuration", "heading_level": 2, "file_order": 1, "section_index": 20, "content_hash": "5d65745078fb6653b42545d5a89b98608a1c82358ae60322348710ab4e8466c7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:14caab7c6e73169ef4e1eb7602b5a630365436f3b7e96f22f7e1b7b0edb559fc", "content": "Most applications that allow a user to specify a password also require a feature for updating that password.\n\nhttps://w3c.github.io/webappsec-change-password-url/[A Well-Known URL for Changing Passwords] indicates a mechanism by which password managers can discover the password update endpoint for a given application.\n\nYou can configure Spring Security to provide this discovery endpoint.\nFor example, if the change password endpoint in your application is `/change-password`, then you can configure Spring Security like so:\n\n.Default Change Password Endpoint\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .passwordManagement(Customizer.withDefaults())\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<sec:password-management/>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n passwordManagement { }\n}\n----\n======\n\nThen, when a password manager navigates to `/.well-known/change-password` then Spring Security will redirect your endpoint, `/change-password`.\n\nOr, if your endpoint is something other than `/change-password`, you can also specify that like so:\n\n.Change Password Endpoint\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .passwordManagement((management) -> management\n .changePasswordPage(\"/update-password\")\n )\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<sec:password-management change-password-page=\"/update-password\"/>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n passwordManagement {\n changePasswordPage = \"/update-password\"\n }\n}\n----\n======\n\nWith the above configuration, when a password manager navigates to `/.well-known/change-password`, then Spring Security will redirect to `/update-password`.\n\n[[authentication-compromised-password-check]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Change Password Configuration", "heading_level": 2, "file_order": 1, "section_index": 21, "content_hash": "14caab7c6e73169ef4e1eb7602b5a630365436f3b7e96f22f7e1b7b0edb559fc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:3cbb1bd2f3cc2001c2f381d33a5d48a2ff0d294f2bd6f4b934cacaa558ba043a", "content": "There are some scenarios where you need to check whether a password has been compromised, for example, if you are creating an application that deals with sensitive data, it is often needed that you perform some check on user's passwords in order to assert its reliability.\nOne of these checks can be if the password has been compromised, usually because it has been found in a https://wikipedia.org/wiki/Data_breach[data breach].\n\nTo facilitate that, Spring Security provides integration with the https://haveibeenpwned.com/API/v3#PwnedPasswords[Have I Been Pwned API] via the javadoc:org.springframework.security.web.authentication.password.HaveIBeenPwnedRestApiPasswordChecker[] implementation of the javadoc:org.springframework.security.authentication.password.CompromisedPasswordChecker[] interface.\n\nYou can either use the `CompromisedPasswordChecker` API by yourself or, if you are using xref:servlet/authentication/passwords/dao-authentication-provider.adoc[the `DaoAuthenticationProvider]` via xref:servlet/authentication/passwords/index.adoc[Spring Security authentication mechanisms], you can provide a `CompromisedPasswordChecker` bean, and it will be automatically picked up by Spring Security configuration.\n\nBy doing that, when you try to authenticate via Form Login using a weak password, let's say `123456`, you will receive a 401 or be redirected to the `/login?error` page (depending on your user-agent).\nHowever, just a 401 or the redirect is not so useful in that case, it will cause some confusion because the user provided the right password and still was not allowed to log in.\nIn such cases, you can handle the `CompromisedPasswordException` via the `AuthenticationFailureHandler` to perform your desired logic, like redirecting the user-agent to `/reset-password`, for example:\n\n.Using CompromisedPasswordChecker\ninclude-code::./CompromisedPasswordCheckerUsage[tag=configuration,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authentication/password-storage.adoc", "title": "password-storage", "heading": "Compromised Password Checking", "heading_level": 2, "file_order": 1, "section_index": 22, "content_hash": "3cbb1bd2f3cc2001c2f381d33a5d48a2ff0d294f2bd6f4b934cacaa558ba043a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authentication/password-storage.adoc"}}
{"id": "sha256:1ba292c1681aa022a0fc0ac5f6ff78cb6efc08f1f3111578ec3ffeecfd094f34", "content": "[[authorization]]\n\nSpring Security provides comprehensive support for https://en.wikipedia.org/wiki/Authorization[authorization].\nAuthorization is determining who is allowed to access a particular resource.\nSpring Security provides https://en.wikipedia.org/wiki/Defense_in_depth_(computing)[defense in depth] by allowing for request based authorization and method based authorization.\n\n[[authorization-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authorization/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 2, "section_index": 0, "content_hash": "1ba292c1681aa022a0fc0ac5f6ff78cb6efc08f1f3111578ec3ffeecfd094f34", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authorization/index.adoc"}}
{"id": "sha256:704d2bbc73e97121c6d05c67a8e6bbe80c8aaa80974836824103ac8105fe6e15", "content": "Spring Security provides authorization based upon the request for both xref:servlet/authorization/authorize-http-requests.adoc[Servlet] and xref:reactive/authorization/authorize-http-requests.adoc[WebFlux] environments.\n\n[[authorization-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authorization/index.adoc", "title": "index", "heading": "Request Based Authorization", "heading_level": 2, "file_order": 2, "section_index": 1, "content_hash": "704d2bbc73e97121c6d05c67a8e6bbe80c8aaa80974836824103ac8105fe6e15", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authorization/index.adoc"}}
{"id": "sha256:69ff9b8a8c23a9664e79091780454329254371c844f720ede82bbb6561227598", "content": "Spring Security provides authorization based on the method invocation for both xref:servlet/authorization/method-security.adoc[Servlet] and xref:reactive/authorization/method.adoc[WebFlux] environments.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/authorization/index.adoc", "title": "index", "heading": "Method Based Authorization", "heading_level": 2, "file_order": 2, "section_index": 2, "content_hash": "69ff9b8a8c23a9664e79091780454329254371c844f720ede82bbb6561227598", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/authorization/index.adoc"}}
{"id": "sha256:090b6bee52f61c1838083bec932623f7497e3f056d4473c076eb7b489b955da8", "content": "[[csrf]]\n\nSpring provides comprehensive support for protecting against https://en.wikipedia.org/wiki/Cross-site_request_forgery[Cross Site Request Forgery (CSRF)] attacks.\nIn the following sections, we explore:\n\n* <<csrf-explained>>\n* <<csrf-protection>>\n* <<csrf-considerations>>\n\n[NOTE]\n====\nThis portion of the documentation discusses the general topic of CSRF protection.\nSee the relevant sections for specific information on CSRF protection for xref:servlet/exploits/csrf.adoc#servlet-csrf[servlet] and xref:reactive/exploits/csrf.adoc#webflux-csrf[WebFlux] based applications.\n====\n\n[[csrf-explained]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "csrf", "heading_level": 1, "file_order": 3, "section_index": 0, "content_hash": "090b6bee52f61c1838083bec932623f7497e3f056d4473c076eb7b489b955da8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:d4ccc5d156af1fa5520c2875254b32a5f82b9f98f8a6277faa4a2c3053ca1649", "content": "The best way to understand a CSRF attack is by taking a look at a concrete example.\n\nAssume that your bank's website provides a form that allows transferring money from the currently logged in user to another bank account.\nFor example, the transfer form might look like:\n\n.Transfer form\n[source,html]\n----\n<form method=\"post\"\n\taction=\"/transfer\">\n<input type=\"text\"\n\tname=\"amount\"/>\n<input type=\"text\"\n\tname=\"routingNumber\"/>\n<input type=\"text\"\n\tname=\"account\"/>\n<input type=\"submit\"\n\tvalue=\"Transfer\"/>\n</form>\n----\n\nThe corresponding HTTP request might look like:\n\n.Transfer HTTP request\n[source]\n----\nPOST /transfer HTTP/1.1\nHost: bank.example.com\nCookie: JSESSIONID=randomid\nContent-Type: application/x-www-form-urlencoded\n\namount=100.00&routingNumber=1234&account=9876\n----\n\nNow pretend you authenticate to your bank's website and then, without logging out, visit an evil website.\nThe evil website contains an HTML page with the following form:\n\n.Evil transfer form\n[source,html]\n----\n<form method=\"post\"\n\taction=\"https://bank.example.com/transfer\">\n<input type=\"hidden\"\n\tname=\"amount\"\n\tvalue=\"100.00\"/>\n<input type=\"hidden\"\n\tname=\"routingNumber\"\n\tvalue=\"evilsRoutingNumber\"/>\n<input type=\"hidden\"\n\tname=\"account\"\n\tvalue=\"evilsAccountNumber\"/>\n<input type=\"submit\"\n\tvalue=\"Win Money!\"/>\n</form>\n----\n\nYou like to win money, so you click on the submit button.\nIn the process, you have unintentionally transferred $100 to a malicious user.\nThis happens because, while the evil website cannot see your cookies, the cookies associated with your bank are still sent along with the request.\n\nWorse yet, this whole process could have been automated by using JavaScript.\nThis means you did not even need to click on the button.\nFurthermore, it could just as easily happen when visiting an honest site that is a victim of a https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)[XSS attack].\nSo how do we protect our users from such attacks?\n\n[[csrf-protection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "What is a CSRF Attack?", "heading_level": 2, "file_order": 3, "section_index": 1, "content_hash": "d4ccc5d156af1fa5520c2875254b32a5f82b9f98f8a6277faa4a2c3053ca1649", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:abd4f782ee767a450c15711876e849ae7975b8cfc0e5ba86d56a0b9f626f12f9", "content": "The reason that a CSRF attack is possible is that the HTTP request from the victim's website and the request from the attacker's website are exactly the same.\nThis means there is no way to reject requests coming from the evil website and allow only requests coming from the bank's website.\nTo protect against CSRF attacks, we need to ensure there is something in the request that the evil site is unable to provide so we can differentiate the two requests.\n\nSpring provides two mechanisms to protect against CSRF attacks:\n\n* The <<Synchronizer Token Pattern>>\n* Specifying the <<SameSite Attribute>> on your session cookie\n\n[NOTE]\n====\nBoth protections require that <<csrf-protection-read-only,Safe Methods be Read-only>>.\n====\n\n[[csrf-protection-read-only]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "Protecting Against CSRF Attacks", "heading_level": 2, "file_order": 3, "section_index": 2, "content_hash": "abd4f782ee767a450c15711876e849ae7975b8cfc0e5ba86d56a0b9f626f12f9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:ec8872033357a8bddf7da47d54f41e817146fa88f9d93915ccd3abe83eb0090d", "content": "For <<csrf-protection,either protection>> against CSRF to work, the application must ensure that https://tools.ietf.org/html/rfc7231#section-4.2.1[\"safe\" HTTP methods are read-only].\nThis means that requests with the HTTP `GET`, `HEAD`, `OPTIONS`, and `TRACE` methods should not change the state of the application.\n\n[[csrf-protection-stp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "Safe Methods Must be Read-only", "heading_level": 3, "file_order": 3, "section_index": 3, "content_hash": "ec8872033357a8bddf7da47d54f41e817146fa88f9d93915ccd3abe83eb0090d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:134c05d5a923fb0248f3d0c989a707a23dfe1414dcd09aecc94eb9c20f147ef8", "content": "The predominant and most comprehensive way to protect against CSRF attacks is to use the https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern[Synchronizer Token Pattern].\nThis solution is to ensure that each HTTP request requires, in addition to our session cookie, a secure random generated value called a CSRF token be present in the HTTP request.\n\nWhen an HTTP request is submitted, the server must look up the expected CSRF token and compare it against the actual CSRF token in the HTTP request.\nIf the values do not match, the HTTP request should be rejected.\n\nThe key to this working is that the actual CSRF token should be in a part of the HTTP request that is not automatically included by the browser.\nFor example, requiring the actual CSRF token in an HTTP parameter or an HTTP header will protect against CSRF attacks.\nRequiring the actual CSRF token in a cookie does not work because cookies are automatically included in the HTTP request by the browser.\n\nWe can relax the expectations to require only the actual CSRF token for each HTTP request that updates the state of the application.\nFor that to work, our application must ensure that <<csrf-protection-read-only,safe HTTP methods are read-only>>.\nThis improves usability, since we want to allow linking to our website from external sites.\nAdditionally, we do not want to include the random token in HTTP GET, as this can cause the tokens to be leaked.\n\nConsider how <<csrf-explained,our example>> would change when we use the Synchronizer Token Pattern.\nAssume that the actual CSRF token is required to be in an HTTP parameter named `_csrf`.\nOur application's transfer form would look like:\n\n.Synchronizer Token Form\n[source,html]\n----\n<form method=\"post\"\n\taction=\"/transfer\">\n<input type=\"hidden\"\n\tname=\"_csrf\"\n\tvalue=\"4bfd1575-3ad1-4d21-96c7-4ef2d9f86721\"/>\n<input type=\"text\"\n\tname=\"amount\"/>\n<input type=\"text\"\n\tname=\"routingNumber\"/>\n<input type=\"hidden\"\n\tname=\"account\"/>\n<input type=\"submit\"\n\tvalue=\"Transfer\"/>\n</form>\n----\n\nThe form now contains a hidden input with the value of the CSRF token.\nExternal sites cannot read the CSRF token since the same origin policy ensures the evil site cannot read the response.\n\nThe corresponding HTTP request to transfer money would look like this:\n\n.Synchronizer Token request\n[source]\n----\nPOST /transfer HTTP/1.1\nHost: bank.example.com\nCookie: JSESSIONID=randomid\nContent-Type: application/x-www-form-urlencoded\n\namount=100.00&routingNumber=1234&account=9876&_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721\n----\n\nYou will notice that the HTTP request now contains the `_csrf` parameter with a secure random value.\nThe evil website will not be able to provide the correct value for the `_csrf` parameter (which must be explicitly provided on the evil website) and the transfer will fail when the server compares the actual CSRF token to the expected CSRF token.\n\n[[csrf-protection-ssa]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "Synchronizer Token Pattern", "heading_level": 3, "file_order": 3, "section_index": 4, "content_hash": "134c05d5a923fb0248f3d0c989a707a23dfe1414dcd09aecc94eb9c20f147ef8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:62355fc5d0cb5f25f1ce5e0db8b676709a42e342e5ca3b26595e2ac62ead6938", "content": "An emerging way to protect against <<csrf,CSRF Attacks>> is to specify the https://tools.ietf.org/html/draft-west-first-party-cookies[SameSite Attribute] on cookies.\nA server can specify the `SameSite` attribute when setting a cookie to indicate that the cookie should not be sent when coming from external sites.\n\n[NOTE]\n====\nSpring Security does not directly control the creation of the session cookie, so it does not provide support for the SameSite attribute.\nhttps://spring.io/projects/spring-session[Spring Session] provides support for the `SameSite` attribute in servlet-based applications.\nSpring Framework's https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/session/CookieWebSessionIdResolver.html[`CookieWebSessionIdResolver`] provides out of the box support for the `SameSite` attribute in WebFlux-based applications.\n====\n\nAn example, of an HTTP response header with the `SameSite` attribute might look like:\n\n.SameSite HTTP response\n[source]\n----\nSet-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax\n----\n\nValid values for the `SameSite` attribute are:\n\n* `Strict`: When specified, any request coming from the https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1[same-site] includes the cookie.\nOtherwise, the cookie is not included in the HTTP request.\n* `Lax`: When specified, cookies are sent when coming from the https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1[same-site] or when the request comes from top-level navigations and the <<Safe Methods Must be Read-only,method is read-only>>.\nOtherwise, the cookie is not included in the HTTP request.\n\nConsider how <<csrf-explained,our example>> could be protected using the `SameSite` attribute.\nThe bank application can protect against CSRF by specifying the `SameSite` attribute on the session cookie.\n\nWith the `SameSite` attribute set on our session cookie, the browser continues to send the `JSESSIONID` cookie with requests coming from the banking website.\nHowever, the browser no longer sends the `JSESSIONID` cookie with a transfer request coming from the evil website.\nSince the session is no longer present in the transfer request coming from the evil website, the application is protected from the CSRF attack.\n\nThere are some important https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-5[considerations] to be aware of when using `SameSite` attribute to protect against CSRF attacks.\n\nSetting the `SameSite` attribute to `Strict` provides a stronger defense but can confuse users.\nConsider a user who stays logged into a social media site hosted at https://social.example.com.\nThe user receives an email at https://email.example.org that includes a link to the social media site.\nIf the user clicks on the link, they would rightfully expect to be authenticated to the social media site.\nHowever, if the `SameSite` attribute is `Strict`, the cookie would not be sent and so the user would not be authenticated.\n\nAnother obvious consideration is that, in order for the `SameSite` attribute to protect users, the browser must support the `SameSite` attribute.\nMost modern browsers do https://developer.mozilla.org/en-US/docs/Web/HTTP/headers/Set-Cookie#Browser_compatibility[support the SameSite attribute].\nHowever, older browsers that are still in use may not.\n\nFor this reason, we generally recommend using the `SameSite` attribute as a defense in depth rather than the sole protection against CSRF attacks.\n\n[[csrf-when]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "SameSite Attribute", "heading_level": 3, "file_order": 3, "section_index": 5, "content_hash": "62355fc5d0cb5f25f1ce5e0db8b676709a42e342e5ca3b26595e2ac62ead6938", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:492eae6427efb52e1f05d845c4bce0e85dfa76f9c31dbdc91a0d4da9a617d2b3", "content": "When should you use CSRF protection?\nOur recommendation is to use CSRF protection for any request that could be processed by a browser by normal users.\nIf you are creating a service that is used only by non-browser clients, you likely want to disable CSRF protection.\n\n[[csrf-when-json]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "When to use CSRF protection", "heading_level": 2, "file_order": 3, "section_index": 6, "content_hash": "492eae6427efb52e1f05d845c4bce0e85dfa76f9c31dbdc91a0d4da9a617d2b3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:bb3c9aa9afa26fa8e282835150898623cdca6d381c3a9fd17f7e22d0d4c58602", "content": "A common question is \"`do I need to protect JSON requests made by JavaScript?`\"\nThe short answer is: It depends.\nHowever, you must be very careful, as there are CSRF exploits that can impact JSON requests.\nFor example, a malicious user can create a http://blog.opensecurityresearch.com/2012/02/json-csrf-with-parameter-padding.html[CSRF with JSON by using the following form]:\n\n.CSRF with JSON form\n[source,html]\n----\n<form action=\"https://bank.example.com/transfer\" method=\"post\" enctype=\"text/plain\">\n\t<input name='{\"amount\":100,\"routingNumber\":\"evilsRoutingNumber\",\"account\":\"evilsAccountNumber\", \"ignore_me\":\"' value='test\"}' type='hidden'>\n\t<input type=\"submit\"\n value=\"Win Money!\"/>\n</form>\n----\n\nThis produces the following JSON structure\n\n.CSRF with JSON request\n[source,javascript]\n----\n{ \"amount\": 100,\n\"routingNumber\": \"evilsRoutingNumber\",\n\"account\": \"evilsAccountNumber\",\n\"ignore_me\": \"=test\"\n}\n----\n\nIf an application were not validating the `Content-Type` header, it would be exposed to this exploit.\nDepending on the setup, a Spring MVC application that validates the Content-Type could still be exploited by updating the URL suffix to end with `.json`, as follows:\n\n.CSRF with JSON Spring MVC form\n[source,html]\n----\n<form action=\"https://bank.example.com/transfer.json\" method=\"post\" enctype=\"text/plain\">\n\t<input name='{\"amount\":100,\"routingNumber\":\"evilsRoutingNumber\",\"account\":\"evilsAccountNumber\", \"ignore_me\":\"' value='test\"}' type='hidden'>\n\t<input type=\"submit\"\n value=\"Win Money!\"/>\n</form>\n----\n\n[[csrf-when-stateless]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "CSRF protection and JSON", "heading_level": 3, "file_order": 3, "section_index": 7, "content_hash": "bb3c9aa9afa26fa8e282835150898623cdca6d381c3a9fd17f7e22d0d4c58602", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:94558604441ae28a5f827b57103050e5ee5f5bbe1cadbf9b75633c398af94f65", "content": "What if my application is stateless?\nThat does not necessarily mean you are protected.\nIn fact, if a user does not need to perform any actions in the web browser for a given request, they are likely still vulnerable to CSRF attacks.\n\nFor example, consider an application that uses a custom cookie that contains all the state within it for authentication (instead of the JSESSIONID).\nWhen the CSRF attack is made, the custom cookie is sent with the request in the same manner that the JSESSIONID cookie was sent in our previous example.\nThis application is vulnerable to CSRF attacks.\n\nApplications that use basic authentication are also vulnerable to CSRF attacks.\nThe application is vulnerable since the browser automatically includes the username and password in any requests in the same manner that the JSESSIONID cookie was sent in our previous example.\n\n[[csrf-considerations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "CSRF and Stateless Browser Applications", "heading_level": 3, "file_order": 3, "section_index": 8, "content_hash": "94558604441ae28a5f827b57103050e5ee5f5bbe1cadbf9b75633c398af94f65", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:67478a82dda38f9645710d21d3dcfee2a10fc2f642ef2499f72ab053e4e3ee73", "content": "There are a few special considerations to consider when implementing protection against CSRF attacks.\n\n[[csrf-considerations-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "CSRF Considerations", "heading_level": 2, "file_order": 3, "section_index": 9, "content_hash": "67478a82dda38f9645710d21d3dcfee2a10fc2f642ef2499f72ab053e4e3ee73", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:7bda31f1881df14c27c787aec6c1e81f30982bb5c466c1702f2be9466394e772", "content": "To protect against https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests[forging login requests], the login HTTP request should be protected against CSRF attacks.\nProtecting against forging login requests is necessary so that a malicious user cannot read a victim's sensitive information.\nThe attack is performed as follows:\n\n. A malicious user performs a CSRF login with the malicious user's credentials.\nThe victim is now authenticated as the malicious user.\n. The malicious user then tricks the victim into visiting the compromised website and entering sensitive information.\n. The information is associated to the malicious user's account so the malicious user can log in with their own credentials and view the victim's sensitive information.\n\nA possible complication to ensuring login HTTP requests are protected against CSRF attacks is that the user might experience a session timeout that causes the request to be rejected.\nA session timeout is surprising to users who do not expect to need to have a session to log in.\nFor more information refer to <<csrf-considerations-timeouts>>.\n\n[[csrf-considerations-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "Logging In", "heading_level": 3, "file_order": 3, "section_index": 10, "content_hash": "7bda31f1881df14c27c787aec6c1e81f30982bb5c466c1702f2be9466394e772", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:3efcaa0b00902ab1aebd45600ee075f239d0772f5ee62c898ed824b1cabc45da", "content": "To protect against forging logout requests, the logout HTTP request should be protected against CSRF attacks.\nProtecting against forging logout requests is necessary so that a malicious user cannot read a victim's sensitive information.\nFor details on the attack, see https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/[this blog post].\n\nA possible complication to ensuring logout HTTP requests are protected against CSRF attacks is that the user might experience a session timeout that causes the request to be rejected.\nA session timeout is surprising to users who do not expect to have a session to log out.\nFor more information, see <<csrf-considerations-timeouts>>.\n\n[[csrf-considerations-timeouts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "Logging Out", "heading_level": 3, "file_order": 3, "section_index": 11, "content_hash": "3efcaa0b00902ab1aebd45600ee075f239d0772f5ee62c898ed824b1cabc45da", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:2ffd56dd670dd28189d7f02560a81e6843ca0e0f25b56b2e1e6881ccf4cc80ba", "content": "More often than not, the expected CSRF token is stored in the session.\nThis means that, as soon as the session expires, the server does not find an expected CSRF token and rejects the HTTP request.\nThere are a number of options (each of which come with trade offs) to solve timeouts:\n\n* The best way to mitigate the timeout is by using JavaScript to request a CSRF token on form submission.\nThe form is then updated with the CSRF token and submitted.\n* Another option is to have some JavaScript that lets the user know their session is about to expire.\nThe user can click a button to continue and refresh the session.\n* Finally, the expected CSRF token could be stored in a cookie.\nThis lets the expected CSRF token outlive the session.\n+\nOne might ask why the expected CSRF token is not stored in a cookie by default.\nThis is because there are known exploits in which headers (for example, to specify the cookies) can be set by another domain.\nThis is the same reason Ruby on Rails https://rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails[no longer skips a CSRF checks when the header X-Requested-With is present].\nSee https://web.archive.org/web/20210221120355/https://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html[this webappsec.org thread] for details on how to perform the exploit.\nAnother disadvantage is that by removing the state (that is, the timeout), you lose the ability to forcibly invalidate the token if it is compromised.\n\n[[csrf-considerations-multipart]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "CSRF and Session Timeouts", "heading_level": 3, "file_order": 3, "section_index": 12, "content_hash": "2ffd56dd670dd28189d7f02560a81e6843ca0e0f25b56b2e1e6881ccf4cc80ba", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:34e7eb103ce81e0e707bb673d461effc8b90233379972fe42aebb6797f231492", "content": "Protecting multipart requests (file uploads) from CSRF attacks causes a https://en.wikipedia.org/wiki/Chicken_or_the_egg[chicken or the egg] problem.\nTo prevent a CSRF attack from occurring, the body of the HTTP request must be read to obtain the actual CSRF token.\nHowever, reading the body means that the file is uploaded, which means an external site can upload a file.\n\nThere are two options to using CSRF protection with multipart/form-data:\n\n* <<csrf-considerations-multipart-body,Place CSRF Token in the Body>>\n* <<csrf-considerations-multipart-url,Place CSRF Token in the URL>>\n\nEach option has its trade-offs.\n\n[NOTE]\n====\nBefore you integrate Spring Security's CSRF protection with multipart file upload, you should first ensure that you can upload without the CSRF protection.\nMore information about using multipart forms with Spring, see the https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart[1.1.11. Multipart Resolver] section of the Spring reference and the https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html[`MultipartFilter` Javadoc].\n====\n\n[[csrf-considerations-multipart-body]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "Multipart (file upload)", "heading_level": 3, "file_order": 3, "section_index": 13, "content_hash": "34e7eb103ce81e0e707bb673d461effc8b90233379972fe42aebb6797f231492", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:1f1514014830c728559b2f69d95923ae5c92f7d605f5ef07ab66522c9da4ddc3", "content": "The first option is to include the actual CSRF token in the body of the request.\nBy placing the CSRF token in the body, the body is read before authorization is performed.\nThis means that anyone can place temporary files on your server.\nHowever, only authorized users can submit a file that is processed by your application.\nIn general, this is the recommended approach, because the temporary file upload should have a negligible impact on most servers.\n\n[[csrf-considerations-multipart-url]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "Place CSRF Token in the Body", "heading_level": 4, "file_order": 3, "section_index": 14, "content_hash": "1f1514014830c728559b2f69d95923ae5c92f7d605f5ef07ab66522c9da4ddc3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:01532d0bfd32a3ffa284f1830ccf4ae4cc93fd39ae1be02369bed843854d7e7a", "content": "If letting unauthorized users upload temporary files is not acceptable, an alternative is to include the expected CSRF token as a query parameter in the action attribute of the form.\nThe disadvantage to this approach is that query parameters can be leaked.\nMore generally, it is considered best practice to place sensitive data within the body or headers to ensure it is not leaked.\nYou can find additional information in https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3[RFC 2616 Section 15.1.3 Encoding Sensitive Information in URI's].\n\n[[csrf-considerations-override-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "Include CSRF Token in URL", "heading_level": 4, "file_order": 3, "section_index": 15, "content_hash": "01532d0bfd32a3ffa284f1830ccf4ae4cc93fd39ae1be02369bed843854d7e7a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:c8745dd02048beb0f7a83bea2a9e7f61abc48b42c296b5aa5fe380ae3a4f2c72", "content": "Some applications can use a form parameter to override the HTTP method.\nFor example, the following form can treat the HTTP method as a `delete` rather than a `post`.\n\n.CSRF Hidden HTTP Method Form\n[source,html]\n----\n<form action=\"/process\"\n\tmethod=\"post\">\n\t<!-- ... -->\n\t<input type=\"hidden\"\n name=\"_method\"\n value=\"delete\"/>\n</form>\n----\n\nOverriding the HTTP method occurs in a filter.\nThat filter must be placed before Spring Security's support.\nNote that overriding happens only on a `post`, so this is actually unlikely to cause any real problems.\nHowever, it is still best practice to ensure that it is placed before Spring Security's filters.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/csrf.adoc", "title": "csrf", "heading": "HiddenHttpMethodFilter", "heading_level": 4, "file_order": 3, "section_index": 16, "content_hash": "c8745dd02048beb0f7a83bea2a9e7f61abc48b42c296b5aa5fe380ae3a4f2c72", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/csrf.adoc"}}
{"id": "sha256:30ca3e496043f67ca1893f6500c617bb8f5ad2511806fef3e9a5805edb3cf40c", "content": "[[headers]]\n\n[NOTE]\n====\nThis portion of the documentation discusses the general topic of Security HTTP Response Headers.\nSee the relevant sections for specific information on Security HTTP Response Headers in xref:servlet/exploits/headers.adoc#servlet-headers[servlet]- and xref:reactive/exploits/headers.adoc#webflux-headers[WebFlux]-based applications.\n====\n\nYou can use https://owasp.org/www-project-secure-headers/#div-headers[HTTP response headers] in many ways to increase the security of web applications.\nThis section is dedicated to the various HTTP response headers for which Spring Security provides explicit support for.\nIf necessary, you can also configure Spring Security to provide <<headers-custom,custom headers>>.\n\n[[headers-default]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "headers", "heading_level": 1, "file_order": 4, "section_index": 0, "content_hash": "30ca3e496043f67ca1893f6500c617bb8f5ad2511806fef3e9a5805edb3cf40c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:d98914fefd5afb220f7e42762d1ff992773c10c1fd4e25ab3b9ef7abb36771d7", "content": "[NOTE]\n====\nSee the relevant sections for how to customize the defaults for both xref:servlet/exploits/headers.adoc#servlet-headers-default[servlet]- and xref:reactive/exploits/headers.adoc#webflux-headers-default[webflux]-based applications.\n====\n\nSpring Security provides a default set of security related HTTP response headers to provide secure defaults.\n\nThe default for Spring Security is to include the following headers:\n\n.Default Security HTTP Response Headers\n[source,http]\n----\nCache-Control: no-cache, no-store, max-age=0, must-revalidate\nPragma: no-cache\nExpires: 0\nX-Content-Type-Options: nosniff\nStrict-Transport-Security: max-age=31536000 ; includeSubDomains\nX-Frame-Options: DENY\nX-XSS-Protection: 0\n----\n\n[NOTE]\n====\nStrict-Transport-Security is added only on HTTPS requests\n====\n\nIf the defaults do not meet your needs, you can easily remove, modify, or add headers from these defaults.\nFor additional details on each of these headers, see the corresponding sections:\n\n* <<headers-cache-control,Cache Control>>\n* <<headers-content-type-options,Content Type Options>>\n* <<headers-hsts,HTTP Strict Transport Security>>\n* <<headers-frame-options,X-Frame-Options>>\n* <<headers-xss-protection,X-XSS-Protection>>\n\n[[headers-cache-control]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "Default Security Headers", "heading_level": 2, "file_order": 4, "section_index": 1, "content_hash": "d98914fefd5afb220f7e42762d1ff992773c10c1fd4e25ab3b9ef7abb36771d7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:6ea7cb843a9e34b407c68e468f93adfc28971fe3be5f9d75a363e6b2dcafd51f", "content": "[NOTE]\n====\nSee to the relevant sections for how to customize the defaults for both xref:servlet/exploits/headers.adoc#servlet-headers-cache-control[servlet]- and xref:reactive/exploits/headers.adoc#webflux-headers-cache-control[webflux]-based applications.\n====\n\nSpring Security's default is to disable caching to protect the user's content.\n\nIf a user authenticates to view sensitive information and then logs out, we do not want a malicious user to be able to click the back button to view the sensitive information.\nThe cache control headers that are sent by default are:\n\n.Default Cache Control HTTP Response Headers\n[source]\n----\nCache-Control: no-cache, no-store, max-age=0, must-revalidate\nPragma: no-cache\nExpires: 0\n----\n\nTo be secure by default, Spring Security adds these headers by default.\nHowever, if your application provides its own cache control headers, Spring Security backs out of the way.\nThis allows for applications to ensure that static resources (such as CSS and JavaScript) can be cached.\n\n[[headers-content-type-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "Cache Control", "heading_level": 2, "file_order": 4, "section_index": 2, "content_hash": "6ea7cb843a9e34b407c68e468f93adfc28971fe3be5f9d75a363e6b2dcafd51f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:9c6631ca99b9ac5388531f3ea6eb684463db405e1a81023d68871d2eff49d825", "content": "[NOTE]\n====\nRefer to the relevant sections to see how to customize the defaults for both xref:servlet/exploits/headers.adoc#servlet-headers-content-type-options[servlet] and xref:reactive/exploits/headers.adoc#webflux-headers-content-type-options[webflux] based applications.\n====\n\nHistorically, browsers, including Internet Explorer, would try to guess the content type of a request by using https://en.wikipedia.org/wiki/Content_sniffing[content sniffing].\nThis allowed browsers to improve the user experience by guessing the content type on resources that had not specified the content type.\nFor example, if a browser encountered a JavaScript file that did not have the content type specified, it would be able to guess the content type and then run it.\n\n[NOTE]\n====\nThere are many additional things one should do (such as only display the document in a distinct domain, ensure Content-Type header is set, sanitize the document, and others) when allowing content to be uploaded.\nHowever, these measures are out of the scope of what Spring Security provides.\nIt is also important to point out that, when disabling content sniffing, you must specify the content type in order for things to work properly.\n====\n\nThe problem with content sniffing is that this allowed malicious users to use polyglots (that is, a file that is valid as multiple content types) to perform XSS attacks.\nFor example, some sites may allow users to submit a valid postscript document to a website and view it.\nA malicious user might create a http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf[postscript document that is also a valid JavaScript file] and perform an XSS attack with it.\n\nBy default, Spring Security disables content sniffing by adding the following header to HTTP responses:\n\n.nosniff HTTP Response Header\n[source,http]\n----\nX-Content-Type-Options: nosniff\n----\n\n[[headers-hsts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "Content Type Options", "heading_level": 2, "file_order": 4, "section_index": 3, "content_hash": "9c6631ca99b9ac5388531f3ea6eb684463db405e1a81023d68871d2eff49d825", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:89a561890781ead4bb19fae33a0d230cdd5a48679926926de98323a51450a7db", "content": "[NOTE]\n====\nRefer to the relevant sections to see how to customize the defaults for both xref:servlet/exploits/headers.adoc#servlet-headers-hsts[servlet] and xref:reactive/exploits/headers.adoc#webflux-headers-hsts[webflux] based applications.\n====\n\nWhen you type in your bank's website, do you enter `mybank.example.com` or do you enter `\\https://mybank.example.com`?\nIf you omit the `https` protocol, you are potentially vulnerable to https://en.wikipedia.org/wiki/Man-in-the-middle_attack[Man-in-the-Middle attacks].\nEven if the website performs a redirect to `\\https://mybank.example.com`, a malicious user could intercept the initial HTTP request and manipulate the response (for example, redirect to `\\https://mibank.example.com` and steal their credentials).\n\nMany users omit the `https` protocol, and this is why https://tools.ietf.org/html/rfc6797[HTTP Strict Transport Security (HSTS)] was created.\nOnce `mybank.example.com` is added as a https://tools.ietf.org/html/rfc6797#section-5.1[HSTS host], a browser can know ahead of time that any request to mybank.example.com should be interpreted as `\\https://mybank.example.com`.\nThis greatly reduces the possibility of a Man-in-the-Middle attack occurring.\n\n[NOTE]\n====\nIn accordance with https://tools.ietf.org/html/rfc6797#section-7.2[RFC6797], the HSTS header is injected only into HTTPS responses.\nFor the browser to acknowledge the header, the browser must first trust the CA that signed the SSL certificate used to make the connection (not just the SSL certificate).\n====\n\nOne way for a site to be marked as a HSTS host is to have the host preloaded into the browser.\nAnother way is to add the `Strict-Transport-Security` header to the response.\nFor example, Spring Security's default behavior is to add the following header, which instructs the browser to treat the domain as an HSTS host for a year (there are 31536000 seconds in a non-leap year):\n\n.Strict Transport Security HTTP Response Header\n[source]\n----\nStrict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload\n----\n\nThe optional `includeSubDomains` directive instructs the browser that subdomains (such as `secure.mybank.example.com`) should also be treated as an HSTS domain.\n\nThe optional `preload` directive instructs the browser that the domain should be preloaded in browser as an HSTS domain.\nFor more details on HSTS preload, see https://hstspreload.org.\n\n[[headers-hpkp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "HTTP Strict Transport Security (HSTS)", "heading_level": 2, "file_order": 4, "section_index": 4, "content_hash": "89a561890781ead4bb19fae33a0d230cdd5a48679926926de98323a51450a7db", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:c6a4aabc710ce5d87916925fa4d8a386b4707d6311e64f24288dda8b42f03c44", "content": "[NOTE]\n====\nTo remain passive, Spring Security still provides xref:servlet/exploits/headers.adoc#servlet-headers-hpkp[support for HPKP in servlet environments].\nHowever, for the reasons listed earlier, HPKP is no longer recommended by the Spring Security team.\n====\n\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning[HTTP Public Key Pinning (HPKP)] specifies to a web client which public key to use with a certain web server to prevent Man-in-the-Middle (MITM) attacks with forged certificates.\nWhen used correctly, HPKP could add additional layers of protection against compromised certificates.\nHowever, due to the complexity of HPKP, many experts no longer recommend using it and https://www.chromestatus.com/feature/5903385005916160[Chrome has even removed support] for it.\n\n[[headers-hpkp-deprecated]]\nFor additional details around why HPKP is no longer recommended, read https://blog.qualys.com/ssllabs/2016/09/06/is-http-public-key-pinning-dead[Is HTTP Public Key Pinning Dead?] and https://scotthelme.co.uk/im-giving-up-on-hpkp/[I'm giving up on HPKP].\n\n[[headers-frame-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "HTTP Public Key Pinning (HPKP)", "heading_level": 2, "file_order": 4, "section_index": 5, "content_hash": "c6a4aabc710ce5d87916925fa4d8a386b4707d6311e64f24288dda8b42f03c44", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:dfa267bf259c8aee850b05f90d194d81a23036b159dfbc5fe0f83d3ae5a1ae38", "content": "[NOTE]\n====\nSee the relevant sections to see how to customize the defaults for both xref:servlet/exploits/headers.adoc#servlet-headers-frame-options[servlet] and xref:reactive/exploits/headers.adoc#webflux-headers-frame-options[webflux] based applications.\n====\n\nLetting your website be added to a frame can be a security issue.\nFor example, by using clever CSS styling, users could be tricked into clicking on something that they were not intending.\nFor example, a user that is logged into their bank might click a button that grants access to other users.\nThis sort of attack is known as https://en.wikipedia.org/wiki/Clickjacking[Clickjacking].\n\n[NOTE]\n====\nAnother modern approach to dealing with clickjacking is to use <<headers-csp>>.\n====\n\nThere are a number ways to mitigate clickjacking attacks.\nFor example, to protect legacy browsers from clickjacking attacks, you can use https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script[frame breaking code].\nWhile not perfect, the frame breaking code is the best you can do for the legacy browsers.\n\nA more modern approach to address clickjacking is to use https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options[X-Frame-Options] header.\nBy default, Spring Security disables rendering pages within an iframe by using with the following header:\n\n[source]\n----\nX-Frame-Options: DENY\n----\n\n[[headers-xss-protection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "X-Frame-Options", "heading_level": 2, "file_order": 4, "section_index": 6, "content_hash": "dfa267bf259c8aee850b05f90d194d81a23036b159dfbc5fe0f83d3ae5a1ae38", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:525ea32f87ed11ec26bcca374246979a09f93a1e18439a49b0e35ddbcd49203e", "content": "[NOTE]\n====\nSee the relevant sections to see how to customize the defaults for both xref:servlet/exploits/headers.adoc#servlet-headers-xss-protection[servlet]- and xref:reactive/exploits/headers.adoc#webflux-headers-xss-protection[webflux]-based applications.\n====\n\nSome browsers have built-in support for filtering out https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OWASP-DV-001)[reflected XSS attacks].\nThe filter has been deprecated in major browsers, and https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-xss-protection[current OWASP recommendation] is to explicitly set the header to 0.\n\nBy default, Spring Security blocks the content by using the following header:\n\n[source]\n----\nX-XSS-Protection: 0\n----\n\n[[headers-csp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "X-XSS-Protection", "heading_level": 2, "file_order": 4, "section_index": 7, "content_hash": "525ea32f87ed11ec26bcca374246979a09f93a1e18439a49b0e35ddbcd49203e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:bbf529b9f0b5b7d74e14f6fedcd2e8f1679f1453498c6e9ee7712f467f59f1e9", "content": "[NOTE]\n====\nSee the relevant sections to see how to configure both xref:servlet/exploits/headers.adoc#servlet-headers-csp[servlet]- and xref:reactive/exploits/headers.adoc#webflux-headers-csp[webflux]-based applications.\n====\n\nhttps://www.w3.org/TR/CSP2/[Content Security Policy (CSP)] is a mechanism that web applications can use to mitigate content injection vulnerabilities, such as cross-site scripting (XSS).\nCSP is a declarative policy that provides a facility for web application authors to declare and ultimately inform the client (user-agent) about the sources from which the web application expects to load resources.\n\n[NOTE]\n====\nContent Security Policy is not intended to solve all content injection vulnerabilities.\nInstead, you can use CSP to help reduce the harm caused by content injection attacks.\nAs a first line of defense, web application authors should validate their input and encode their output.\n====\n\nA web application can use CSP by including one of the following HTTP headers in the response:\n\n* `Content-Security-Policy`\n* `Content-Security-Policy-Report-Only`\n\nEach of these headers are used as a mechanism to deliver a security policy to the client.\nA security policy contains a set of security policy directives, each responsible for declaring the restrictions for a particular resource representation.\n\nFor example, a web application can declare that it expects to load scripts from specific, trusted sources by including the following header in the response:\n\n.Content Security Policy Example\n[source]\n----\nContent-Security-Policy: script-src https://trustedscripts.example.com\n----\n\nAn attempt to load a script from another source other than what is declared in the `script-src` directive is blocked by the user-agent.\nAdditionally, if the https://www.w3.org/TR/CSP2/#directive-report-uri[report-uri] directive is declared in the security policy, the violation will be reported by the user-agent to the declared URL.\n\nFor example, if a web application violates the declared security policy, the following response header instructs the user-agent to send violation reports to the URL specified in the policy's `report-uri` directive.\n\n.Content Security Policy with report-uri\n[source]\n----\nContent-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/\n----\n\nhttps://www.w3.org/TR/CSP2/#violation-reports[Violation reports] are standard JSON structures that can be captured either by the web application's own API or by a publicly hosted CSP violation reporting service, such as https://report-uri.io/.\n\nThe `Content-Security-Policy-Report-Only` header provides the capability for web application authors and administrators to monitor security policies rather than enforce them.\nThis header is typically used when experimenting or developing security policies for a site.\nWhen a policy is deemed effective, it can be enforced by using the `Content-Security-Policy` header field instead.\n\nGiven the following response header, the policy declares that scripts can be loaded from one of two possible sources.\n\n.Content Security Policy Report Only\n[source]\n----\nContent-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/\n----\n\nIf the site violates this policy, by attempting to load a script from `evil.example.com`, the user-agent sends a violation report to the declared URL specified by the `report-uri` directive but still lets the violating resource load.\n\nApplying Content Security Policy to a web application is often a non-trivial undertaking.\nThe following resources may provide further assistance in developing effective security policies for your site:\n\nhttps://www.html5rocks.com/en/tutorials/security/content-security-policy/[An Introduction to Content Security Policy]\n\nhttps://developer.mozilla.org/en-US/docs/Web/Security/CSP[CSP Guide - Mozilla Developer Network]\n\nhttps://www.w3.org/TR/CSP2/[W3C Candidate Recommendation]\n\n[[headers-referrer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "Content Security Policy (CSP)", "heading_level": 2, "file_order": 4, "section_index": 8, "content_hash": "bbf529b9f0b5b7d74e14f6fedcd2e8f1679f1453498c6e9ee7712f467f59f1e9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:9f99980b303acbee161c422dba56caa7079c11b43f28270f59e084c8c9c82f91", "content": "[NOTE]\n====\nSee the relevant sections to see how to configure both xref:servlet/exploits/headers.adoc#servlet-headers-referrer[servlet]- and xref:reactive/exploits/headers.adoc#webflux-headers-referrer[webflux]-based applications.\n====\n\nhttps://www.w3.org/TR/referrer-policy[Referrer Policy] is a mechanism that web applications can use to manage the referrer field, which contains the last\npage the user was on.\n\nSpring Security's approach is to use the https://www.w3.org/TR/referrer-policy/[Referrer Policy] header, which provides different https://www.w3.org/TR/referrer-policy/#referrer-policies[policies]:\n\n.Referrer Policy Example\n[source]\n----\nReferrer-Policy: same-origin\n----\n\nThe Referrer-Policy response header instructs the browser to let the destination knows the source where the user was previously.\n\n[[headers-feature]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "Referrer Policy", "heading_level": 2, "file_order": 4, "section_index": 9, "content_hash": "9f99980b303acbee161c422dba56caa7079c11b43f28270f59e084c8c9c82f91", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:eb9d565fb362aa36c277550c553ba2f98e07c8d98827dbe0be55b89f479b364c", "content": "[NOTE]\n====\nSee the relevant sections to see how to configure both xref:servlet/exploits/headers.adoc#servlet-headers-feature[servlet]- and xref:reactive/exploits/headers.adoc#webflux-headers-feature[webflux]-based applications.\n====\n\nhttps://wicg.github.io/feature-policy/[Feature Policy] is a mechanism that lets web developers to selectively enable, disable, and modify the behavior of certain APIs and web features in the browser.\n\n.Feature Policy Example\n[source]\n----\nFeature-Policy: geolocation 'self'\n----\n\nWith Feature Policy, developers can opt-in to a set of \"`policies`\" for the browser to enforce on specific features used throughout your site.\nThese policies restrict what APIs the site can access or modify the browser's default behavior for certain features.\n\n[[headers-permissions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "Feature Policy", "heading_level": 2, "file_order": 4, "section_index": 10, "content_hash": "eb9d565fb362aa36c277550c553ba2f98e07c8d98827dbe0be55b89f479b364c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:0214733c09fd5c234511f684d6d5e1818c121cca0c9cb54ab13d4918570e4335", "content": "[NOTE]\n====\nSee the relevant sections to see how to configure both xref:servlet/exploits/headers.adoc#servlet-headers-permissions[servlet]- and xref:reactive/exploits/headers.adoc#webflux-headers-permissions[webflux]-based applications.\n====\n\nhttps://w3c.github.io/webappsec-permissions-policy/[Permissions Policy] is a mechanism that lets web developers selectively enable, disable, and modify the behavior of certain APIs and web features in the browser.\n\n.Permissions Policy Example\n[source]\n----\nPermissions-Policy: geolocation=(self)\n----\n\nWith Permissions Policy, developers can opt-in to a set of \"policies\" for the browser to enforce on specific features used throughout your site.\nThese policies restrict what APIs the site can access or modify the browser's default behavior for certain features.\n\n[[headers-clear-site-data]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "Permissions Policy", "heading_level": 2, "file_order": 4, "section_index": 11, "content_hash": "0214733c09fd5c234511f684d6d5e1818c121cca0c9cb54ab13d4918570e4335", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:95303d2df3c42d03e2e396fa829b18ad9010755c099a1d38c0b5a8c671ce8202", "content": "[NOTE]\n====\nSee the relevant sections to see how to configure both xref:servlet/exploits/headers.adoc#servlet-headers-clear-site-data[servlet]- and xref:reactive/exploits/headers.adoc#webflux-headers-clear-site-data[webflux]- based applications.\n====\n\nhttps://www.w3.org/TR/clear-site-data/[Clear Site Data] is a mechanism by which any browser-side data (cookies, local storage, and the like) can be removed when an HTTP response contains this header:\n\n[source]\n----\nClear-Site-Data: \"cache\", \"cookies\", \"storage\", \"executionContexts\"\n----\n\nThis is a nice clean-up action to perform on logout.\n\n[[headers-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "Clear Site Data", "heading_level": 2, "file_order": 4, "section_index": 12, "content_hash": "95303d2df3c42d03e2e396fa829b18ad9010755c099a1d38c0b5a8c671ce8202", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:7d25de97a94758ef942db78d508b19f089e713a947d783e8194eed95141a22f9", "content": "[NOTE]\n====\nSee the relevant section to see how to configure xref:servlet/exploits/headers.adoc#servlet-headers-custom[servlet] based applications.\n====\n\nSpring Security has mechanisms to make it convenient to add the more common security headers to your application.\nHowever, it also provides hooks to enable adding custom headers.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/headers.adoc", "title": "headers", "heading": "Custom Headers", "heading_level": 2, "file_order": 4, "section_index": 13, "content_hash": "7d25de97a94758ef942db78d508b19f089e713a947d783e8194eed95141a22f9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/headers.adoc"}}
{"id": "sha256:30766df9b84c9203fa291ee2dc1fefe478483351cdb3db6e1a8d7027e9187157", "content": "[[http]]\n\nAll HTTP-based communication, including https://www.troyhunt.com/heres-why-your-static-website-needs-https/[static resources], should be protected by https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html[using TLS].\n\nAs a framework, Spring Security does not handle HTTP connections and thus does not provide support for HTTPS directly.\nHowever, it does provide a number of features that help with HTTPS usage.\n\n[[http-redirect]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/http.adoc", "title": "http", "heading": "http", "heading_level": 1, "file_order": 5, "section_index": 0, "content_hash": "30766df9b84c9203fa291ee2dc1fefe478483351cdb3db6e1a8d7027e9187157", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/http.adoc"}}
{"id": "sha256:63b490d76b361fbd7f807f787a1599991f87f4fd1803760c31ec675c1995c368", "content": "When a client uses HTTP, you can configure Spring Security to redirect to HTTPS in both xref:servlet/exploits/http.adoc#servlet-http-redirect[Servlet] and xref:reactive/exploits/http.adoc#webflux-http-redirect[WebFlux] environments.\n\n[[http-hsts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/http.adoc", "title": "http", "heading": "Redirect to HTTPS", "heading_level": 2, "file_order": 5, "section_index": 1, "content_hash": "63b490d76b361fbd7f807f787a1599991f87f4fd1803760c31ec675c1995c368", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/http.adoc"}}
{"id": "sha256:025a33cc2118fd6b5724096bf8020e7fc815a37f98f2db001c7aec64c293271a", "content": "Spring Security provides support for xref:features/exploits/headers.adoc#headers-hsts[Strict Transport Security] and enables it by default.\n\n[[http-proxy-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/http.adoc", "title": "http", "heading": "Strict Transport Security", "heading_level": 2, "file_order": 5, "section_index": 2, "content_hash": "025a33cc2118fd6b5724096bf8020e7fc815a37f98f2db001c7aec64c293271a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/http.adoc"}}
{"id": "sha256:fcd84411d2c9d9ba372197c3b17bfd16fd253a65b232dcb14407c630504083a4", "content": "When using a proxy server, it is important to ensure that you have configured your application properly.\nFor example, many applications have a load balancer that responds to request for `\\https://example.com/` by forwarding the request to an application server at `\\https://192.168.0.107`\nWithout proper configuration, the application server can not know that the load balancer exists and treats the request as though `\\https://192.168.0.107:8080` was requested by the client.\n\nTo fix this, you can use https://tools.ietf.org/html/rfc7239[RFC 7239] to specify that a load balancer is being used.\nTo make the application aware of this, you need to configure your application server to be aware of the X-Forwarded headers.\nFor example, Tomcat uses https://tomcat.apache.org/tomcat-10.1-doc/api/org/apache/catalina/valves/RemoteIpValve.html[`RemoteIpValve`] and Jetty uses https://eclipse.dev/jetty/javadoc/jetty-11/org/eclipse/jetty/server/ForwardedRequestCustomizer.html[`ForwardedRequestCustomizer`].\nAlternatively, Spring users can use https://docs.spring.io/spring-framework/reference/web/webmvc/filters.html#filters-forwarded-headers[`ForwardedHeaderFilter`] with the Servlet stack or https://docs.spring.io/spring-framework/reference/web/webflux/reactive-spring.html#webflux-forwarded-headers[`ForwardedHeaderTransformer`] with the Reactive stack.\n\nSpring Boot users can use the `server.forward-headers-strategy` property to configure the application.\nSee the https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto.webserver.use-behind-a-proxy-server[Spring Boot documentation] for further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/http.adoc", "title": "http", "heading": "Proxy Server Configuration", "heading_level": 2, "file_order": 5, "section_index": 3, "content_hash": "fcd84411d2c9d9ba372197c3b17bfd16fd253a65b232dcb14407c630504083a4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/http.adoc"}}
{"id": "sha256:b5902ba1e847b0693cc3a6e5aa2f21485525767288a8e8a462d628890cbc90cb", "content": "[[exploits]]\n\nSpring Security provides protection against common exploits.\nWhenever possible, the protection is enabled by default.\nThis section describes the various exploits that Spring Security protects against.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/exploits/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 6, "section_index": 0, "content_hash": "b5902ba1e847b0693cc3a6e5aa2f21485525767288a8e8a462d628890cbc90cb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/exploits/index.adoc"}}
{"id": "sha256:cc35128fe2fc7623cc84858c33fed831f3e2a4d9bce88c96418751a41bf60faa", "content": "Spring Security's OAuth Support can integrate with `RestClient` and `WebClient` {spring-framework-reference-url}integration/rest-clients.html#rest-http-service-client[HTTP Service Clients].\n\n[[configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc", "title": "HTTP Service Clients Integration", "heading": "HTTP Service Clients Integration", "heading_level": 1, "file_order": 7, "section_index": 0, "content_hash": "cc35128fe2fc7623cc84858c33fed831f3e2a4d9bce88c96418751a41bf60faa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc"}}
{"id": "sha256:f3831a0bf518f88c6157402b8971a21d5966a06ec0bc21870e907a57ba1cabfa", "content": "After xref:features/integrations/rest/http-service-client.adoc#configuration-restclient[RestClient] or xref:features/integrations/rest/http-service-client.adoc#configuration-webclient[WebClient] specific configuration, usage of xref:features/integrations/rest/http-service-client.adoc[] only requires adding a xref:features/integrations/rest/http-service-client.adoc#client-registration-id[`@ClientRegistrationId`] to methods that require OAuth or their declaring HTTP interface.\n\nSince the presence of xref:features/integrations/rest/http-service-client.adoc#client-registration-id[`@ClientRegistrationId`] determines if and how the OAuth token will be resolved, it is safe to add Spring Security's OAuth support any configuration.\n\n[[configuration-restclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc", "title": "HTTP Service Clients Integration", "heading": "Configuration", "heading_level": 2, "file_order": 7, "section_index": 1, "content_hash": "f3831a0bf518f88c6157402b8971a21d5966a06ec0bc21870e907a57ba1cabfa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc"}}
{"id": "sha256:642f5fee7c7b441b816f384d10b5d58790968daac2a85c46074eac423610d4d8", "content": "Spring Security's OAuth Support can integrate with {spring-framework-reference-url}integration/rest-clients.html#rest-http-service-client[HTTP Service Clients] backed by `RestClient`.\nThe first step is to xref:servlet/oauth2/client/core.adoc#oauth2Client-authorized-manager-provider[create an `OAuthAuthorizedClientManager` Bean].\n\nNext you must configure `HttpServiceProxyFactory` and `RestClient` to be aware of xref:./http-service-client.adoc#client-registration-id[@ClientRegistrationId]\nTo simplify this configuration, use javadoc:org.springframework.security.oauth2.client.web.client.support.OAuth2RestClientHttpServiceGroupConfigurer[].\n\ninclude-code::./RestClientHttpInterfaceIntegrationConfiguration[tag=config,indent=0]\n\nThe configuration:\n\n- Adds xref:features/integrations/rest/http-service-client.adoc#client-registration-id-processor[`ClientRegistrationIdProcessor`] to {spring-framework-reference-url}integration/rest-clients.html#rest-http-service-client[`HttpServiceProxyFactory`]\n- Adds xref:servlet/oauth2/client/authorized-clients.adoc#oauth2-client-rest-client[`OAuth2ClientHttpRequestInterceptor`] to the `RestClient`\n\n[[configuration-webclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc", "title": "HTTP Service Clients Integration", "heading": "RestClient Configuration", "heading_level": 3, "file_order": 7, "section_index": 2, "content_hash": "642f5fee7c7b441b816f384d10b5d58790968daac2a85c46074eac423610d4d8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc"}}
{"id": "sha256:9dff2326d4cda524bc26e2f2c9fb9b3cc674cb6a309ba7152a5b820cdf6403cd", "content": "Spring Security's OAuth Support can integrate with {spring-framework-reference-url}integration/rest-clients.html#rest-http-service-client[HTTP Service Clients] backed by `WebClient`.\nThe first step is to xref:reactive/oauth2/client/core.adoc#oauth2Client-authorized-manager-provider[create an `ReactiveOAuthAuthorizedClientManager` Bean].\n\nNext you must configure `HttpServiceProxyFactory` and `WebRestClient` to be aware of xref:./http-service-client.adoc#client-registration-id[@ClientRegistrationId]\nTo simplify this configuration, use javadoc:org.springframework.security.oauth2.client.web.reactive.function.client.support.OAuth2WebClientHttpServiceGroupConfigurer[].\n\ninclude-code::./ServerWebClientHttpInterfaceIntegrationConfiguration[tag=config,indent=0]\n\nThe configuration:\n\n- Adds xref:features/integrations/rest/http-service-client.adoc#client-registration-id-processor[`ClientRegistrationIdProcessor`] to {spring-framework-reference-url}/integration/rest-clients.html#rest-http-service-client[`HttpServiceProxyFactory`]\n- Adds xref:reactive/oauth2/client/authorized-clients.adoc#oauth2-client-web-client[`ServerOAuth2AuthorizedClientExchangeFilterFunction`] to the `WebClient`\n\n[[client-registration-id]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc", "title": "HTTP Service Clients Integration", "heading": "WebClient Configuration", "heading_level": 3, "file_order": 7, "section_index": 3, "content_hash": "9dff2326d4cda524bc26e2f2c9fb9b3cc674cb6a309ba7152a5b820cdf6403cd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc"}}
{"id": "sha256:cf9390a76d80b8c1c0edf850a2946bb64df23ab17cdd8c3f6eab772f7f0fdc1c", "content": "You can add the javadoc:org.springframework.security.oauth2.client.annotation.ClientRegistrationId[] on the HTTP Service to specify which javadoc:org.springframework.security.oauth2.client.registration.ClientRegistration[] to use.\n\ninclude-code::./UserService[tag=getAuthenticatedUser]\n\nThe xref:features/integrations/rest/http-service-client.adoc#client-registration-id[`@ClientRegistrationId`] will be processed by xref:features/integrations/rest/http-service-client.adoc#client-registration-id-processor[`ClientRegistrationIdProcessor`]\n\n[[type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc", "title": "HTTP Service Clients Integration", "heading": "@ClientRegistrationId", "heading_level": 2, "file_order": 7, "section_index": 4, "content_hash": "cf9390a76d80b8c1c0edf850a2946bb64df23ab17cdd8c3f6eab772f7f0fdc1c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc"}}
{"id": "sha256:14200f40ea8899f258282facfda61a0b00b88e55537de95024b4b331872f9dec", "content": "`@ClientRegistrationId` can also be added at the type level to avoid repeating the declaration on every method.\n\ninclude-code::./UserService[tag=type]\n\n[[client-registration-id-processor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc", "title": "HTTP Service Clients Integration", "heading": "Type Level Declarations", "heading_level": 3, "file_order": 7, "section_index": 5, "content_hash": "14200f40ea8899f258282facfda61a0b00b88e55537de95024b4b331872f9dec", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc"}}
{"id": "sha256:c3933414b7c8bd14f63798b81797214d6b6f72774c3df0b0bdfcf201e2751e2d", "content": "The xref:features/integrations/rest/http-service-client.adoc#configuration[configured] javadoc:org.springframework.security.oauth2.client.web.client.ClientRegistrationIdProcessor[] will:\n\n- Automatically invoke javadoc:org.springframework.security.oauth2.client.web.ClientAttributes#clientRegistrationId(java.lang.String)[] for each xref:features/integrations/rest/http-service-client.adoc#client-registration-id[`@ClientRegistrationId`].\n- This adds the javadoc:org.springframework.security.oauth2.client.registration.ClientRegistration#getId()[] to the attributes\n\nThe `id` is then processed by:\n\n- `OAuth2ClientHttpRequestInterceptor` for xref:servlet/oauth2/client/authorized-clients.adoc#oauth2-client-rest-client[RestClient Integration]\n- xref:servlet/oauth2/client/authorized-clients.adoc#oauth2-client-web-client[`ServletOAuth2AuthorizedClientExchangeFilterFunction`] (servlets) or xref:servlet/oauth2/client/authorized-clients.adoc#oauth2-client-web-client[`ServerOAuth2AuthorizedClientExchangeFilterFunction`] (reactive environments) for `WebClient`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc", "title": "HTTP Service Clients Integration", "heading": "`ClientRegistrationIdProcessor`", "heading_level": 2, "file_order": 7, "section_index": 6, "content_hash": "c3933414b7c8bd14f63798b81797214d6b6f72774c3df0b0bdfcf201e2751e2d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/rest/http-service-client.adoc"}}
{"id": "sha256:b2891aa46e82820188db059b7ad72b576358b87a4f3b14582b85a1f50215d77a", "content": "[[concurrency]]\n\nIn most environments, Security is stored on a per `Thread` basis.\nThis means that when work is done on a new `Thread`, the `SecurityContext` is lost.\nSpring Security provides some infrastructure to help make this much easier for users.\nSpring Security provides low level abstractions for working with Spring Security in multi-threaded environments.\nIn fact, this is what Spring Security builds on to integration with xref:servlet/integrations/servlet-api.adoc#servletapi-start-runnable[AsyncContext.start(Runnable)] and xref:servlet/integrations/mvc.adoc#mvc-async[Spring MVC Async Integration].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/concurrency.adoc", "title": "concurrency", "heading": "concurrency", "heading_level": 1, "file_order": 8, "section_index": 0, "content_hash": "b2891aa46e82820188db059b7ad72b576358b87a4f3b14582b85a1f50215d77a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/concurrency.adoc"}}
{"id": "sha256:b1b9b76f54df6659bb888fafc1d715b06f847efcb225d8fd24e472b6a7f7bc49", "content": "One of the most fundamental building blocks within Spring Security's concurrency support is the `DelegatingSecurityContextRunnable`.\nIt wraps a delegate `Runnable` in order to initialize the `SecurityContextHolder` with a specified `SecurityContext` for the delegate.\nIt then invokes the delegate Runnable ensuring to clear the `SecurityContextHolder` afterwards.\nThe `DelegatingSecurityContextRunnable` looks something like this:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic void run() {\ntry {\n\tSecurityContextHolder.setContext(securityContext);\n\tdelegate.run();\n} finally {\n\tSecurityContextHolder.clearContext();\n}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nfun run() {\n try {\n SecurityContextHolder.setContext(securityContext)\n delegate.run()\n } finally {\n SecurityContextHolder.clearContext()\n }\n}\n----\n======\n\nWhile very simple, it makes it seamless to transfer the SecurityContext from one Thread to another.\nThis is important since, in most cases, the SecurityContextHolder acts on a per Thread basis.\nFor example, you might have used Spring Security's xref:servlet/appendix/namespace/method-security.adoc#nsa-global-method-security[<global-method-security>] support to secure one of your services.\nYou can now easily transfer the `SecurityContext` of the current `Thread` to the `Thread` that invokes the secured service.\nAn example of how you might do this can be found below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nRunnable originalRunnable = new Runnable() {\npublic void run() {\n\t// invoke secured service\n}\n};\n\nSecurityContext context = SecurityContextHolder.getContext();\nDelegatingSecurityContextRunnable wrappedRunnable =\n\tnew DelegatingSecurityContextRunnable(originalRunnable, context);\n\nnew Thread(wrappedRunnable).start();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval originalRunnable = Runnable {\n // invoke secured service\n}\nval context: SecurityContext = SecurityContextHolder.getContext()\nval wrappedRunnable = DelegatingSecurityContextRunnable(originalRunnable, context)\n\nThread(wrappedRunnable).start()\n----\n======\n\nThe code above performs the following steps:\n\n* Creates a `Runnable` that will be invoking our secured service.\nNotice that it is not aware of Spring Security\n* Obtains the `SecurityContext` that we wish to use from the `SecurityContextHolder` and initializes the `DelegatingSecurityContextRunnable`\n* Use the `DelegatingSecurityContextRunnable` to create a Thread\n* Start the Thread we created\n\nSince it is quite common to create a `DelegatingSecurityContextRunnable` with the `SecurityContext` from the `SecurityContextHolder` there is a shortcut constructor for it.\nThe following code is the same as the code above:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nRunnable originalRunnable = new Runnable() {\npublic void run() {\n\t// invoke secured service\n}\n};\n\nDelegatingSecurityContextRunnable wrappedRunnable =\n\tnew DelegatingSecurityContextRunnable(originalRunnable);\n\nnew Thread(wrappedRunnable).start();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval originalRunnable = Runnable {\n // invoke secured service\n}\n\nval wrappedRunnable = DelegatingSecurityContextRunnable(originalRunnable)\n\nThread(wrappedRunnable).start()\n----\n======\n\nThe code we have is simple to use, but it still requires knowledge that we are using Spring Security.\nIn the next section we will take a look at how we can utilize `DelegatingSecurityContextExecutor` to hide the fact that we are using Spring Security.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/concurrency.adoc", "title": "concurrency", "heading": "DelegatingSecurityContextRunnable", "heading_level": 2, "file_order": 8, "section_index": 1, "content_hash": "b1b9b76f54df6659bb888fafc1d715b06f847efcb225d8fd24e472b6a7f7bc49", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/concurrency.adoc"}}
{"id": "sha256:56715c2e4da47b05a08506a7dda813fb850959fac38d902b6e18e3dba78a236c", "content": "In the previous section we found that it was easy to use the `DelegatingSecurityContextRunnable`, but it was not ideal since we had to be aware of Spring Security in order to use it.\nLet's take a look at how `DelegatingSecurityContextExecutor` can shield our code from any knowledge that we are using Spring Security.\n\nThe design of `DelegatingSecurityContextExecutor` is very similar to that of `DelegatingSecurityContextRunnable` except it accepts a delegate `Executor` instead of a delegate `Runnable`.\nYou can see an example of how it might be used below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nSecurityContext context = SecurityContextHolder.createEmptyContext();\nAuthentication authentication =\n\tUsernamePasswordAuthenticationToken.authenticated(\"user\",\"doesnotmatter\", AuthorityUtils.createAuthorityList(\"ROLE_USER\"));\ncontext.setAuthentication(authentication);\n\nSimpleAsyncTaskExecutor delegateExecutor =\n\tnew SimpleAsyncTaskExecutor();\nDelegatingSecurityContextExecutor executor =\n\tnew DelegatingSecurityContextExecutor(delegateExecutor, context);\n\nRunnable originalRunnable = new Runnable() {\npublic void run() {\n\t// invoke secured service\n}\n};\n\nexecutor.execute(originalRunnable);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval context: SecurityContext = SecurityContextHolder.createEmptyContext()\nval authentication: Authentication =\n UsernamePasswordAuthenticationToken(\"user\", \"doesnotmatter\", AuthorityUtils.createAuthorityList(\"ROLE_USER\"))\ncontext.authentication = authentication\n\nval delegateExecutor = SimpleAsyncTaskExecutor()\nval executor = DelegatingSecurityContextExecutor(delegateExecutor, context)\n\nval originalRunnable = Runnable {\n // invoke secured service\n}\n\nexecutor.execute(originalRunnable)\n----\n======\n\nThe code performs the following steps:\n\n* Creates the `SecurityContext` to be used for our `DelegatingSecurityContextExecutor`.\nNote that in this example we simply create the `SecurityContext` by hand.\nHowever, it does not matter where or how we get the `SecurityContext` (i.e. we could obtain it from the `SecurityContextHolder` if we wanted).\n* Creates a delegateExecutor that is in charge of executing submitted ``Runnable``s\n* Finally we create a `DelegatingSecurityContextExecutor` which is in charge of wrapping any Runnable that is passed into the execute method with a `DelegatingSecurityContextRunnable`.\nIt then passes the wrapped Runnable to the delegateExecutor.\nIn this instance, the same `SecurityContext` will be used for every Runnable submitted to our `DelegatingSecurityContextExecutor`.\nThis is nice if we are running background tasks that need to be run by a user with elevated privileges.\n* At this point you may be asking yourself \"How does this shield my code of any knowledge of Spring Security?\" Instead of creating the `SecurityContext` and the `DelegatingSecurityContextExecutor` in our own code, we can inject an already initialized instance of `DelegatingSecurityContextExecutor`.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nprivate Executor executor; // becomes an instance of our DelegatingSecurityContextExecutor\n\npublic void submitRunnable() {\nRunnable originalRunnable = new Runnable() {\n\tpublic void run() {\n\t// invoke secured service\n\t}\n};\nexecutor.execute(originalRunnable);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Autowired\nlateinit var executor: Executor // becomes an instance of our DelegatingSecurityContextExecutor\n\nfun submitRunnable() {\n val originalRunnable = Runnable {\n // invoke secured service\n }\n executor.execute(originalRunnable)\n}\n----\n======\n\nNow our code is unaware that the `SecurityContext` is being propagated to the `Thread`, then the `originalRunnable` is run, and then the `SecurityContextHolder` is cleared out.\nIn this example, the same user is being used to run each thread.\nWhat if we wanted to use the user from `SecurityContextHolder` at the time we invoked `executor.execute(Runnable)` (i.e. the currently logged in user) to process ``originalRunnable``?\nThis can be done by removing the `SecurityContext` argument from our `DelegatingSecurityContextExecutor` constructor.\nFor example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nSimpleAsyncTaskExecutor delegateExecutor = new SimpleAsyncTaskExecutor();\nDelegatingSecurityContextExecutor executor =\n\tnew DelegatingSecurityContextExecutor(delegateExecutor);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval delegateExecutor = SimpleAsyncTaskExecutor()\nval executor = DelegatingSecurityContextExecutor(delegateExecutor)\n----\n======\n\nNow anytime `executor.execute(Runnable)` is executed the `SecurityContext` is first obtained by the `SecurityContextHolder` and then that `SecurityContext` is used to create our `DelegatingSecurityContextRunnable`.\nThis means that we are running our `Runnable` with the same user that was used to invoke the `executor.execute(Runnable)` code.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/concurrency.adoc", "title": "concurrency", "heading": "DelegatingSecurityContextExecutor", "heading_level": 2, "file_order": 8, "section_index": 2, "content_hash": "56715c2e4da47b05a08506a7dda813fb850959fac38d902b6e18e3dba78a236c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/concurrency.adoc"}}
{"id": "sha256:f42158ca5c9119bb0caa11fc428f654ea048bc372eca36fb3bd0167972c6ecec", "content": "Refer to the Javadoc for additional integrations with both the Java concurrent APIs and the Spring Task abstractions.\nThey are quite self-explanatory once you understand the previous code.\n\n* `DelegatingSecurityContextCallable`\n* `DelegatingSecurityContextExecutor`\n* `DelegatingSecurityContextExecutorService`\n* `DelegatingSecurityContextRunnable`\n* `DelegatingSecurityContextScheduledExecutorService`\n* `DelegatingSecurityContextSchedulingTaskExecutor`\n* `DelegatingSecurityContextAsyncTaskExecutor`\n* `DelegatingSecurityContextTaskExecutor`\n* `DelegatingSecurityContextTaskScheduler`", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/concurrency.adoc", "title": "concurrency", "heading": "Spring Security Concurrency Classes", "heading_level": 2, "file_order": 8, "section_index": 3, "content_hash": "f42158ca5c9119bb0caa11fc428f654ea048bc372eca36fb3bd0167972c6ecec", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/concurrency.adoc"}}
{"id": "sha256:43a78b406d4a45514f79a19f633fd80a3204c65c8670e367af3fd3fef6c4cb70", "content": "[[crypto]]\n\n[[spring-security-crypto-introduction]]\nThe Spring Security Crypto module provides support for symmetric encryption, key generation, and password encoding.\nThe code is distributed as part of the core module but has no dependencies on any other Spring Security (or Spring) code.\n\n[[spring-security-crypto-encryption]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/cryptography.adoc", "title": "cryptography", "heading": "cryptography", "heading_level": 1, "file_order": 9, "section_index": 0, "content_hash": "43a78b406d4a45514f79a19f633fd80a3204c65c8670e367af3fd3fef6c4cb70", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/cryptography.adoc"}}
{"id": "sha256:5128f7b6078358c227c88b9ba91603db0820f368005958c0c56813340f13d2aa", "content": "The javadoc:org.springframework.security.crypto.encrypt.Encryptors[] class provides factory methods for constructing symmetric encryptors.\nThis class lets you create javadoc:org.springframework.security.crypto.encrypt.BytesEncryptor[] instances to encrypt data in raw `byte[]` form.\nYou can also construct javadoc:org.springframework.security.crypto.encrypt.TextEncryptor[] instances to encrypt text strings.\nEncryptors are thread-safe.\n\n[NOTE]\n====\nBoth `BytesEncryptor` and `TextEncryptor` are interfaces. `BytesEncryptor` has multiple implementations.\n====\n\n[[spring-security-crypto-encryption-bytes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/cryptography.adoc", "title": "cryptography", "heading": "Encryptors", "heading_level": 2, "file_order": 9, "section_index": 1, "content_hash": "5128f7b6078358c227c88b9ba91603db0820f368005958c0c56813340f13d2aa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/cryptography.adoc"}}
{"id": "sha256:0a9d542a8cf526b17c72eef59850658c318506406c592026c44445f28e15d60a", "content": "You can use the `Encryptors.stronger` factory method to construct a `BytesEncryptor`:\n\n.BytesEncryptor\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nEncryptors.stronger(\"password\", \"salt\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nEncryptors.stronger(\"password\", \"salt\")\n----\n======\n\nThe `stronger` encryption method creates an encryptor by using 256-bit AES encryption with\nGalois Counter Mode (GCM).\nIt derives the secret key by using PKCS #5's PBKDF2 (Password-Based Key Derivation Function #2).\nThis method requires Java 6.\nThe password used to generate the `SecretKey` should be kept in a secure place and should not be shared.\nThe salt is used to prevent dictionary attacks against the key in the event that your encrypted data is compromised.\nA 16-byte random initialization vector is also applied so that each encrypted message is unique.\n\nThe provided salt should be in hex-encoded String form, be random, and be at least 8 bytes in length.\nYou can generate such a salt by using a `KeyGenerator`:\n\n.Generating a key\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nString salt = KeyGenerators.string().generateKey(); // generates a random 8-byte salt that is then hex-encoded\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval salt = KeyGenerators.string().generateKey() // generates a random 8-byte salt that is then hex-encoded\n----\n======\n\nYou can also use the `standard` encryption method, which is 256-bit AES in Cipher Block Chaining (CBC) Mode.\nThis mode is not https://en.wikipedia.org/wiki/Authenticated_encryption[authenticated] and does not provide any\nguarantees about the authenticity of the data.\nFor a more secure alternative, use `Encryptors.stronger`.\n\n[[spring-security-crypto-encryption-text]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/cryptography.adoc", "title": "cryptography", "heading": "BytesEncryptor", "heading_level": 3, "file_order": 9, "section_index": 2, "content_hash": "0a9d542a8cf526b17c72eef59850658c318506406c592026c44445f28e15d60a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/cryptography.adoc"}}
{"id": "sha256:e549e0e63c2647d43736746b5d7b39bc94bbf8861ce3ee3064e2f409cadcd6cf", "content": "You can use the `Encryptors.text` factory method to construct a standard TextEncryptor:\n\n.TextEncryptor\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nEncryptors.text(\"password\", \"salt\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nEncryptors.text(\"password\", \"salt\")\n----\n======\n\nA `TextEncryptor` uses a standard `BytesEncryptor` to encrypt text data.\nEncrypted results are returned as hex-encoded strings for easy storage on the filesystem or in a database.\n\n[[spring-security-crypto-keygenerators]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/cryptography.adoc", "title": "cryptography", "heading": "TextEncryptor", "heading_level": 3, "file_order": 9, "section_index": 3, "content_hash": "e549e0e63c2647d43736746b5d7b39bc94bbf8861ce3ee3064e2f409cadcd6cf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/cryptography.adoc"}}
{"id": "sha256:2b17d7d4c90a13202417af17db1050f57b0237e2193bf6ed71b94a9f525d2e9e", "content": "The javadoc:org.springframework.security.crypto.keygen.KeyGenerators[] class provides a number of convenience factory methods for constructing different types of key generators.\nBy using this class, you can create a javadoc:org.springframework.security.crypto.keygen.BytesKeyGenerator[] to generate `byte[]` keys.\nYou can also construct a javadoc:org.springframework.security.crypto.keygen.StringKeyGenerator[] to generate string keys.\n`KeyGenerators` is a thread-safe class.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/cryptography.adoc", "title": "cryptography", "heading": "Key Generators", "heading_level": 2, "file_order": 9, "section_index": 4, "content_hash": "2b17d7d4c90a13202417af17db1050f57b0237e2193bf6ed71b94a9f525d2e9e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/cryptography.adoc"}}
{"id": "sha256:21624b5222c5a9a4d8dcc13ec081074c473239b4b9ad5d9df97daeeedce38075", "content": "You can use the `KeyGenerators.secureRandom` factory methods to generate a `BytesKeyGenerator` backed by a `SecureRandom` instance:\n\n.BytesKeyGenerator\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nBytesKeyGenerator generator = KeyGenerators.secureRandom();\nbyte[] key = generator.generateKey();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval generator = KeyGenerators.secureRandom()\nval key = generator.generateKey()\n----\n======\n\nThe default key length is 8 bytes.\nA `KeyGenerators.secureRandom` variant provides control over the key length:\n\n.KeyGenerators.secureRandom\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nKeyGenerators.secureRandom(16);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nKeyGenerators.secureRandom(16)\n----\n======\n\nUse the `KeyGenerators.shared` factory method to construct a BytesKeyGenerator that always returns the same key on every invocation:\n\n.KeyGenerators.shared\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nKeyGenerators.shared(16);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nKeyGenerators.shared(16)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/cryptography.adoc", "title": "cryptography", "heading": "BytesKeyGenerator", "heading_level": 3, "file_order": 9, "section_index": 5, "content_hash": "21624b5222c5a9a4d8dcc13ec081074c473239b4b9ad5d9df97daeeedce38075", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/cryptography.adoc"}}
{"id": "sha256:bb8b09e05bc48fb5bfc85367c10f985cd55ca036853b58bf13d0ed6ebaf49467", "content": "You can use the `KeyGenerators.string` factory method to construct an 8-byte, `SecureRandom` `KeyGenerator` that hex-encodes each key as a `String`:\n\n.StringKeyGenerator\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nKeyGenerators.string();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nKeyGenerators.string()\n----\n======\n\n[[spring-security-crypto-passwordencoders]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/cryptography.adoc", "title": "cryptography", "heading": "StringKeyGenerator", "heading_level": 3, "file_order": 9, "section_index": 6, "content_hash": "bb8b09e05bc48fb5bfc85367c10f985cd55ca036853b58bf13d0ed6ebaf49467", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/cryptography.adoc"}}
{"id": "sha256:a66c2a4dcaddf98f1656b8b10e01534fcac254aed8a285fac54536021fb16e35", "content": "The password package of the `spring-security-crypto` module provides support for encoding passwords.\n`PasswordEncoder` is the central service interface and has the following signature:\n\n[source,java]\n----\npublic interface PasswordEncoder {\n\tString encode(CharSequence rawPassword);\n\n\tboolean matches(CharSequence rawPassword, String encodedPassword);\n\n\tdefault boolean upgradeEncoding(String encodedPassword) {\n return false;\n\t}\n}\n----\n\nThe `matches` method returns true if the `rawPassword`, once encoded, equals the `encodedPassword`.\nThis method is designed to support password-based authentication schemes.\n\nThe `BCryptPasswordEncoder` implementation uses the widely supported \"`bcrypt`\" algorithm to hash the passwords.\nBcrypt uses a random 16-byte salt value and is a deliberately slow algorithm, to hinder password crackers.\nYou can tune the amount of work it does by using the `strength` parameter, which takes a value from 4 to 31.\nThe higher the value, the more work has to be done to calculate the hash.\nThe default value is `10`.\nYou can change this value in your deployed system without affecting existing passwords, as the value is also stored in the encoded hash.\nThe following example uses the `BCryptPasswordEncoder`:\n\n.BCryptPasswordEncoder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n\nBCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16);\nString result = encoder.encode(\"myPassword\");\nassertTrue(encoder.matches(\"myPassword\", result));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n\nval encoder = BCryptPasswordEncoder(16)\nval result: String = encoder.encode(\"myPassword\")\nassertTrue(encoder.matches(\"myPassword\", result))\n----\n======\n\nThe `Pbkdf2PasswordEncoder` implementation uses PBKDF2 algorithm to hash the passwords.\nTo defeat password cracking, PBKDF2 is a deliberately slow algorithm and should be tuned to take about .5 seconds to verify a password on your system.\nThe following system uses the `Pbkdf2PasswordEncoder`:\n\n.Pbkdf2PasswordEncoder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nPbkdf2PasswordEncoder encoder = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8();\nString result = encoder.encode(\"myPassword\");\nassertTrue(encoder.matches(\"myPassword\", result));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval encoder = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8()\nval result: String = encoder.encode(\"myPassword\")\nassertTrue(encoder.matches(\"myPassword\", result))\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/cryptography.adoc", "title": "cryptography", "heading": "Password Encoding", "heading_level": 2, "file_order": 9, "section_index": 7, "content_hash": "a66c2a4dcaddf98f1656b8b10e01534fcac254aed8a285fac54536021fb16e35", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/cryptography.adoc"}}
{"id": "sha256:67d3a063920253aed03db612a51659d53563e5ab7ed6385ee38ffbb34087476a", "content": "[[data]]\n\nSpring Security provides Spring Data integration that allows referring to the current user within your queries.\nIt is not only useful but necessary to include the user in the queries to support paged results since filtering the results afterwards would not scale.\n\n[[data-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/data.adoc", "title": "data", "heading": "data", "heading_level": 1, "file_order": 10, "section_index": 0, "content_hash": "67d3a063920253aed03db612a51659d53563e5ab7ed6385ee38ffbb34087476a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/data.adoc"}}
{"id": "sha256:10bd928e57e9c78aab29192749ee5bebb38f33586473138e96cd53e843725fc2", "content": "To use this support, add `org.springframework.security:spring-security-data` dependency and provide a bean of type `SecurityEvaluationContextExtension`.\nIn Java Configuration, this would look like:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityEvaluationContextExtension securityEvaluationContextExtension() {\n\treturn new SecurityEvaluationContextExtension();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun securityEvaluationContextExtension(): SecurityEvaluationContextExtension {\n return SecurityEvaluationContextExtension()\n}\n----\n======\n\nIn XML Configuration, this would look like:\n\n[source,xml]\n----\n<bean class=\"org.springframework.security.data.repository.query.SecurityEvaluationContextExtension\"/>\n----\n\n[[data-query]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/data.adoc", "title": "data", "heading": "Spring Data & Spring Security Configuration", "heading_level": 2, "file_order": 10, "section_index": 1, "content_hash": "10bd928e57e9c78aab29192749ee5bebb38f33586473138e96cd53e843725fc2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/data.adoc"}}
{"id": "sha256:2bb06f1adc519a931c2dac3d9b0a8e0765e349cc8d84ce263f43984ba66d47d2", "content": "Now Spring Security can be used within your queries.\nFor example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Repository\npublic interface MessageRepository extends PagingAndSortingRepository<Message,Long> {\n\t@Query(\"select m from Message m where m.to.id = ?#{ principal?.id }\")\n\tPage<Message> findInbox(Pageable pageable);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Repository\ninterface MessageRepository : PagingAndSortingRepository<Message?, Long?> {\n @Query(\"select m from Message m where m.to.id = ?#{ principal?.id }\")\n fun findInbox(pageable: Pageable?): Page<Message?>?\n}\n----\n======\n\nThis checks to see if the `Authentication.getPrincipal().getId()` is equal to the recipient of the `Message`.\nNote that this example assumes you have customized the principal to be an Object that has an id property.\nBy exposing the `SecurityEvaluationContextExtension` bean, all of the xref:servlet/authorization/method-security.adoc#authorization-expressions[Common Security Expressions] are available within the Query.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/data.adoc", "title": "data", "heading": "Security Expressions within @Query", "heading_level": 2, "file_order": 10, "section_index": 2, "content_hash": "2bb06f1adc519a931c2dac3d9b0a8e0765e349cc8d84ce263f43984ba66d47d2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/data.adoc"}}
{"id": "sha256:d21d3937fed150273f57c58064ece243f716b31c9d481d08689c7872e28815ca", "content": "[[integrations]]\n\nSpring Security provides integrations with numerous frameworks and APIs.\nIn this section, we discuss generic integrations that are not specific to Servlet or Reactive environments.\nTo see specific integrations, refer to the xref:servlet/integrations/index.adoc[Servlet] and xref:reactive/integrations/cors.adoc[Reactive] Integrations sections.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 11, "section_index": 0, "content_hash": "d21d3937fed150273f57c58064ece243f716b31c9d481d08689c7872e28815ca", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/index.adoc"}}
{"id": "sha256:4e7e2e7b1afb5862af449963ab26552224caa70f987822c2a99ca235ca5fd87b", "content": "[[jackson]]\n\nSpring Security provides Jackson 3 support for persisting Spring Security related classes.\nThis can improve the performance of serializing Spring Security related classes when working with distributed sessions (i.e. session replication, Spring Session, etc).\n\n[NOTE]\n====\nJackson 2 support is still available but deprecated for removal, so you are encouraged to migrate to Jackson 3.\n====\n\nTo use it, register `SecurityJacksonModules.getModules(ClassLoader)` with `JsonMapper.Builder` (https://github.com/FasterXML/jackson-databind[jackson-databind]):\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nClassLoader loader = getClass().getClassLoader();\nJsonMapper mapper = JsonMapper.builder()\n .addModules(SecurityJacksonModules.getModules(loader))\n .build();\n\nSecurityContext context = new SecurityContextImpl();\nString json = mapper.writeValueAsString(context);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval loader = javaClass.classLoader\nval mapper = JsonMapper.builder()\n .addModules(SecurityJacksonModules.getModules(loader))\n .build()\n\nval context: SecurityContext = SecurityContextImpl()\nval json: String = mapper.writeValueAsString(context)\n----\n======\n\n[NOTE]\n====\nUsing `SecurityJacksonModules` as above enables automatic inclusion of type information and configure a\n`PolymorphicTypeValidator` that handles the validation of class names.\n====\n\nIf needed, you can add custom classes to the validation handling.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nClassLoader loader = getClass().getClassLoader();\nBasicPolymorphicTypeValidator.Builder builder = BasicPolymorphicTypeValidator.builder()\n .allowIfSubType(MyCustomType.class);\nJsonMapper mapper = JsonMapper.builder()\n .addModules(SecurityJacksonModules.getModules(loader, builder))\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval loader = javaClass.classLoader\nval builder = BasicPolymorphicTypeValidator.builder()\n .allowIfSubType(MyCustomType::class)\nval mapper = JsonMapper.builder()\n .addModules(SecurityJacksonModules.getModules(loader, builder))\n .build()\n----\n======\n\n[NOTE]\n====\nThe following Spring Security modules provide Jackson support:\n\n- spring-security-core (javadoc:org.springframework.security.jackson.CoreJacksonModule[])\n- spring-security-web (javadoc:org.springframework.security.web.jackson.WebJacksonModule[], javadoc:org.springframework.security.web.jackson.WebServletJacksonModule[], javadoc:org.springframework.security.web.server.jackson.WebServerJacksonModule[])\n- spring-security-oauth2-client (javadoc:org.springframework.security.oauth2.client.jackson.OAuth2ClientJacksonModule[])\n- spring-security-oauth2-authorization-server (javadoc:org.springframework.security.oauth2.server.authorization.jackson.OAuth2AuthorizationServerJacksonModule[])\n- spring-security-cas (javadoc:org.springframework.security.cas.jackson.CasJacksonModule[])\n- spring-security-ldap (javadoc:org.springframework.security.ldap.jackson.LdapJacksonModule[])\n- spring-security-saml2 (javadoc:org.springframework.security.saml2.jackson.Saml2JacksonModule[])\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/jackson.adoc", "title": "jackson", "heading": "jackson", "heading_level": 1, "file_order": 12, "section_index": 0, "content_hash": "4e7e2e7b1afb5862af449963ab26552224caa70f987822c2a99ca235ca5fd87b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/jackson.adoc"}}
{"id": "sha256:ded97bdfe0f632916429d1e43becf0d7d927093c4d6a2b0b65e2113bfef27d65", "content": "[[localization]]\nSpring Security supports localization of exception messages that end users are likely to see.\nIf your application is designed for English-speaking users, you don't need to do anything as by default all Security messages are in English.\nIf you need to support other locales, everything you need to know is contained in this section.\n\nAll exception messages can be localized, including messages related to authentication failures and access being denied (authorization failures).\nExceptions and logging messages that are focused on developers or system deployers (including incorrect attributes, interface contract violations, using incorrect constructors, startup time validation, debug-level logging) are not localized and instead are hard-coded in English within Spring Security's code.\n\nShipping in the `spring-security-core-xx.jar` you will find an `org.springframework.security` package that in turn contains a `messages.properties` file, as well as localized versions for some common languages.\nThis should be referred to by your `ApplicationContext`, as Spring Security classes implement Spring's `MessageSourceAware` interface and expect the message resolver to be dependency injected at application context startup time.\nUsually all you need to do is register a bean inside your application context to refer to the messages.\nAn example is shown below:\n\n[source,xml]\n----\n<bean id=\"messageSource\"\n\tclass=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\">\n<property name=\"basename\" value=\"classpath:org/springframework/security/messages\"/>\n</bean>\n----\n\nThe `messages.properties` is named in accordance with standard resource bundles and represents the default language supported by Spring Security messages.\nThis default file is in English.\n\nIf you wish to customize the `messages.properties` file, or support other languages, you should copy the file, rename it accordingly, and register it inside the above bean definition.\nThere are not a large number of message keys inside this file, so localization should not be considered a major initiative.\nIf you do perform localization of this file, please consider sharing your work with the community by logging a JIRA task and attaching your appropriately-named localized version of `messages.properties`.\n\nSpring Security relies on Spring's localization support in order to actually lookup the appropriate message.\nIn order for this to work, you have to make sure that the locale from the incoming request is stored in Spring's `org.springframework.context.i18n.LocaleContextHolder`.\nSpring MVC's `DispatcherServlet` does this for your application automatically, but since Spring Security's filters are invoked before this, the `LocaleContextHolder` needs to be set up to contain the correct `Locale` before the filters are called.\nYou can either do this in a filter yourself (which must come before the Spring Security filters in `web.xml`) or you can use Spring's `RequestContextFilter`.\nPlease refer to the Spring Framework documentation for further details on using localization with Spring.\n\nThe \"contacts\" sample application is set up to use localized messages.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/integrations/localization.adoc", "title": "localization", "heading": "localization", "heading_level": 1, "file_order": 13, "section_index": 0, "content_hash": "ded97bdfe0f632916429d1e43becf0d7d927093c4d6a2b0b65e2113bfef27d65", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/integrations/localization.adoc"}}
{"id": "sha256:e25dbbda09a0fb0f82db522be82cd113f54637fc99ad18cf2265fdca0ea4b0f3", "content": "[[features]]\n\nSpring Security provides comprehensive support for xref:features/authentication/index.adoc[authentication], xref:features/authorization/index.adoc[authorization], and protection against xref:features/exploits/index.adoc#exploits[common exploits].\nIt also provides integration with other libraries to simplify its usage.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/features/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 14, "section_index": 0, "content_hash": "e25dbbda09a0fb0f82db522be82cd113f54637fc99ad18cf2265fdca0ea4b0f3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/features/index.adoc"}}
{"id": "sha256:d69173d68ca654fd4ca15499ddbc3b833c883253aef785a8eadfd39ab44de96a", "content": "Spring Security 7 moves `AccessDecisionManager`, `AccessDecisionVoter`, and the related Access API to a legacy module, `spring-security-access`.\nThe Access API is deprecated in favor of the Authorization API as of Spring Security 5.\n\nYou can add the dependency like other Spring Security dependencies like so:\n\n[tabs]\n======\nMaven::\n+\n[source,xml,role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.security</groupId>\n <artifactId>spring-security-access</artifactId>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,role=\"primary\"]\n----\nimplementation('org.springframework.security:spring-security-access')\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/servlet/authorization.adoc", "title": "Authorization Changes", "heading": "If Using Access API, Add `spring-security-access`", "heading_level": 2, "file_order": 15, "section_index": 0, "content_hash": "d69173d68ca654fd4ca15499ddbc3b833c883253aef785a8eadfd39ab44de96a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/servlet/authorization.adoc"}}
{"id": "sha256:fefd4a207f9598d4037f616f7d392e21e739abb77bc754cbb15957af8cf094c6", "content": "If you have already performed the xref:migration/index.adoc[initial migration steps] for your Servlet application, you're now ready to perform steps specific to Servlet applications.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/servlet/index.adoc", "title": "Servlet Migrations", "heading": "Servlet Migrations", "heading_level": 1, "file_order": 16, "section_index": 0, "content_hash": "fefd4a207f9598d4037f616f7d392e21e739abb77bc754cbb15957af8cf094c6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/servlet/index.adoc"}}
{"id": "sha256:664d59ffbe6a40245c9b6c88d2847491100961da0ce93fb701ab6fca3ff94635", "content": "If when following the 6.5 preparatory steps you set `validateTypes` to `false`, you can now remove it.\nYou can also remove explicitly adding `JwtTypeValidator` to the list of defaults.\n\nFor example, change this:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n\tNimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withIssuerLocation(location)\n .validateTypes(false) <1>\n // ... your remaining configuration\n .build();\n\tjwtDecoder.setJwtValidator(JwtValidators.createDefaultWithValidators(\n new JwtIssuerValidator(location), JwtTypeValidator.jwt())); <2>\n\treturn jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n val jwtDecoder = NimbusJwtDecoder.withIssuerLocation(location)\n .validateTypes(false) <1>\n // ... your remaining configuration\n .build()\n jwtDecoder.setJwtValidator(JwtValidators.createDefaultWithValidators(\n JwtIssuerValidator(location), JwtTypeValidator.jwt())) <2>\n return jwtDecoder\n}\n----\n======\n<1> - Switch off Nimbus verifying the `typ`\n<2> - Add the default `typ` validator\n\nto this:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n\tNimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withIssuerLocation(location)\n // ... your remaining configuration <1>\n .build();\n\tjwtDecoder.setJwtValidator(JwtValidators.createDefaultWithIssuer(location)); <2>\n\treturn jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n val jwtDecoder = NimbusJwtDecoder.withIssuerLocation(location)\n // ... your remaining configuration\n .build()\n jwtDecoder.setJwtValidator(JwtValidators.createDefaultWithIssuer(location)) <2>\n return jwtDecoder\n}\n----\n======\n<1> - `validateTypes` now defaults to `false`\n<2> - `JwtTypeValidator#jwt` is added by all `createDefaultXXX` methods", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/servlet/oauth2.adoc", "title": "OAuth 2.0 Migrations", "heading": "Validate `typ` Header with `JwtTypeValidator`", "heading_level": 2, "file_order": 17, "section_index": 0, "content_hash": "664d59ffbe6a40245c9b6c88d2847491100961da0ce93fb701ab6fca3ff94635", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/servlet/oauth2.adoc"}}
{"id": "sha256:e043eacdd56425dbb90d8cb7463cdf50e8dacf81f880dbade6d9edf409550c8d", "content": "In Spring Security 7, `BearerTokenAuthenticationFilter#setBearerTokenResolver` and `#setAuthenticaionDetailsSource` are deprecated in favor of configuring those on `BearerTokenAuthenticationConverter`.\n\nThe `oauth2ResourceServer` DSL addresses most use cases and you need to nothing.\n\nIf you are setting a `BearerTokenResolver` or `AuthenticationDetailsSource` directly on `BearerTokenAuthenticationFilter` similar to the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nBearerTokenAuthenticationFilter filter = new BearerTokenAuthenticationFilter(authenticationManager);\nfilter.setBearerTokenResolver(myBearerTokenResolver);\nfilter.setAuthenticationDetailsSource(myAuthenticationDetailsSource);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval filter = BearerTokenAuthenticationFilter(authenticationManager)\nfilter.setBearerTokenResolver(myBearerTokenResolver)\nfilter.setAuthenticationDetailsSource(myAuthenticationDetailsSource)\n----\n======\n\nyou are encouraged to use `BearerTokenAuthenticationConverter` to specify both:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nBearerTokenAuthenticationConverter authenticationConverter =\n new BearerTokenAuthenticationConverter();\nauthenticationConverter.setBearerTokenResolver(myBearerTokenResolver);\nauthenticationConverter.setAuthenticationDetailsSource(myAuthenticationDetailsSource);\nBearerTokenAuthenticationFilter filter = new BearerTokenAuthenticationFilter(authenticationManager, authenicationConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval authenticationConverter = BearerTokenAuthenticationConverter()\nauthenticationConverter.setBearerTokenResolver(myBearerTokenResolver)\nauthenticationConverter.setAuthenticationDetailsSource(myAuthenticationDetailsSource)\nval filter = BearerTokenAuthenticationFilter(authenticationManager, authenticationConverter)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/servlet/oauth2.adoc", "title": "OAuth 2.0 Migrations", "heading": "Provide an AuthenticationConverter to BearerTokenAuthenticationFilter", "heading_level": 2, "file_order": 17, "section_index": 1, "content_hash": "e043eacdd56425dbb90d8cb7463cdf50e8dacf81f880dbade6d9edf409550c8d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/servlet/oauth2.adoc"}}
{"id": "sha256:88ee2540ff6265a103e8879d928eac3d0329786e0f056d528d872435680f0fca", "content": "SAML identity providers expect service providers to return an error `<saml2:LogoutResponse>` if it fails to process the `<saml2:LogoutRequest>`.\n\nPast versions of Spring Security returned a 401 in some cases, breaking the chain of logout requests and responses from each relying party.\n\nIn Spring Security 7, this behavior is repaired, and you need do nothing.\n\nHowever, if this gives you trouble, you can revert back to the old behavior by publishing a `Saml2LogoutRequestResolver` that returns `null` when an error `<saml2:LogoutRequest>` is needed.\nYou can create a delegate like this one:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSaml2LogoutResponseResolver logoutResponseResolver(RelyingPartyRegistrationRepository registrations) {\n OpenSaml5LogoutResponseResolver delegate = new OpenSaml5LogoutResponseResolver(registrations);\n return new Saml2LogoutResponseResolver() {\n @Override\n public void resolve(HttpServletRequest request, Authentication authentication) {\n delegate.resolve(request, authentication);\n }\n\n @Override\n public void resolve(HttpServletRequest request, Authentication authentication, Saml2AuthenticationException error) {\n return null;\n }\n };\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun logoutResponseResolver(registrations: RelyingPartyRegistrationRepository?): Saml2LogoutResponseResolver {\n val delegate = OpenSaml5LogoutResponseResolver(registrations)\n return object : Saml2LogoutResponseResolver() {\n override fun resolve(request: HttpServletRequest?, authentication: Authentication?) {\n delegate.resolve(request, authentication)\n }\n\n override fun resolve(request: HttpServletRequest?, authentication: Authentication?, error: Saml2AuthenticationException?) {\n return null\n }\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/servlet/saml2.adoc", "title": "SAML 2.0 Migrations", "heading": "Expect `<saml2:LogoutResponse>` When `<saml2:LogoutRequest>` Validation Fails", "heading_level": 2, "file_order": 18, "section_index": 0, "content_hash": "88ee2540ff6265a103e8879d928eac3d0329786e0f056d528d872435680f0fca", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/servlet/saml2.adoc"}}
{"id": "sha256:fb2894e66fd39f9179b520ff40b0cd7f9691a270bf1aa0681beaed569f79caf6", "content": "Spring Security 7 separates `<saml2:Assertion>` details from the principal.\nThis allows Spring Security to retrieve needed assertion details to perform Single Logout.\n\nThis deprecates `Saml2AuthenticatedPrincipal`.\nYou no longer need to implement it to use `Saml2Authentication`.\n\nInstead, the credential implements `Saml2ResponseAssertionAccessor`, which Spring Security 7 favors when determining the appropriate action based on the authentication.\n\nThis change is made automatically for you when using the defaults.\n\nIf this causes you trouble when upgrading, you can publish a custom `ResponseAuhenticationConverter` to return a `Saml2Authentication` instead of returning a `Saml2AssertionAuthentication` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nOpenSaml5AuthenticationProvider authenticationProvider() {\n\tOpenSaml5AuthenticationProvider authenticationProvider =\n new OpenSaml5AuthenticationProvider();\n\tResponseAuthenticationConverter defaults = new ResponseAuthenticationConverter();\n\tauthenticationProvider.setResponseAuthenticationConverter(\n defaults.andThen((authentication) -> new Saml2Authentication(\n authentication.getPrincipal(),\n authentication.getSaml2Response(),\n authentication.getAuthorities())));\n\treturn authenticationProvider;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationProvider(): OpenSaml5AuthenticationProvider {\n\tval authenticationProvider = OpenSaml5AuthenticationProvider()\n\tval defaults = ResponseAuthenticationConverter()\n\tauthenticationProvider.setResponseAuthenticationConverter(\n defaults.andThen { authentication ->\n Saml2Authentication(authentication.getPrincipal(),\n authentication.getSaml2Response(),\n authentication.getAuthorities())\n })\n\treturn authenticationProvider\n}\n----\n======\n\nIf you are constructing a `Saml2Authentication` instance yourself, consider changing to `Saml2AssertionAuthentication` to get the same benefit as the current default.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/servlet/saml2.adoc", "title": "SAML 2.0 Migrations", "heading": "Favor `Saml2ResponseAuthenticationAccessor` over `Saml2AuthenticatedPrincipal`", "heading_level": 2, "file_order": 18, "section_index": 1, "content_hash": "fb2894e66fd39f9179b520ff40b0cd7f9691a270bf1aa0681beaed569f79caf6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/servlet/saml2.adoc"}}
{"id": "sha256:fb591ac47c12cd8a82cacf0162c5e43e93175ccaa3a3c2fd71436e68073b72ca", "content": "Spring Security does not support processing `<saml2:Response>` payloads over GET as this is not supported by the SAML 2.0 spec.\n\nTo better comply with this, `Saml2AuthenticationTokenConverter` and `OpenSaml5AuthenticationTokenConverter` will not process GET requests by default as of Spring Security 8.\nTo prepare for this, the property `shouldConvertGetRequests` is available.\nTo use it, publish your own converter like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nOpenSaml5AuthenticationTokenConverter authenticationConverter(RelyingPartyRegistrationRepository registrations) {\n\tOpenSaml5AuthenticationTokenConverter authenticationConverter = new OpenSaml5AuthenticationTokenConverter(registrations);\n\tauthenticationConverter.setShouldConvertGetRequests(false);\n\treturn authenticationConverter;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationConverter(val registrations: RelyingPartyRegistrationRepository): Saml2AuthenticationTokenConverter {\n\tval authenticationConverter = Saml2AuthenticationTokenConverter(registrations)\n\tauthenticationConverter.setShouldConvertGetRequests(false)\n\treturn authenticationConverter\n}\n----\n======\n\nIf you must continue using `Saml2AuthenticationTokenConverter` or `OpenSaml5AuthenticationTokenConverter` to process GET requests, you can call `setShouldConvertGetRequests` to `true.`", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/servlet/saml2.adoc", "title": "SAML 2.0 Migrations", "heading": "Do Not Process `<saml2:Response>` GET Requests with `Saml2AuthenticationTokenConverter`", "heading_level": 2, "file_order": 18, "section_index": 2, "content_hash": "fb591ac47c12cd8a82cacf0162c5e43e93175ccaa3a3c2fd71436e68073b72ca", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/servlet/saml2.adoc"}}
{"id": "sha256:96ca3d9f0f74964cb87cd4322f391e5d74fc3ac2237d5cfe2409c8a0752b7edb", "content": "[[migration]]\n\nSpring Security 6.5 is the last release in the 6.x generation of Spring Security.\nIt provides strategies for configuring breaking changes to use the 7.0 way before updating.\nWe recommend you use 6.5 and {spring-security-reference-base-url}/6.5/migration-7/index.html[its preparation steps] to simplify updating to 7.0.\n\nAfter updating to 6.5, follow this guide to perform any remaining migration or cleanup steps.\n\nAnd recall that if you run into trouble, the preparation guide includes opt-out steps to revert to 5.x behaviors.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 19, "section_index": 0, "content_hash": "96ca3d9f0f74964cb87cd4322f391e5d74fc3ac2237d5cfe2409c8a0752b7edb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/index.adoc"}}
{"id": "sha256:1fb945d140ccfd3b610d1d804c84c9dbd17a7ee7906ac9ad25dd519940552828", "content": "The first step is to ensure you are the latest patch release of Spring Boot 4.0.\nNext, you should ensure you are on the latest patch release of Spring Security 7.\nFor directions, on how to update to Spring Security 7 visit the xref:getting-spring-security.adoc[] section of the reference guide.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/index.adoc", "title": "index", "heading": "Update to Spring Security 7", "heading_level": 2, "file_order": 19, "section_index": 1, "content_hash": "1fb945d140ccfd3b610d1d804c84c9dbd17a7ee7906ac9ad25dd519940552828", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/index.adoc"}}
{"id": "sha256:d72ad488a11e713f986790603c1cda8d1e2cf3db0b8f2a6a5f38c633317480c0", "content": "The configuration of Jackson 2 `ObjectMapper` with `SecurityJackson2Modules` should be replaced by the configuration of\nJackson 3 `JsonMapper.Builder` with `SecurityJacksonModules`. See the\nhttps://github.com/FasterXML/jackson/blob/main/jackson3/MIGRATING_TO_JACKSON_3.md[Jackson 3 Migration Guide] for more details.\n\nIt is recommended to replace the configuration of\nindividual modules like `CoreJacksonModule` by the module detection from `SecurityJacksonModules` as it enables\nautomatic inclusion of type information and configure a `PolymorphicTypeValidator` that handles the validation of class\nnames.\n\nThe Jackson 3 support uses a format compatible with the now deprecated Jackson 2 one, so class instances serialized with\nJackson 2 should be deserializable with the Jackson 3 support.\n\n`spring-security-oauth2-authorization-server` now uses Jackson 3 by default. If you want to continue\nto use the deprecated Jackson 2 support, the transitive dependency on Jackson 3 (`tools.jackson.core:jackson-databind`)\nshould be excluded and a dependency on Jackson 2 (`com.fasterxml.jackson.core:jackson-databind`) should be added.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/index.adoc", "title": "index", "heading": "Migrate from Jackson 2 to Jackson 3", "heading_level": 3, "file_order": 19, "section_index": 2, "content_hash": "d72ad488a11e713f986790603c1cda8d1e2cf3db0b8f2a6a5f38c633317480c0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/index.adoc"}}
{"id": "sha256:1236d2e057623b5517d318bc9237e75d05c1c3761b938040978a61f71a888eea", "content": "Next, there are steps you need to perform based on whether it is a xref:migration/servlet/index.adoc[Servlet] or xref:migration/reactive.adoc[Reactive] application.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/index.adoc", "title": "index", "heading": "Perform Application-Specific Steps", "heading_level": 2, "file_order": 19, "section_index": 3, "content_hash": "1236d2e057623b5517d318bc9237e75d05c1c3761b938040978a61f71a888eea", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/index.adoc"}}
{"id": "sha256:b4d883237077cec844025644ce00906cec1d024823d053912c05c2944c6ae485", "content": "If you have already performed the xref:migration/index.adoc[initial migration steps] for your Reactive application, you're now ready to perform steps specific to Reactive applications.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/reactive.adoc", "title": "Reactive", "heading": "Reactive", "heading_level": 1, "file_order": 20, "section_index": 0, "content_hash": "b4d883237077cec844025644ce00906cec1d024823d053912c05c2944c6ae485", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/reactive.adoc"}}
{"id": "sha256:7e37d4b1e5c6bfd1b99bb82ec4da6ac12c22c75fa734bd273a4afe746d1207f0", "content": "If when following the 6.5 preparatory steps you set `validateTypes` to `false`, you can now remove it.\nYou can also remove explicitly adding `JwtTypeValidator` to the list of defaults.\n\nFor example, change this:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n\tNimbusReactiveJwtDecoder jwtDecoder = NimbusReactiveJwtDecoder.withIssuerLocation(location)\n .validateTypes(false) <1>\n // ... your remaining configuration\n .build();\n\tjwtDecoder.setJwtValidator(JwtValidators.createDefaultWithValidators(\n new JwtIssuerValidator(location), JwtTypeValidator.jwt())); <2>\n\treturn jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n val jwtDecoder = NimbusReactiveJwtDecoder.withIssuerLocation(location)\n .validateTypes(false) <1>\n // ... your remaining configuration\n .build()\n jwtDecoder.setJwtValidator(JwtValidators.createDefaultWithValidators(\n JwtIssuerValidator(location), JwtTypeValidator.jwt())) <2>\n return jwtDecoder\n}\n----\n======\n<1> - Switch off Nimbus verifying the `typ`\n<2> - Add the default `typ` validator\n\nto this:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nNimbusReactiveJwtDecoder jwtDecoder() {\n\tNimbusJwtDecoder jwtDecoder = NimbusReactiveJwtDecoder.withIssuerLocation(location)\n // ... your remaining configuration <1>\n .build();\n\tjwtDecoder.setJwtValidator(JwtValidators.createDefaultWithIssuer(location)); <2>\n\treturn jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): NimbusReactiveJwtDecoder {\n val jwtDecoder = NimbusReactiveJwtDecoder.withIssuerLocation(location)\n // ... your remaining configuration\n .build()\n jwtDecoder.setJwtValidator(JwtValidators.createDefaultWithIssuer(location)) <2>\n return jwtDecoder\n}\n----\n======\n<1> - `validateTypes` now defaults to `false`\n<2> - `JwtTypeValidator#jwt` is added by all `createDefaultXXX` methods", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration/reactive.adoc", "title": "Reactive", "heading": "Validate `typ` Header with `JwtTypeValidator`", "heading_level": 2, "file_order": 20, "section_index": 1, "content_hash": "7e37d4b1e5c6bfd1b99bb82ec4da6ac12c22c75fa734bd273a4afe746d1207f0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration/reactive.adoc"}}
{"id": "sha256:fa413dee90205d2d1cec249ac25e78e1f883cc339face60641c1760930ae80de", "content": "[[preparing]]\n\nWhile Spring Security 8.0 does not have a release date yet, it is important to start preparing for it now.\n\nThis preparation guide is designed to summarize the biggest changes in Spring Security 8.0 and provide steps to prepare for them.\n\nIt is important to keep your application up to date with the latest Spring Security 7 and Spring Boot 4 releases.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/migration-8/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 21, "section_index": 0, "content_hash": "fa413dee90205d2d1cec249ac25e78e1f883cc339face60641c1760930ae80de", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/migration-8/index.adoc"}}
{"id": "sha256:7999f35d82bb7a32e7d3bb30822673fdbe2aea1f2468d27f989f43ecd0f08649", "content": "Spring Boot 3.0 provides https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images[support for generating native images with GraalVM].\nSpring Security integrates with that support and provides its features ready for native images.\n\nHowever, as mentioned in the https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.introducing-graalvm-native-images.understanding-aot-processing.hint-file-generation[Spring Boot documentation], there are some cases where we need to provide hints to be used by GraalVM.\n\nThis section aims to provide guidance in some Spring Security features that likely need to have additional hints provided by the application.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/native-image/index.adoc", "title": "GraalVM Native Image Support", "heading": "GraalVM Native Image Support", "heading_level": 1, "file_order": 22, "section_index": 0, "content_hash": "7999f35d82bb7a32e7d3bb30822673fdbe2aea1f2468d27f989f43ecd0f08649", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/native-image/index.adoc"}}
{"id": "sha256:adcfe1f54735deecb061429c89c729d291d0d06710d0f060074acd9dda7367d2", "content": "[[native-image-method-security]]\n\nAlthough xref:servlet/authorization/method-security.adoc[Method Security] is supported in GraalVM Native Image, there are some use cases that need additional hints provided by the application.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/native-image/method-security.adoc", "title": "method-security", "heading": "method-security", "heading_level": 1, "file_order": 23, "section_index": 0, "content_hash": "adcfe1f54735deecb061429c89c729d291d0d06710d0f060074acd9dda7367d2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/native-image/method-security.adoc"}}
{"id": "sha256:278bdfe1f1e9dcf6cf666d16cb159de06a0a4db346d9b7fad3226ba7510c9d98", "content": "Using `@PreAuthorize` and `@PostAuthorize` annotations require additional hints if you have a custom implementation of `UserDetails` or `Authentication` classes.\n\nLet's take an example where you have a custom implementation of `UserDetails` class as follows and that implementation is returned by your `UserDetailsService`:\n\n.Custom Implementation of UserDetails\n[source,java]\n----\npublic class CustomUserDetails implements UserDetails {\n\n private final String username;\n\n private final String password;\n\n private final Collection<? extends GrantedAuthority> authorities;\n\n public boolean isAdmin() {\n return this.authorities.contains(new SimpleGrantedAuthority(\"ROLE_ADMIN\"));\n }\n\n // constructors, getters and setters\n}\n----\n\nAnd you want to use the `isAdmin()` method inside a `@PreAuthorize` annotation as follows:\n\n.Using isAdmin() to secure a method\n[source,java]\n----\n@PreAuthorize(\"principal?.isAdmin()\")\npublic String hello() {\n return \"Hello!\";\n}\n----\n\n[NOTE]\n====\nRemember that you need to xref:servlet/authorization/method-security.adoc#jc-enable-method-security[add `@EnableMethodSecurity` annotation] to your configuration class to enable method security annotations.\n====\n\nIf you https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.developing-your-first-application[run the native image] of your application with the above configuration, you will get an error similar to the following when trying to invoke the `hello()` method:\n\n[source]\n----\nfailed: java.lang.IllegalArgumentException: Failed to evaluate expression 'principal?.isAdmin()' with root cause\norg.springframework.expression.spel.SpelEvaluationException: EL1004E: Method call: Method isAdmin() cannot be found on type com.mypackage.CustomUserDetails\n----\n\nWhich means that the `isAdmin()` method cannot be found on the `CustomUserDetails` class.\nThis is because Spring Security uses reflection to invoke the `isAdmin()` method and GraalVM Native Image does not support reflection by default.\n\nTo fix this issue, you need to give hints to GraalVM Native Image to allow reflection on the `CustomUserDetails#isAdmin()` method.\nWe can do that by providing a https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html#native-image.advanced.custom-hints[custom hint].\nIn this example we are going to use {spring-framework-reference-url}core.html#core.aot.hints.register-reflection-for-binding[the `@RegisterReflectionForBinding` annotation].\n\n[NOTE]\n====\nYou might need to register all your classes that you want to use in your `@PreAuthorize` and `@PostAuthorize` annotations.\n====\n\n.Using @RegisterReflectionForBinding\n[source,java]\n----\n@Configuration\n@RegisterReflectionForBinding(CustomUserDetails.class)\npublic class MyConfiguration {\n //...\n}\n----\n\nAnd that's it, now you can run the native image of your application and it should work as expected.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/native-image/method-security.adoc", "title": "method-security", "heading": "Using `@PreAuthorize` and `@PostAuthorize` Annotations", "heading_level": 2, "file_order": 23, "section_index": 1, "content_hash": "278bdfe1f1e9dcf6cf666d16cb159de06a0a4db346d9b7fad3226ba7510c9d98", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/native-image/method-security.adoc"}}
{"id": "sha256:0e8d37754959e2b884d5fb1dbcd40e6a4fa56cf3a1e19182c26980afe2ca6670", "content": "[[reactive-concurrent-sessions-control]]\n\nSimilar to xref:servlet/authentication/session-management.adoc#ns-concurrent-sessions[Servlet's Concurrent Sessions Control], Spring Security also provides support to limit the number of concurrent sessions a user can have in a Reactive application.\n\nWhen you set up Concurrent Sessions Control in Spring Security, it monitors authentications carried out through Form Login, xref:reactive/oauth2/login/index.adoc[OAuth 2.0 Login], and HTTP Basic authentication by hooking into the way those authentication mechanisms handle authentication success.\nMore specifically, the session management DSL will add the javadoc:org.springframework.security.web.server.authentication.ConcurrentSessionControlServerAuthenticationSuccessHandler[] and the javadoc:org.springframework.security.web.server.authentication.RegisterSessionServerAuthenticationSuccessHandler[] to the list of `ServerAuthenticationSuccessHandler` used by the authentication filter.\n\nThe following sections contains examples of how to configure Concurrent Sessions Control.\n\n* <<reactive-concurrent-sessions-control-limit,I want to limit the number of concurrent sessions a user can have>>\n* <<concurrent-sessions-control-custom-strategy,I want to customize the strategy used when the maximum number of sessions is exceeded>>\n* <<reactive-concurrent-sessions-control-specify-session-registry,I want to know how to specify a `ReactiveSessionRegistry`>>\n* <<concurrent-sessions-control-sample,I want to see a sample application that uses Concurrent Sessions Control>>\n* <<disabling-for-authentication-filters,I want to know how to disable it for some authentication filter>>\n\n[[reactive-concurrent-sessions-control-limit]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc", "title": "concurrent-sessions-control", "heading": "concurrent-sessions-control", "heading_level": 1, "file_order": 24, "section_index": 0, "content_hash": "0e8d37754959e2b884d5fb1dbcd40e6a4fa56cf3a1e19182c26980afe2ca6670", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc"}}
{"id": "sha256:1d27db5da7e8c36309a9f5eaa9c1560d91d77d31ef621b98e2e563db0a0aa82c", "content": "By default, Spring Security will allow any number of concurrent sessions for a user.\nTo limit the number of concurrent sessions, you can use the `maximumSessions` DSL method:\n\n.Configuring one session for any user\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .sessionManagement((sessions) -> sessions\n .concurrentSessions((concurrency) -> concurrency\n .maximumSessions(SessionLimit.of(1))\n )\n );\n return http.build();\n}\n\n@Bean\nReactiveSessionRegistry reactiveSessionRegistry() {\n return new InMemoryReactiveSessionRegistry();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n sessionManagement {\n sessionConcurrency {\n maximumSessions = SessionLimit.of(1)\n }\n }\n }\n}\n@Bean\nopen fun reactiveSessionRegistry(): ReactiveSessionRegistry {\n return InMemoryReactiveSessionRegistry()\n}\n----\n======\n\nThe above configuration allows one session for any user.\nSimilarly, you can also allow unlimited sessions by using the `SessionLimit#UNLIMITED` constant:\n\n.Configuring unlimited sessions\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .sessionManagement((sessions) -> sessions\n .concurrentSessions((concurrency) -> concurrency\n .maximumSessions(SessionLimit.UNLIMITED))\n );\n return http.build();\n}\n\n@Bean\nReactiveSessionRegistry reactiveSessionRegistry() {\n return new InMemoryReactiveSessionRegistry();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n sessionManagement {\n sessionConcurrency {\n maximumSessions = SessionLimit.UNLIMITED\n }\n }\n }\n}\n@Bean\nopen fun reactiveSessionRegistry(webSessionManager: WebSessionManager): ReactiveSessionRegistry {\n return InMemoryReactiveSessionRegistry()\n}\n----\n======\n\nSince the `maximumSessions` method accepts a `SessionLimit` interface, which in turn extends `Function<Authentication, Mono<Integer>>`, you can have a more complex logic to determine the maximum number of sessions based on the user's authentication:\n\n.Configuring maximumSessions based on `Authentication`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .sessionManagement((sessions) -> sessions\n .concurrentSessions((concurrency) -> concurrency\n .maximumSessions(maxSessions()))\n );\n return http.build();\n}\n\nprivate SessionLimit maxSessions() {\n return (authentication) -> {\n if (authentication.getAuthorities().contains(new SimpleGrantedAuthority(\"ROLE_UNLIMITED_SESSIONS\"))) {\n return Mono.empty(); // allow unlimited sessions for users with ROLE_UNLIMITED_SESSIONS\n }\n if (authentication.getAuthorities().contains(new SimpleGrantedAuthority(\"ROLE_ADMIN\"))) {\n return Mono.just(2); // allow two sessions for admins\n }\n return Mono.just(1); // allow one session for every other user\n };\n}\n\n@Bean\nReactiveSessionRegistry reactiveSessionRegistry() {\n return new InMemoryReactiveSessionRegistry();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n sessionManagement {\n sessionConcurrency {\n maximumSessions = maxSessions()\n }\n }\n }\n}\n\nfun maxSessions(): SessionLimit {\n return { authentication ->\n if (authentication.authorities.contains(SimpleGrantedAuthority(\"ROLE_UNLIMITED_SESSIONS\"))) Mono.empty\n if (authentication.authorities.contains(SimpleGrantedAuthority(\"ROLE_ADMIN\"))) Mono.just(2)\n Mono.just(1)\n }\n}\n\n@Bean\nopen fun reactiveSessionRegistry(): ReactiveSessionRegistry {\n return InMemoryReactiveSessionRegistry()\n}\n----\n======\n\nWhen the maximum number of sessions is exceeded, by default, the least recently used session(s) will be expired.\nIf you want to change that behavior, you can <<concurrent-sessions-control-custom-strategy,customize the strategy used when the maximum number of sessions is exceeded>>.\n\n[IMPORTANT]\n====\nThe Concurrent Session Management is not aware if there is another session in some Identity Provider that you might use via xref:reactive/oauth2/login/index.adoc[OAuth 2 Login] for example.\nIf you also need to invalidate the session against the Identity Provider you must <<concurrent-sessions-control-custom-strategy,include your own implementation of `ServerMaximumSessionsExceededHandler`>>.\n====\n\n[[concurrent-sessions-control-custom-strategy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc", "title": "concurrent-sessions-control", "heading": "Limiting Concurrent Sessions", "heading_level": 2, "file_order": 24, "section_index": 1, "content_hash": "1d27db5da7e8c36309a9f5eaa9c1560d91d77d31ef621b98e2e563db0a0aa82c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc"}}
{"id": "sha256:cc885dbcb9c3e62f77d173864b974203e17e7803131b98bd12d22dc662b4bc41", "content": "By default, when the maximum number of sessions is exceeded, the least recently used session(s) will be expired by using the javadoc:org.springframework.security.web.server.authentication.InvalidateLeastUsedServerMaximumSessionsExceededHandler[].\nSpring Security also provides another implementation that prevents the user from creating new sessions by using the javadoc:org.springframework.security.web.server.authentication.PreventLoginServerMaximumSessionsExceededHandler[].\nIf you want to use your own strategy, you can provide a different implementation of javadoc:org.springframework.security.web.server.authentication.ServerMaximumSessionsExceededHandler[].\n\n.Configuring maximumSessionsExceededHandler\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .sessionManagement((sessions) -> sessions\n .concurrentSessions((concurrency) -> concurrency\n .maximumSessions(SessionLimit.of(1))\n .maximumSessionsExceededHandler(new PreventLoginMaximumSessionsExceededHandler())\n )\n );\n return http.build();\n}\n\n@Bean\nReactiveSessionRegistry reactiveSessionRegistry() {\n return new InMemoryReactiveSessionRegistry();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n sessionManagement {\n sessionConcurrency {\n maximumSessions = SessionLimit.of(1)\n maximumSessionsExceededHandler = PreventLoginMaximumSessionsExceededHandler()\n }\n }\n }\n}\n\n@Bean\nopen fun reactiveSessionRegistry(): ReactiveSessionRegistry {\n return InMemoryReactiveSessionRegistry()\n}\n----\n======\n\n[[reactive-concurrent-sessions-control-specify-session-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc", "title": "concurrent-sessions-control", "heading": "Handling Maximum Number of Sessions Exceeded", "heading_level": 2, "file_order": 24, "section_index": 2, "content_hash": "cc885dbcb9c3e62f77d173864b974203e17e7803131b98bd12d22dc662b4bc41", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc"}}
{"id": "sha256:8eaac17f823f9d4940a9b85c15e787dbfa3d3ecfa4f6ebf71b9e8b0709871957", "content": "In order to keep track of the user's sessions, Spring Security uses a javadoc:org.springframework.security.core.session.ReactiveSessionRegistry[], and, every time a user logs in, their session information is saved.\n\nSpring Security ships with javadoc:org.springframework.security.core.session.InMemoryReactiveSessionRegistry[] implementation of `ReactiveSessionRegistry`.\n\nTo specify a `ReactiveSessionRegistry` implementation you can either declare it as a bean:\n\n.ReactiveSessionRegistry as a Bean\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .sessionManagement((sessions) -> sessions\n .concurrentSessions((concurrency) -> concurrency\n .maximumSessions(SessionLimit.of(1))\n )\n );\n return http.build();\n}\n\n@Bean\nReactiveSessionRegistry reactiveSessionRegistry() {\n return new MyReactiveSessionRegistry();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n sessionManagement {\n sessionConcurrency {\n maximumSessions = SessionLimit.of(1)\n }\n }\n }\n}\n\n@Bean\nopen fun reactiveSessionRegistry(): ReactiveSessionRegistry {\n return MyReactiveSessionRegistry()\n}\n----\n======\n\nor you can use the `sessionRegistry` DSL method:\n\n.ReactiveSessionRegistry using sessionRegistry DSL method\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .sessionManagement((sessions) -> sessions\n .concurrentSessions((concurrency) -> concurrency\n .maximumSessions(SessionLimit.of(1))\n .sessionRegistry(new MyReactiveSessionRegistry())\n )\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n sessionManagement {\n sessionConcurrency {\n maximumSessions = SessionLimit.of(1)\n sessionRegistry = MyReactiveSessionRegistry()\n }\n }\n }\n}\n----\n======\n\n[[reactive-concurrent-sessions-control-manually-invalidating-sessions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc", "title": "concurrent-sessions-control", "heading": "Specifying a `ReactiveSessionRegistry`", "heading_level": 2, "file_order": 24, "section_index": 3, "content_hash": "8eaac17f823f9d4940a9b85c15e787dbfa3d3ecfa4f6ebf71b9e8b0709871957", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc"}}
{"id": "sha256:84758cab259b780573b3757267ae7a85fd05183a0b61645e56fa25ffee8e8764", "content": "At times, it is handy to be able to invalidate all or some of a user's sessions.\nFor example, when a user changes their password, you may want to invalidate all of their sessions so that they are forced to log in again.\nTo do that, you can use the `ReactiveSessionRegistry` bean to retrieve all the user's sessions, invalidate them, and them remove them from the `WebSessionStore`:\n\n.Using ReactiveSessionRegistry to invalidate sessions manually\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class SessionControl {\n private final ReactiveSessionRegistry reactiveSessionRegistry;\n\n private final WebSessionStore webSessionStore;\n\n public Mono<Void> invalidateSessions(String username) {\n return this.reactiveSessionRegistry.getAllSessions(username)\n .flatMap((session) -> session.invalidate().thenReturn(session))\n .flatMap((session) -> this.webSessionStore.removeSession(session.getSessionId()))\n .then();\n }\n}\n----\n======\n\n[[disabling-for-authentication-filters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc", "title": "concurrent-sessions-control", "heading": "Invalidating Registered User's Sessions", "heading_level": 2, "file_order": 24, "section_index": 4, "content_hash": "84758cab259b780573b3757267ae7a85fd05183a0b61645e56fa25ffee8e8764", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc"}}
{"id": "sha256:dcbdcc830ccfd0efc7aa705a4323ce56ebec1628808f04ec4bfb335bce8a282d", "content": "By default, Concurrent Sessions Control will be configured automatically for Form Login, OAuth 2.0 Login, and HTTP Basic authentication as long as they do not specify an `ServerAuthenticationSuccessHandler` themselves.\nFor example, the following configuration will disable Concurrent Sessions Control for Form Login:\n\n.Disabling Concurrent Sessions Control for Form Login\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .formLogin((login) -> login\n .authenticationSuccessHandler(new RedirectServerAuthenticationSuccessHandler(\"/\"))\n )\n .sessionManagement((sessions) -> sessions\n .concurrentSessions((concurrency) -> concurrency\n .maximumSessions(SessionLimit.of(1))\n )\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun springSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n formLogin {\n authenticationSuccessHandler = RedirectServerAuthenticationSuccessHandler(\"/\")\n }\n sessionManagement {\n sessionConcurrency {\n maximumSessions = SessionLimit.of(1)\n }\n }\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc", "title": "concurrent-sessions-control", "heading": "Disabling It for Some Authentication Filters", "heading_level": 2, "file_order": 24, "section_index": 5, "content_hash": "dcbdcc830ccfd0efc7aa705a4323ce56ebec1628808f04ec4bfb335bce8a282d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc"}}
{"id": "sha256:62f6fa6f6301fe500defec79eea17285956f3f13573630254e4ed6b0c9beb654", "content": "You can also include additional `ServerAuthenticationSuccessHandler` instances to the list of handlers used by the authentication filter without disabling Concurrent Sessions Control.\nTo do that you can use the `authenticationSuccessHandler(Consumer<List<ServerAuthenticationSuccessHandler>>)` method:\n\n.Adding additional handlers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .formLogin((login) -> login\n .authenticationSuccessHandler((handlers) -> handlers.add(new MyAuthenticationSuccessHandler()))\n )\n .sessionManagement((sessions) -> sessions\n .concurrentSessions((concurrency) -> concurrency\n .maximumSessions(SessionLimit.of(1))\n )\n );\n return http.build();\n}\n----\n======\n\n[[concurrent-sessions-control-sample]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc", "title": "concurrent-sessions-control", "heading": "Adding Additional Success Handlers Without Disabling Concurrent Sessions Control", "heading_level": 3, "file_order": 24, "section_index": 6, "content_hash": "62f6fa6f6301fe500defec79eea17285956f3f13573630254e4ed6b0c9beb654", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc"}}
{"id": "sha256:5776a745d50e210ce21e3b6941ff1365b2652fba40251c66ed15e2148f44e701", "content": "You can check the {gh-samples-url}/reactive/webflux/java/session-management/maximum-sessions[sample application here].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc", "title": "concurrent-sessions-control", "heading": "Checking a Sample Application", "heading_level": 2, "file_order": 24, "section_index": 7, "content_hash": "5776a745d50e210ce21e3b6941ff1365b2652fba40251c66ed15e2148f44e701", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/concurrent-sessions-control.adoc"}}
{"id": "sha256:97b1b300f3751ca87a0d21367737c463e04d93d0d0ec0c8cb147805b80614802", "content": "[[webflux-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 25, "section_index": 0, "content_hash": "97b1b300f3751ca87a0d21367737c463e04d93d0d0ec0c8cb147805b80614802", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/index.adoc"}}
{"id": "sha256:6d5c97fec7bbf78d4d2c68e7ec824061fd115796988c5b8e6198f3886c9afb94", "content": "[[reactive-logout]]\n\nSpring Security provides a logout endpoint by default.\nOnce logged in, you can `GET /logout` to see a default logout confirmation page, or you can `POST /logout` to initiate logout.\nThis will:\n\n- clear the `ServerCsrfTokenRepository`, `ServerSecurityContextRepository`, and\n- redirect back to the login page\n\nOften, you will want to also invalidate the session on logout.\nTo achieve this, you can add the `WebSessionServerLogoutHandler` to your logout configuration, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain http(ServerHttpSecurity http) throws Exception {\n DelegatingServerLogoutHandler logoutHandler = new DelegatingServerLogoutHandler(\n new SecurityContextServerLogoutHandler(), new WebSessionServerLogoutHandler()\n );\n\n http\n .authorizeExchange((authorize) -> authorize.anyExchange().authenticated())\n .logout((logout) -> logout.logoutHandler(logoutHandler));\n\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun http(http: ServerHttpSecurity): SecurityWebFilterChain {\n val customLogoutHandler = DelegatingServerLogoutHandler(\n SecurityContextServerLogoutHandler(), WebSessionServerLogoutHandler()\n )\n\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n logout {\n logoutHandler = customLogoutHandler\n }\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/logout.adoc", "title": "logout", "heading": "logout", "heading_level": 1, "file_order": 26, "section_index": 0, "content_hash": "6d5c97fec7bbf78d4d2c68e7ec824061fd115796988c5b8e6198f3886c9afb94", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/logout.adoc"}}
{"id": "sha256:c03ecb43871350439f6dad959764bc6cbf2294983bf95a8c71ecd03319ce2e65", "content": "[[one-time-token-login]]\n\nSpring Security offers support for One-Time Token (OTT) authentication via the `oneTimeTokenLogin()` DSL.\nBefore diving into implementation details, it's important to clarify the scope of the OTT feature within the framework, highlighting what is supported and what isn't.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "onetimetoken", "heading_level": 1, "file_order": 27, "section_index": 0, "content_hash": "c03ecb43871350439f6dad959764bc6cbf2294983bf95a8c71ecd03319ce2e65", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:d6c240b0b0b8f467d8a88da532a28abe79fa4f472ced76904f2f755bd5d39b66", "content": "It's common to confuse One-Time Tokens (OTT) with https://en.wikipedia.org/wiki/One-time_password[One-Time Passwords] (OTP), but in Spring Security, these concepts differ in several key ways.\nFor clarity, we'll assume OTP refers to https://en.wikipedia.org/wiki/Time-based_one-time_password[TOTP] (Time-Based One-Time Password) or https://en.wikipedia.org/wiki/HMAC-based_one-time_password[HOTP] (HMAC-Based One-Time Password).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Understanding One-Time Tokens vs. One-Time Passwords", "heading_level": 2, "file_order": 27, "section_index": 1, "content_hash": "d6c240b0b0b8f467d8a88da532a28abe79fa4f472ced76904f2f755bd5d39b66", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:204e1c5111bb7c1abfbda8b369e43f45fd4a55ed8d4f9ea9227b10799ad5bf2a", "content": "- OTT: No initial setup is required. The user doesn't need to configure anything in advance.\n- OTP: Typically requires setup, such as generating and sharing a secret key with an external tool to produce the one-time passwords.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Setup Requirements", "heading_level": 3, "file_order": 27, "section_index": 2, "content_hash": "204e1c5111bb7c1abfbda8b369e43f45fd4a55ed8d4f9ea9227b10799ad5bf2a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:55330c920093ce498a100456c4e1c13654f7ba4b5bfe6965ab63bc11a57e11aa", "content": "- OTT: Usually a custom javadoc:org.springframework.security.web.server.authentication.ott.ServerOneTimeTokenGenerationSuccessHandler[] must be implemented, responsible for delivering the token to the end user.\n- OTP: The token is often generated by an external tool, so there's no need to send it to the user via the application.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Token Delivery", "heading_level": 3, "file_order": 27, "section_index": 3, "content_hash": "55330c920093ce498a100456c4e1c13654f7ba4b5bfe6965ab63bc11a57e11aa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:780e60724dff11b7ec1e56e458eb54ece0415d49cfd10c486b75ab16e04a00d4", "content": "- OTT: The javadoc:org.springframework.security.authentication.ott.reactive.ReactiveOneTimeTokenService#generate(org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest)[] method requires a javadoc:org.springframework.security.authentication.ott.OneTimeToken[], wrapped in Mono, to be returned, emphasizing server-side generation.\n- OTP: The token is not necessarily generated on the server side, it's often created by the client using the shared secret.\n\nIn summary, One-Time Tokens (OTT) provide a way to authenticate users without additional account setup, differentiating them from One-Time Passwords (OTP), which typically involve a more complex setup process and rely on external tools for token generation.\n\nThe One-Time Token Login works in two major steps.\n\n1. User requests a token by submitting their user identifier, usually the username, and the token is delivered to them, often as a Magic Link, via e-mail, SMS, etc.\n2. User submits the token to the one-time token login endpoint and, if valid, the user gets logged in.\n\nIn the following sections we will explore how to configure OTT Login for your needs.\n\n- <<default-pages,Understanding the integration with the default generated login page>>\n- <<sending-token-to-user,Sending the token to the user>>\n- <<changing-submit-page-url,Configuring the One-Time Token submit page>>\n- <<changing-generate-url,Changing the One-Time Token generate URL>>\n- <<customize-generate-consume-token,Customize how to generate and consume tokens>>\n\n[[default-pages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Token Generation", "heading_level": 3, "file_order": 27, "section_index": 4, "content_hash": "780e60724dff11b7ec1e56e458eb54ece0415d49cfd10c486b75ab16e04a00d4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:bf5a9f799a72ae8fec694d1414d1e2276e4e3177691bd204a66ca8ec0a23ba50", "content": "The `oneTimeTokenLogin()` DSL can be used in conjunction with `formLogin()`, which will produce an additional One-Time Token Request Form in the xref:servlet/authentication/passwords/form.adoc[default generated login page].\nIt will also set up the javadoc:org.springframework.security.web.server.ui.OneTimeTokenSubmitPageGeneratingWebFilter[] to generate a default One-Time Token submit page.\n\n[[sending-token-to-user]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Default Login Page and Default One-Time Token Submit Page", "heading_level": 2, "file_order": 27, "section_index": 5, "content_hash": "bf5a9f799a72ae8fec694d1414d1e2276e4e3177691bd204a66ca8ec0a23ba50", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:fc9dc01932ee99d361a98457f429cb75408de7a37a6a5baab22d89dc41447530", "content": "It is not possible for Spring Security to reasonably determine the way the token should be delivered to your users.\nTherefore, a custom javadoc:org.springframework.security.web.server.authentication.ott.ServerOneTimeTokenGenerationSuccessHandler[] must be provided to deliver the token to the user based on your needs.\nOne of the most common delivery strategies is a Magic Link, via e-mail, SMS, etc.\nIn the following example, we are going to create a magic link and sent it to the user's email.\n\n.One-Time Token Login Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin(Customizer.withDefaults());\n return http.build();\n }\n\n}\n\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\n\n@Component <1>\npublic class MagicLinkOneTimeTokenGenerationSuccessHandler implements ServerOneTimeTokenGenerationSuccessHandler {\n\n private final MailSender mailSender;\n\n private final ServerOneTimeTokenGenerationSuccessHandler redirectHandler = new ServerRedirectOneTimeTokenGenerationSuccessHandler(\"/ott/sent\");\n\n // constructor omitted\n\n @Override\n public Mono<Void> handle(ServerWebExchange exchange, OneTimeToken oneTimeToken) {\n return Mono.just(exchange.getRequest())\n .map((request) ->\n UriComponentsBuilder.fromUri(request.getURI())\n .replacePath(request.getPath().contextPath().value())\n .replaceQuery(null)\n .fragment(null)\n .path(\"/login/ott\")\n .queryParam(\"token\", oneTimeToken.getTokenValue())\n .toUriString() <2>\n )\n .flatMap((uri) -> this.mailSender.send(getUserEmail(oneTimeToken.getUsername()), <3>\n \"Use the following link to sign in into the application: \" + magicLink)) <4>\n .then(this.redirectHandler.handle(exchange, oneTimeToken)); <5>\n }\n\n private String getUserEmail() {\n // ...\n }\n\n}\n\n@Controller\nclass PageController {\n\n @GetMapping(\"/ott/sent\")\n String ottSent() {\n return \"my-template\";\n }\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n open fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oneTimeTokenLogin { }\n }\n }\n\n}\n\n@Component (1)\nclass MagicLinkOneTimeTokenGenerationSuccessHandler(val mailSender: MailSender): ServerOneTimeTokenGenerationSuccessHandler {\n\n private val redirectStrategy: ServerRedirectStrategy = DefaultServerRedirectStrategy()\n\n override fun handle(exchange: ServerWebExchange, oneTimeToken: OneTimeToken): Mono<Void> {\n val builder = UriComponentsBuilder.fromUri(exchange.request.uri)\n .replacePath(null)\n .replaceQuery(null)\n .fragment(null)\n .path(\"/login/ott\")\n .queryParam(\"token\", oneTimeToken.getTokenValue()) (2)\n val magicLink = builder.toUriString()\n builder.replacePath(null)\n .replaceQuery(null)\n .path(\"/ott/sent\")\n val redirectLink = builder.toUriString()\n return this.mailSender.send(\n getUserEmail(oneTimeToken.getUsername()), (3)\n \"Use the following link to sign in into the application: $magicLink\") (4)\n .then(this.redirectStrategy.sendRedirect(exchange, URI.create(redirectLink))) (5)\n }\n\n private String getUserEmail() {\n // ...\n }\n}\n\n@Controller\nclass PageController {\n\n @GetMapping(\"/ott/sent\")\n fun ottSent(): String {\n return \"my-template\"\n }\n}\n\n----\n======\n\n<1> Make the `MagicLinkOneTimeTokenGenerationSuccessHandler` a Spring bean\n<2> Create a login processing URL with the `token` as a query param\n<3> Retrieve the user's email based on the username\n<4> Use the `MailSender` API to send the email to the user with the magic link\n<5> Use the `ServerRedirectStrategy` to perform a redirect to your desired URL\n\nThe email content will look similar to:\n\n> Use the following link to sign in into the application: \\http://localhost:8080/login/ott?token=a830c444-29d8-4d98-9b46-6aba7b22fe5b\n\nThe default submit page will detect that the URL has the `token` query param and will automatically fill the form field with the token value.\n\n[[changing-generate-url]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Sending the Token to the User", "heading_level": 2, "file_order": 27, "section_index": 6, "content_hash": "fc9dc01932ee99d361a98457f429cb75408de7a37a6a5baab22d89dc41447530", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:97fc362e67b27245ad01fda039da450b7eb18e3254d51056937378681168a16c", "content": "By default, the javadoc:org.springframework.security.web.server.authentication.ott.GenerateOneTimeTokenWebFilter[] listens to `POST /ott/generate` requests.\nThat URL can be changed by using the `generateTokenUrl(String)` DSL method:\n\n.Changing the Generate URL\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin((ott) -> ott\n .generateTokenUrl(\"/ott/my-generate-url\")\n );\n return http.build();\n }\n\n}\n\n@Component\npublic class MagicLinkOneTimeTokenGenerationSuccessHandler implements ServerOneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n open fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n formLogin { }\n oneTimeTokenLogin {\n generateTokenUrl = \"/ott/my-generate-url\"\n }\n }\n }\n\n}\n\n@Component\nclass MagicLinkOneTimeTokenGenerationSuccessHandler(val mailSender: MailSender): ServerOneTimeTokenGenerationSuccessHandler {\n // ...\n}\n\n----\n======\n\n[[changing-submit-page-url]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Changing the One-Time Token Generate URL", "heading_level": 2, "file_order": 27, "section_index": 7, "content_hash": "97fc362e67b27245ad01fda039da450b7eb18e3254d51056937378681168a16c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:2323a516e46e6f739e360332dbf083165f198389de15917d0b7656143ee6d4fd", "content": "The default One-Time Token submit page is generated by the javadoc:org.springframework.security.web.server.ui.OneTimeTokenSubmitPageGeneratingWebFilter[] and listens to `GET /login/ott`.\nThe URL can also be changed, like so:\n\n.Configuring the Default Submit Page URL\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin((ott) -> ott\n .submitPageUrl(\"/ott/submit\")\n );\n return http.build();\n }\n\n}\n\n@Component\npublic class MagicLinkOneTimeTokenGenerationSuccessHandler implements ServerOneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n open fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n formLogin { }\n oneTimeTokenLogin {\n submitPageUrl = \"/ott/submit\"\n }\n }\n }\n\n}\n\n@Component\nclass MagicLinkOneTimeTokenGenerationSuccessHandler(val mailSender: MailSender): ServerOneTimeTokenGenerationSuccessHandler {\n // ...\n}\n\n----\n======\n\n[[disabling-default-submit-page]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Changing the Default Submit Page URL", "heading_level": 2, "file_order": 27, "section_index": 8, "content_hash": "2323a516e46e6f739e360332dbf083165f198389de15917d0b7656143ee6d4fd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:bf7a5df6428ba756e944c66c71e9b9279867616ed116957894184dfd91a9e8cb", "content": "If you want to use your own One-Time Token submit page, you can disable the default page and then provide your own endpoint.\n\n.Disabling the Default Submit Page\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .pathMatchers(\"/my-ott-submit\").permitAll()\n .anyExchange().authenticated()\n )\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin((ott) -> ott\n .showDefaultSubmitPage(false)\n );\n return http.build();\n }\n\n}\n\n@Controller\npublic class MyController {\n\n @GetMapping(\"/my-ott-submit\")\n public String ottSubmitPage() {\n return \"my-ott-submit\";\n }\n\n}\n\n@Component\npublic class MagicLinkOneTimeTokenGenerationSuccessHandler implements ServerOneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n open fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(pathMatchers(\"/my-ott-submit\"), permitAll)\n authorize(anyExchange, authenticated)\n }\n .formLogin { }\n oneTimeTokenLogin {\n showDefaultSubmitPage = false\n }\n }\n }\n\n}\n\n@Controller\nclass MyController {\n\n @GetMapping(\"/my-ott-submit\")\n fun ottSubmitPage(): String {\n return \"my-ott-submit\"\n }\n}\n\n@Component\nclass MagicLinkOneTimeTokenGenerationSuccessHandler(val mailSender: MailSender): ServerOneTimeTokenGenerationSuccessHandler {\n // ...\n}\n\n----\n======\n\n[[customize-generate-consume-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Disabling the Default Submit Page", "heading_level": 2, "file_order": 27, "section_index": 9, "content_hash": "bf7a5df6428ba756e944c66c71e9b9279867616ed116957894184dfd91a9e8cb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:ad41eb869de1af29342cfd27b92d50fb5277da0eb440a17ded43bed2b0e933cc", "content": "The interface that define the common operations for generating and consuming one-time tokens is the javadoc:org.springframework.security.authentication.ott.reactive.ReactiveOneTimeTokenService[].\nSpring Security uses the javadoc:org.springframework.security.authentication.ott.reactive.InMemoryReactiveOneTimeTokenService[] as the default implementation of that interface, if none is provided.\n\nSome of the most common reasons to customize the `ReactiveOneTimeTokenService` are, but not limited to:\n\n- Changing the one-time token expire time\n- Storing more information from the generate token request\n- Changing how the token value is created\n- Additional validation when consuming a one-time token\n\nThere are two options to customize the `ReactiveOneTimeTokenService`.\nOne option is to provide it as a bean, so it can be automatically be picked-up by the `oneTimeTokenLogin()` DSL:\n\n.Passing the ReactiveOneTimeTokenService as a Bean\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin(Customizer.withDefaults());\n return http.build();\n }\n\n @Bean\n public ReactiveOneTimeTokenService oneTimeTokenService() {\n return new MyCustomReactiveOneTimeTokenService();\n }\n\n}\n\n@Component\npublic class MagicLinkOneTimeTokenGenerationSuccessHandler implements ServerOneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n open fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n //..\n .formLogin { }\n oneTimeTokenLogin { }\n }\n }\n\n @Bean\n open fun oneTimeTokenService():ReactiveOneTimeTokenService {\n return MyCustomReactiveOneTimeTokenService();\n }\n\n}\n\n@Component\nclass MagicLinkOneTimeTokenGenerationSuccessHandler(val mailSender: MailSender): ServerOneTimeTokenGenerationSuccessHandler {\n // ...\n}\n\n----\n======\n\nThe second option is to pass the `ReactiveOneTimeTokenService` instance to the DSL, which is useful if there are multiple ``SecurityWebFilterChain``s and a different ``ReactiveOneTimeTokenService``s is needed for each of them.\n\n.Passing the ReactiveOneTimeTokenService using the DSL\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityWebFilterChain filterChain(ServerHttpSecurity http) {\n http\n // ...\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin((ott) -> ott\n .oneTimeTokenService(new MyCustomReactiveOneTimeTokenService())\n );\n return http.build();\n }\n\n}\n\n@Component\npublic class MagicLinkOneTimeTokenGenerationSuccessHandler implements ServerOneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n open fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n //..\n .formLogin { }\n oneTimeTokenLogin {\n oneTimeTokenService = MyCustomReactiveOneTimeTokenService()\n }\n }\n }\n}\n\n@Component\nclass MagicLinkOneTimeTokenGenerationSuccessHandler(val mailSender: MailSender): ServerOneTimeTokenGenerationSuccessHandler {\n // ...\n}\n\n----\n======\n\n[[customize-generate-token-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Customize How to Generate and Consume One-Time Tokens", "heading_level": 2, "file_order": 27, "section_index": 10, "content_hash": "ad41eb869de1af29342cfd27b92d50fb5277da0eb440a17ded43bed2b0e933cc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:d62415fdd649b94fe0efdd64d2922c843903e82ab1e6670c46425b86e666ec5d", "content": "There are a number of reasons that you may want to adjust an GenerateOneTimeTokenRequest. For example, you may want expiresIn to be set to 10 mins, which Spring Security sets to 5 mins by default.\n\nYou can customize elements of GenerateOneTimeTokenRequest by publishing an ServerGenerateOneTimeTokenRequestResolver as a @Bean, like so:\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nServerGenerateOneTimeTokenRequestResolver generateOneTimeTokenRequestResolver() {\n DefaultServerGenerateOneTimeTokenRequestResolver resolver = new DefaultServerGenerateOneTimeTokenRequestResolver();\n resolver.setExpiresIn(Duration.ofSeconds(600));\n return resolver;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun generateOneTimeTokenRequestResolver() : ServerGenerateOneTimeTokenRequestResolver {\n return DefaultServerGenerateOneTimeTokenRequestResolver().apply {\n this.setExpiresIn(Duration.ofMinutes(10))\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Customize GenerateOneTimeTokenRequest Instance", "heading_level": 2, "file_order": 27, "section_index": 11, "content_hash": "d62415fdd649b94fe0efdd64d2922c843903e82ab1e6670c46425b86e666ec5d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/onetimetoken.adoc"}}
{"id": "sha256:9d2540a3bc974108c3cd00f00f2763e73cabbb7018937a5e06bc8727af03af4f", "content": "[[reactive-x509]]\n\nSimilar to xref:servlet/authentication/x509.adoc#servlet-x509[Servlet X.509 authentication], the reactive x509 authentication filter allows extracting an authentication token from a certificate provided by a client.\n\nThe following example shows a reactive x509 security configuration:\n\ninclude-code::./DefaultX509Configuration[tag=springSecurity,indent=0]\n\nIn the preceding configuration, when neither `principalExtractor` nor `authenticationManager` is provided, defaults are used.\nThe default principal extractor is `SubjectX500PrincipalExtractor`, which extracts the CN (common name) field from a certificate provided by a client.\nThe default authentication manager is `ReactivePreAuthenticatedAuthenticationManager`, which performs user account validation, checking that a user account with a name extracted by `principalExtractor` exists and that it is not locked, disabled, or expired.\n\nThe following example demonstrates how these defaults can be overridden:\n\ninclude-code::./CustomX509Configuration[tag=springSecurity,indent=0]\n\nIn the previous example, a username is extracted from the `emailAddress` field of a client certificate instead of CN, and account lookup uses a custom `ReactiveAuthenticationManager` instance.\n\nFor an example of configuring Netty and `WebClient` or `curl` command-line tool to use mutual TLS and enable X.509 authentication, see https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration/authentication/x509.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authentication/x509.adoc", "title": "x509", "heading": "x509", "heading_level": 1, "file_order": 28, "section_index": 0, "content_hash": "9d2540a3bc974108c3cd00f00f2763e73cabbb7018937a5e06bc8727af03af4f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authentication/x509.adoc"}}
{"id": "sha256:3b6cda9d12b185ae88d90599aa108801e15c12a64ce7bc4ee16029a1fce12cab", "content": "[[servlet-authorization-authorizationfilter]]\n\nSpring Security provides support for authorizing the incoming HTTP requests.\nBy default, Spring Securitys authorization will require all requests to be authenticated.\nThe explicit configuration looks like:\n\n.All Requests Require Authenticated User\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .httpBasic(withDefaults())\n .formLogin(withDefaults());\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n formLogin { }\n httpBasic { }\n }\n}\n----\n======\n\nWe can configure Spring Security to have different rules by adding more rules in order of precedence.\n\n.Multiple Authorize Requests Rules\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.authorization.AuthorityReactiveAuthorizationManager.hasRole;\n@Bean\nSecurityWebFilterChain springWebFilterChain(ServerHttpSecurity http) {\n\t// @formatter:off\n\thttp\n // ...\n .authorizeExchange((authorize) -> authorize // <1>\n .pathMatchers(\"/resources/**\", \"/signup\", \"/about\").permitAll() // <2>\n .pathMatchers(\"/admin/**\").hasRole(\"ADMIN\") // <3>\n .pathMatchers(\"/db/**\").access((authentication, context) -> // <4>\n hasRole(\"ADMIN\").check(authentication, context)\n .filter(decision -> !decision.isGranted())\n .switchIfEmpty(hasRole(\"DBA\").check(authentication, context))\n )\n .anyExchange().denyAll() // <5>\n );\n\t// @formatter:on\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange { // <1>\n authorize(pathMatchers(\"/resources/**\", \"/signup\", \"/about\"), permitAll) // <2>\n authorize(\"/admin/**\", hasRole(\"ADMIN\")) // <3>\n authorize(\"/db/**\", { authentication, context -> // <4>\n hasRole(\"ADMIN\").check(authentication, context)\n .filter({ decision -> !decision.isGranted() })\n .switchIfEmpty(hasRole(\"DBA\").check(authentication, context))\n })\n authorize(anyExchange, denyAll) // <5>\n }\n // ...\n }\n}\n----\n======\n\n<1> There are multiple authorization rules specified.\nEach rule is considered in the order they were declared.\n<2> We specified multiple URL patterns that any user can access.\nSpecifically, any user can access a request if the URL starts with \"/resources/\", equals \"/signup\", or equals \"/about\".\n<3> Any URL that starts with \"/admin/\" will be restricted to users who have the authority \"ROLE_ADMIN\".\nYou will notice that since we are invoking the `hasRole` method we do not need to specify the \"ROLE_\" prefix.\n<4> Any URL that starts with \"/db/\" requires the user to have both \"ROLE_ADMIN\" and \"ROLE_DBA\".\nThis demonstrates the flexibility of providing a custom `ReactiveAuthorizationManager` allowing us to implement arbitrary authorization logic.\nFor simplicity, the sample uses a lambda and delegate to the existing `AuthorityReactiveAuthorizationManager.hasRole` implementation.\nHowever, in a real world situation applications would likely implement the logic in a proper class implementing `ReactiveAuthorizationManager`.\n<5> Any URL that has not already been matched on is denied access.\nThis is a good strategy if you do not want to accidentally forget to update your authorization rules.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "authorize-http-requests", "heading_level": 1, "file_order": 29, "section_index": 0, "content_hash": "3b6cda9d12b185ae88d90599aa108801e15c12a64ce7bc4ee16029a1fce12cab", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:e21583f6d3a7ce973311d18b34cb428a5f6e0e16a12041d02520aec2d234d0f0", "content": "[[jc-erms]]\n\nSpring Security supports method security by using https://projectreactor.io/docs/core/release/reference/#context[Reactor's Context], which is set up by `ReactiveSecurityContextHolder`.\nThe following example shows how to retrieve the currently logged in user's message:\n\n[NOTE]\n====\nFor this example to work, the return type of the method must be a `org.reactivestreams.Publisher` (that is, a `Mono` or a `Flux`).\nThis is necessary to integrate with Reactor's `Context`.\n====\n\n[[jc-enable-reactive-method-security-authorization-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authorization/method.adoc", "title": "method", "heading": "method", "heading_level": 1, "file_order": 30, "section_index": 0, "content_hash": "e21583f6d3a7ce973311d18b34cb428a5f6e0e16a12041d02520aec2d234d0f0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authorization/method.adoc"}}
{"id": "sha256:a4222a197b59111665a5860a3157454486d982136efbb8fa067bb73ba7a1348a", "content": "In Spring Security 5.8, we can enable annotation-based security using the `@EnableReactiveMethodSecurity(useAuthorizationManager=true)` annotation on any `@Configuration` instance.\n\nThis improves upon `@EnableReactiveMethodSecurity` in a number of ways. `@EnableReactiveMethodSecurity(useAuthorizationManager=true)`:\n\n1. Uses the simplified `AuthorizationManager` API instead of metadata sources, config attributes, decision managers, and voters.\nThis simplifies reuse and customization.\n2. Supports reactive return types including Kotlin coroutines.\n3. Is built using native Spring AOP, removing abstractions and allowing you to use Spring AOP building blocks to customize\n4. Checks for conflicting annotations to ensure an unambiguous security configuration\n5. Complies with JSR-250\n\n[NOTE]\n====\nFor earlier versions, please read about similar support with <<jc-enable-reactive-method-security, @EnableReactiveMethodSecurity>>.\n====\n\nFor example, the following would enable Spring Security's `@PreAuthorize` annotation:\n\n.Method Security Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@EnableReactiveMethodSecurity(useAuthorizationManager=true)\npublic class MethodSecurityConfig {\n\t// ...\n}\n----\n======\n\nAdding an annotation to a method (on a class or interface) would then limit the access to that method accordingly.\nSpring Security's native annotation support defines a set of attributes for the method.\nThese will be passed to the various method interceptors, like `AuthorizationManagerBeforeReactiveMethodInterceptor`, for it to make the actual decision:\n\n.Method Security Annotation Usage\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic interface BankService {\n\t@PreAuthorize(\"hasRole('USER')\")\n\tMono<Account> readAccount(Long id);\n\n\t@PreAuthorize(\"hasRole('USER')\")\n\tFlux<Account> findAccounts();\n\n\t@PreAuthorize(\"@func.apply(#account)\")\n\tMono<Account> post(Account account, Double amount);\n}\n----\n======\n\nIn this case `hasRole` refers to the method found in `SecurityExpressionRoot` that gets invoked by the SpEL evaluation engine.\n\n`@bean` refers to a custom component you have defined, where `apply` can return `Boolean` or `Mono<Boolean>` to indicate the authorization decision.\nA bean like that might look something like this:\n\n.Method Security Reactive Boolean Expression\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic Function<Account, Mono<Boolean>> func() {\n return (account) -> Mono.defer(() -> Mono.just(account.getId().equals(12)));\n}\n----\n======\n\nMethod authorization is a combination of before- and after-method authorization.\n\n[NOTE]\n====\nBefore-method authorization is performed before the method is invoked.\nIf that authorization denies access, the method is not invoked, and an `AccessDeniedException` is thrown.\nAfter-method authorization is performed after the method is invoked, but before the method returns to the caller.\nIf that authorization denies access, the value is not returned, and an `AccessDeniedException` is thrown\n====\n\nTo recreate what adding `@EnableReactiveMethodSecurity(useAuthorizationManager=true)` does by default, you would publish the following configuration:\n\n.Full Pre-post Method Security Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\nclass MethodSecurityConfig {\n\t@Bean\n\tBeanDefinitionRegistryPostProcessor aopConfig() {\n return AopConfigUtils::registerAutoProxyCreatorIfNecessary;\n\t}\n\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tPreFilterAuthorizationReactiveMethodInterceptor preFilterInterceptor() {\n return new PreFilterAuthorizationReactiveMethodInterceptor();\n\t}\n\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tAuthorizationManagerBeforeReactiveMethodInterceptor preAuthorizeInterceptor() {\n return AuthorizationManagerBeforeReactiveMethodInterceptor.preAuthorize();\n\t}\n\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tAuthorizationManagerAfterReactiveMethodInterceptor postAuthorizeInterceptor() {\n return AuthorizationManagerAfterReactiveMethodInterceptor.postAuthorize();\n\t}\n\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tPostFilterAuthorizationReactiveMethodInterceptor postFilterInterceptor() {\n return new PostFilterAuthorizationReactiveMethodInterceptor();\n\t}\n}\n----\n======\n\nNotice that Spring Security's method security is built using Spring AOP.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authorization/method.adoc", "title": "method", "heading": "EnableReactiveMethodSecurity with AuthorizationManager", "heading_level": 2, "file_order": 30, "section_index": 1, "content_hash": "a4222a197b59111665a5860a3157454486d982136efbb8fa067bb73ba7a1348a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authorization/method.adoc"}}
{"id": "sha256:1003c2acc18f65f0c90b84b7ad798407d9315e27a852052d8f56bc3a16c53af3", "content": "Spring Security's `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, and `@PostFilter` ship with rich expression-based support.\n\n[[jc-reactive-method-security-custom-granted-authority-defaults]]\nAlso, for role-based authorization, Spring Security adds a default `ROLE_` prefix, which is uses when evaluating expressions like `hasRole`.\nYou can configure the authorization rules to use a different prefix by exposing a `GrantedAuthorityDefaults` bean, like so:\n\n.Custom GrantedAuthorityDefaults\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\nstatic GrantedAuthorityDefaults grantedAuthorityDefaults() {\n\treturn new GrantedAuthorityDefaults(\"MYPREFIX_\");\n}\n----\n======\n\n[TIP]\n====\nWe expose `GrantedAuthorityDefaults` using a `static` method to ensure that Spring publishes it before it initializes Spring Security's method security `@Configuration` classes.\nSince the `GrantedAuthorityDefaults` bean is part of internal workings of Spring Security, we should also expose it as an infrastructural bean effectively avoiding some warnings related to bean post-processing (see https://github.com/spring-projects/spring-security/issues/14751[gh-14751]).\n====\n\n[[use-programmatic-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authorization/method.adoc", "title": "method", "heading": "Customizing Authorization", "heading_level": 3, "file_order": 30, "section_index": 2, "content_hash": "1003c2acc18f65f0c90b84b7ad798407d9315e27a852052d8f56bc3a16c53af3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authorization/method.adoc"}}
{"id": "sha256:7ae5258cce8b6b7611d7c8afc43032539189f72d4eb17d996fa3f32947542cff", "content": "As you've already seen, there are several ways that you can specify non-trivial authorization rules using xref:servlet/authorization/method-security.adoc#authorization-expressions[Method Security SpEL expressions].\n\nThere are a number of ways that you can instead allow your logic to be Java-based instead of SpEL-based.\nThis gives use access the entire Java language for increased testability and flow control.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authorization/method.adoc", "title": "method", "heading": "Authorizing Methods Programmatically", "heading_level": 2, "file_order": 30, "section_index": 3, "content_hash": "7ae5258cce8b6b7611d7c8afc43032539189f72d4eb17d996fa3f32947542cff", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authorization/method.adoc"}}
{"id": "sha256:d12ed423e40d9995919ae82c3943b22de752c4f763850734395f0e569430afc0", "content": "The first way to authorize a method programmatically is a two-step process.\n\nFirst, declare a bean that has a method that takes a `MethodSecurityExpressionOperations` instance like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component(\"authz\")\npublic class AuthorizationLogic {\n public decide(MethodSecurityExpressionOperations operations): Mono<Boolean> {\n // ... authorization logic\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component(\"authz\")\nopen class AuthorizationLogic {\n fun decide(val operations: MethodSecurityExpressionOperations): Mono<Boolean> {\n // ... authorization logic\n }\n}\n----\n======\n\nThen, reference that bean in your annotations in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class MyController {\n @PreAuthorize(\"@authz.decide(#root)\")\n @GetMapping(\"/endpoint\")\n public Mono<String> endpoint() {\n // ...\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nopen class MyController {\n @PreAuthorize(\"@authz.decide(#root)\")\n @GetMapping(\"/endpoint\")\n fun endpoint(): Mono<String> {\n // ...\n }\n}\n----\n======\n\nSpring Security will invoke the given method on that bean for each method invocation.\n\nWhat's nice about this is all your authorization logic is in a separate class that can be independently unit tested and verified for correctness.\nIt also has access to the full Java language.\n\n[TIP]\nIn addition to returning a `Mono<Boolean>`, you can also return `Mono.empty()` to indicate that the code abstains from making a decision.\n\nIf you want to include more information about the nature of the decision, you can instead return a custom `AuthorizationDecision` like this:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component(\"authz\")\npublic class AuthorizationLogic {\n public Mono<AuthorizationDecision> decide(MethodSecurityExpressionOperations operations) {\n // ... authorization logic\n return Mono.just(new MyAuthorizationDecision(false, details));\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component(\"authz\")\nopen class AuthorizationLogic {\n fun decide(val operations: MethodSecurityExpressionOperations): Mono<AuthorizationDecision> {\n // ... authorization logic\n return Mono.just(MyAuthorizationDecision(false, details))\n }\n}\n----\n======\n\nOr throw a custom `AuthorizationDeniedException` instance.\nNote, though, that returning an object is preferred as this doesn't incur the expense of generating a stacktrace.\n\nThen, you can access the custom details when you xref:servlet/authorization/method-security.adoc#fallback-values-authorization-denied[customize how the authorization result is handled].\n\n[[jc-reactive-method-security-custom-authorization-manager]]\n[[custom-authorization-managers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authorization/method.adoc", "title": "method", "heading": "Using a Custom Bean in SpEL", "heading_level": 3, "file_order": 30, "section_index": 4, "content_hash": "d12ed423e40d9995919ae82c3943b22de752c4f763850734395f0e569430afc0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authorization/method.adoc"}}
{"id": "sha256:855d58c5a3452ee2aadcabdf4362a76d598a2c014b935345e8b2f64860488d95", "content": "The second way to authorize a method programmatically is to create a custom xref:servlet/authorization/architecture.adoc#_the_authorizationmanager[`AuthorizationManager`].\n\nFirst, declare an authorization manager instance, perhaps like this one:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class MyPreAuthorizeAuthorizationManager implements ReactiveAuthorizationManager<MethodInvocation> {\n @Override\n public Mono<AuthorizationResult> authorize(Supplier<Authentication> authentication, MethodInvocation invocation) {\n // ... authorization logic\n }\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass MyPreAuthorizeAuthorizationManager : ReactiveAuthorizationManager<MethodInvocation> {\n override fun authorize(authentication: Supplier<Authentication>, invocation: MethodInvocation): Mono<AuthorizationResult> {\n // ... authorization logic\n }\n\n}\n----\n======\n\nThen, publish the method interceptor with a pointcut that corresponds to when you want that `ReactiveAuthorizationManager` to run.\nFor example, you could replace how `@PreAuthorize` and `@PostAuthorize` work like so:\n\n.Only @PreAuthorize and @PostAuthorize Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableMethodSecurity(prePostEnabled = false)\nclass MethodSecurityConfig {\n @Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tAdvisor preAuthorize(MyPreAuthorizeAuthorizationManager manager) {\n return AuthorizationManagerBeforeReactiveMethodInterceptor.preAuthorize(manager);\n\t}\n\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tAdvisor postAuthorize(MyPostAuthorizeAuthorizationManager manager) {\n return AuthorizationManagerAfterReactiveMethodInterceptor.postAuthorize(manager);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableMethodSecurity(prePostEnabled = false)\nclass MethodSecurityConfig {\n @Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tfun preAuthorize(val manager: MyPreAuthorizeAuthorizationManager) : Advisor {\n return AuthorizationManagerBeforeReactiveMethodInterceptor.preAuthorize(manager)\n\t}\n\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tfun postAuthorize(val manager: MyPostAuthorizeAuthorizationManager) : Advisor {\n return AuthorizationManagerAfterReactiveMethodInterceptor.postAuthorize(manager)\n\t}\n}\n----\n======\n\n[TIP]\n====\nYou can place your interceptor in between Spring Security method interceptors using the order constants specified in `AuthorizationInterceptorsOrder`.\n====\n\n[[customizing-expression-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authorization/method.adoc", "title": "method", "heading": "Using a Custom Authorization Manager", "heading_level": 3, "file_order": 30, "section_index": 5, "content_hash": "855d58c5a3452ee2aadcabdf4362a76d598a2c014b935345e8b2f64860488d95", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authorization/method.adoc"}}
{"id": "sha256:5f1a27f76a7830a33dc9a1c9f5c61a5a695575b7c05d4f84cde6652d6a465800", "content": "Or, third, you can customize how each SpEL expression is handled.\nTo do that, you can expose a custom `MethodSecurityExpressionHandler`, like so:\n\n.Custom MethodSecurityExpressionHandler\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nstatic MethodSecurityExpressionHandler methodSecurityExpressionHandler(RoleHierarchy roleHierarchy) {\n\tDefaultMethodSecurityExpressionHandler handler = new DefaultMethodSecurityExpressionHandler();\n\thandler.setRoleHierarchy(roleHierarchy);\n\treturn handler;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ncompanion object {\n\t@Bean\n\tfun methodSecurityExpressionHandler(val roleHierarchy: RoleHierarchy) : MethodSecurityExpressionHandler {\n val handler = DefaultMethodSecurityExpressionHandler()\n handler.setRoleHierarchy(roleHierarchy)\n return handler\n\t}\n}\n----\n======\n\n[TIP]\n====\nWe expose `MethodSecurityExpressionHandler` using a `static` method to ensure that Spring publishes it before it initializes Spring Security's method security `@Configuration` classes\n====\n\nYou can also subclass xref:servlet/authorization/method-security.adoc#subclass-defaultmethodsecurityexpressionhandler[`DefaultMessageSecurityExpressionHandler`] to add your own custom authorization expressions beyond the defaults.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authorization/method.adoc", "title": "method", "heading": "Customizing Expression Handling", "heading_level": 3, "file_order": 30, "section_index": 6, "content_hash": "5f1a27f76a7830a33dc9a1c9f5c61a5a695575b7c05d4f84cde6652d6a465800", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authorization/method.adoc"}}
{"id": "sha256:86d11053832c82c746c8a1fbf0e9cc09844ec9556690a03423b1f06c7a25213b", "content": "[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nAuthentication authentication = new TestingAuthenticationToken(\"user\", \"password\", \"ROLE_USER\");\n\nMono<String> messageByUsername = ReactiveSecurityContextHolder.getContext()\n\t.map(SecurityContext::getAuthentication)\n\t.map(Authentication::getName)\n\t.flatMap(this::findMessageByUsername)\n\t// In a WebFlux application the `subscriberContext` is automatically setup using `ReactorContextWebFilter`\n\t.contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication));\n\nStepVerifier.create(messageByUsername)\n\t.expectNext(\"Hi user\")\n\t.verifyComplete();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval authentication: Authentication = TestingAuthenticationToken(\"user\", \"password\", \"ROLE_USER\")\n\nval messageByUsername: Mono<String> = ReactiveSecurityContextHolder.getContext()\n\t.map(SecurityContext::getAuthentication)\n\t.map(Authentication::getName)\n\t.flatMap(this::findMessageByUsername) // In a WebFlux application the `subscriberContext` is automatically setup using `ReactorContextWebFilter`\n\t.contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication))\n\nStepVerifier.create(messageByUsername)\n\t.expectNext(\"Hi user\")\n\t.verifyComplete()\n----\n======\n\nWhere `this::findMessageByUsername` is defined as:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nMono<String> findMessageByUsername(String username) {\n\treturn Mono.just(\"Hi \" + username);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nfun findMessageByUsername(username: String): Mono<String> {\n\treturn Mono.just(\"Hi $username\")\n}\n----\n======\n\nThe following minimal method security configures method security in reactive applications:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableReactiveMethodSecurity\npublic class SecurityConfig {\n\t@Bean\n\tpublic MapReactiveUserDetailsService userDetailsService() {\n User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();\n UserDetails rob = userBuilder.username(\"rob\")\n .password(\"rob\")\n .roles(\"USER\")\n .build();\n UserDetails admin = userBuilder.username(\"admin\")\n .password(\"admin\")\n .roles(\"USER\",\"ADMIN\")\n .build();\n return new MapReactiveUserDetailsService(rob, admin);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableReactiveMethodSecurity\nclass SecurityConfig {\n\t@Bean\n\tfun userDetailsService(): MapReactiveUserDetailsService {\n val userBuilder: User.UserBuilder = User.withDefaultPasswordEncoder()\n val rob = userBuilder.username(\"rob\")\n .password(\"rob\")\n .roles(\"USER\")\n .build()\n val admin = userBuilder.username(\"admin\")\n .password(\"admin\")\n .roles(\"USER\", \"ADMIN\")\n .build()\n return MapReactiveUserDetailsService(rob, admin)\n\t}\n}\n----\n======\n\nConsider the following class:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class HelloWorldMessageService {\n\t@PreAuthorize(\"hasRole('ADMIN')\")\n\tpublic Mono<String> findMessage() {\n return Mono.just(\"Hello World!\");\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass HelloWorldMessageService {\n\t@PreAuthorize(\"hasRole('ADMIN')\")\n\tfun findMessage(): Mono<String> {\n return Mono.just(\"Hello World!\")\n\t}\n}\n----\n======\n\nAlternatively, the following class uses Kotlin coroutines:\n\n[tabs]\n======\nKotlin::\n+\n[source,kotlin,role=\"primary\"]\n----\n@Component\nclass HelloWorldMessageService {\n @PreAuthorize(\"hasRole('ADMIN')\")\n suspend fun findMessage(): String {\n delay(10)\n return \"Hello World!\"\n }\n}\n----\n======\n\nCombined with our configuration above, `@PreAuthorize(\"hasRole('ADMIN')\")` ensures that `findByMessage` is invoked only by a user with the `ADMIN` role.\nNote that any of the expressions in standard method security work for `@EnableReactiveMethodSecurity`.\nHowever, at this time, we support only a return type of `Boolean` or `boolean` of the expression.\nThis means that the expression must not block.\n\nWhen integrating with xref:reactive/configuration/webflux.adoc#jc-webflux[WebFlux Security], the Reactor Context is automatically established by Spring Security according to the authenticated user:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\n@EnableReactiveMethodSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tSecurityWebFilterChain springWebFilterChain(ServerHttpSecurity http) throws Exception {\n return http\n // Demonstrate that method security works\n // Best practice to use both for defense in depth\n .authorizeExchange((authorize) -> authorize\n .anyExchange().permitAll()\n )\n .httpBasic(withDefaults())\n .build();\n\t}\n\n\t@Bean\n\tMapReactiveUserDetailsService userDetailsService() {\n User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();\n UserDetails rob = userBuilder.username(\"rob\")\n .password(\"rob\")\n .roles(\"USER\")\n .build();\n UserDetails admin = userBuilder.username(\"admin\")\n .password(\"admin\")\n .roles(\"USER\",\"ADMIN\")\n .build();\n return new MapReactiveUserDetailsService(rob, admin);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\n@EnableReactiveMethodSecurity\nclass SecurityConfig {\n\t@Bean\n\topen fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, permitAll)\n }\n httpBasic { }\n }\n\t}\n\n\t@Bean\n\tfun userDetailsService(): MapReactiveUserDetailsService {\n val userBuilder: User.UserBuilder = User.withDefaultPasswordEncoder()\n val rob = userBuilder.username(\"rob\")\n .password(\"rob\")\n .roles(\"USER\")\n .build()\n val admin = userBuilder.username(\"admin\")\n .password(\"admin\")\n .roles(\"USER\", \"ADMIN\")\n .build()\n return MapReactiveUserDetailsService(rob, admin)\n\t}\n}\n----\n======\n\nYou can find a complete sample in {gh-samples-url}/reactive/webflux/java/method[hellowebflux-method].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/authorization/method.adoc", "title": "method", "heading": "EnableReactiveMethodSecurity", "heading_level": 2, "file_order": 30, "section_index": 7, "content_hash": "86d11053832c82c746c8a1fbf0e9cc09844ec9556690a03423b1f06c7a25213b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/authorization/method.adoc"}}
{"id": "sha256:2d584f939c5eee1bd378770f02a85a69c3b3a9fecb13a2c24d0ea8ff45035a83", "content": "[[jc-webflux]]\n\nSpring Security's WebFlux support relies on a `WebFilter` and works the same for Spring WebFlux and Spring WebFlux.Fn.\nA few sample applications demonstrate the code:\n\n* Hello WebFlux {gh-samples-url}/reactive/webflux/java/hello-security[hellowebflux]\n* Hello WebFlux.Fn {gh-samples-url}/reactive/webflux-fn/hello-security[hellowebfluxfn]\n* Hello WebFlux Method {gh-samples-url}/reactive/webflux/java/method[hellowebflux-method]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/configuration/webflux.adoc", "title": "webflux", "heading": "webflux", "heading_level": 1, "file_order": 31, "section_index": 0, "content_hash": "2d584f939c5eee1bd378770f02a85a69c3b3a9fecb13a2c24d0ea8ff45035a83", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/configuration/webflux.adoc"}}
{"id": "sha256:8921410b49552b78a079f430e153345094954be02dbd348e364b0571ff407eb1", "content": "The following listing shows a minimal WebFlux Security configuration:\n\n.Minimal WebFlux Security Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n-----\n@Configuration\n@EnableWebFluxSecurity\npublic class HelloWebfluxSecurityConfig {\n\n\t@Bean\n\tpublic MapReactiveUserDetailsService userDetailsService() {\n UserDetails user = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"user\")\n .roles(\"USER\")\n .build();\n return new MapReactiveUserDetailsService(user);\n\t}\n}\n-----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n-----\n@Configuration\n@EnableWebFluxSecurity\nclass HelloWebfluxSecurityConfig {\n\n @Bean\n fun userDetailsService(): ReactiveUserDetailsService {\n val userDetails = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"user\")\n .roles(\"USER\")\n .build()\n return MapReactiveUserDetailsService(userDetails)\n }\n}\n-----\n======\n\nThis configuration provides form and HTTP basic authentication, sets up authorization to require an authenticated user for accessing any page, sets up a default login page and a default logout page, sets up security related HTTP headers, adds CSRF protection, and more.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/configuration/webflux.adoc", "title": "webflux", "heading": "Minimal WebFlux Security Configuration", "heading_level": 2, "file_order": 31, "section_index": 1, "content_hash": "8921410b49552b78a079f430e153345094954be02dbd348e364b0571ff407eb1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/configuration/webflux.adoc"}}
{"id": "sha256:fd653696a7ae2ed0890e07b502dda3d058a07975e991055560cf3cb9f88f84ed", "content": "The following page shows an explicit version of the minimal WebFlux Security configuration:\n\n.Explicit WebFlux Security Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n-----\n@Configuration\n@EnableWebFluxSecurity\npublic class HelloWebfluxSecurityConfig {\n\n\t@Bean\n\tpublic MapReactiveUserDetailsService userDetailsService() {\n UserDetails user = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"user\")\n .roles(\"USER\")\n .build();\n return new MapReactiveUserDetailsService(user);\n\t}\n\n\t@Bean\n\tpublic SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .httpBasic(withDefaults())\n .formLogin(withDefaults());\n return http.build();\n\t}\n}\n-----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n-----\nimport org.springframework.security.config.web.server.invoke\n\n@Configuration\n@EnableWebFluxSecurity\nclass HelloWebfluxSecurityConfig {\n\n @Bean\n fun userDetailsService(): ReactiveUserDetailsService {\n val userDetails = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"user\")\n .roles(\"USER\")\n .build()\n return MapReactiveUserDetailsService(userDetails)\n }\n\n @Bean\n fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n formLogin { }\n httpBasic { }\n }\n }\n}\n-----\n======\n\n[NOTE]\nMake sure to import the `org.springframework.security.config.web.server.invoke` function to enable the Kotlin DSL in your class, as the IDE will not always auto-import the method, causing compilation issues.\n\nThis configuration explicitly sets up all the same things as our minimal configuration.\nFrom here, you can more easily make changes to the defaults.\n\nYou can find more examples of explicit configuration in unit tests, by searching for https://github.com/spring-projects/spring-security/search?q=path%3Aconfig%2Fsrc%2Ftest%2F+EnableWebFluxSecurity[`EnableWebFluxSecurity` in the `config/src/test/` directory].\n\n[[jc-webflux-multiple-filter-chains]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/configuration/webflux.adoc", "title": "webflux", "heading": "Explicit WebFlux Security Configuration", "heading_level": 2, "file_order": 31, "section_index": 2, "content_hash": "fd653696a7ae2ed0890e07b502dda3d058a07975e991055560cf3cb9f88f84ed", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/configuration/webflux.adoc"}}
{"id": "sha256:145179bdf0f7f491c7c76ccb7d876d689e4332dd0a2e8a95062acff29b4dac36", "content": "You can configure multiple `SecurityWebFilterChain` instances to separate configuration by `RequestMatcher` instances.\n\nFor example, you can isolate configuration for URLs that start with `/api`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nstatic class MultiSecurityHttpConfig {\n\n @Order(Ordered.HIGHEST_PRECEDENCE) <1>\n @Bean\n SecurityWebFilterChain apiHttpSecurity(ServerHttpSecurity http) {\n http\n .securityMatcher(new PathPatternParserServerWebExchangeMatcher(\"/api/**\")) <2>\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer(OAuth2ResourceServerSpec::jwt); <3>\n return http.build();\n }\n\n @Bean\n SecurityWebFilterChain webHttpSecurity(ServerHttpSecurity http) { <4>\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .httpBasic(withDefaults()); <5>\n return http.build();\n }\n\n @Bean\n ReactiveUserDetailsService userDetailsService() {\n return new MapReactiveUserDetailsService(\n PasswordEncodedUser.user(), PasswordEncodedUser.admin());\n }\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.web.server.invoke\n\n@Configuration\n@EnableWebFluxSecurity\nopen class MultiSecurityHttpConfig {\n @Order(Ordered.HIGHEST_PRECEDENCE) <1>\n @Bean\n open fun apiHttpSecurity(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n securityMatcher(PathPatternParserServerWebExchangeMatcher(\"/api/**\")) <2>\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n jwt { } <3>\n }\n }\n }\n\n @Bean\n open fun webHttpSecurity(http: ServerHttpSecurity): SecurityWebFilterChain { <4>\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n httpBasic { } <5>\n }\n }\n\n @Bean\n open fun userDetailsService(): ReactiveUserDetailsService {\n return MapReactiveUserDetailsService(\n PasswordEncodedUser.user(), PasswordEncodedUser.admin()\n )\n }\n}\n----\n======\n\n<1> Configure a `SecurityWebFilterChain` with an `@Order` to specify which `SecurityWebFilterChain` Spring Security should consider first\n<2> Use `PathPatternParserServerWebExchangeMatcher` to state that this `SecurityWebFilterChain` will only apply to URL paths that start with `/api/`\n<3> Specify the authentication mechanisms that will be used for `/api/**` endpoints\n<4> Create another instance of `SecurityWebFilterChain` with lower precedence to match all other URLs\n<5> Specify the authentication mechanisms that will be used for the rest of the application\n\nSpring Security selects one `SecurityWebFilterChain` `@Bean` for each request.\nIt matches the requests in order by the `securityMatcher` definition.\n\nIn this case, that means that, if the URL path starts with `/api`, Spring Security uses `apiHttpSecurity`.\nIf the URL does not start with `/api`, Spring Security defaults to `webHttpSecurity`, which has an implied `securityMatcher` that matches any request.\n\n[[modular-serverhttpsecurity-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/configuration/webflux.adoc", "title": "webflux", "heading": "Multiple Chains Support", "heading_level": 3, "file_order": 31, "section_index": 3, "content_hash": "145179bdf0f7f491c7c76ccb7d876d689e4332dd0a2e8a95062acff29b4dac36", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/configuration/webflux.adoc"}}
{"id": "sha256:0b7bf3144f469a938a29469c7e4cba61f5269ac6c7f0db1242eb2d88ab9e0b8c", "content": "Many users prefer that their Spring Security configuration lives in a centralized place and will choose to configure it within the `SecurityWebFilterChain` Bean declaration.\nHowever, there are times that users may want to modularize the configuration.\nThis can be done using:\n\n* xref:#serverhttpsecurity-customizer-bean[Customizer<ServerHttpSecurity> Beans]\n* xref:#top-level-customizer-bean[Top Level ServerHttpSecurity Customizer Beans]\n\n[[serverhttpsecurity-customizer-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/configuration/webflux.adoc", "title": "webflux", "heading": "Modular ServerHttpSecurity Configuration", "heading_level": 2, "file_order": 31, "section_index": 4, "content_hash": "0b7bf3144f469a938a29469c7e4cba61f5269ac6c7f0db1242eb2d88ab9e0b8c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/configuration/webflux.adoc"}}
{"id": "sha256:bbcb1e9b5de8d024649c85433f560c6fc830430065691dce753fd55e2b91074a", "content": "If you would like to modularize your security configuration you can place logic in a `Customizer<ServerHttpSecurity>` Bean.\nFor example, the following configuration will ensure all `ServerHttpSecurity` instances are configured to:\n\ninclude-code::./ServerHttpSecurityCustomizerBeanConfiguration[tag=httpSecurityCustomizer,indent=0]\n\n<1> Set the xref:servlet/exploits/headers.adoc#servlet-headers-csp[Content Security Policy] to `object-src 'none'`\n<2> xref:servlet/exploits/http.adoc#servlet-http-redirect[Redirect any request to https]\n\n[[top-level-customizer-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/configuration/webflux.adoc", "title": "webflux", "heading": "Customizer<ServerHttpSecurity> Beans", "heading_level": 3, "file_order": 31, "section_index": 5, "content_hash": "bbcb1e9b5de8d024649c85433f560c6fc830430065691dce753fd55e2b91074a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/configuration/webflux.adoc"}}
{"id": "sha256:ef122c548da68495e0630cf300c322c43e5b0a3e556393235539d834c6c350c8", "content": "If you prefer to have further modularization of your security configuration, Spring Security will automatically apply any top level `HttpSecurity` `Customizer` Beans.\n\nA top level `HttpSecurity` `Customizer` type can be summarized as any `Customizer<T>` that matches `public HttpSecurity.*(Customizer<T>)`.\nThis translates to any `Customizer<T>` that is a single argument to a public method on javadoc:org.springframework.security.config.annotation.web.builders.HttpSecurity[].\n\nA few examples can help to clarify.\nIf `Customizer<ContentTypeOptionsConfig>` is published as a Bean, it will not be be automatically applied because it is an argument to javadoc:org.springframework.security.config.annotation.web.configurers.HeadersConfigurer#contentTypeOptions(org.springframework.security.config.Customizer)[] which is not a method defined on `HttpSecurity`.\nHowever, if `Customizer<HeadersConfigurer<HttpSecurity>>` is published as a Bean, it will be automatically applied because it is an argument to javadoc:org.springframework.security.config.annotation.web.builders.HttpSecurity#headers(org.springframework.security.config.Customizer)[].\n\nFor example, the following configuration will ensure that the xref:servlet/exploits/headers.adoc#servlet-headers-csp[Content Security Policy] is set to `object-src 'none'`:\n\ninclude-code::./TopLevelCustomizerBeanConfiguration[tag=headersCustomizer,indent=0]\n\n[[customizer-bean-ordering]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/configuration/webflux.adoc", "title": "webflux", "heading": "Top Level ServerHttpSecurity Customizer Beans", "heading_level": 3, "file_order": 31, "section_index": 6, "content_hash": "ef122c548da68495e0630cf300c322c43e5b0a3e556393235539d834c6c350c8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/configuration/webflux.adoc"}}
{"id": "sha256:f5d9733ac0d6902dfba003a1222c3fec3f7bb2430b3800846ff0f36f4223eb19", "content": "First each xref:#httpsecurity-customizer-bean[Customizer<HttpSecurity> Bean] is applied using https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/ObjectProvider.html#orderedStream()[ObjectProvider#orderedStream()].\nThis means that if there are multiple `Customizer<HttpSecurity>` Beans, the https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/annotation/Order.html[@Order] annotation can be added to the Bean definitions to control the ordering.\n\nNext every xref:#top-level-customizer-bean[Top Level HttpSecurity Customizer Beans] type is looked up and each is is applied using `ObjectProvider#orderedStream()`.\nIf there is are two `Customizer<HeadersConfigurer<HttpSecurity>>` beans and two `Customizer<HttpsRedirectConfigurer<HttpSecurity>>` instances, the order that each `Customizer` type is invoked is undefined.\nHowever, the order that each instance of `Customizer<HttpsRedirectConfigurer<HttpSecurity>>` is defined by `ObjectProvider#orderedStream()` and can be controlled using `@Order` on the Bean the definitions.\n\nFinally, the `HttpSecurity` Bean is injected as a Bean.\nAll `Customizer` instances are applied before the `HttpSecurity` Bean is created.\nThis allows overriding the customizations provided by the `Customizer` Beans.\n\nYou can find an example below that illustrates the ordering:\n\ninclude-code::./CustomizerBeanOrderingConfiguration[tag=sample,indent=0]\n\n<1> First all `Customizer<HttpSecurity>` instances are applied.\nThe `adminAuthorization` Bean has the highest `@Order` so it is applied first.\nIf there are no `@Order` annotations on the `Customizer<HttpSecurity>` Beans or the `@Order` annotations had the same value, then the order that the `Customizer<HttpSecurity>` instances are applied is undefined.\n<2> The `userAuthorization` is applied next due to being an instance of `Customizer<HttpSecurity>`\n<3> The order that the `Customizer` types are undefined.\nIn this example, the order of `contentSecurityPolicy`, `contentTypeOptions`, and `httpsRedirect` are undefined.\nIf `@Order(Ordered.HIGHEST_PRECEDENCE)` was added to `contentTypeOptions`, then we would know that `contentTypeOptions` is before `contentSecurityPolicy` (they are the same type), but we do not know if `httpsRedirect` is before or after the `Customizer<HeadersConfigurer<HttpSecurity>>` Beans.\n<4> After all of the `Customizer` Beans are applied, the `HttpSecurity` is passed in as a Bean.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/configuration/webflux.adoc", "title": "webflux", "heading": "Customizer Bean Ordering", "heading_level": 3, "file_order": 31, "section_index": 7, "content_hash": "f5d9733ac0d6902dfba003a1222c3fec3f7bb2430b3800846ff0f36f4223eb19", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/configuration/webflux.adoc"}}
{"id": "sha256:ceca9fee16eecf88b4a2968d39fea21d1b55e65143bf164faacd13de5072dc96", "content": "[[webflux-csrf]]\n\nThis section discusses Spring Security's xref:features/exploits/csrf.adoc#csrf[Cross Site Request Forgery (CSRF)] support for WebFlux environments.\n\n[[webflux-csrf-using]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "csrf", "heading_level": 1, "file_order": 32, "section_index": 0, "content_hash": "ceca9fee16eecf88b4a2968d39fea21d1b55e65143bf164faacd13de5072dc96", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:3ef90160c80161fb4ca23d9cb3d58a61cb163f3fe21eedd0772a5e52843cbbdc", "content": "The steps to using Spring Security's CSRF protection are outlined below:\n\n* <<webflux-csrf-read-only,Use proper HTTP verbs>>\n* <<webflux-csrf-configure,Configure CSRF Protection>>\n* <<webflux-csrf-include,Include the CSRF Token>>\n\n[[webflux-csrf-read-only]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Using Spring Security CSRF Protection", "heading_level": 2, "file_order": 32, "section_index": 1, "content_hash": "3ef90160c80161fb4ca23d9cb3d58a61cb163f3fe21eedd0772a5e52843cbbdc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:75422cb8ca5943e3e793fcc3467d83e85ad96d6dbc7a049c7b6b969529e979a9", "content": "The first step to protecting against CSRF attacks is to ensure your website uses proper HTTP verbs.\nThis is covered in detail in xref:features/exploits/csrf.adoc#csrf-protection-read-only[Safe Methods Must be Read-only].\n\n[[webflux-csrf-configure]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Use Proper HTTP Verbs", "heading_level": 3, "file_order": 32, "section_index": 2, "content_hash": "75422cb8ca5943e3e793fcc3467d83e85ad96d6dbc7a049c7b6b969529e979a9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:8cfa1b376bf1306f0626bd5d58120e6e21b3a93c3d2672bbff83b864238d9958", "content": "The next step is to configure Spring Security's CSRF protection within your application.\nBy default, Spring Security's CSRF protection is enabled, but you may need to customize the configuration.\nThe next few subsections cover a few common customizations.\n\n[[webflux-csrf-configure-custom-repository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Configure CSRF Protection", "heading_level": 3, "file_order": 32, "section_index": 3, "content_hash": "8cfa1b376bf1306f0626bd5d58120e6e21b3a93c3d2672bbff83b864238d9958", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:dcd9670a5b03a05c288ad75451de1cf07c1fc752059392de896f0c564aedc9cc", "content": "By default, Spring Security stores the expected CSRF token in the `WebSession` by using `WebSessionServerCsrfTokenRepository`.\nSometimes, you may need to configure a custom `ServerCsrfTokenRepository`.\nFor example, you may want to persist the `CsrfToken` in a cookie to <<webflux-csrf-include-ajax-auto,support a JavaScript-based application>>.\n\nBy default, the `CookieServerCsrfTokenRepository` writes to a cookie named `XSRF-TOKEN` and read its from a header named `X-XSRF-TOKEN` or the HTTP `_csrf` parameter.\nThese defaults come from https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]\n\nYou can configure `CookieServerCsrfTokenRepository` in Java Configuration:\n\n.Store CSRF Token in a Cookie\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n-----\n@Bean\npublic SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .csrf((csrf) -> csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse()))\n\treturn http.build();\n}\n-----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n-----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n csrf {\n csrfTokenRepository = CookieServerCsrfTokenRepository.withHttpOnlyFalse()\n }\n }\n}\n-----\n======\n\n[NOTE]\n====\nThe preceding sample explicitly sets `cookieHttpOnly=false`.\nThis is necessary to let JavaScript (in this case, AngularJS) to read it.\nIf you do not need the ability to read the cookie with JavaScript directly, we recommend to omitting `cookieHttpOnly=false` (by using `new CookieServerCsrfTokenRepository()` instead) to improve security.\n====\n\n[[webflux-csrf-configure-disable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Custom CsrfTokenRepository", "heading_level": 4, "file_order": 32, "section_index": 4, "content_hash": "dcd9670a5b03a05c288ad75451de1cf07c1fc752059392de896f0c564aedc9cc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:a12072dac2c2ff7de2c20c0ae2e2fd7addfaad3a14040e82137e658f6130aa85", "content": "By default, CSRF protection is enabled.\nHowever, you can disable CSRF protection if it xref:features/exploits/csrf.adoc#csrf-when[makes sense for your application].\n\nThe Java configuration below will disable CSRF protection.\n\n.Disable CSRF Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .csrf((csrf) -> csrf.disable()))\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n-----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n csrf {\n disable()\n }\n }\n}\n-----\n======\n\n[[webflux-csrf-configure-request-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Disable CSRF Protection", "heading_level": 4, "file_order": 32, "section_index": 5, "content_hash": "a12072dac2c2ff7de2c20c0ae2e2fd7addfaad3a14040e82137e658f6130aa85", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:0db177ee515cd094293af52120f8a589090a2c67794a2fd520f45ce8e08fe1b7", "content": "Spring Security's javadoc:org.springframework.security.web.server.csrf.CsrfWebFilter[] exposes a javadoc:org.springframework.security.web.server.csrf.CsrfToken[`Mono<CsrfToken>`] as a `ServerWebExchange` attribute named `org.springframework.security.web.server.csrf.CsrfToken` with the help of a javadoc:org.springframework.security.web.server.csrf.ServerCsrfTokenRequestHandler[].\nIn 5.8, the default implementation was `ServerCsrfTokenRequestAttributeHandler`, which simply makes the `Mono<CsrfToken>` available as an exchange attribute.\n\nAs of 6.0, the default implementation is `XorServerCsrfTokenRequestAttributeHandler`, which provides protection for BREACH (see https://github.com/spring-projects/spring-security/issues/4001[gh-4001]).\n\nIf you wish to disable BREACH protection of the `CsrfToken` and revert to the 5.8 default, you can configure `ServerCsrfTokenRequestAttributeHandler` using the following Java configuration:\n\n.Disable BREACH protection\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n-----\n@Bean\npublic SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .csrf((csrf) -> csrf\n .csrfTokenRequestHandler(new ServerCsrfTokenRequestAttributeHandler())\n )\n\treturn http.build();\n}\n-----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n-----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n csrf {\n csrfTokenRequestHandler = ServerCsrfTokenRequestAttributeHandler()\n }\n }\n}\n-----\n======\n\n[[webflux-csrf-include]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Configure ServerCsrfTokenRequestHandler", "heading_level": 4, "file_order": 32, "section_index": 6, "content_hash": "0db177ee515cd094293af52120f8a589090a2c67794a2fd520f45ce8e08fe1b7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:6c2f5157e49ee095f3cf117da2c503a7f8cd0717bca3896493e09ab01aa7cf26", "content": "For the xref:features/exploits/csrf.adoc#csrf-protection-stp[synchronizer token pattern] to protect against CSRF attacks, we must include the actual CSRF token in the HTTP request.\nIt must be included in a part of the request (a form parameter, an HTTP header, or other option) that is not automatically included in the HTTP request by the browser.\n\n<<webflux-csrf-configure-request-handler,We've seen>> that the `Mono<CsrfToken>` is exposed as a `ServerWebExchange` attribute.\nThis means that any view technology can access the `Mono<CsrfToken>` to expose the expected token as either a <<webflux-csrf-include-form-attr,form>> or a <<webflux-csrf-include-ajax-meta,meta tag>>.\n\n[[webflux-csrf-include-subscribe]]\nIf your view technology does not provide a simple way to subscribe to the `Mono<CsrfToken>`, a common pattern is to use Spring's `@ControllerAdvice` to expose the `CsrfToken` directly.\nThe following example places the `CsrfToken` on the default attribute name (`_csrf`) used by Spring Security's <<webflux-csrf-include-form-auto,CsrfRequestDataValueProcessor>> to automatically include the CSRF token as a hidden input:\n\n.`CsrfToken` as `@ModelAttribute`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@ControllerAdvice\npublic class SecurityControllerAdvice {\n\t@ModelAttribute\n\tMono<CsrfToken> csrfToken(ServerWebExchange exchange) {\n Mono<CsrfToken> csrfToken = exchange.getAttribute(CsrfToken.class.getName());\n return csrfToken.doOnSuccess((token) -> token.getAttributes()\n .put(CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME, token));\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@ControllerAdvice\nclass SecurityControllerAdvice {\n @ModelAttribute\n fun csrfToken(exchange: ServerWebExchange): Mono<CsrfToken> {\n val csrfToken: Mono<CsrfToken>? = exchange.getAttribute(CsrfToken::class.java.name)\n return csrfToken!!.doOnSuccess { token ->\n exchange.attributes[CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME] = token\n }\n }\n}\n----\n======\n\nFortunately, Thymeleaf provides <<webflux-csrf-include-form-auto,integration>> that works without any additional work.\n\n[[webflux-csrf-include-form]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Include the CSRF Token", "heading_level": 3, "file_order": 32, "section_index": 7, "content_hash": "6c2f5157e49ee095f3cf117da2c503a7f8cd0717bca3896493e09ab01aa7cf26", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:cc82ebc36099dd8d8efedebb3f20f7274bd5feb1ce02f5f70cf5c1b4a1410a1b", "content": "To post an HTML form, the CSRF token must be included in the form as a hidden input.\nThe following example shows what the rendered HTML might look like:\n\n.CSRF Token HTML\n[source,html]\n----\n<input type=\"hidden\"\n\tname=\"_csrf\"\n\tvalue=\"4bfd1575-3ad1-4d21-96c7-4ef2d9f86721\"/>\n----\n\nNext, we discuss various ways of including the CSRF token in a form as a hidden input.\n\n[[webflux-csrf-include-form-auto]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Form URL Encoded", "heading_level": 4, "file_order": 32, "section_index": 8, "content_hash": "cc82ebc36099dd8d8efedebb3f20f7274bd5feb1ce02f5f70cf5c1b4a1410a1b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:af01088aac4057d3fb97dda4e8303a4c28821bc46af3965f37a29831b1265197", "content": "Spring Security's CSRF support provides integration with Spring's https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/reactive/result/view/RequestDataValueProcessor.html[`RequestDataValueProcessor`] through its javadoc:org.springframework.security.web.reactive.result.view.CsrfRequestDataValueProcessor[].\nFor `CsrfRequestDataValueProcessor` to work, the `Mono<CsrfToken>` must be subscribed to and the `CsrfToken` must be <<webflux-csrf-include-subscribe,exposed as an attribute>> that matches javadoc:org.springframework.security.web.reactive.result.view.CsrfRequestDataValueProcessor#DEFAULT_CSRF_ATTR_NAME[].\n\nFortunately, Thymeleaf https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor[takes care of all the boilerplate] for you by integrating with `RequestDataValueProcessor` to ensure that forms that have an unsafe HTTP method (POST) automatically include the actual CSRF token.\n\n[[webflux-csrf-include-form-attr]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Automatic CSRF Token Inclusion", "heading_level": 5, "file_order": 32, "section_index": 9, "content_hash": "af01088aac4057d3fb97dda4e8303a4c28821bc46af3965f37a29831b1265197", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:45024578bfc98018f650c86cf847f01ac233240d8ad6b7632bbd88d3cd217fd6", "content": "If the <<webflux-csrf-include,other options>> for including the actual CSRF token in the request do not work, you can take advantage of the fact that the `Mono<CsrfToken>` <<webflux-csrf-include,is exposed>> as a `ServerWebExchange` attribute named `org.springframework.security.web.server.csrf.CsrfToken`.\n\nThe following Thymeleaf sample assumes that you <<webflux-csrf-include-subscribe,expose>> the `CsrfToken` on an attribute named `_csrf`:\n\n.CSRF Token in Form with Request Attribute\n[source,html]\n----\n<form th:action=\"@{/logout}\"\n\tmethod=\"post\">\n<input type=\"submit\"\n\tvalue=\"Log out\" />\n<input type=\"hidden\"\n\tth:name=\"${_csrf.parameterName}\"\n\tth:value=\"${_csrf.token}\"/>\n</form>\n----\n\n[[webflux-csrf-include-ajax]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "CsrfToken Request Attribute", "heading_level": 5, "file_order": 32, "section_index": 10, "content_hash": "45024578bfc98018f650c86cf847f01ac233240d8ad6b7632bbd88d3cd217fd6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:a1e8b52732009422123a1f1fdcc4a12e4c8394fb1a3b6c6951660942786bf197", "content": "If you use JSON, you cannot submit the CSRF token within an HTTP parameter.\nInstead, you can submit the token within a HTTP header.\n\nIn the following sections, we discuss various ways of including the CSRF token as an HTTP request header in JavaScript-based applications.\n\n[[webflux-csrf-include-ajax-auto]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Ajax and JSON Requests", "heading_level": 4, "file_order": 32, "section_index": 11, "content_hash": "a1e8b52732009422123a1f1fdcc4a12e4c8394fb1a3b6c6951660942786bf197", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:5600517908bd546612a1ada3256460a85ae6196678f89ce260f5136affb4c1df", "content": "You can <<webflux-csrf-configure-custom-repository,configure>> Spring Security to store the expected CSRF token in a cookie.\nBy storing the expected CSRF in a cookie, JavaScript frameworks, such as https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS], automatically include the actual CSRF token in the HTTP request headers.\n\n[[webflux-csrf-include-ajax-meta]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Automatic Inclusion", "heading_level": 5, "file_order": 32, "section_index": 12, "content_hash": "5600517908bd546612a1ada3256460a85ae6196678f89ce260f5136affb4c1df", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:d190d4a07b1a595570edbc8888ff2e7c877a8c455ec9aa58c2aa6002fdf7b5e4", "content": "An alternative pattern to <<webflux-csrf-include-form-auto,exposing the CSRF in a cookie>> is to include the CSRF token within your `meta` tags.\nThe HTML might look something like this:\n\n.CSRF meta tag HTML\n[source,html]\n----\n<html>\n<head>\n\t<meta name=\"_csrf\" content=\"4bfd1575-3ad1-4d21-96c7-4ef2d9f86721\"/>\n\t<meta name=\"_csrf_header\" content=\"X-CSRF-TOKEN\"/>\n\t<!-- ... -->\n</head>\n<!-- ... -->\n----\n\nOnce the meta tags contain the CSRF token, the JavaScript code can read the meta tags and include the CSRF token as a header.\nIf you use jQuery, you could read the meta tags with the following code:\n\n.AJAX send CSRF Token\n[source,javascript]\n----\n$(function () {\n\tvar token = $(\"meta[name='_csrf']\").attr(\"content\");\n\tvar header = $(\"meta[name='_csrf_header']\").attr(\"content\");\n\t$(document).ajaxSend(function(e, xhr, options) {\n xhr.setRequestHeader(header, token);\n\t});\n});\n----\n\nThe following sample assumes that you <<webflux-csrf-include-subscribe,expose>> the `CsrfToken` on an attribute named `_csrf`.\nThe following example does this with Thymeleaf:\n\n.CSRF meta tag JSP\n[source,html]\n----\n<html>\n<head>\n\t<meta name=\"_csrf\" th:content=\"${_csrf.token}\"/>\n\t<!-- default header name is X-CSRF-TOKEN -->\n\t<meta name=\"_csrf_header\" th:content=\"${_csrf.headerName}\"/>\n\t<!-- ... -->\n</head>\n<!-- ... -->\n----\n\n[[webflux-csrf-considerations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Meta Tags", "heading_level": 5, "file_order": 32, "section_index": 13, "content_hash": "d190d4a07b1a595570edbc8888ff2e7c877a8c455ec9aa58c2aa6002fdf7b5e4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:86340171439edd7810ae8e4922e2a7e299bfad7316c62b6581a189a242aaad25", "content": "There are a few special considerations to consider when implementing protection against CSRF attacks.\nThis section discusses those considerations as it pertains to WebFlux environments.\nSee xref:features/exploits/csrf.adoc#csrf-considerations[CSRF Considerations] for a more general discussion.\n\n[[webflux-considerations-csrf-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "CSRF Considerations", "heading_level": 2, "file_order": 32, "section_index": 14, "content_hash": "86340171439edd7810ae8e4922e2a7e299bfad7316c62b6581a189a242aaad25", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:6ade455cf27172f32740ccf8e5add977719c723184ba694a3e5c35ff8be95c23", "content": "You should xref:features/exploits/csrf.adoc#csrf-considerations-login[require CSRF for login] requests to protect against forged login attempts.\nSpring Security's WebFlux support automatically does this.\n\n[[webflux-considerations-csrf-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Logging In", "heading_level": 3, "file_order": 32, "section_index": 15, "content_hash": "6ade455cf27172f32740ccf8e5add977719c723184ba694a3e5c35ff8be95c23", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:af1cd93f149e4a6cec88cb6f0af5bc1e5c4a9ae70692c2cb80becef0382419b6", "content": "You should xref:features/exploits/csrf.adoc#csrf-considerations-logout[require CSRF for logout] requests to protect against forging logout attempts.\nBy default, Spring Security's `LogoutWebFilter` only processes only HTTP post requests.\nThis ensures that logout requires a CSRF token and that a malicious user cannot forcibly log out your users.\n\nThe easiest approach is to use a form to log out.\nIf you really want a link, you can use JavaScript to have the link perform a POST (maybe on a hidden form).\nFor browsers with JavaScript that is disabled, you can optionally have the link take the user to a logout confirmation page that performs the POST.\n\nIf you really want to use HTTP GET with logout, you can do so, but remember that doing so is generally not recommended.\nFor example, the following Java Configuration logs out when the `/logout` URL is requested with any HTTP method:\n\n.Log out with HTTP GET\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .logout((logout) -> logout.requiresLogout(new PathPatternParserServerWebExchangeMatcher(\"/logout\")))\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n logout {\n requiresLogout = PathPatternParserServerWebExchangeMatcher(\"/logout\")\n }\n }\n}\n----\n======\n\n[[webflux-considerations-csrf-timeouts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Logging Out", "heading_level": 3, "file_order": 32, "section_index": 16, "content_hash": "af1cd93f149e4a6cec88cb6f0af5bc1e5c4a9ae70692c2cb80becef0382419b6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:11cd52b5f34b2bfe4d94ae9cd0d7dfc3dd21cafda2ead766e531d45a15b6710b", "content": "By default, Spring Security stores the CSRF token in the `WebSession`.\nThis arrangement can lead to a situation where the session expires, which means that there is not an expected CSRF token to validate against.\n\nWe have already discussed xref:features/exploits/csrf.adoc#csrf-considerations-login[general solutions] to session timeouts.\nThis section discusses the specifics of CSRF timeouts as it pertains to the WebFlux support.\n\nYou can change storage of the expected CSRF token to be in a cookie.\nFor details, see the <<webflux-csrf-configure-custom-repository>> section.\n\n[[webflux-csrf-considerations-multipart]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "CSRF and Session Timeouts", "heading_level": 3, "file_order": 32, "section_index": 17, "content_hash": "11cd52b5f34b2bfe4d94ae9cd0d7dfc3dd21cafda2ead766e531d45a15b6710b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:5655f5d75b889a9b936480d34fdda70e293047348ed9c7f7d95419ee7f0b1a04", "content": "We have xref:features/exploits/csrf.adoc#csrf-considerations-multipart[already discussed] how protecting multipart requests (file uploads) from CSRF attacks causes a https://en.wikipedia.org/wiki/Chicken_or_the_egg[chicken and the egg] problem.\nThis section discusses how to implement placing the CSRF token in the <<webflux-csrf-considerations-multipart-body,body>> and <<webflux-csrf-considerations-multipart-url,url>> within a WebFlux application.\n\n[NOTE]\n====\nFor more information about using multipart forms with Spring, see the https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web-reactive.html#webflux-multipart[Multipart Data] section of the Spring reference.\n====\n\n[[webflux-csrf-considerations-multipart-body]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Multipart (file upload)", "heading_level": 3, "file_order": 32, "section_index": 18, "content_hash": "5655f5d75b889a9b936480d34fdda70e293047348ed9c7f7d95419ee7f0b1a04", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:e0975243c382a618f7eb48c8d621fa7510af1e04b78adf4e228f892d092530e1", "content": "We have xref:features/exploits/csrf.adoc#csrf-considerations-multipart[already discussed] the trade-offs of placing the CSRF token in the body.\n\nIn a WebFlux application, you can do so with the following configuration:\n\n.Enable obtaining CSRF token from multipart/form-data\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .csrf((csrf) -> csrf.tokenFromMultipartDataEnabled(true))\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n csrf {\n tokenFromMultipartDataEnabled = true\n }\n }\n}\n----\n======\n\n[[webflux-csrf-considerations-multipart-url]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Place CSRF Token in the Body", "heading_level": 4, "file_order": 32, "section_index": 19, "content_hash": "e0975243c382a618f7eb48c8d621fa7510af1e04b78adf4e228f892d092530e1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:efc7bae55ee499eed13d601edaac35f267e3bce5fe5c6b590c33128c70ee7f21", "content": "We have xref:features/exploits/csrf.adoc#csrf-considerations-multipart[already discussed] the trade-offs of placing the CSRF token in the URL.\nSince the `CsrfToken` is exposed as an `ServerHttpRequest` <<webflux-csrf-include,request attribute>>, we can use that to create an `action` with the CSRF token in it.\nAn example with Thymeleaf is shown below:\n\n.CSRF Token in Action\n[source,html]\n----\n<form method=\"post\"\n\tth:action=\"@{/upload(${_csrf.parameterName}=${_csrf.token})}\"\n\tenctype=\"multipart/form-data\">\n----\n\n[[webflux-csrf-considerations-override-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "Include CSRF Token in URL", "heading_level": 4, "file_order": 32, "section_index": 20, "content_hash": "efc7bae55ee499eed13d601edaac35f267e3bce5fe5c6b590c33128c70ee7f21", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:998c6a1af19a293e0e1f49c7d512b705e1826ea27755c16e249d8eaa216415f2", "content": "We have xref:features/exploits/csrf.adoc#csrf-considerations-override-method[already discussed] overriding the HTTP method.\n\nIn a Spring WebFlux application, overriding the HTTP method is done by using https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html[`HiddenHttpMethodFilter`].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/csrf.adoc", "title": "csrf", "heading": "HiddenHttpMethodFilter", "heading_level": 3, "file_order": 32, "section_index": 21, "content_hash": "998c6a1af19a293e0e1f49c7d512b705e1826ea27755c16e249d8eaa216415f2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/csrf.adoc"}}
{"id": "sha256:a310611df369e767fb4452bbd69542c745b12ff4944d3462fd4e999ac0fb642c", "content": "[[webflux-serverwebexchangefirewall]]\n\nThere are various ways a request can be created by malicious users that can exploit applications.\nSpring Security provides the `ServerWebExchangeFirewall` to allow rejecting requests that look malicious.\nThe default implementation is `StrictServerWebExchangeFirewall` which rejects malicious requests.\n\nFor example a request could contain path-traversal sequences (such as `/../`) or multiple forward slashes (`//`) that could also cause pattern-matches to fail.\nSome containers normalize these out before performing the servlet mapping, but others do not.\nTo protect against issues like these, `WebFilterChainProxy` uses a `ServerWebExchangeFirewall` strategy to check and wrap the request.\nBy default, un-normalized requests are automatically rejected, and path parameters are removed for matching purposes.\n(So, for example, an original request path of `/secure;hack=1/somefile.html;hack=2` is returned as `/secure/somefile.html`.)\nIt is, therefore, essential that a `WebFilterChainProxy` is used.\n\nIn practice, we recommend that you use method security at your service layer, to control access to your application, rather than rely entirely on the use of security constraints defined at the web-application level.\nURLs change, and it is difficult to take into account all the possible URLs that an application might support and how requests might be manipulated.\nYou should restrict yourself to using a few simple patterns that are simple to understand.\nAlways try to use a \"`deny-by-default`\" approach, where you have a catch-all wildcard (`/**` or `**`) defined last to deny access.\n\nSecurity defined at the service layer is much more robust and harder to bypass, so you should always take advantage of Spring Security's method security options.\n\nYou can customize the `ServerWebExchangeFirewall` by exposing it as a Bean.\n\n.Allow Matrix Variables\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic StrictServerWebExchangeFirewall httpFirewall() {\n StrictServerWebExchangeFirewall firewall = new StrictServerWebExchangeFirewall();\n firewall.setAllowSemicolon(true);\n return firewall;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun httpFirewall(): StrictServerWebExchangeFirewall {\n val firewall = StrictServerWebExchangeFirewall()\n firewall.setAllowSemicolon(true)\n return firewall\n}\n----\n======\n\nTo protect against https://www.owasp.org/index.php/Cross_Site_Tracing[Cross Site Tracing (XST)] and https://www.owasp.org/index.php/Test_HTTP_Methods_(OTG-CONFIG-006)[HTTP Verb Tampering], the `StrictServerWebExchangeFirewall` provides an allowed list of valid HTTP methods that are allowed.\nThe default valid methods are `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, and `PUT`.\nIf your application needs to modify the valid methods, you can configure a custom `StrictServerWebExchangeFirewall` bean.\nThe following example allows only HTTP `GET` and `POST` methods:\n\n.Allow Only GET & POST\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic StrictServerWebExchangeFirewall httpFirewall() {\n StrictServerWebExchangeFirewall firewall = new StrictServerWebExchangeFirewall();\n firewall.setAllowedHttpMethods(Arrays.asList(\"GET\", \"POST\"));\n return firewall;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun httpFirewall(): StrictServerWebExchangeFirewall {\n val firewall = StrictServerWebExchangeFirewall()\n firewall.setAllowedHttpMethods(listOf(\"GET\", \"POST\"))\n return firewall\n}\n----\n======\n\nIf you must allow any HTTP method (not recommended), you can use `StrictServerWebExchangeFirewall.setUnsafeAllowAnyHttpMethod(true)`.\nDoing so entirely disables validation of the HTTP method.\n\n[[webflux-serverwebexchangefirewall-headers-parameters]]\n`StrictServerWebExchangeFirewall` also checks header names and values and parameter names.\nIt requires that each character have a defined code point and not be a control character.\n\nThis requirement can be relaxed or adjusted as necessary by using the following methods:\n\n* `StrictServerWebExchangeFirewall#setAllowedHeaderNames(Predicate)`\n* `StrictServerWebExchangeFirewall#setAllowedHeaderValues(Predicate)`\n* `StrictServerWebExchangeFirewall#setAllowedParameterNames(Predicate)`\n\n[NOTE]\n====\nParameter values can be also controlled with `setAllowedParameterValues(Predicate)`.\n====\n\nFor example, to switch off this check, you can wire your `StrictServerWebExchangeFirewall` with `Predicate` instances that always return `true`:\n\n.Allow Any Header Name, Header Value, and Parameter Name\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic StrictServerWebExchangeFirewall httpFirewall() {\n StrictServerWebExchangeFirewall firewall = new StrictServerWebExchangeFirewall();\n firewall.setAllowedHeaderNames((header) -> true);\n firewall.setAllowedHeaderValues((header) -> true);\n firewall.setAllowedParameterNames((parameter) -> true);\n return firewall;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun httpFirewall(): StrictServerWebExchangeFirewall {\n val firewall = StrictServerWebExchangeFirewall()\n firewall.setAllowedHeaderNames { true }\n firewall.setAllowedHeaderValues { true }\n firewall.setAllowedParameterNames { true }\n return firewall\n}\n----\n======\n\nAlternatively, there might be a specific value that you need to allow.\n\nFor example, iPhone X uses a `User-Agent` that includes a character that is not in the ISO-8859-1 charset.\nDue to this fact, some application servers parse this value into two separate characters, the latter being an undefined character.\n\nYou can address this with the `setAllowedHeaderValues` method:\n\n.Allow Certain User Agents\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic StrictServerWebExchangeFirewall httpFirewall() {\n StrictServerWebExchangeFirewall firewall = new StrictServerWebExchangeFirewall();\n Pattern allowed = Pattern.compile(\"[\\\\p{IsAssigned}&&[^\\\\p{IsControl}]]*\");\n Pattern userAgent = ...;\n firewall.setAllowedHeaderValues((header) -> allowed.matcher(header).matches() || userAgent.matcher(header).matches());\n return firewall;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun httpFirewall(): StrictServerWebExchangeFirewall {\n val firewall = StrictServerWebExchangeFirewall()\n val allowed = Pattern.compile(\"[\\\\p{IsAssigned}&&[^\\\\p{IsControl}]]*\")\n val userAgent = Pattern.compile(...)\n firewall.setAllowedHeaderValues { allowed.matcher(it).matches() || userAgent.matcher(it).matches() }\n return firewall\n}\n----\n======\n\nIn the case of header values, you may instead consider parsing them as UTF-8 at verification time:\n\n.Parse Headers As UTF-8\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nfirewall.setAllowedHeaderValues((header) -> {\n String parsed = new String(header.getBytes(ISO_8859_1), UTF_8);\n return allowed.matcher(parsed).matches();\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nfirewall.setAllowedHeaderValues {\n val parsed = String(header.getBytes(ISO_8859_1), UTF_8)\n return allowed.matcher(parsed).matches()\n}\n----\n======\n\nThe `ServerExchangeRejectedHandler` interface is used to handle `ServerExchangeRejectedException` throw by Spring Security's `ServerWebExchangeFirewall`.\nBy default `HttpStatusExchangeRejectedHandler` is used to send an HTTP 400 response to clients when a request is rejected.\nTo customize the behavior, users can expose a `ServerExchangeRejectedHandler` Bean.\nFor example, the following will send an HTTP 404 when the request is rejected:\n\n.Send 404 on Request Rejected\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nServerExchangeRejectedHandler rejectedHandler() {\n\treturn new HttpStatusExchangeRejectedHandler(HttpStatus.NOT_FOUND);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun rejectedHandler(): ServerExchangeRejectedHandler {\n return HttpStatusExchangeRejectedHandler(HttpStatus.NOT_FOUND)\n}\n----\n======\n\nHandling can be completely customized by creating a custom `ServerExchangeRejectedHandler` implementation.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/firewall.adoc", "title": "firewall", "heading": "firewall", "heading_level": 1, "file_order": 33, "section_index": 0, "content_hash": "a310611df369e767fb4452bbd69542c745b12ff4944d3462fd4e999ac0fb642c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/firewall.adoc"}}
{"id": "sha256:700efeed1b0c80bcd48624e8a4cd628ac0e3d7822b0b78405216dd18200359ca", "content": "[[webflux-headers]]\n\nYou can use xref:features/exploits/headers.adoc#headers[Security HTTP Response Headers] to increase the security of web applications.\nThis section is dedicated to WebFlux-based support for Security HTTP Response Headers.\n\n[[webflux-headers-default]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "headers", "heading_level": 1, "file_order": 34, "section_index": 0, "content_hash": "700efeed1b0c80bcd48624e8a4cd628ac0e3d7822b0b78405216dd18200359ca", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:9ce27dc7fb2b44b108c211501f9ba6ff7433f3eb42ceec52a23f073c4e81e65c", "content": "Spring Security provides a xref:features/exploits/headers.adoc#headers-default[default set of Security HTTP Response Headers] to provide secure defaults.\nWhile each of these headers are considered best practice, it should be noted that not all clients use the headers, so additional testing is encouraged.\n\nYou can customize specific headers.\nFor example, assume that you want the defaults but you wish to specify `SAMEORIGIN` for xref:servlet/exploits/headers.adoc#servlet-headers-frame-options[`X-Frame-Options`].\n\nYou can do so with the following configuration:\n\n.Customize Default Security Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .frameOptions((frameOptions) -> frameOptions\n .mode(Mode.SAMEORIGIN)\n )\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n frameOptions {\n mode = Mode.SAMEORIGIN\n }\n }\n }\n}\n----\n======\n\nIf you do not want the defaults to be added and want explicit control over what should be used, you can disable the defaults:\n\n.Disable HTTP Security Response Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers.disable());\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n disable()\n }\n }\n}\n----\n======\n\n[[webflux-headers-cache-control]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "Default Security Headers", "heading_level": 2, "file_order": 34, "section_index": 1, "content_hash": "9ce27dc7fb2b44b108c211501f9ba6ff7433f3eb42ceec52a23f073c4e81e65c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:873ef6f4816822be8307fdb1201ae8512439f59819e757aa28e8bf2736ea7699", "content": "Spring Security includes xref:features/exploits/headers.adoc#headers-cache-control[Cache Control] headers by default.\n\nHowever, if you actually want to cache specific responses, your application can selectively add them to the https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/server/reactive/ServerHttpResponse.html[`ServerHttpResponse`] to override the header set by Spring Security.\nThis is useful to ensure that such things as CSS, JavaScript, and images are properly cached.\n\nWhen using Spring WebFlux, you typically do so within your configuration.\nYou can find details on how to do so in the https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-static-resources[Static Resources] portion of the Spring Reference documentation.\n\nIf necessary, you can also disable Spring Security's cache control HTTP response headers.\n\n.Cache Control Disabled\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .cache((cache) -> cache.disable())\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n cache {\n disable()\n }\n }\n }\n}\n----\n======\n\n[[webflux-headers-content-type-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "Cache Control", "heading_level": 2, "file_order": 34, "section_index": 2, "content_hash": "873ef6f4816822be8307fdb1201ae8512439f59819e757aa28e8bf2736ea7699", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:442102abce30efc10fd1920621d3485ec68065323f89d6d22a2ae87f9f1d6331", "content": "By default, Spring Security includes xref:features/exploits/headers.adoc#headers-content-type-options[Content-Type] headers.\nHowever, you can disable it:\n\n.Content Type Options Disabled\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .contentTypeOptions((contentTypeOptions) -> contentTypeOptions.disable())\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n contentTypeOptions {\n disable()\n }\n }\n }\n}\n----\n======\n\n[[webflux-headers-hsts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "Content Type Options", "heading_level": 2, "file_order": 34, "section_index": 3, "content_hash": "442102abce30efc10fd1920621d3485ec68065323f89d6d22a2ae87f9f1d6331", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:73c31dfbf9e45ba2976ae584b31f4dd1ca89a609956ad865441ddec05203ed7b", "content": "By default, Spring Security provides the xref:features/exploits/headers.adoc#headers-hsts[Strict Transport Security] header.\nHowever, you can customize the results explicitly.\nFor example, the following example explicitly provides HSTS:\n\n.Strict Transport Security\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .hsts((hsts) -> hsts\n .includeSubdomains(true)\n .preload(true)\n .maxAge(Duration.ofDays(365))\n )\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n hsts {\n includeSubdomains = true\n preload = true\n maxAge = Duration.ofDays(365)\n }\n }\n }\n}\n----\n======\n\n[[webflux-headers-frame-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "HTTP Strict Transport Security (HSTS)", "heading_level": 2, "file_order": 34, "section_index": 4, "content_hash": "73c31dfbf9e45ba2976ae584b31f4dd1ca89a609956ad865441ddec05203ed7b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:9f102313878ca61dd3c09a85cdcfa534f7df10533a5d50f446be9a767011f7ef", "content": "By default, Spring Security disables rendering within an iframe by using xref:features/exploits/headers.adoc#headers-frame-options[`X-Frame-Options`].\n\nYou can customize frame options to use the same origin:\n\n.X-Frame-Options: SAMEORIGIN\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .frameOptions((frameOptions) -> frameOptions\n .mode(SAMEORIGIN)\n )\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n frameOptions {\n mode = SAMEORIGIN\n }\n }\n }\n}\n----\n======\n\n[[webflux-headers-xss-protection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "X-Frame-Options", "heading_level": 2, "file_order": 34, "section_index": 5, "content_hash": "9f102313878ca61dd3c09a85cdcfa534f7df10533a5d50f446be9a767011f7ef", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:2e394940446ed2c2fdaa3709fb2f563b92f5afc16841809c453bd3887231123c", "content": "By default, Spring Security instructs browsers to disable the XSS Auditor by using <<headers-xss-protection,X-XSS-Protection header>.\nYou can disable the `X-XSS-Protection` header entirely:\n\n.X-XSS-Protection Customization\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .xssProtection((xssProtection) -> xssProtection.disable())\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n xssProtection {\n disable()\n }\n }\n }\n}\n----\n======\n\nYou can also change the header value:\n\n.X-XSS-Protection Explicit header value\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .xssProtection((xssProtection) -> xssProtection.headerValue(XXssProtectionServerHttpHeadersWriter.HeaderValue.ENABLED_MODE_BLOCK))\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n xssProtection {\n headerValue = XXssProtectionServerHttpHeadersWriter.HeaderValue.ENABLED_MODE_BLOCK\n }\n }\n }\n}\n----\n======\n\n[[webflux-headers-csp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "X-XSS-Protection", "heading_level": 2, "file_order": 34, "section_index": 6, "content_hash": "2e394940446ed2c2fdaa3709fb2f563b92f5afc16841809c453bd3887231123c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:e2e86f5c80fdf18b9c3df05b1bbb5d0563afdc0d8d9eae9d5342bdeac1dcad08", "content": "By default, Spring Security does not add xref:features/exploits/headers.adoc#headers-csp[Content Security Policy], because a reasonable default is impossible to know without the context of the application.\nThe web application author must declare the security policies to enforce and/or monitor for the protected resources.\n\nFor example, consider the following security policy:\n\n.Content Security Policy Example\n[source,http]\n----\nContent-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\n----\n\nGiven the preceding policy, you can enable the CSP header:\n\n.Content Security Policy\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .contentSecurityPolicy((policy) -> policy\n .policyDirectives(\"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\")\n )\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n contentSecurityPolicy {\n policyDirectives = \"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\"\n }\n }\n }\n}\n----\n======\n\nTo enable the CSP `report-only` header, provide the following configuration:\n\n.Content Security Policy Report Only\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .contentSecurityPolicy((policy) -> policy\n .policyDirectives(\"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\")\n .reportOnly()\n )\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n contentSecurityPolicy {\n policyDirectives = \"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\"\n reportOnly = true\n }\n }\n }\n}\n----\n======\n\n[[webflux-headers-referrer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "Content Security Policy (CSP)", "heading_level": 2, "file_order": 34, "section_index": 7, "content_hash": "e2e86f5c80fdf18b9c3df05b1bbb5d0563afdc0d8d9eae9d5342bdeac1dcad08", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:dc9025dcb7f32fd63453d406e97c6b185e1933c2e29d6fcdb2c9a18720923436", "content": "Spring Security adds the xref:features/exploits/headers.adoc#headers-referrer[Referrer Policy] header by default with the directive `no-referrer`.\nYou can change the Referrer Policy header using configuration as shown below:\n\n.Referrer Policy Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .referrerPolicy((referrer) -> referrer\n .policy(ReferrerPolicy.SAME_ORIGIN)\n )\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n referrerPolicy {\n policy = ReferrerPolicy.SAME_ORIGIN\n }\n }\n }\n}\n----\n======\n\n[[webflux-headers-feature]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "Referrer Policy", "heading_level": 2, "file_order": 34, "section_index": 8, "content_hash": "dc9025dcb7f32fd63453d406e97c6b185e1933c2e29d6fcdb2c9a18720923436", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:f247ba3c59091e78d61546a48abb61508ad2f7a95f14d9000fcb1e11acd95d56", "content": "By default, Spring Security does not add xref:features/exploits/headers.adoc#headers-feature[Feature Policy] headers.\nConsider the following `Feature-Policy` header:\n\n.Feature-Policy Example\n[source]\n----\nFeature-Policy: geolocation 'self'\n----\n\nYou can enable the preceding Feature Policy header:\n\n.Feature-Policy Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .featurePolicy(\"geolocation 'self'\")\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n featurePolicy(\"geolocation 'self'\")\n }\n }\n}\n----\n======\n\n[[webflux-headers-permissions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "Feature Policy", "heading_level": 2, "file_order": 34, "section_index": 9, "content_hash": "f247ba3c59091e78d61546a48abb61508ad2f7a95f14d9000fcb1e11acd95d56", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:e764b7b47647c0c11ab09e329ebab569689b49b1ecb384d5b2d7fe71cfc8bce4", "content": "By default, Spring Security does not add xref:features/exploits/headers.adoc#headers-permissions[Permissions Policy] headers.\nConsider the following `Permissions-Policy` header:\n\n.Permissions-Policy Example\n[source]\n----\nPermissions-Policy: geolocation=(self)\n----\n\nYou can enable the preceding Permissions Policy header:\n\n.Permissions-Policy Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .headers((headers) -> headers\n .permissionsPolicy((permissions) -> permissions\n .policy(\"geolocation=(self)\")\n )\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n headers {\n permissionsPolicy {\n policy = \"geolocation=(self)\"\n }\n }\n }\n}\n----\n======\n\n[[webflux-headers-clear-site-data]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "Permissions Policy", "heading_level": 2, "file_order": 34, "section_index": 10, "content_hash": "e764b7b47647c0c11ab09e329ebab569689b49b1ecb384d5b2d7fe71cfc8bce4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:4cc6e64ed9ae8717134d35aa0075b1c1492f64bcda849a0c221f6ef05ac55493", "content": "By default, Spring Security does not add xref:features/exploits/headers.adoc#headers-clear-site-data[Clear-Site-Data] headers.\nConsider the following `Clear-Site-Data` header:\n\n.Clear-Site-Data Example\n----\nClear-Site-Data: \"cache\", \"cookies\"\n----\n\nYou can send the `Clear-Site-Data` header on logout:\n\n.Clear-Site-Data Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\tServerLogoutHandler securityContext = new SecurityContextServerLogoutHandler();\n\tClearSiteDataServerHttpHeadersWriter writer = new ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES);\n\tServerLogoutHandler clearSiteData = new HeaderWriterServerLogoutHandler(writer);\n\tDelegatingServerLogoutHandler logoutHandler = new DelegatingServerLogoutHandler(securityContext, clearSiteData);\n\n\thttp\n // ...\n .logout()\n .logoutHandler(logoutHandler);\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n val securityContext: ServerLogoutHandler = SecurityContextServerLogoutHandler()\n val writer = ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES)\n val clearSiteData: ServerLogoutHandler = HeaderWriterServerLogoutHandler(writer)\n val customLogoutHandler = DelegatingServerLogoutHandler(securityContext, clearSiteData)\n\n return http {\n // ...\n logout {\n logoutHandler = customLogoutHandler\n }\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/headers.adoc", "title": "headers", "heading": "Clear Site Data", "heading_level": 2, "file_order": 34, "section_index": 11, "content_hash": "4cc6e64ed9ae8717134d35aa0075b1c1492f64bcda849a0c221f6ef05ac55493", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/headers.adoc"}}
{"id": "sha256:3285e656918e934d1fc4d0f3ddf615610d6b9787958960a59d8257fc40155509", "content": "[[webflux-http]]\n\nAll HTTP-based communication should be protected with xref:features/exploits/http.adoc#http[using TLS].\n\nThis section covers details about using WebFlux-specific features that assist with HTTPS usage.\n\n[[webflux-http-redirect]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/http.adoc", "title": "http", "heading": "http", "heading_level": 1, "file_order": 35, "section_index": 0, "content_hash": "3285e656918e934d1fc4d0f3ddf615610d6b9787958960a59d8257fc40155509", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/http.adoc"}}
{"id": "sha256:e780ab8833bc4bf446a318b3d0e8e730d5a43f210b1536c907e456165dfcb159", "content": "If a client makes a request using HTTP rather than HTTPS, you can configure Spring Security to redirect to HTTPS.\n\nThe following Java configuration redirects any HTTP requests to HTTPS:\n\n.Redirect to HTTPS\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .redirectToHttps(withDefaults());\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n redirectToHttps { }\n }\n}\n----\n======\n\nYou can wrap the configuration can be wrapped around an `if` statement to be turned on only in production.\nAlternatively, you can enable it by looking for a property about the request that happens only in production.\nFor example, if the production environment adds a header named `X-Forwarded-Proto`, you should use the following Java Configuration:\n\n.Redirect to HTTPS when X-Forwarded\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .redirectToHttps((redirect) -> redirect\n .httpsRedirectWhen((e) -> e.getRequest().getHeaders().containsKey(\"X-Forwarded-Proto\"))\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n redirectToHttps {\n httpsRedirectWhen {\n it.request.headers.containsKey(\"X-Forwarded-Proto\")\n }\n }\n }\n}\n----\n======\n\n[[webflux-hsts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/http.adoc", "title": "http", "heading": "Redirect to HTTPS", "heading_level": 2, "file_order": 35, "section_index": 1, "content_hash": "e780ab8833bc4bf446a318b3d0e8e730d5a43f210b1536c907e456165dfcb159", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/http.adoc"}}
{"id": "sha256:773cf9bbf5f42008c9d28598510e4dade32aadfa44833c4a4c0d97c2d382e4e4", "content": "Spring Security provides support for xref:servlet/exploits/headers.adoc#servlet-headers-hsts[Strict Transport Security] and enables it by default.\n\n[[webflux-http-proxy-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/http.adoc", "title": "http", "heading": "Strict Transport Security", "heading_level": 2, "file_order": 35, "section_index": 2, "content_hash": "773cf9bbf5f42008c9d28598510e4dade32aadfa44833c4a4c0d97c2d382e4e4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/http.adoc"}}
{"id": "sha256:ff54488a00fdba426c98194cb71ae70212e56c1467b3eccb3940af8b8884a539", "content": "Spring Security xref:features/exploits/http.adoc#http-proxy-server[integrates with proxy servers].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/http.adoc", "title": "http", "heading": "Proxy Server Configuration", "heading_level": 2, "file_order": 35, "section_index": 3, "content_hash": "ff54488a00fdba426c98194cb71ae70212e56c1467b3eccb3940af8b8884a539", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/http.adoc"}}
{"id": "sha256:18d33eef7cd9a4669fac9ac5e0f45e35eafdfb83b9e29d6808b7c21fbe7858c4", "content": "Spring Security provides protection against numerous exploits.\nThis section discusses WebFlux specific support for:\n\n* xref:reactive/exploits/csrf.adoc[CSRF]\n* xref:reactive/exploits/headers.adoc[Headers]\n* xref:reactive/exploits/http.adoc[HTTP Requests]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/exploits/index.adoc", "title": "Protection Against Exploits", "heading": "Protection Against Exploits", "heading_level": 1, "file_order": 36, "section_index": 0, "content_hash": "18d33eef7cd9a4669fac9ac5e0f45e35eafdfb83b9e29d6808b7c21fbe7858c4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/exploits/index.adoc"}}
{"id": "sha256:e76629d59451085414f1771c24877a2ab2f8e69d8c3598e8341b05d52f1e41ae", "content": "[[webflux-cors]]\n\nSpring Framework provides https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-cors-intro[first class support for CORS].\nCORS must be processed before Spring Security because the pre-flight request will not contain any cookies (i.e. the `JSESSIONID`).\nIf the request does not contain any cookies and Spring Security is first, the request will determine the user is not authenticated (since there are no cookies in the request) and reject it.\n\nThe easiest way to ensure that CORS is handled first is to use the `CorsWebFilter`.\nUsers can integrate the `CorsWebFilter` with Spring Security by providing a `CorsConfigurationSource`.\nFor example, the following will integrate CORS support within Spring Security:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nUrlBasedCorsConfigurationSource corsConfigurationSource() {\n\tCorsConfiguration configuration = new CorsConfiguration();\n\tconfiguration.setAllowedOrigins(Arrays.asList(\"https://example.com\"));\n\tconfiguration.setAllowedMethods(Arrays.asList(\"GET\",\"POST\"));\n\tUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n\tsource.registerCorsConfiguration(\"/**\", configuration);\n\treturn source;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun corsConfigurationSource(): UrlBasedCorsConfigurationSource {\n val configuration = CorsConfiguration()\n configuration.allowedOrigins = listOf(\"https://example.com\")\n configuration.allowedMethods = listOf(\"GET\", \"POST\")\n val source = UrlBasedCorsConfigurationSource()\n source.registerCorsConfiguration(\"/**\", configuration)\n return source\n}\n----\n======\n\nThe following will disable the CORS integration within Spring Security:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n // ...\n .cors((cors) -> cors.disable());\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n cors {\n disable()\n }\n }\n}\n----\n======\n\n[WARNING]\n====\nCORS is a browser-based security feature.\nBy disabling CORS in Spring Security, you are not removing CORS protection from your browser.\nInstead, you are removing CORS support from Spring Security, and users will not be able to interact with your Spring backend from a cross-origin browser application.\nTo fix CORS errors in your application, you must enable CORS support, and provide an appropriate configuration source.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/cors.adoc", "title": "cors", "heading": "cors", "heading_level": 1, "file_order": 37, "section_index": 0, "content_hash": "e76629d59451085414f1771c24877a2ab2f8e69d8c3598e8341b05d52f1e41ae", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/cors.adoc"}}
{"id": "sha256:a7193cca7336a657870d216201b7195a368cec151713b17c877cff6edf8f28c3", "content": "[[webflux-observability]]\n\nSpring Security integrates with Spring Observability out-of-the-box for tracing; though it's also quite simple to configure for gathering metrics.\n\n[[webflux-observability-tracing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/observability.adoc", "title": "observability", "heading": "observability", "heading_level": 1, "file_order": 38, "section_index": 0, "content_hash": "a7193cca7336a657870d216201b7195a368cec151713b17c877cff6edf8f28c3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/observability.adoc"}}
{"id": "sha256:05f6664dad6377d750f61c3a94a08551ee2b2fa013bdd0bb7f8fcbbd57d5abd5", "content": "When an `ObservationRegistry` bean is present, Spring Security creates traces for:\n\n* the filter chain\n* the `ReactiveAuthenticationManager`, and\n* the `ReactiveAuthorizationManager`\n\n[[webflux-observability-tracing-boot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/observability.adoc", "title": "observability", "heading": "Tracing", "heading_level": 2, "file_order": 38, "section_index": 1, "content_hash": "05f6664dad6377d750f61c3a94a08551ee2b2fa013bdd0bb7f8fcbbd57d5abd5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/observability.adoc"}}
{"id": "sha256:fd15ced88b684d74f5198a24dbfd2836654de173ba1bd5171061e889dd2388c4", "content": "For example, consider a simple Boot application:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@SpringBootApplication\npublic class MyApplication {\n\t@Bean\n\tpublic ReactiveUserDetailsService userDetailsService() {\n return new MapReactiveUserDetailsManager(\n User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .authorities(\"app\")\n .build()\n );\n\t}\n\n\t@Bean\n\tObservationRegistryCustomizer<ObservationRegistry> addTextHandler() {\n return (registry) -> registry.observationConfig().observationHandler(new ObservationTextPublisher());\n\t}\n\n\tpublic static void main(String[] args) {\n SpringApplication.run(ListenerSamplesApplication.class, args);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@SpringBootApplication\nclass MyApplication {\n\t@Bean\n\tfun userDetailsService(): ReactiveUserDetailsService {\n MapReactiveUserDetailsManager(\n User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .authorities(\"app\")\n .build()\n );\n\t}\n\n\t@Bean\n\tfun addTextHandler(): ObservationRegistryCustomizer<ObservationRegistry> {\n return registry: ObservationRegistry -> registry.observationConfig()\n .observationHandler(ObservationTextPublisher());\n\t}\n\n\tfun main(args: Array<String>) {\n runApplication<MyApplication>(*args)\n\t}\n}\n----\n======\n\nAnd a corresponding request:\n\n[source,bash]\n----\n?> http -a user:password :8080\n----\n\nWill produce the following output (indentation added for clarity):\n\n[source,bash]\n----\nSTART - name='http.server.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@5dfdb78', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.00191856, duration(nanos)=1918560.0, startTimeNanos=101177265022745}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@121549e0']\n\tSTART - name='spring.security.http.chains', contextualName='spring.security.http.chains.before', error='null', lowCardinalityKeyValues=[chain.size='14', filter.section='before'], highCardinalityKeyValues=[request.line='/'], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@3932a48c', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=4.65777E-4, duration(nanos)=465777.0, startTimeNanos=101177276300777}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@562db70f']\n\tSTOP - name='spring.security.http.chains', contextualName='spring.security.http.chains.before', error='null', lowCardinalityKeyValues=[chain.size='14', filter.section='before'], highCardinalityKeyValues=[request.line='/'], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@3932a48c', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.003733105, duration(nanos)=3733105.0, startTimeNanos=101177276300777}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@562db70f']\n START - name='spring.security.authentications', contextualName='null', error='null', lowCardinalityKeyValues=[authentication.failure.type='Optional', authentication.method='UserDetailsRepositoryReactiveAuthenticationManager', authentication.request.type='UsernamePasswordAuthenticationToken'], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@574ba6cd', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=3.21015E-4, duration(nanos)=321015.0, startTimeNanos=101177336038417}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@49202cc7']\n STOP - name='spring.security.authentications', contextualName='null', error='null', lowCardinalityKeyValues=[authentication.failure.type='Optional', authentication.method='UserDetailsRepositoryReactiveAuthenticationManager', authentication.request.type='UsernamePasswordAuthenticationToken', authentication.result.type='UsernamePasswordAuthenticationToken'], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@574ba6cd', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.37574992, duration(nanos)=3.7574992E8, startTimeNanos=101177336038417}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@49202cc7']\n START - name='spring.security.authorizations', contextualName='null', error='null', lowCardinalityKeyValues=[object.type='SecurityContextServerWebExchange'], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@6f837332', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=2.65687E-4, duration(nanos)=265687.0, startTimeNanos=101177777941381}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@7f5bc7cb']\n STOP - name='spring.security.authorizations', contextualName='null', error='null', lowCardinalityKeyValues=[authorization.decision='true', object.type='SecurityContextServerWebExchange'], highCardinalityKeyValues=[authentication.authorities='[app]', authorization.decision.details='AuthorizationDecision [granted=true]'], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@6f837332', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.039239047, duration(nanos)=3.9239047E7, startTimeNanos=101177777941381}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@7f5bc7cb']\n START - name='spring.security.http.secured.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@2f33dfae', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=3.1775E-4, duration(nanos)=317750.0, startTimeNanos=101177821377592}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@63b0d28f']\n STOP - name='spring.security.http.secured.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@2f33dfae', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.219901971, duration(nanos)=2.19901971E8, startTimeNanos=101177821377592}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@63b0d28f']\n\tSTART - name='spring.security.http.chains', contextualName='spring.security.http.chains.after', error='null', lowCardinalityKeyValues=[chain.size='14', filter.section='after'], highCardinalityKeyValues=[request.line='/'], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@40b25623', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=3.25118E-4, duration(nanos)=325118.0, startTimeNanos=101178044824275}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@3b6cec2']\n\tSTOP - name='spring.security.http.chains', contextualName='spring.security.http.chains.after', error='null', lowCardinalityKeyValues=[chain.size='14', filter.section='after'], highCardinalityKeyValues=[request.line='/'], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@40b25623', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.001693146, duration(nanos)=1693146.0, startTimeNanos=101178044824275}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@3b6cec2']\nSTOP - name='http.server.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.tracing.handler.TracingObservationHandler$TracingContext='io.micrometer.tracing.handler.TracingObservationHandler$TracingContext@5dfdb78', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.784320641, duration(nanos)=7.84320641E8, startTimeNanos=101177265022745}', class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@121549e0']\n----\n\n[[webflux-observability-tracing-manual-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/observability.adoc", "title": "observability", "heading": "Boot Integration", "heading_level": 3, "file_order": 38, "section_index": 2, "content_hash": "fd15ced88b684d74f5198a24dbfd2836654de173ba1bd5171061e889dd2388c4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/observability.adoc"}}
{"id": "sha256:c6f9249b70fa5e561ba4abd568bc2af84661aa9ed5361189d0c0e2bc3bfdb08d", "content": "For a non-Spring Boot application, or to override the existing Boot configuration, you can publish your own `ObservationRegistry` and Spring Security will still pick it up.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@SpringBootApplication\npublic class MyApplication {\n\t@Bean\n\tpublic ReactiveUserDetailsService userDetailsService() {\n return new MapReactiveUserDetailsManager(\n User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .authorities(\"app\")\n .build()\n );\n\t}\n\n\t@Bean\n\tObservationRegistry observationRegistry() {\n ObservationRegistry registry = ObservationRegistry.create();\n registry.observationConfig().observationHandler(new ObservationTextPublisher());\n return registry;\n\t}\n\n\tpublic static void main(String[] args) {\n SpringApplication.run(ListenerSamplesApplication.class, args);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@SpringBootApplication\nclass MyApplication {\n\t@Bean\n\tfun userDetailsService(): ReactiveUserDetailsService {\n MapReactiveUserDetailsManager(\n User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .authorities(\"app\")\n .build()\n );\n\t}\n\n\t@Bean\n\tfun observationRegistry(): ObservationRegistry {\n ObservationRegistry registry = ObservationRegistry.create()\n registry.observationConfig().observationHandler(ObservationTextPublisher())\n return registry\n\t}\n\n\tfun main(args: Array<String>) {\n runApplication<MyApplication>(*args)\n\t}\n}\n----\n\nXml::\n+\n[source,kotlin,role=\"secondary\"]\n----\n<sec:http auto-config=\"true\" observation-registry-ref=\"ref\">\n\t<sec:intercept-url pattern=\"/**\" access=\"authenticated\"/>\n</sec:http>\n\n<!-- define and configure ObservationRegistry bean -->\n----\n======\n\n[[webflux-observability-tracing-disable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/observability.adoc", "title": "observability", "heading": "Manual Configuration", "heading_level": 3, "file_order": 38, "section_index": 3, "content_hash": "c6f9249b70fa5e561ba4abd568bc2af84661aa9ed5361189d0c0e2bc3bfdb08d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/observability.adoc"}}
{"id": "sha256:9c10f231f6b21b5fa27009732bb5c3694cfb7e3a21d6cc057fdb7e9925cde93b", "content": "If you don't want any Spring Security observations, in a Spring Boot application you can publish a `ObservationRegistry.NOOP` `@Bean`.\nHowever, this may turn off observations for more than just Spring Security.\n\nInstead, you can publish a `SecurityObservationSettings` like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityObservationSettings noSpringSecurityObservations() {\n\treturn SecurityObservationSettings.noObservations();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun noSpringSecurityObservations(): SecurityObservationSettings {\n\treturn SecurityObservationSettings.noObservations()\n}\n----\n======\n\nand then Spring Security will not wrap any filter chains, authentications, or authorizations in their `ObservationXXX` counterparts.\n\n[TIP]\nThere is no facility for disabling observations with XML support.\nInstead, simply do not set the `observation-registry-ref` attribute.\n\nYou can also disable security for only a subset of Security's observations.\nFor example, the `SecurityObservationSettings` bean excludes the filter chain observations by default.\nSo, you can also do:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityObservationSettings defaultSpringSecurityObservations() {\n\treturn SecurityObservationSettings.withDefaults().build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun defaultSpringSecurityObservations(): SecurityObservationSettings {\n\treturn SecurityObservationSettings.withDefaults().build()\n}\n----\n======\n\nOr you can turn on and off observations individually, based on the defaults:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityObservationSettings allSpringSecurityObservations() {\n\treturn SecurityObservationSettings.withDefaults()\n .shouldObserveFilterChains(true).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun allSpringSecurityObservations(): SecurityObservationSettings {\n return SecurityObservabilityDefaults.builder()\n .shouldObserveFilterChains(true).build()\n}\n----\n======\n\n[NOTE]\n=====\nFor backward compatibility, all Spring Security observations are made unless a `SecurityObservationSettings` is published.\n=====\n\n[[webflux-observability-tracing-listing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/observability.adoc", "title": "observability", "heading": "Disabling Observability", "heading_level": 3, "file_order": 38, "section_index": 4, "content_hash": "9c10f231f6b21b5fa27009732bb5c3694cfb7e3a21d6cc057fdb7e9925cde93b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/observability.adoc"}}
{"id": "sha256:9497d240131f51b6b2cd253af304269e9a3a1814d4252f0f77648332c9110d7f", "content": "Spring Security tracks the following spans on each request:\n\n1. `spring.security.http.requests` - a span that wraps the entire filter chain, including the request\n2. `spring.security.http.chains.before` - a span that wraps the receiving part of the security filters\n3. `spring.security.http.chains.after` - a span that wraps the returning part of the security filters\n4. `spring.security.http.secured.requests` - a span that wraps the now-secured application request\n5. `spring.security.http.unsecured.requests` - a span that wraps requests that Spring Security does not secure\n6. `spring.security.authentications` - a span that wraps authentication attempts\n7. `spring.security.authorizations` - a span that wraps authorization attempts\n\n[TIP]\n`spring.security.http.chains.before` + `spring.security.http.secured.requests` + `spring.security.http.chains.after` = `spring.security.http.requests` +\n`spring.security.http.chains.before` + `spring.security.http.chains.after` = Spring Security's part of the request", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/observability.adoc", "title": "observability", "heading": "Trace Listing", "heading_level": 3, "file_order": 38, "section_index": 5, "content_hash": "9497d240131f51b6b2cd253af304269e9a3a1814d4252f0f77648332c9110d7f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/observability.adoc"}}
{"id": "sha256:bbe5a925d55925e62143b4684a700fa0c413e42b46716822c06941ab66cb634c", "content": "[[rsocket]]\n\nSpring Security's RSocket support relies on a `SocketAcceptorInterceptor`.\nThe main entry point into security is in `PayloadSocketAcceptorInterceptor`, which adapts the RSocket APIs to allow intercepting a `PayloadExchange` with `PayloadInterceptor` implementations.\n\nThe following example shows a minimal RSocket Security configuration:\n\n* Hello RSocket {gh-samples-url}/reactive/rsocket/hello-security[hellorsocket]\n* https://github.com/rwinch/spring-flights/tree/security[Spring Flights]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc", "title": "rsocket", "heading": "rsocket", "heading_level": 1, "file_order": 39, "section_index": 0, "content_hash": "bbe5a925d55925e62143b4684a700fa0c413e42b46716822c06941ab66cb634c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc"}}
{"id": "sha256:c48046f719da4e5cac9214e406f6f5edaeab5872521e40958838f4178b00f2d8", "content": "You can find a minimal RSocket Security configuration below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableRSocketSecurity\npublic class HelloRSocketSecurityConfig {\n\n\t@Bean\n\tpublic MapReactiveUserDetailsService userDetailsService() {\n UserDetails user = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"user\")\n .roles(\"USER\")\n .build();\n return new MapReactiveUserDetailsService(user);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableRSocketSecurity\nopen class HelloRSocketSecurityConfig {\n @Bean\n open fun userDetailsService(): MapReactiveUserDetailsService {\n val user = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"user\")\n .roles(\"USER\")\n .build()\n return MapReactiveUserDetailsService(user)\n }\n}\n----\n======\n\nThis configuration enables <<rsocket-authentication-simple,simple authentication>> and sets up <<rsocket-authorization,rsocket-authorization>> to require an authenticated user for any request.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc", "title": "rsocket", "heading": "Minimal RSocket Security Configuration", "heading_level": 2, "file_order": 39, "section_index": 1, "content_hash": "c48046f719da4e5cac9214e406f6f5edaeab5872521e40958838f4178b00f2d8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc"}}
{"id": "sha256:ad2f0984de4585b7dd4f27740fc4385b4250e001bed32677bbd27e06be7ea52f", "content": "For Spring Security to work, we need to apply `SecuritySocketAcceptorInterceptor` to the `ServerRSocketFactory`.\nDoing so connects our `PayloadSocketAcceptorInterceptor` with the RSocket infrastructure.\n\nSpring Boot registers it automatically in `RSocketSecurityAutoConfiguration` when you include {gh-samples-url}/reactive/rsocket/hello-security/build.gradle[the correct dependencies].\n\nOr, if you are not using Boot's auto-configuration, you can register it manually in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nRSocketServerCustomizer springSecurityRSocketSecurity(SecuritySocketAcceptorInterceptor interceptor) {\n return (server) -> server.interceptors((registry) -> registry.forSocketAcceptor(interceptor));\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityRSocketSecurity(interceptor: SecuritySocketAcceptorInterceptor): RSocketServerCustomizer {\n return RSocketServerCustomizer { server ->\n server.interceptors { registry ->\n registry.forSocketAcceptor(interceptor)\n }\n }\n}\n----\n======\n\nTo customize the interceptor itself, use `RSocketSecurity` to add <<rsocket-authentication,authentication>> and <<rsocket-authorization,authorization>>.\n\n[[rsocket-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc", "title": "rsocket", "heading": "Adding SecuritySocketAcceptorInterceptor", "heading_level": 2, "file_order": 39, "section_index": 2, "content_hash": "ad2f0984de4585b7dd4f27740fc4385b4250e001bed32677bbd27e06be7ea52f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc"}}
{"id": "sha256:4c21c4d9ed3d14597c83b25087dfd6cb073c1ecf5be6e99198a9fad03dcb0b93", "content": "RSocket authentication is performed with `AuthenticationPayloadInterceptor`, which acts as a controller to invoke a `ReactiveAuthenticationManager` instance.\n\n[[rsocket-authentication-setup-vs-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc", "title": "rsocket", "heading": "RSocket Authentication", "heading_level": 2, "file_order": 39, "section_index": 3, "content_hash": "4c21c4d9ed3d14597c83b25087dfd6cb073c1ecf5be6e99198a9fad03dcb0b93", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc"}}
{"id": "sha256:5dea93785b0c2f0c49d0853d187f05814003fbe4b57a4108a620ceae9002ea36", "content": "Generally, authentication can occur at setup time or at request time or both.\n\nAuthentication at setup time makes sense in a few scenarios.\nA common scenarios is when a single user (such as a mobile connection) uses an RSocket connection.\nIn this case, only a single user uses the connection, so authentication can be done once at connection time.\n\nIn a scenario where the RSocket connection is shared, it makes sense to send credentials on each request.\nFor example, a web application that connects to an RSocket server as a downstream service would make a single connection that all users use.\nIn this case, if the RSocket server needs to perform authorization based on the web application's users credentials, authentication for each request makes sense.\n\nIn some scenarios, authentication at both setup and for each request makes sense.\nConsider a web application, as described previously.\nIf we need to restrict the connection to the web application itself, we can provide a credential with a `SETUP` authority at connection time.\nThen each user can have different authorities but not the `SETUP` authority.\nThis means that individual users can make requests but not make additional connections.\n\n[[rsocket-authentication-simple]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc", "title": "rsocket", "heading": "Authentication at Setup versus Request Time", "heading_level": 3, "file_order": 39, "section_index": 4, "content_hash": "5dea93785b0c2f0c49d0853d187f05814003fbe4b57a4108a620ceae9002ea36", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc"}}
{"id": "sha256:f88c6d67c5e440b6609c6f5e8beb755282defe33b9b7daa6dd5db69f8d449119", "content": "Spring Security has support for the https://github.com/rsocket/rsocket/blob/5920ed374d008abb712cb1fd7c9d91778b2f4a68/Extensions/Security/Simple.md[Simple Authentication Metadata Extension].\n\n[NOTE]\n====\nBasic Authentication evolved into Simple Authentication and is only supported for backward compatibility.\nSee `RSocketSecurity.basicAuthentication(Customizer)` for setting it up.\n====\n\nThe RSocket receiver can decode the credentials by using `AuthenticationPayloadExchangeConverter`, which is automatically setup by using the `simpleAuthentication` portion of the DSL.\nThe following example shows an explicit configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nPayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) {\n\trsocket\n .authorizePayload(authorize ->\n authorize\n .anyRequest().authenticated()\n .anyExchange().permitAll()\n )\n .simpleAuthentication(Customizer.withDefaults());\n\treturn rsocket.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun rsocketInterceptor(rsocket: RSocketSecurity): PayloadSocketAcceptorInterceptor {\n rsocket\n .authorizePayload { authorize -> authorize\n .anyRequest().authenticated()\n .anyExchange().permitAll()\n }\n .simpleAuthentication(withDefaults())\n return rsocket.build()\n}\n----\n======\n\nThe RSocket sender can send credentials by using `SimpleAuthenticationEncoder`, which you can add to Spring's `RSocketStrategies`.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nRSocketStrategies.Builder strategies = ...;\nstrategies.encoder(new SimpleAuthenticationEncoder());\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nvar strategies: RSocketStrategies.Builder = ...\nstrategies.encoder(SimpleAuthenticationEncoder())\n----\n======\n\nYou can then use it to send a username and password to the receiver in the setup:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nMimeType authenticationMimeType =\n\tMimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());\nUsernamePasswordMetadata credentials = new UsernamePasswordMetadata(\"user\", \"password\");\nMono<RSocketRequester> requester = RSocketRequester.builder()\n\t.setupMetadata(credentials, authenticationMimeType)\n\t.rsocketStrategies(strategies.build())\n\t.connectTcp(host, port);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval authenticationMimeType: MimeType =\n MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.string)\nval credentials = UsernamePasswordMetadata(\"user\", \"password\")\nval requester: Mono<RSocketRequester> = RSocketRequester.builder()\n .setupMetadata(credentials, authenticationMimeType)\n .rsocketStrategies(strategies.build())\n .connectTcp(host, port)\n----\n======\n\nAlternatively or additionally, a username and password can be sent in a request.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nMono<RSocketRequester> requester;\nUsernamePasswordMetadata credentials = new UsernamePasswordMetadata(\"user\", \"password\");\n\npublic Mono<AirportLocation> findRadar(String code) {\n\treturn this.requester.flatMap(req ->\n req.route(\"find.radar.{code}\", code)\n .metadata(credentials, authenticationMimeType)\n .retrieveMono(AirportLocation.class)\n\t);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.messaging.rsocket.retrieveMono\n\nvar requester: Mono<RSocketRequester>? = null\nvar credentials = UsernamePasswordMetadata(\"user\", \"password\")\n\nopen fun findRadar(code: String): Mono<AirportLocation> {\n return requester!!.flatMap { req ->\n req.route(\"find.radar.{code}\", code)\n .metadata(credentials, authenticationMimeType)\n .retrieveMono<AirportLocation>()\n }\n}\n----\n======\n\n[[rsocket-authentication-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc", "title": "rsocket", "heading": "Simple Authentication", "heading_level": 3, "file_order": 39, "section_index": 5, "content_hash": "f88c6d67c5e440b6609c6f5e8beb755282defe33b9b7daa6dd5db69f8d449119", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc"}}
{"id": "sha256:b88648b47fb02275c960f2605c9553cad44cb3f620da816d0ef3c4db310121f0", "content": "Spring Security has support for the https://github.com/rsocket/rsocket/blob/5920ed374d008abb712cb1fd7c9d91778b2f4a68/Extensions/Security/Bearer.md[Bearer Token Authentication Metadata Extension].\nThe support comes in the form of authenticating a JWT (determining that the JWT is valid) and then using the JWT to make authorization decisions.\n\nThe RSocket receiver can decode the credentials by using `BearerPayloadExchangeConverter`, which is automatically setup by using the `jwt` portion of the DSL.\nThe following listing shows an example configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nPayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) {\n\trsocket\n .authorizePayload(authorize ->\n authorize\n .anyRequest().authenticated()\n .anyExchange().permitAll()\n )\n .jwt(Customizer.withDefaults());\n\treturn rsocket.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun rsocketInterceptor(rsocket: RSocketSecurity): PayloadSocketAcceptorInterceptor {\n rsocket\n .authorizePayload { authorize -> authorize\n .anyRequest().authenticated()\n .anyExchange().permitAll()\n }\n .jwt(withDefaults())\n return rsocket.build()\n}\n----\n======\n\nThe configuration above relies on the existence of a `ReactiveJwtDecoder` `@Bean` being present.\nAn example of creating one from the issuer can be found below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nReactiveJwtDecoder jwtDecoder() {\n\treturn ReactiveJwtDecoders\n .fromIssuerLocation(\"https://example.com/auth/realms/demo\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n return ReactiveJwtDecoders\n .fromIssuerLocation(\"https://example.com/auth/realms/demo\")\n}\n----\n======\n\nThe RSocket sender does not need to do anything special to send the token, because the value is a simple `String`.\nThe following example sends the token at setup time:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nMimeType authenticationMimeType =\n\tMimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());\nBearerTokenMetadata token = ...;\nMono<RSocketRequester> requester = RSocketRequester.builder()\n\t.setupMetadata(token, authenticationMimeType)\n\t.connectTcp(host, port);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval authenticationMimeType: MimeType =\n MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.string)\nval token: BearerTokenMetadata = ...\n\nval requester = RSocketRequester.builder()\n .setupMetadata(token, authenticationMimeType)\n .connectTcp(host, port)\n----\n======\n\nAlternatively or additionally, you can send the token in a request:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nMimeType authenticationMimeType =\n\tMimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());\nMono<RSocketRequester> requester;\nBearerTokenMetadata token = ...;\n\npublic Mono<AirportLocation> findRadar(String code) {\n\treturn this.requester.flatMap(req ->\n req.route(\"find.radar.{code}\", code)\n .metadata(token, authenticationMimeType)\n .retrieveMono(AirportLocation.class)\n\t);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval authenticationMimeType: MimeType =\n MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.string)\nvar requester: Mono<RSocketRequester>? = null\nval token: BearerTokenMetadata = ...\n\nopen fun findRadar(code: String): Mono<AirportLocation> {\n return this.requester!!.flatMap { req ->\n req.route(\"find.radar.{code}\", code)\n .metadata(token, authenticationMimeType)\n .retrieveMono<AirportLocation>()\n }\n}\n----\n======\n\n[[rsocket-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc", "title": "rsocket", "heading": "JWT", "heading_level": 3, "file_order": 39, "section_index": 6, "content_hash": "b88648b47fb02275c960f2605c9553cad44cb3f620da816d0ef3c4db310121f0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc"}}
{"id": "sha256:55c3b6b74c58f177c43b5e49cd4de958dfc1860d96676de78bb81fdbbfb73624", "content": "RSocket authorization is performed with `AuthorizationPayloadInterceptor`, which acts as a controller to invoke a `ReactiveAuthorizationManager` instance.\nYou can use the DSL to set up authorization rules based upon the `PayloadExchange`.\nThe following listing shows an example configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nrsocket\n\t.authorizePayload(authz ->\n authz\n .setup().hasRole(\"SETUP\") // <1>\n .route(\"fetch.profile.me\").authenticated() // <2>\n .matcher((payloadExchange) -> payloadExchange(payloadExchange)) // <3>\n .hasRole(\"CUSTOM\")\n .route(\"fetch.profile.{username}\") // <4>\n .access((authentication, context) -> checkFriends(authentication, context))\n .anyRequest().authenticated() // <5>\n .anyExchange().permitAll() // <6>\n\t);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nrsocket\n .authorizePayload { authz ->\n authz\n .setup().hasRole(\"SETUP\") // <1>\n .route(\"fetch.profile.me\").authenticated() // <2>\n .matcher { payloadExchange -> isMatch(payloadExchange) } // <3>\n .hasRole(\"CUSTOM\")\n .route(\"fetch.profile.{username}\") // <4>\n .access { authentication, context -> checkFriends(authentication, context) }\n .anyRequest().authenticated() // <5>\n .anyExchange().permitAll()\n } // <6>\n----\n======\n<1> Setting up a connection requires the `ROLE_SETUP` authority.\n<2> If the route is `fetch.profile.me`, authorization only requires the user to be authenticated.\n<3> In this rule, we set up a custom matcher, where authorization requires the user to have the `ROLE_CUSTOM` authority.\n<4> This rule uses custom authorization.\nThe matcher expresses a variable with a name of `username` that is made available in the `context`.\nA custom authorization rule is exposed in the `checkFriends` method.\n<5> This rule ensures that a request that does not already have a rule requires the user to be authenticated.\nA request is where the metadata is included.\nIt would not include additional payloads.\n<6> This rule ensures that any exchange that does not already have a rule is allowed for anyone.\nIn this example, it means that payloads that have no metadata also have no authorization rules.\n\nNote that authorization rules are performed in order.\nOnly the first authorization rule that matches is invoked.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc", "title": "rsocket", "heading": "RSocket Authorization", "heading_level": 2, "file_order": 39, "section_index": 7, "content_hash": "55c3b6b74c58f177c43b5e49cd4de958dfc1860d96676de78bb81fdbbfb73624", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/integrations/rsocket.adoc"}}
{"id": "sha256:87b327a3d16abae77fa6f4b24159e8cd65fa93b06191fa13615f1f9443caac22", "content": "[[oauth2-client-authorization-grants]]\n\nThis section describes Spring Security's support for authorization grants.\n\n[[oauth2-client-authorization-code]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "authorization-grants", "heading_level": 1, "file_order": 40, "section_index": 0, "content_hash": "87b327a3d16abae77fa6f4b24159e8cd65fa93b06191fa13615f1f9443caac22", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:b8fa5eccb7ab9d04c497fa32af4dab44004fd4fd0d6b0058eb33774f51a48847", "content": "[NOTE]\n====\nPlease refer to the OAuth 2.0 Authorization Framework for further details on the https://tools.ietf.org/html/rfc6749#section-1.3.1[Authorization Code] grant.\n====\n\n[[oauth2-client-authorization-code-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "[[oauth2Client-auth-code-grant]]Authorization Code", "heading_level": 2, "file_order": 40, "section_index": 1, "content_hash": "b8fa5eccb7ab9d04c497fa32af4dab44004fd4fd0d6b0058eb33774f51a48847", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:b86d6cadee98f194f54e0e4ed05d1f24284577463aacb7d5e637b3f8b9f5b8d2", "content": "[NOTE]\n====\nPlease refer to the https://tools.ietf.org/html/rfc6749#section-4.1.1[Authorization Request/Response] protocol flow for the Authorization Code grant.\n====\n\n[[oauth2-client-authorization-code-authorization-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Obtaining Authorization", "heading_level": 3, "file_order": 40, "section_index": 2, "content_hash": "b86d6cadee98f194f54e0e4ed05d1f24284577463aacb7d5e637b3f8b9f5b8d2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:27748916cc28f6ce2e0dbc05e1b6c3689818a1f696f8902f27d73f8ef3a1d7b8", "content": "The `OAuth2AuthorizationRequestRedirectWebFilter` uses a `ServerOAuth2AuthorizationRequestResolver` to resolve an `OAuth2AuthorizationRequest` and initiate the Authorization Code grant flow by redirecting the end-user's user-agent to the Authorization Server's Authorization Endpoint.\n\nThe primary role of the `ServerOAuth2AuthorizationRequestResolver` is to resolve an `OAuth2AuthorizationRequest` from the provided web request.\nThe default implementation `DefaultServerOAuth2AuthorizationRequestResolver` matches on the (default) path `+/oauth2/authorization/{registrationId}+` extracting the `registrationId` and using it to build the `OAuth2AuthorizationRequest` for the associated `ClientRegistration`.\n\nGiven the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml,attrs=\"-attributes\"]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n authorization-grant-type: authorization_code\n redirect-uri: \"{baseUrl}/authorized/okta\"\n scope: read, write\n provider:\n okta:\n authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize\n token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token\n----\n\nA request with the base path `/oauth2/authorization/okta` will initiate the Authorization Request redirect by the `OAuth2AuthorizationRequestRedirectWebFilter` and ultimately start the Authorization Code grant flow.\n\n[NOTE]\n====\nThe `AuthorizationCodeReactiveOAuth2AuthorizedClientProvider` is an implementation of `ReactiveOAuth2AuthorizedClientProvider` for the Authorization Code grant,\nwhich also initiates the Authorization Request redirect by the `OAuth2AuthorizationRequestRedirectWebFilter`.\n====\n\nIf the OAuth 2.0 Client is a https://tools.ietf.org/html/rfc6749#section-2.1[Public Client], then configure the OAuth 2.0 Client registration as follows:\n\n[source,yaml,attrs=\"-attributes\"]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-authentication-method: none\n authorization-grant-type: authorization_code\n redirect-uri: \"{baseUrl}/authorized/okta\"\n # ...\n----\n\nPublic Clients are supported using https://tools.ietf.org/html/rfc7636[Proof Key for Code Exchange] (PKCE).\nIf the client is running in an untrusted environment (e.g. native application or web browser-based application) and therefore incapable of maintaining the confidentiality of its credentials, PKCE will automatically be used when the following conditions are true:\n\n. `client-secret` is omitted (or empty)\n. `client-authentication-method` is set to `none` (`ClientAuthenticationMethod.NONE`)\n\nor\n\n. When `ClientRegistration.clientSettings.requireProofKey` is `true` (in this case `ClientRegistration.authorizationGrantType` must be `authorization_code`)\n\n[TIP]\n====\nIf the OAuth 2.0 Provider doesn't support PKCE for https://tools.ietf.org/html/rfc6749#section-2.1[Confidential Clients], you need to disable it by setting `ClientRegistration.clientSettings.requireProofKey` to `false`.\n====\n\n[[oauth2-client-authorization-code-redirect-uri]]\n[[oauth2Client-auth-code-redirect-uri]]The `DefaultServerOAuth2AuthorizationRequestResolver` also supports `URI` template variables for the `redirect-uri` using `UriComponentsBuilder`.\n\nThe following configuration uses all the supported `URI` template variables:\n\n[source,yaml,attrs=\"-attributes\"]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n # ...\n redirect-uri: \"{baseScheme}://{baseHost}{basePort}{basePath}/authorized/{registrationId}\"\n # ...\n----\n\n[NOTE]\n====\n`+{baseUrl}+` resolves to `+{baseScheme}://{baseHost}{basePort}{basePath}+`\n====\n\nConfiguring the `redirect-uri` with `URI` template variables is especially useful when the OAuth 2.0 Client is running behind a xref:features/exploits/http.adoc#http-proxy-server[Proxy Server].\nThis ensures that the `X-Forwarded-*` headers are used when expanding the `redirect-uri`.\n\n[[oauth2-client-authorization-code-authorization-request-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Initiating the Authorization Request", "heading_level": 3, "file_order": 40, "section_index": 3, "content_hash": "27748916cc28f6ce2e0dbc05e1b6c3689818a1f696f8902f27d73f8ef3a1d7b8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:0ab5d6fcd8239fd7188ed91c2a1a25e257f88d9503a2d3294dcdef595ded75d3", "content": "One of the primary use cases a `ServerOAuth2AuthorizationRequestResolver` can realize is the ability to customize the Authorization Request with additional parameters above the standard parameters defined in the OAuth 2.0 Authorization Framework.\n\nFor example, OpenID Connect defines additional OAuth 2.0 request parameters for the https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest[Authorization Code Flow] extending from the standard parameters defined in the https://tools.ietf.org/html/rfc6749#section-4.1.1[OAuth 2.0 Authorization Framework].\nOne of those extended parameters is the `prompt` parameter.\n\n[NOTE]\n====\nThe `prompt` parameter is optional. Space delimited, case sensitive list of ASCII string values that specifies whether the Authorization Server prompts the End-User for re-authentication and consent. The defined values are: `none`, `login`, `consent`, and `select_account`.\n====\n\nThe following example shows how to configure the `DefaultServerOAuth2AuthorizationRequestResolver` with a `Consumer<OAuth2AuthorizationRequest.Builder>` that customizes the Authorization Request for `oauth2Login()`, by including the request parameter `prompt=consent`.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Autowired\n\tprivate ReactiveClientRegistrationRepository clientRegistrationRepository;\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2Login((oauth2) -> oauth2\n .authorizationRequestResolver(\n authorizationRequestResolver(this.clientRegistrationRepository)\n )\n );\n return http.build();\n\t}\n\n\tprivate ServerOAuth2AuthorizationRequestResolver authorizationRequestResolver(\n ReactiveClientRegistrationRepository clientRegistrationRepository) {\n\n DefaultServerOAuth2AuthorizationRequestResolver authorizationRequestResolver =\n new DefaultServerOAuth2AuthorizationRequestResolver(\n clientRegistrationRepository);\n authorizationRequestResolver.setAuthorizationRequestCustomizer(\n authorizationRequestCustomizer());\n\n return authorizationRequestResolver;\n\t}\n\n\tprivate Consumer<OAuth2AuthorizationRequest.Builder> authorizationRequestCustomizer() {\n return customizer -> customizer\n .additionalParameters((params) -> params.put(\"prompt\", \"consent\"));\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n @Autowired\n private lateinit var customClientRegistrationRepository: ReactiveClientRegistrationRepository\n\n @Bean\n fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2Login {\n authorizationRequestResolver = authorizationRequestResolver(customClientRegistrationRepository)\n }\n }\n\n return http.build()\n }\n\n private fun authorizationRequestResolver(\n clientRegistrationRepository: ReactiveClientRegistrationRepository): ServerOAuth2AuthorizationRequestResolver {\n val authorizationRequestResolver = DefaultServerOAuth2AuthorizationRequestResolver(\n clientRegistrationRepository)\n authorizationRequestResolver.setAuthorizationRequestCustomizer(\n authorizationRequestCustomizer())\n return authorizationRequestResolver\n }\n\n private fun authorizationRequestCustomizer(): Consumer<OAuth2AuthorizationRequest.Builder> {\n return Consumer { customizer ->\n customizer\n .additionalParameters { params -> params[\"prompt\"] = \"consent\" }\n }\n }\n}\n----\n======\n\nFor the simple use case, where the additional request parameter is always the same for a specific provider, it may be added directly in the `authorization-uri` property.\n\nFor example, if the value for the request parameter `prompt` is always `consent` for the provider `okta`, than simply configure as follows:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n provider:\n okta:\n authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize?prompt=consent\n----\n\nThe preceding example shows the common use case of adding a custom parameter on top of the standard parameters.\nAlternatively, if your requirements are more advanced, you can take full control in building the Authorization Request URI by simply overriding the `OAuth2AuthorizationRequest.authorizationRequestUri` property.\n\n[TIP]\n====\n`OAuth2AuthorizationRequest.Builder.build()` constructs the `OAuth2AuthorizationRequest.authorizationRequestUri`, which represents the Authorization Request URI including all query parameters using the `application/x-www-form-urlencoded` format.\n====\n\nThe following example shows a variation of `authorizationRequestCustomizer()` from the preceding example, and instead overrides the `OAuth2AuthorizationRequest.authorizationRequestUri` property.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nprivate Consumer<OAuth2AuthorizationRequest.Builder> authorizationRequestCustomizer() {\n\treturn customizer -> customizer\n .authorizationRequestUri((uriBuilder) -> uriBuilder\n .queryParam(\"prompt\", \"consent\").build());\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nprivate fun authorizationRequestCustomizer(): Consumer<OAuth2AuthorizationRequest.Builder> {\n return Consumer { customizer: OAuth2AuthorizationRequest.Builder ->\n customizer\n .authorizationRequestUri { uriBuilder: UriBuilder ->\n uriBuilder\n .queryParam(\"prompt\", \"consent\").build()\n }\n }\n}\n----\n======\n\n[[oauth2-client-authorization-code-authorization-request-repository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customizing the Authorization Request", "heading_level": 3, "file_order": 40, "section_index": 4, "content_hash": "0ab5d6fcd8239fd7188ed91c2a1a25e257f88d9503a2d3294dcdef595ded75d3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:c7ebe6b0a62c085fa482c787b754b77fff954cdcaa035b49329a0d1935bef9f5", "content": "The `ServerAuthorizationRequestRepository` is responsible for the persistence of the `OAuth2AuthorizationRequest` from the time the Authorization Request is initiated to the time the Authorization Response is received (the callback).\n\n[TIP]\n====\nThe `OAuth2AuthorizationRequest` is used to correlate and validate the Authorization Response.\n====\n\nThe default implementation of `ServerAuthorizationRequestRepository` is `WebSessionOAuth2ServerAuthorizationRequestRepository`, which stores the `OAuth2AuthorizationRequest` in the `WebSession`.\n\nIf you have a custom implementation of `ServerAuthorizationRequestRepository`, you may configure it as shown in the following example:\n\n.ServerAuthorizationRequestRepository Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2ClientSecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .oauth2Client((oauth2) -> oauth2\n .authorizationRequestRepository(this.authorizationRequestRepository())\n // ...\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2ClientSecurityConfig {\n\n @Bean\n fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n oauth2Client {\n authorizationRequestRepository = authorizationRequestRepository()\n }\n }\n\n return http.build()\n }\n}\n----\n======\n\n[[oauth2-client-authorization-code-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Storing the Authorization Request", "heading_level": 3, "file_order": 40, "section_index": 5, "content_hash": "c7ebe6b0a62c085fa482c787b754b77fff954cdcaa035b49329a0d1935bef9f5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:53ec39caf02ba0f1c7799570f535fd6ef383931aee132591eea17a87bd3972a6", "content": "[NOTE]\n====\nPlease refer to the https://tools.ietf.org/html/rfc6749#section-4.1.3[Access Token Request/Response] protocol flow for the Authorization Code grant.\n====\n\nThe default implementation of `ReactiveOAuth2AccessTokenResponseClient` for the Authorization Code grant is `WebClientReactiveAuthorizationCodeTokenResponseClient`, which uses a `WebClient` for exchanging an authorization code for an access token at the Authorization Servers Token Endpoint.\n\nTo customize `{class-name}`, simply provide a bean as in the following example and it will be picked up by the default `ReactiveOAuth2AuthorizedClientManager` automatically:\n\n[#oauth2-client-{section-id}-access-token-response-client-bean]\n.Access Token Response Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n@Bean\npublic ReactiveOAuth2AccessTokenResponseClient<{grant-request}> accessTokenResponseClient() {\n\t{class-name} accessTokenResponseClient =\n\t\tnew {class-name}();\n\t// ...\n\treturn accessTokenResponseClient;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\n@Bean\nfun accessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<{grant-type}> {\n\tval accessTokenResponseClient = {class-name}()\n\t// ...\n\treturn accessTokenResponseClient\n}\n----\n======\n\n`{class-name}` is very flexible and provides several options for customizing the OAuth 2.0 Access Token request and response for the {grant-type} grant.\nChoose from the following use cases to learn more:\n\n* I want to <<oauth2-client-{section-id}-access-token-request-headers,customize headers of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-request-parameters,customize parameters of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-response-parameters,customize parameters of the Access Token response>>\n* I want to <<oauth2-client-{section-id}-access-token-response-web-client,customize the instance of `WebClient` that is used>>\n\n[#oauth2-client-{section-id}-access-token-request]\n== Customizing the Access Token Request\n\n`{class-name}` provides hooks for customizing HTTP headers and request parameters of the Token Request.\n\n[#oauth2-client-{section-id}-access-token-request-headers]\n=== Customizing Request Headers\n\nThere are two options for customizing HTTP headers:\n\n* Add additional headers by calling `addHeadersConverter()`\n* Fully customize headers by calling `setHeadersConverter()`\n\nYou can include additional headers without affecting the default headers added to every request using `addHeadersConverter()`.\nThe following example adds a `User-Agent` header to the request when the `registrationId` is `spring`:\n\n.Include Additional HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addHeadersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tHttpHeaders headers = new HttpHeaders();\n\tif (clientRegistration.getRegistrationId().equals(\"spring\")) {\n\t\theaders.set(HttpHeaders.USER_AGENT, \"my-user-agent\");\n\t}\n\treturn headers;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addHeadersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval headers = HttpHeaders()\n\tif (clientRegistration.getRegistrationId() == \"spring\") {\n        headers[HttpHeaders.USER_AGENT] = \"my-user-agent\"\n\t}\n\theaders\n}\n----\n======\n\nYou can fully customize headers by re-using `DefaultOAuth2TokenRequestHeadersConverter` or providing a custom implementation using `setHeadersConverter()`.\nThe following example re-uses `DefaultOAuth2TokenRequestHeadersConverter` and disables `encodeClientCredentials` so that HTTP Basic credentials are no longer encoded with `application/x-www-form-urlencoded`:\n\n.Customize HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter headersConverter =\n\tnew DefaultOAuth2TokenRequestHeadersConverter();\nheadersConverter.setEncodeClientCredentials(false);\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter()\nheadersConverter.setEncodeClientCredentials(false)\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[#oauth2-client-{section-id}-access-token-request-parameters]\n=== Customizing Request Parameters\n\nThere are three options for customizing request parameters:\n\n* Add additional parameters by calling `addParametersConverter()`\n* Override parameters by calling `setParametersConverter()`\n* Fully customize parameters by calling `setParametersCustomizer()`\n\n[NOTE]\n====\nUsing `setParametersConverter()` does not fully customize parameters because it would require the user to provide all default parameters themselves.\nDefault parameters are always provided, but can be fully customized or omitted by calling `setParametersCustomizer()`.\n====\n\nYou can include additional parameters without affecting the default parameters added to every request using `addParametersConverter()`.\nThe following example adds an `audience` parameter to the request when the `registrationId` is `keycloak`:\n\n.Include Additional Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tMultiValueMap<String, String> parameters = new LinkedMultiValueMap<String, String>();\n\tif (clientRegistration.getRegistrationId().equals(\"keycloak\")) {\n\t\tparameters.set(OAuth2ParameterNames.AUDIENCE, \"my-audience\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addParametersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"keycloak\") {\n        parameters[OAuth2ParameterNames.AUDIENCE] = \"my-audience\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can override default parameters using `setParametersConverter()`.\nThe following example overrides the `client_id` parameter when the `registrationId` is `okta`:\n\n.Override Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tLinkedMultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n\tif (clientRegistration.getRegistrationId().equals(\"okta\")) {\n\t\tparameters.set(OAuth2ParameterNames.CLIENT_ID, \"my-client\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersConverter { grantRequest ->\n    val clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"okta\") {\n        parameters[OAuth2ParameterNames.CLIENT_ID] = \"my-client\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can fully customize parameters (including omitting default parameters) using `setParametersCustomizer()`.\nThe following example omits the `client_id` parameter when the `client_assertion` parameter is present in the request:\n\n.Omit Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersCustomizer(parameters -> {\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID);\n\t}\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response]\n== Customizing the Access Token Response\n\n`{class-name}` provides hooks for customizing the OAuth 2.0 Access Token Response.\n\n[#oauth2-client-{section-id}-access-token-response-parameters]\n=== Customizing Response Parameters\n\nYou can customize the conversion of Token Response parameters to an `OAuth2AccessTokenResponse` by calling `setBodyExtractor()`.\nThe default implementation provided by `OAuth2BodyExtractors.oauth2AccessTokenResponse()` parses the response and handles errors accordingly.\n\nThe following example provides a starting point for customizing the conversion of Token Response parameters to an `OAuth2AccessTokenResponse`:\n\n.Customize Body Extractor\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\n\nBodyExtractor<Mono<Map<String, Object>>, ReactiveHttpInputMessage> bodyExtractor =\n\tBodyExtractors.toMono(new ParameterizedTypeReference<>() {});\naccessTokenResponseClient.setBodyExtractor((inputMessage, context) ->\n\tbodyExtractor.extract(inputMessage, context)\n\t\t.map((parameters) -> parameters.withToken(\"custom-token\")\n\t\t\t// ...\n\t\t\t.build()\n\t\t)\n);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\n\nval bodyExtractor = BodyExtractors.toMono(object : ParameterizedTypeReference<Map<String, Any>>() {})\naccessTokenResponseClient.setBodyExtractor { inputMessage, context ->\n\tbodyExtractor.extract(inputMessage, context).map { parameters ->\n\t\tOAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t\t// ...\n\t\t\t.build()\n\t}\n}\n----\n======\n\n[CAUTION]\n====\nWhen providing a custom `BodyExtractor`, you are responsible for detecting and converting an OAuth 2.0 Error Response to a `Mono.error()` with `OAuth2Error` based on parameters of the response.\n====\n\n[#oauth2-client-{section-id}-access-token-response-web-client]\n=== Customizing the `WebClient`\n\nAlternatively, if your requirements are more advanced, you can take full control of the request and/or response by providing a pre-configured `WebClient` to `setWebClient()` as the following example shows:\n\n.Customize `WebClient`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nWebClient webClient = WebClient.builder()\n\t// ...\n\t.build();\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setWebClient(webClient);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval webClient = WebClient.builder()\n\t// ...\n\t.build()\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setWebClient(webClient)\n----\n======\n\n[[oauth2-client-authorization-code-access-token-response-client-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Requesting an Access Token", "heading_level": 3, "file_order": 40, "section_index": 6, "content_hash": "53ec39caf02ba0f1c7799570f535fd6ef383931aee132591eea17a87bd3972a6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:0e4fb4c0766c47beb60f2916ba0ced8e480b5b2f26447fa329f227df02f74450", "content": "Whether you customize `{class-name}` or provide your own implementation of `ReactiveOAuth2AccessTokenResponseClient`, you can configure it using the DSL (as an alternative to <<oauth2-client-authorization-code-access-token-response-client-bean,publishing a bean>>) as shown in the following example:\n\n.Access Token Response Configuration via DSL\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2ClientSecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .oauth2Client((oauth2) -> oauth2\n .authenticationManager(this.authorizationCodeAuthenticationManager())\n // ...\n );\n return http.build();\n\t}\n\n\tprivate ReactiveAuthenticationManager authorizationCodeAuthenticationManager() {\n WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient =\n new WebClientReactiveAuthorizationCodeTokenResponseClient();\n // ...\n\n return new OAuth2AuthorizationCodeReactiveAuthenticationManager(accessTokenResponseClient);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2ClientSecurityConfig {\n\n @Bean\n fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n oauth2Client {\n authenticationManager = authorizationCodeAuthenticationManager()\n }\n }\n\n return http.build()\n }\n\n private fun authorizationCodeAuthenticationManager(): ReactiveAuthenticationManager {\n val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()\n // ...\n\n return OAuth2AuthorizationCodeReactiveAuthenticationManager(accessTokenResponseClient)\n }\n}\n----\n======\n\n[[oauth2-client-refresh-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customize using the DSL", "heading_level": 3, "file_order": 40, "section_index": 7, "content_hash": "0e4fb4c0766c47beb60f2916ba0ced8e480b5b2f26447fa329f227df02f74450", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:996ebd0a05be9be847f99b3647dfbb431ed00681efd252f53a4463121762fbba", "content": "[NOTE]\n====\nPlease refer to the OAuth 2.0 Authorization Framework for further details on the https://tools.ietf.org/html/rfc6749#section-1.5[Refresh Token].\n====\n\n[[oauth2-client-refresh-token-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "[[oauth2Client-refresh-token-grant]]Refresh Token", "heading_level": 2, "file_order": 40, "section_index": 8, "content_hash": "996ebd0a05be9be847f99b3647dfbb431ed00681efd252f53a4463121762fbba", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:449bf187ce369996b0fd2cbee74aac648152eb11cdd2d5a7179197b4112ebd45", "content": "[NOTE]\n====\nPlease refer to the https://tools.ietf.org/html/rfc6749#section-6[Access Token Request/Response] protocol flow for the Refresh Token grant.\n====\n\nThe default implementation of `ReactiveOAuth2AccessTokenResponseClient` for the Refresh Token grant is `WebClientReactiveRefreshTokenTokenResponseClient`, which uses a `WebClient` when refreshing an access token at the Authorization Servers Token Endpoint.\n\nTo customize `{class-name}`, simply provide a bean as in the following example and it will be picked up by the default `ReactiveOAuth2AuthorizedClientManager` automatically:\n\n[#oauth2-client-{section-id}-access-token-response-client-bean]\n.Access Token Response Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n@Bean\npublic ReactiveOAuth2AccessTokenResponseClient<{grant-request}> accessTokenResponseClient() {\n\t{class-name} accessTokenResponseClient =\n\t\tnew {class-name}();\n\t// ...\n\treturn accessTokenResponseClient;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\n@Bean\nfun accessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<{grant-type}> {\n\tval accessTokenResponseClient = {class-name}()\n\t// ...\n\treturn accessTokenResponseClient\n}\n----\n======\n\n`{class-name}` is very flexible and provides several options for customizing the OAuth 2.0 Access Token request and response for the {grant-type} grant.\nChoose from the following use cases to learn more:\n\n* I want to <<oauth2-client-{section-id}-access-token-request-headers,customize headers of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-request-parameters,customize parameters of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-response-parameters,customize parameters of the Access Token response>>\n* I want to <<oauth2-client-{section-id}-access-token-response-web-client,customize the instance of `WebClient` that is used>>\n\n[#oauth2-client-{section-id}-access-token-request]\n== Customizing the Access Token Request\n\n`{class-name}` provides hooks for customizing HTTP headers and request parameters of the Token Request.\n\n[#oauth2-client-{section-id}-access-token-request-headers]\n=== Customizing Request Headers\n\nThere are two options for customizing HTTP headers:\n\n* Add additional headers by calling `addHeadersConverter()`\n* Fully customize headers by calling `setHeadersConverter()`\n\nYou can include additional headers without affecting the default headers added to every request using `addHeadersConverter()`.\nThe following example adds a `User-Agent` header to the request when the `registrationId` is `spring`:\n\n.Include Additional HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addHeadersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tHttpHeaders headers = new HttpHeaders();\n\tif (clientRegistration.getRegistrationId().equals(\"spring\")) {\n\t\theaders.set(HttpHeaders.USER_AGENT, \"my-user-agent\");\n\t}\n\treturn headers;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addHeadersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval headers = HttpHeaders()\n\tif (clientRegistration.getRegistrationId() == \"spring\") {\n        headers[HttpHeaders.USER_AGENT] = \"my-user-agent\"\n\t}\n\theaders\n}\n----\n======\n\nYou can fully customize headers by re-using `DefaultOAuth2TokenRequestHeadersConverter` or providing a custom implementation using `setHeadersConverter()`.\nThe following example re-uses `DefaultOAuth2TokenRequestHeadersConverter` and disables `encodeClientCredentials` so that HTTP Basic credentials are no longer encoded with `application/x-www-form-urlencoded`:\n\n.Customize HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter headersConverter =\n\tnew DefaultOAuth2TokenRequestHeadersConverter();\nheadersConverter.setEncodeClientCredentials(false);\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter()\nheadersConverter.setEncodeClientCredentials(false)\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[#oauth2-client-{section-id}-access-token-request-parameters]\n=== Customizing Request Parameters\n\nThere are three options for customizing request parameters:\n\n* Add additional parameters by calling `addParametersConverter()`\n* Override parameters by calling `setParametersConverter()`\n* Fully customize parameters by calling `setParametersCustomizer()`\n\n[NOTE]\n====\nUsing `setParametersConverter()` does not fully customize parameters because it would require the user to provide all default parameters themselves.\nDefault parameters are always provided, but can be fully customized or omitted by calling `setParametersCustomizer()`.\n====\n\nYou can include additional parameters without affecting the default parameters added to every request using `addParametersConverter()`.\nThe following example adds an `audience` parameter to the request when the `registrationId` is `keycloak`:\n\n.Include Additional Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tMultiValueMap<String, String> parameters = new LinkedMultiValueMap<String, String>();\n\tif (clientRegistration.getRegistrationId().equals(\"keycloak\")) {\n\t\tparameters.set(OAuth2ParameterNames.AUDIENCE, \"my-audience\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addParametersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"keycloak\") {\n        parameters[OAuth2ParameterNames.AUDIENCE] = \"my-audience\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can override default parameters using `setParametersConverter()`.\nThe following example overrides the `client_id` parameter when the `registrationId` is `okta`:\n\n.Override Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tLinkedMultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n\tif (clientRegistration.getRegistrationId().equals(\"okta\")) {\n\t\tparameters.set(OAuth2ParameterNames.CLIENT_ID, \"my-client\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersConverter { grantRequest ->\n    val clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"okta\") {\n        parameters[OAuth2ParameterNames.CLIENT_ID] = \"my-client\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can fully customize parameters (including omitting default parameters) using `setParametersCustomizer()`.\nThe following example omits the `client_id` parameter when the `client_assertion` parameter is present in the request:\n\n.Omit Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersCustomizer(parameters -> {\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID);\n\t}\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response]\n== Customizing the Access Token Response\n\n`{class-name}` provides hooks for customizing the OAuth 2.0 Access Token Response.\n\n[#oauth2-client-{section-id}-access-token-response-parameters]\n=== Customizing Response Parameters\n\nYou can customize the conversion of Token Response parameters to an `OAuth2AccessTokenResponse` by calling `setBodyExtractor()`.\nThe default implementation provided by `OAuth2BodyExtractors.oauth2AccessTokenResponse()` parses the response and handles errors accordingly.\n\nThe following example provides a starting point for customizing the conversion of Token Response parameters to an `OAuth2AccessTokenResponse`:\n\n.Customize Body Extractor\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\n\nBodyExtractor<Mono<Map<String, Object>>, ReactiveHttpInputMessage> bodyExtractor =\n\tBodyExtractors.toMono(new ParameterizedTypeReference<>() {});\naccessTokenResponseClient.setBodyExtractor((inputMessage, context) ->\n\tbodyExtractor.extract(inputMessage, context)\n\t\t.map((parameters) -> parameters.withToken(\"custom-token\")\n\t\t\t// ...\n\t\t\t.build()\n\t\t)\n);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\n\nval bodyExtractor = BodyExtractors.toMono(object : ParameterizedTypeReference<Map<String, Any>>() {})\naccessTokenResponseClient.setBodyExtractor { inputMessage, context ->\n\tbodyExtractor.extract(inputMessage, context).map { parameters ->\n\t\tOAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t\t// ...\n\t\t\t.build()\n\t}\n}\n----\n======\n\n[CAUTION]\n====\nWhen providing a custom `BodyExtractor`, you are responsible for detecting and converting an OAuth 2.0 Error Response to a `Mono.error()` with `OAuth2Error` based on parameters of the response.\n====\n\n[#oauth2-client-{section-id}-access-token-response-web-client]\n=== Customizing the `WebClient`\n\nAlternatively, if your requirements are more advanced, you can take full control of the request and/or response by providing a pre-configured `WebClient` to `setWebClient()` as the following example shows:\n\n.Customize `WebClient`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nWebClient webClient = WebClient.builder()\n\t// ...\n\t.build();\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setWebClient(webClient);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval webClient = WebClient.builder()\n\t// ...\n\t.build()\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setWebClient(webClient)\n----\n======\n\n[[oauth2-client-refresh-token-authorized-client-provider-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Refreshing an Access Token", "heading_level": 3, "file_order": 40, "section_index": 9, "content_hash": "449bf187ce369996b0fd2cbee74aac648152eb11cdd2d5a7179197b4112ebd45", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:bad1cfecbd17cdf3ea26e794d4e057ab6ace24a6602a84c32296f1ae856c9d50", "content": "Whether you customize `WebClientReactiveRefreshTokenTokenResponseClient` or provide your own implementation of `ReactiveOAuth2AccessTokenResponseClient`, you can configure it using the `ReactiveOAuth2AuthorizedClientProviderBuilder` (as an alternative to <<oauth2-client-refresh-token-access-token-response-client-bean,publishing a bean>>) as follows:\n\n.Access Token Response Configuration via Builder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> refreshTokenTokenResponseClient = ...\n\nReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken((configurer) -> configurer.accessTokenResponseClient(refreshTokenTokenResponseClient))\n .build();\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval refreshTokenTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> = ...\n\nval authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken { it.accessTokenResponseClient(refreshTokenTokenResponseClient) }\n .build()\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n----\n======\n\n[NOTE]\n====\n`ReactiveOAuth2AuthorizedClientProviderBuilder.builder().refreshToken()` configures a `RefreshTokenReactiveOAuth2AuthorizedClientProvider`,\nwhich is an implementation of a `ReactiveOAuth2AuthorizedClientProvider` for the Refresh Token grant.\n====\n\nThe `OAuth2RefreshToken` may optionally be returned in the Access Token Response for the `authorization_code` grant type.\nIf the `OAuth2AuthorizedClient.getRefreshToken()` is available and the `OAuth2AuthorizedClient.getAccessToken()` is expired, it will automatically be refreshed by the `RefreshTokenReactiveOAuth2AuthorizedClientProvider`.\n\n[[oauth2-client-client-credentials]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customize using the Builder", "heading_level": 3, "file_order": 40, "section_index": 10, "content_hash": "bad1cfecbd17cdf3ea26e794d4e057ab6ace24a6602a84c32296f1ae856c9d50", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:0f0df274b04d8698eae17150a1f4ad10ff92424e8d88523b65e3357df7436ddf", "content": "[NOTE]\n====\nPlease refer to the OAuth 2.0 Authorization Framework for further details on the https://tools.ietf.org/html/rfc6749#section-1.3.4[Client Credentials] grant.\n====\n\n[[oauth2-client-client-credentials-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "[[oauth2Client-client-creds-grant]]Client Credentials", "heading_level": 2, "file_order": 40, "section_index": 11, "content_hash": "0f0df274b04d8698eae17150a1f4ad10ff92424e8d88523b65e3357df7436ddf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:dd6312bc6a4ae97d5211bb1cf2b2870430642a1558fbba68dd9e5375d93b8216", "content": "[NOTE]\n====\nPlease refer to the https://tools.ietf.org/html/rfc6749#section-4.4.2[Access Token Request/Response] protocol flow for the Client Credentials grant.\n====\n\nThe default implementation of `ReactiveOAuth2AccessTokenResponseClient` for the Client Credentials grant is `WebClientReactiveClientCredentialsTokenResponseClient`, which uses a `WebClient` when requesting an access token at the Authorization Servers Token Endpoint.\n\nTo customize `{class-name}`, simply provide a bean as in the following example and it will be picked up by the default `ReactiveOAuth2AuthorizedClientManager` automatically:\n\n[#oauth2-client-{section-id}-access-token-response-client-bean]\n.Access Token Response Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n@Bean\npublic ReactiveOAuth2AccessTokenResponseClient<{grant-request}> accessTokenResponseClient() {\n\t{class-name} accessTokenResponseClient =\n\t\tnew {class-name}();\n\t// ...\n\treturn accessTokenResponseClient;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\n@Bean\nfun accessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<{grant-type}> {\n\tval accessTokenResponseClient = {class-name}()\n\t// ...\n\treturn accessTokenResponseClient\n}\n----\n======\n\n`{class-name}` is very flexible and provides several options for customizing the OAuth 2.0 Access Token request and response for the {grant-type} grant.\nChoose from the following use cases to learn more:\n\n* I want to <<oauth2-client-{section-id}-access-token-request-headers,customize headers of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-request-parameters,customize parameters of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-response-parameters,customize parameters of the Access Token response>>\n* I want to <<oauth2-client-{section-id}-access-token-response-web-client,customize the instance of `WebClient` that is used>>\n\n[#oauth2-client-{section-id}-access-token-request]\n== Customizing the Access Token Request\n\n`{class-name}` provides hooks for customizing HTTP headers and request parameters of the Token Request.\n\n[#oauth2-client-{section-id}-access-token-request-headers]\n=== Customizing Request Headers\n\nThere are two options for customizing HTTP headers:\n\n* Add additional headers by calling `addHeadersConverter()`\n* Fully customize headers by calling `setHeadersConverter()`\n\nYou can include additional headers without affecting the default headers added to every request using `addHeadersConverter()`.\nThe following example adds a `User-Agent` header to the request when the `registrationId` is `spring`:\n\n.Include Additional HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addHeadersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tHttpHeaders headers = new HttpHeaders();\n\tif (clientRegistration.getRegistrationId().equals(\"spring\")) {\n\t\theaders.set(HttpHeaders.USER_AGENT, \"my-user-agent\");\n\t}\n\treturn headers;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addHeadersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval headers = HttpHeaders()\n\tif (clientRegistration.getRegistrationId() == \"spring\") {\n        headers[HttpHeaders.USER_AGENT] = \"my-user-agent\"\n\t}\n\theaders\n}\n----\n======\n\nYou can fully customize headers by re-using `DefaultOAuth2TokenRequestHeadersConverter` or providing a custom implementation using `setHeadersConverter()`.\nThe following example re-uses `DefaultOAuth2TokenRequestHeadersConverter` and disables `encodeClientCredentials` so that HTTP Basic credentials are no longer encoded with `application/x-www-form-urlencoded`:\n\n.Customize HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter headersConverter =\n\tnew DefaultOAuth2TokenRequestHeadersConverter();\nheadersConverter.setEncodeClientCredentials(false);\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter()\nheadersConverter.setEncodeClientCredentials(false)\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[#oauth2-client-{section-id}-access-token-request-parameters]\n=== Customizing Request Parameters\n\nThere are three options for customizing request parameters:\n\n* Add additional parameters by calling `addParametersConverter()`\n* Override parameters by calling `setParametersConverter()`\n* Fully customize parameters by calling `setParametersCustomizer()`\n\n[NOTE]\n====\nUsing `setParametersConverter()` does not fully customize parameters because it would require the user to provide all default parameters themselves.\nDefault parameters are always provided, but can be fully customized or omitted by calling `setParametersCustomizer()`.\n====\n\nYou can include additional parameters without affecting the default parameters added to every request using `addParametersConverter()`.\nThe following example adds an `audience` parameter to the request when the `registrationId` is `keycloak`:\n\n.Include Additional Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tMultiValueMap<String, String> parameters = new LinkedMultiValueMap<String, String>();\n\tif (clientRegistration.getRegistrationId().equals(\"keycloak\")) {\n\t\tparameters.set(OAuth2ParameterNames.AUDIENCE, \"my-audience\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addParametersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"keycloak\") {\n        parameters[OAuth2ParameterNames.AUDIENCE] = \"my-audience\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can override default parameters using `setParametersConverter()`.\nThe following example overrides the `client_id` parameter when the `registrationId` is `okta`:\n\n.Override Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tLinkedMultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n\tif (clientRegistration.getRegistrationId().equals(\"okta\")) {\n\t\tparameters.set(OAuth2ParameterNames.CLIENT_ID, \"my-client\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersConverter { grantRequest ->\n    val clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"okta\") {\n        parameters[OAuth2ParameterNames.CLIENT_ID] = \"my-client\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can fully customize parameters (including omitting default parameters) using `setParametersCustomizer()`.\nThe following example omits the `client_id` parameter when the `client_assertion` parameter is present in the request:\n\n.Omit Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersCustomizer(parameters -> {\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID);\n\t}\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response]\n== Customizing the Access Token Response\n\n`{class-name}` provides hooks for customizing the OAuth 2.0 Access Token Response.\n\n[#oauth2-client-{section-id}-access-token-response-parameters]\n=== Customizing Response Parameters\n\nYou can customize the conversion of Token Response parameters to an `OAuth2AccessTokenResponse` by calling `setBodyExtractor()`.\nThe default implementation provided by `OAuth2BodyExtractors.oauth2AccessTokenResponse()` parses the response and handles errors accordingly.\n\nThe following example provides a starting point for customizing the conversion of Token Response parameters to an `OAuth2AccessTokenResponse`:\n\n.Customize Body Extractor\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\n\nBodyExtractor<Mono<Map<String, Object>>, ReactiveHttpInputMessage> bodyExtractor =\n\tBodyExtractors.toMono(new ParameterizedTypeReference<>() {});\naccessTokenResponseClient.setBodyExtractor((inputMessage, context) ->\n\tbodyExtractor.extract(inputMessage, context)\n\t\t.map((parameters) -> parameters.withToken(\"custom-token\")\n\t\t\t// ...\n\t\t\t.build()\n\t\t)\n);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\n\nval bodyExtractor = BodyExtractors.toMono(object : ParameterizedTypeReference<Map<String, Any>>() {})\naccessTokenResponseClient.setBodyExtractor { inputMessage, context ->\n\tbodyExtractor.extract(inputMessage, context).map { parameters ->\n\t\tOAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t\t// ...\n\t\t\t.build()\n\t}\n}\n----\n======\n\n[CAUTION]\n====\nWhen providing a custom `BodyExtractor`, you are responsible for detecting and converting an OAuth 2.0 Error Response to a `Mono.error()` with `OAuth2Error` based on parameters of the response.\n====\n\n[#oauth2-client-{section-id}-access-token-response-web-client]\n=== Customizing the `WebClient`\n\nAlternatively, if your requirements are more advanced, you can take full control of the request and/or response by providing a pre-configured `WebClient` to `setWebClient()` as the following example shows:\n\n.Customize `WebClient`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nWebClient webClient = WebClient.builder()\n\t// ...\n\t.build();\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setWebClient(webClient);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval webClient = WebClient.builder()\n\t// ...\n\t.build()\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setWebClient(webClient)\n----\n======\n\n[[oauth2-client-client-credentials-authorized-client-provider-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Requesting an Access Token", "heading_level": 3, "file_order": 40, "section_index": 12, "content_hash": "dd6312bc6a4ae97d5211bb1cf2b2870430642a1558fbba68dd9e5375d93b8216", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:00ad7fd6852984e40cdfff5f5711e5823dbd72e43e4a1a98d200cd5e91c18d33", "content": "Whether you customize `WebClientReactiveClientCredentialsTokenResponseClient` or provide your own implementation of `ReactiveOAuth2AccessTokenResponseClient`, you can configure it using the `ReactiveOAuth2AuthorizedClientProviderBuilder` (as an alternative to <<oauth2-client-client-credentials-access-token-response-client-bean,publishing a bean>>) as follows:\n\n.Access Token Response Configuration via Builder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsTokenResponseClient = ...\n\nReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials((configurer) -> configurer.accessTokenResponseClient(clientCredentialsTokenResponseClient))\n .build();\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval clientCredentialsTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> = ...\n\nval authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials { it.accessTokenResponseClient(clientCredentialsTokenResponseClient) }\n .build()\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n----\n======\n\n[NOTE]\n====\n`ReactiveOAuth2AuthorizedClientProviderBuilder.builder().clientCredentials()` configures a `ClientCredentialsReactiveOAuth2AuthorizedClientProvider`, which is an implementation of a `ReactiveOAuth2AuthorizedClientProvider` for the Client Credentials grant.\n====\n\n[[oauth2-client-client-credentials-authorized-client-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customize using the Builder", "heading_level": 3, "file_order": 40, "section_index": 13, "content_hash": "00ad7fd6852984e40cdfff5f5711e5823dbd72e43e4a1a98d200cd5e91c18d33", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:15700f652629e57bd79cd4a8196bcdcabc9ff22e25bfb79d792562b32cbfd538", "content": "Given the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n authorization-grant-type: client_credentials\n scope: read, write\n provider:\n okta:\n token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token\n----\n\n...and the `ReactiveOAuth2AuthorizedClientManager` `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveOAuth2AuthorizedClientManager authorizedClientManager(\n ReactiveClientRegistrationRepository clientRegistrationRepository,\n ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials()\n .build();\n\n\tDefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ReactiveClientRegistrationRepository,\n authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {\n val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials()\n .build()\n val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======\n\nYou may obtain the `OAuth2AccessToken` as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class OAuth2ClientController {\n\n\t@Autowired\n\tprivate ReactiveOAuth2AuthorizedClientManager authorizedClientManager;\n\n\t@GetMapping(\"/\")\n\tpublic Mono<String> index(Authentication authentication, ServerWebExchange exchange) {\n OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(authentication)\n .attribute(ServerWebExchange.class.getName(), exchange)\n .build();\n\n return this.authorizedClientManager.authorize(authorizeRequest)\n .map(OAuth2AuthorizedClient::getAccessToken)\n // ...\n .thenReturn(\"index\");\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass OAuth2ClientController {\n\n @Autowired\n private lateinit var authorizedClientManager: ReactiveOAuth2AuthorizedClientManager\n\n @GetMapping(\"/\")\n fun index(authentication: Authentication, exchange: ServerWebExchange): Mono<String> {\n val authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(authentication)\n .attribute(ServerWebExchange::class.java.name, exchange)\n .build()\n\n return authorizedClientManager.authorize(authorizeRequest)\n .map { it.accessToken }\n // ...\n .thenReturn(\"index\")\n }\n}\n----\n======\n\n[NOTE]\n====\n`ServerWebExchange` is an OPTIONAL attribute.\nIf not provided, it will be obtained from the https://projectreactor.io/docs/core/release/reference/#context[Reactor's Context] via the key `ServerWebExchange.class`.\n====\n\n[[oauth2-client-jwt-bearer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Using the Access Token", "heading_level": 3, "file_order": 40, "section_index": 14, "content_hash": "15700f652629e57bd79cd4a8196bcdcabc9ff22e25bfb79d792562b32cbfd538", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:b197bfd4678a38c5574305a50e65cdacec0afdcf0f81d4efa5302f42f60a0154", "content": "[NOTE]\n====\nPlease refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on the https://datatracker.ietf.org/doc/html/rfc7523[JWT Bearer] grant.\n====\n\n[[oauth2-client-jwt-bearer-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "JWT Bearer", "heading_level": 2, "file_order": 40, "section_index": 15, "content_hash": "b197bfd4678a38c5574305a50e65cdacec0afdcf0f81d4efa5302f42f60a0154", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:941baab52dd7d1bb9c2ae2996372acd7e7ffe0da556e8f2eb793b410823b512f", "content": "[NOTE]\n====\nPlease refer to the https://datatracker.ietf.org/doc/html/rfc7523#section-2.1[Access Token Request/Response] protocol flow for the JWT Bearer grant.\n====\n\nThe default implementation of `ReactiveOAuth2AccessTokenResponseClient` for the JWT Bearer grant is `WebClientReactiveJwtBearerTokenResponseClient`, which uses a `WebClient` when requesting an access token at the Authorization Servers Token Endpoint.\n\nTo customize `{class-name}`, simply provide a bean as in the following example and it will be picked up by the default `ReactiveOAuth2AuthorizedClientManager` automatically:\n\n[#oauth2-client-{section-id}-access-token-response-client-bean]\n.Access Token Response Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n@Bean\npublic ReactiveOAuth2AccessTokenResponseClient<{grant-request}> accessTokenResponseClient() {\n\t{class-name} accessTokenResponseClient =\n\t\tnew {class-name}();\n\t// ...\n\treturn accessTokenResponseClient;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\n@Bean\nfun accessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<{grant-type}> {\n\tval accessTokenResponseClient = {class-name}()\n\t// ...\n\treturn accessTokenResponseClient\n}\n----\n======\n\n`{class-name}` is very flexible and provides several options for customizing the OAuth 2.0 Access Token request and response for the {grant-type} grant.\nChoose from the following use cases to learn more:\n\n* I want to <<oauth2-client-{section-id}-access-token-request-headers,customize headers of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-request-parameters,customize parameters of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-response-parameters,customize parameters of the Access Token response>>\n* I want to <<oauth2-client-{section-id}-access-token-response-web-client,customize the instance of `WebClient` that is used>>\n\n[#oauth2-client-{section-id}-access-token-request]\n== Customizing the Access Token Request\n\n`{class-name}` provides hooks for customizing HTTP headers and request parameters of the Token Request.\n\n[#oauth2-client-{section-id}-access-token-request-headers]\n=== Customizing Request Headers\n\nThere are two options for customizing HTTP headers:\n\n* Add additional headers by calling `addHeadersConverter()`\n* Fully customize headers by calling `setHeadersConverter()`\n\nYou can include additional headers without affecting the default headers added to every request using `addHeadersConverter()`.\nThe following example adds a `User-Agent` header to the request when the `registrationId` is `spring`:\n\n.Include Additional HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addHeadersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tHttpHeaders headers = new HttpHeaders();\n\tif (clientRegistration.getRegistrationId().equals(\"spring\")) {\n\t\theaders.set(HttpHeaders.USER_AGENT, \"my-user-agent\");\n\t}\n\treturn headers;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addHeadersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval headers = HttpHeaders()\n\tif (clientRegistration.getRegistrationId() == \"spring\") {\n        headers[HttpHeaders.USER_AGENT] = \"my-user-agent\"\n\t}\n\theaders\n}\n----\n======\n\nYou can fully customize headers by re-using `DefaultOAuth2TokenRequestHeadersConverter` or providing a custom implementation using `setHeadersConverter()`.\nThe following example re-uses `DefaultOAuth2TokenRequestHeadersConverter` and disables `encodeClientCredentials` so that HTTP Basic credentials are no longer encoded with `application/x-www-form-urlencoded`:\n\n.Customize HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter headersConverter =\n\tnew DefaultOAuth2TokenRequestHeadersConverter();\nheadersConverter.setEncodeClientCredentials(false);\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter()\nheadersConverter.setEncodeClientCredentials(false)\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[#oauth2-client-{section-id}-access-token-request-parameters]\n=== Customizing Request Parameters\n\nThere are three options for customizing request parameters:\n\n* Add additional parameters by calling `addParametersConverter()`\n* Override parameters by calling `setParametersConverter()`\n* Fully customize parameters by calling `setParametersCustomizer()`\n\n[NOTE]\n====\nUsing `setParametersConverter()` does not fully customize parameters because it would require the user to provide all default parameters themselves.\nDefault parameters are always provided, but can be fully customized or omitted by calling `setParametersCustomizer()`.\n====\n\nYou can include additional parameters without affecting the default parameters added to every request using `addParametersConverter()`.\nThe following example adds an `audience` parameter to the request when the `registrationId` is `keycloak`:\n\n.Include Additional Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tMultiValueMap<String, String> parameters = new LinkedMultiValueMap<String, String>();\n\tif (clientRegistration.getRegistrationId().equals(\"keycloak\")) {\n\t\tparameters.set(OAuth2ParameterNames.AUDIENCE, \"my-audience\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addParametersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"keycloak\") {\n        parameters[OAuth2ParameterNames.AUDIENCE] = \"my-audience\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can override default parameters using `setParametersConverter()`.\nThe following example overrides the `client_id` parameter when the `registrationId` is `okta`:\n\n.Override Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tLinkedMultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n\tif (clientRegistration.getRegistrationId().equals(\"okta\")) {\n\t\tparameters.set(OAuth2ParameterNames.CLIENT_ID, \"my-client\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersConverter { grantRequest ->\n    val clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"okta\") {\n        parameters[OAuth2ParameterNames.CLIENT_ID] = \"my-client\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can fully customize parameters (including omitting default parameters) using `setParametersCustomizer()`.\nThe following example omits the `client_id` parameter when the `client_assertion` parameter is present in the request:\n\n.Omit Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersCustomizer(parameters -> {\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID);\n\t}\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response]\n== Customizing the Access Token Response\n\n`{class-name}` provides hooks for customizing the OAuth 2.0 Access Token Response.\n\n[#oauth2-client-{section-id}-access-token-response-parameters]\n=== Customizing Response Parameters\n\nYou can customize the conversion of Token Response parameters to an `OAuth2AccessTokenResponse` by calling `setBodyExtractor()`.\nThe default implementation provided by `OAuth2BodyExtractors.oauth2AccessTokenResponse()` parses the response and handles errors accordingly.\n\nThe following example provides a starting point for customizing the conversion of Token Response parameters to an `OAuth2AccessTokenResponse`:\n\n.Customize Body Extractor\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\n\nBodyExtractor<Mono<Map<String, Object>>, ReactiveHttpInputMessage> bodyExtractor =\n\tBodyExtractors.toMono(new ParameterizedTypeReference<>() {});\naccessTokenResponseClient.setBodyExtractor((inputMessage, context) ->\n\tbodyExtractor.extract(inputMessage, context)\n\t\t.map((parameters) -> parameters.withToken(\"custom-token\")\n\t\t\t// ...\n\t\t\t.build()\n\t\t)\n);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\n\nval bodyExtractor = BodyExtractors.toMono(object : ParameterizedTypeReference<Map<String, Any>>() {})\naccessTokenResponseClient.setBodyExtractor { inputMessage, context ->\n\tbodyExtractor.extract(inputMessage, context).map { parameters ->\n\t\tOAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t\t// ...\n\t\t\t.build()\n\t}\n}\n----\n======\n\n[CAUTION]\n====\nWhen providing a custom `BodyExtractor`, you are responsible for detecting and converting an OAuth 2.0 Error Response to a `Mono.error()` with `OAuth2Error` based on parameters of the response.\n====\n\n[#oauth2-client-{section-id}-access-token-response-web-client]\n=== Customizing the `WebClient`\n\nAlternatively, if your requirements are more advanced, you can take full control of the request and/or response by providing a pre-configured `WebClient` to `setWebClient()` as the following example shows:\n\n.Customize `WebClient`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nWebClient webClient = WebClient.builder()\n\t// ...\n\t.build();\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setWebClient(webClient);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval webClient = WebClient.builder()\n\t// ...\n\t.build()\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setWebClient(webClient)\n----\n======\n\n[[oauth2-client-jwt-bearer-authorized-client-provider-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Requesting an Access Token", "heading_level": 3, "file_order": 40, "section_index": 16, "content_hash": "941baab52dd7d1bb9c2ae2996372acd7e7ffe0da556e8f2eb793b410823b512f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:6300abb7deb22d472a854f3921b06d80a4d96f6fe78cdc83563f20345fa639cb", "content": "Whether you customize `WebClientReactiveJwtBearerTokenResponseClient` or provide your own implementation of `ReactiveOAuth2AccessTokenResponseClient`, you can configure it using the `ReactiveOAuth2AuthorizedClientProviderBuilder` (as an alternative to <<oauth2-client-jwt-bearer-access-token-response-client-bean,publishing a bean>>) as follows:\n\n.Access Token Response Configuration via Builder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> jwtBearerTokenResponseClient = ...\n\nJwtBearerReactiveOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider = new JwtBearerReactiveOAuth2AuthorizedClientProvider();\njwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient);\n\nReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .provider(jwtBearerAuthorizedClientProvider)\n .build();\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwtBearerTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> = ...\n\nval jwtBearerAuthorizedClientProvider = JwtBearerReactiveOAuth2AuthorizedClientProvider()\njwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient)\n\nval authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .provider(jwtBearerAuthorizedClientProvider)\n .build()\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n----\n======\n\n[[oauth2-client-jwt-bearer-authorized-client-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customize using the Builder", "heading_level": 3, "file_order": 40, "section_index": 17, "content_hash": "6300abb7deb22d472a854f3921b06d80a4d96f6fe78cdc83563f20345fa639cb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:3921f9ce7365a96b2242e95028a56bb03375d5169eeb0ae7a0ce57ec7711b650", "content": "Given the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n authorization-grant-type: urn:ietf:params:oauth:grant-type:jwt-bearer\n scope: read\n provider:\n okta:\n token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token\n----\n\n...and the `OAuth2AuthorizedClientManager` `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveOAuth2AuthorizedClientManager authorizedClientManager(\n ReactiveClientRegistrationRepository clientRegistrationRepository,\n ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tJwtBearerReactiveOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider =\n new JwtBearerReactiveOAuth2AuthorizedClientProvider();\n\n\tReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .provider(jwtBearerAuthorizedClientProvider)\n .build();\n\n\tDefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ReactiveClientRegistrationRepository,\n authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {\n val jwtBearerAuthorizedClientProvider = JwtBearerReactiveOAuth2AuthorizedClientProvider()\n val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .provider(jwtBearerAuthorizedClientProvider)\n .build()\n val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======\n\nYou may obtain the `OAuth2AccessToken` as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic class OAuth2ResourceServerController {\n\n\t@Autowired\n\tprivate ReactiveOAuth2AuthorizedClientManager authorizedClientManager;\n\n\t@GetMapping(\"/resource\")\n\tpublic Mono<String> resource(JwtAuthenticationToken jwtAuthentication, ServerWebExchange exchange) {\n OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(jwtAuthentication)\n .build();\n\n return this.authorizedClientManager.authorize(authorizeRequest)\n .map(OAuth2AuthorizedClient::getAccessToken)\n // ...\n .thenReturn(\"index\");\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass OAuth2ResourceServerController {\n\n @Autowired\n private lateinit var authorizedClientManager: ReactiveOAuth2AuthorizedClientManager\n\n @GetMapping(\"/resource\")\n fun resource(jwtAuthentication: JwtAuthenticationToken, exchange: ServerWebExchange): Mono<String> {\n val authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(jwtAuthentication)\n .build()\n return authorizedClientManager.authorize(authorizeRequest)\n .map { it.accessToken }\n // ...\n .thenReturn(\"index\")\n }\n}\n----\n======\n\n[NOTE]\n====\n`JwtBearerReactiveOAuth2AuthorizedClientProvider` resolves the `Jwt` assertion via `OAuth2AuthorizationContext.getPrincipal().getPrincipal()` by default, hence the use of `JwtAuthenticationToken` in the preceding example.\n====\n\n[TIP]\n====\nIf you need to resolve the `Jwt` assertion from a different source, you can provide `JwtBearerReactiveOAuth2AuthorizedClientProvider.setJwtAssertionResolver()` with a custom `Function<OAuth2AuthorizationContext, Mono<Jwt>>`.\n====\n\n[[oauth2-client-token-exchange]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Using the Access Token", "heading_level": 3, "file_order": 40, "section_index": 18, "content_hash": "3921f9ce7365a96b2242e95028a56bb03375d5169eeb0ae7a0ce57ec7711b650", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:21226644e5e18cb6d9d9bb5d44c04ff743968aaaad315beeed9e855642e73012", "content": "[NOTE]\n====\nPlease refer to OAuth 2.0 Token Exchange for further details on the https://datatracker.ietf.org/doc/html/rfc8693[Token Exchange] grant.\n====\n\n[[oauth2-client-token-exchange-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "[[oauth2Client-token-exchange-grant]]Token Exchange", "heading_level": 2, "file_order": 40, "section_index": 19, "content_hash": "21226644e5e18cb6d9d9bb5d44c04ff743968aaaad315beeed9e855642e73012", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:243d1c16fee30595d62269371db15e08a8675742e9b9fc33d8c80bbb130ea667", "content": "[NOTE]\n====\nPlease refer to the https://datatracker.ietf.org/doc/html/rfc8693#section-2[Token Exchange Request and Response] protocol flow for the Token Exchange grant.\n====\n\nThe default implementation of `ReactiveOAuth2AccessTokenResponseClient` for the Token Exchange grant is `WebClientReactiveTokenExchangeTokenResponseClient`, which uses a `WebClient` when requesting an access token at the Authorization Servers Token Endpoint.\n\nTo customize `{class-name}`, simply provide a bean as in the following example and it will be picked up by the default `ReactiveOAuth2AuthorizedClientManager` automatically:\n\n[#oauth2-client-{section-id}-access-token-response-client-bean]\n.Access Token Response Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n@Bean\npublic ReactiveOAuth2AccessTokenResponseClient<{grant-request}> accessTokenResponseClient() {\n\t{class-name} accessTokenResponseClient =\n\t\tnew {class-name}();\n\t// ...\n\treturn accessTokenResponseClient;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\n@Bean\nfun accessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<{grant-type}> {\n\tval accessTokenResponseClient = {class-name}()\n\t// ...\n\treturn accessTokenResponseClient\n}\n----\n======\n\n`{class-name}` is very flexible and provides several options for customizing the OAuth 2.0 Access Token request and response for the {grant-type} grant.\nChoose from the following use cases to learn more:\n\n* I want to <<oauth2-client-{section-id}-access-token-request-headers,customize headers of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-request-parameters,customize parameters of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-response-parameters,customize parameters of the Access Token response>>\n* I want to <<oauth2-client-{section-id}-access-token-response-web-client,customize the instance of `WebClient` that is used>>\n\n[#oauth2-client-{section-id}-access-token-request]\n== Customizing the Access Token Request\n\n`{class-name}` provides hooks for customizing HTTP headers and request parameters of the Token Request.\n\n[#oauth2-client-{section-id}-access-token-request-headers]\n=== Customizing Request Headers\n\nThere are two options for customizing HTTP headers:\n\n* Add additional headers by calling `addHeadersConverter()`\n* Fully customize headers by calling `setHeadersConverter()`\n\nYou can include additional headers without affecting the default headers added to every request using `addHeadersConverter()`.\nThe following example adds a `User-Agent` header to the request when the `registrationId` is `spring`:\n\n.Include Additional HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addHeadersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tHttpHeaders headers = new HttpHeaders();\n\tif (clientRegistration.getRegistrationId().equals(\"spring\")) {\n\t\theaders.set(HttpHeaders.USER_AGENT, \"my-user-agent\");\n\t}\n\treturn headers;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addHeadersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval headers = HttpHeaders()\n\tif (clientRegistration.getRegistrationId() == \"spring\") {\n        headers[HttpHeaders.USER_AGENT] = \"my-user-agent\"\n\t}\n\theaders\n}\n----\n======\n\nYou can fully customize headers by re-using `DefaultOAuth2TokenRequestHeadersConverter` or providing a custom implementation using `setHeadersConverter()`.\nThe following example re-uses `DefaultOAuth2TokenRequestHeadersConverter` and disables `encodeClientCredentials` so that HTTP Basic credentials are no longer encoded with `application/x-www-form-urlencoded`:\n\n.Customize HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter headersConverter =\n\tnew DefaultOAuth2TokenRequestHeadersConverter();\nheadersConverter.setEncodeClientCredentials(false);\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter()\nheadersConverter.setEncodeClientCredentials(false)\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[#oauth2-client-{section-id}-access-token-request-parameters]\n=== Customizing Request Parameters\n\nThere are three options for customizing request parameters:\n\n* Add additional parameters by calling `addParametersConverter()`\n* Override parameters by calling `setParametersConverter()`\n* Fully customize parameters by calling `setParametersCustomizer()`\n\n[NOTE]\n====\nUsing `setParametersConverter()` does not fully customize parameters because it would require the user to provide all default parameters themselves.\nDefault parameters are always provided, but can be fully customized or omitted by calling `setParametersCustomizer()`.\n====\n\nYou can include additional parameters without affecting the default parameters added to every request using `addParametersConverter()`.\nThe following example adds an `audience` parameter to the request when the `registrationId` is `keycloak`:\n\n.Include Additional Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tMultiValueMap<String, String> parameters = new LinkedMultiValueMap<String, String>();\n\tif (clientRegistration.getRegistrationId().equals(\"keycloak\")) {\n\t\tparameters.set(OAuth2ParameterNames.AUDIENCE, \"my-audience\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addParametersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"keycloak\") {\n        parameters[OAuth2ParameterNames.AUDIENCE] = \"my-audience\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can override default parameters using `setParametersConverter()`.\nThe following example overrides the `client_id` parameter when the `registrationId` is `okta`:\n\n.Override Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tLinkedMultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n\tif (clientRegistration.getRegistrationId().equals(\"okta\")) {\n\t\tparameters.set(OAuth2ParameterNames.CLIENT_ID, \"my-client\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersConverter { grantRequest ->\n    val clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"okta\") {\n        parameters[OAuth2ParameterNames.CLIENT_ID] = \"my-client\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can fully customize parameters (including omitting default parameters) using `setParametersCustomizer()`.\nThe following example omits the `client_id` parameter when the `client_assertion` parameter is present in the request:\n\n.Omit Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersCustomizer(parameters -> {\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID);\n\t}\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response]\n== Customizing the Access Token Response\n\n`{class-name}` provides hooks for customizing the OAuth 2.0 Access Token Response.\n\n[#oauth2-client-{section-id}-access-token-response-parameters]\n=== Customizing Response Parameters\n\nYou can customize the conversion of Token Response parameters to an `OAuth2AccessTokenResponse` by calling `setBodyExtractor()`.\nThe default implementation provided by `OAuth2BodyExtractors.oauth2AccessTokenResponse()` parses the response and handles errors accordingly.\n\nThe following example provides a starting point for customizing the conversion of Token Response parameters to an `OAuth2AccessTokenResponse`:\n\n.Customize Body Extractor\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\n\nBodyExtractor<Mono<Map<String, Object>>, ReactiveHttpInputMessage> bodyExtractor =\n\tBodyExtractors.toMono(new ParameterizedTypeReference<>() {});\naccessTokenResponseClient.setBodyExtractor((inputMessage, context) ->\n\tbodyExtractor.extract(inputMessage, context)\n\t\t.map((parameters) -> parameters.withToken(\"custom-token\")\n\t\t\t// ...\n\t\t\t.build()\n\t\t)\n);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\n\nval bodyExtractor = BodyExtractors.toMono(object : ParameterizedTypeReference<Map<String, Any>>() {})\naccessTokenResponseClient.setBodyExtractor { inputMessage, context ->\n\tbodyExtractor.extract(inputMessage, context).map { parameters ->\n\t\tOAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t\t// ...\n\t\t\t.build()\n\t}\n}\n----\n======\n\n[CAUTION]\n====\nWhen providing a custom `BodyExtractor`, you are responsible for detecting and converting an OAuth 2.0 Error Response to a `Mono.error()` with `OAuth2Error` based on parameters of the response.\n====\n\n[#oauth2-client-{section-id}-access-token-response-web-client]\n=== Customizing the `WebClient`\n\nAlternatively, if your requirements are more advanced, you can take full control of the request and/or response by providing a pre-configured `WebClient` to `setWebClient()` as the following example shows:\n\n.Customize `WebClient`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nWebClient webClient = WebClient.builder()\n\t// ...\n\t.build();\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setWebClient(webClient);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval webClient = WebClient.builder()\n\t// ...\n\t.build()\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setWebClient(webClient)\n----\n======\n\n[[oauth2-client-token-exchange-authorized-client-provider-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Requesting an Access Token", "heading_level": 3, "file_order": 40, "section_index": 20, "content_hash": "243d1c16fee30595d62269371db15e08a8675742e9b9fc33d8c80bbb130ea667", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:1c37f203e1646d9ffd050a91be14894777c1acf96c1f2413ec8665dd9978af73", "content": "Whether you customize `WebClientReactiveTokenExchangeTokenResponseClient` or provide your own implementation of `ReactiveOAuth2AccessTokenResponseClient`, you can configure it using the `ReactiveOAuth2AuthorizedClientProviderBuilder` (as an alternative to <<oauth2-client-token-exchange-access-token-response-client-bean,publishing a bean>>) as follows:\n\n.Access Token Response Configuration via Builder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> tokenExchangeTokenResponseClient = ...\n\nTokenExchangeReactiveOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider = new TokenExchangeReactiveOAuth2AuthorizedClientProvider();\ntokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeTokenResponseClient);\n\nReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .provider(tokenExchangeAuthorizedClientProvider)\n .build();\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval tokenExchangeTokenResponseClient: ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> = ...\n\nval tokenExchangeAuthorizedClientProvider = TokenExchangeReactiveOAuth2AuthorizedClientProvider()\ntokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeTokenResponseClient)\n\nval authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .provider(tokenExchangeAuthorizedClientProvider)\n .build()\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n----\n======\n\n[[oauth2-client-token-exchange-authorized-client-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customize using the Builder", "heading_level": 3, "file_order": 40, "section_index": 21, "content_hash": "1c37f203e1646d9ffd050a91be14894777c1acf96c1f2413ec8665dd9978af73", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:ac285f1d3c7d2eaab9b5b9bf33464a507606badeaf273f7c6707e6c052c05fd4", "content": "Given the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n authorization-grant-type: urn:ietf:params:oauth:grant-type:token-exchange\n scope: read\n provider:\n okta:\n token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token\n----\n\n...and the `OAuth2AuthorizedClientManager` `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveOAuth2AuthorizedClientManager authorizedClientManager(\n ReactiveClientRegistrationRepository clientRegistrationRepository,\n ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tTokenExchangeReactiveOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider =\n new TokenExchangeReactiveOAuth2AuthorizedClientProvider();\n\n\tReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .provider(tokenExchangeAuthorizedClientProvider)\n .build();\n\n\tDefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ReactiveClientRegistrationRepository,\n authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {\n val tokenExchangeAuthorizedClientProvider = TokenExchangeReactiveOAuth2AuthorizedClientProvider()\n val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .provider(tokenExchangeAuthorizedClientProvider)\n .build()\n val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======\n\nYou may obtain the `OAuth2AccessToken` as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic class OAuth2ResourceServerController {\n\n\t@Autowired\n\tprivate ReactiveOAuth2AuthorizedClientManager authorizedClientManager;\n\n\t@GetMapping(\"/resource\")\n\tpublic Mono<String> resource(JwtAuthenticationToken jwtAuthentication) {\n OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(jwtAuthentication)\n .build();\n\n return this.authorizedClientManager.authorize(authorizeRequest)\n .map(OAuth2AuthorizedClient::getAccessToken)\n // ...\n .thenReturn(\"index\");\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass OAuth2ResourceServerController {\n\n @Autowired\n private lateinit var authorizedClientManager: ReactiveOAuth2AuthorizedClientManager\n\n @GetMapping(\"/resource\")\n fun resource(jwtAuthentication: JwtAuthenticationToken): Mono<String> {\n val authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(jwtAuthentication)\n .build()\n return authorizedClientManager.authorize(authorizeRequest)\n .map { it.accessToken }\n // ...\n .thenReturn(\"index\")\n }\n}\n----\n======\n\n[NOTE]\n====\n`TokenExchangeReactiveOAuth2AuthorizedClientProvider` resolves the subject token (as an `OAuth2Token`) via `OAuth2AuthorizationContext.getPrincipal().getPrincipal()` by default, hence the use of `JwtAuthenticationToken` in the preceding example.\nAn actor token is not resolved by default.\n====\n\n[TIP]\n====\nIf you need to resolve the subject token from a different source, you can provide `TokenExchangeReactiveOAuth2AuthorizedClientProvider.setSubjectTokenResolver()` with a custom `Function<OAuth2AuthorizationContext, Mono<OAuth2Token>>`.\n====\n\n[TIP]\n====\nIf you need to resolve an actor token, you can provide `TokenExchangeReactiveOAuth2AuthorizedClientProvider.setActorTokenResolver()` with a custom `Function<OAuth2AuthorizationContext, Mono<OAuth2Token>>`.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Using the Access Token", "heading_level": 3, "file_order": 40, "section_index": 22, "content_hash": "ac285f1d3c7d2eaab9b5b9bf33464a507606badeaf273f7c6707e6c052c05fd4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:4887c3ba59b73453575ae7a2952f9a46d6dcb3c7fefcd563506451b700ec71bd", "content": "[[oauth2-client-additional-features]]\n\nThis section covers additional features provided by Spring Security for OAuth2 Client.\n\n[[oauth2-client-registered-authorized-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "authorized-clients", "heading_level": 1, "file_order": 41, "section_index": 0, "content_hash": "4887c3ba59b73453575ae7a2952f9a46d6dcb3c7fefcd563506451b700ec71bd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:c1c4a0746e45e8c1b617abf942f6b878152b04c0c5728363cb3967186016f90c", "content": "The `@RegisteredOAuth2AuthorizedClient` annotation provides the capability of resolving a method parameter to an argument value of type `OAuth2AuthorizedClient`.\nThis is a convenient alternative compared to accessing the `OAuth2AuthorizedClient` using the `ReactiveOAuth2AuthorizedClientManager` or `ReactiveOAuth2AuthorizedClientService`.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class OAuth2ClientController {\n\n\t@GetMapping(\"/\")\n\tpublic Mono<String> index(@RegisteredOAuth2AuthorizedClient(\"okta\") OAuth2AuthorizedClient authorizedClient) {\n return Mono.just(authorizedClient.getAccessToken())\n ...\n .thenReturn(\"index\");\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nclass OAuth2ClientController {\n @GetMapping(\"/\")\n fun index(@RegisteredOAuth2AuthorizedClient(\"okta\") authorizedClient: OAuth2AuthorizedClient): Mono<String> {\n return Mono.just(authorizedClient.accessToken)\n ...\n .thenReturn(\"index\")\n }\n}\n----\n======\n\nThe `@RegisteredOAuth2AuthorizedClient` annotation is handled by `OAuth2AuthorizedClientArgumentResolver`, which directly uses a xref:reactive/oauth2/client/core.adoc#oauth2Client-authorized-manager-provider[ReactiveOAuth2AuthorizedClientManager] and therefore inherits it's capabilities.\n\n[[oauth2-client-web-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "[[oauth2Client-registered-authorized-client]]Resolving an Authorized Client", "heading_level": 2, "file_order": 41, "section_index": 1, "content_hash": "c1c4a0746e45e8c1b617abf942f6b878152b04c0c5728363cb3967186016f90c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:5cdbe72391430b1bfa2de0ea174ca34e6a16e00ebdddf30ee5441b611914a8bb", "content": "The OAuth 2.0 Client support integrates with `WebClient` using an `ExchangeFilterFunction`.\n\nThe `ServerOAuth2AuthorizedClientExchangeFilterFunction` provides a simple mechanism for requesting protected resources by using an `OAuth2AuthorizedClient` and including the associated `OAuth2AccessToken` as a Bearer Token.\nIt directly uses an xref:reactive/oauth2/client/core.adoc#oauth2Client-authorized-manager-provider[ReactiveOAuth2AuthorizedClientManager] and therefore inherits the following capabilities:\n\n* An `OAuth2AccessToken` will be requested if the client has not yet been authorized.\n** `authorization_code` - triggers the Authorization Request redirect to initiate the flow\n** `client_credentials` - the access token is obtained directly from the Token Endpoint\n* If the `OAuth2AccessToken` is expired, it will be refreshed (or renewed) if a `ReactiveOAuth2AuthorizedClientProvider` is available to perform the authorization\n\nThe following code shows an example of how to configure `WebClient` with OAuth 2.0 Client support:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nWebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) {\n\tServerOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =\n new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);\n\treturn WebClient.builder()\n .filter(oauth2Client)\n .build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient {\n val oauth2Client = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)\n return WebClient.builder()\n .filter(oauth2Client)\n .build()\n}\n----\n======\n\n[[oauth2-client-web-client-authorized-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "[[oauth2Client-webclient-webflux]]WebClient integration for Reactive Environments", "heading_level": 2, "file_order": 41, "section_index": 2, "content_hash": "5cdbe72391430b1bfa2de0ea174ca34e6a16e00ebdddf30ee5441b611914a8bb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:6860d27a7263207429cc31ab17cd86199a462d7dc2703dc6fcd6b052381e7663", "content": "The `ServerOAuth2AuthorizedClientExchangeFilterFunction` determines the client to use (for a request) by resolving the `OAuth2AuthorizedClient` from the `ClientRequest.attributes()` (request attributes).\n\nThe following code shows how to set an `OAuth2AuthorizedClient` as a request attribute:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/\")\npublic Mono<String> index(@RegisteredOAuth2AuthorizedClient(\"okta\") OAuth2AuthorizedClient authorizedClient) {\n\tString resourceUri = ...\n\n\treturn webClient\n .get()\n .uri(resourceUri)\n .attributes(oauth2AuthorizedClient(authorizedClient)) <1>\n .retrieve()\n .bodyToMono(String.class)\n ...\n .thenReturn(\"index\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/\")\nfun index(@RegisteredOAuth2AuthorizedClient(\"okta\") authorizedClient: OAuth2AuthorizedClient): Mono<String> {\n val resourceUri: String = ...\n\n return webClient\n .get()\n .uri(resourceUri)\n .attributes(oauth2AuthorizedClient(authorizedClient)) <1>\n .retrieve()\n .bodyToMono<String>()\n ...\n .thenReturn(\"index\")\n}\n----\n======\n\n<1> `oauth2AuthorizedClient()` is a `static` method in `ServerOAuth2AuthorizedClientExchangeFilterFunction`.\n\nThe following code shows how to set the `ClientRegistration.getRegistrationId()` as a request attribute:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/\")\npublic Mono<String> index() {\n\tString resourceUri = ...\n\n\treturn webClient\n .get()\n .uri(resourceUri)\n .attributes(clientRegistrationId(\"okta\")) <1>\n .retrieve()\n .bodyToMono(String.class)\n ...\n .thenReturn(\"index\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/\")\nfun index(): Mono<String> {\n val resourceUri: String = ...\n\n return webClient\n .get()\n .uri(resourceUri)\n .attributes(clientRegistrationId(\"okta\")) <1>\n .retrieve()\n .bodyToMono<String>()\n ...\n .thenReturn(\"index\")\n}\n----\n======\n<1> `clientRegistrationId()` is a `static` method in `ServerOAuth2AuthorizedClientExchangeFilterFunction`.\n\n[[oauth2-client-web-client-default-authorized-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "Providing the Authorized Client", "heading_level": 3, "file_order": 41, "section_index": 3, "content_hash": "6860d27a7263207429cc31ab17cd86199a462d7dc2703dc6fcd6b052381e7663", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:9ea8f82bb3998297dfe55fc501cbbc1e9f784c766f0873e5cf9e4556785aadf0", "content": "If neither `OAuth2AuthorizedClient` or `ClientRegistration.getRegistrationId()` is provided as a request attribute, the `ServerOAuth2AuthorizedClientExchangeFilterFunction` can determine the _default_ client to use depending on it's configuration.\n\nIf `setDefaultOAuth2AuthorizedClient(true)` is configured and the user has authenticated using `ServerHttpSecurity.oauth2Login()`, the `OAuth2AccessToken` associated with the current `OAuth2AuthenticationToken` is used.\n\nThe following code shows the specific configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nWebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) {\n\tServerOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =\n new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);\n\toauth2Client.setDefaultOAuth2AuthorizedClient(true);\n\treturn WebClient.builder()\n .filter(oauth2Client)\n .build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient {\n val oauth2Client = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)\n oauth2Client.setDefaultOAuth2AuthorizedClient(true)\n return WebClient.builder()\n .filter(oauth2Client)\n .build()\n}\n----\n======\n\n[WARNING]\n====\nIt is recommended to be cautious with this feature since all HTTP requests will receive the access token.\n====\n\nAlternatively, if `setDefaultClientRegistrationId(\"okta\")` is configured with a valid `ClientRegistration`, the `OAuth2AccessToken` associated with the `OAuth2AuthorizedClient` is used.\n\nThe following code shows the specific configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nWebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) {\n\tServerOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =\n new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);\n\toauth2Client.setDefaultClientRegistrationId(\"okta\");\n\treturn WebClient.builder()\n .filter(oauth2Client)\n .build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient {\n val oauth2Client = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)\n oauth2Client.setDefaultClientRegistrationId(\"okta\")\n return WebClient.builder()\n .filter(oauth2Client)\n .build()\n}\n----\n======\n\n[WARNING]\n====\nIt is recommended to be cautious with this feature since all HTTP requests will receive the access token.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "Defaulting the Authorized Client", "heading_level": 3, "file_order": 41, "section_index": 4, "content_hash": "9ea8f82bb3998297dfe55fc501cbbc1e9f784c766f0873e5cf9e4556785aadf0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:d673726e06614844d59b3b478e363b46d63b7645a98ab174dacdb055123add1a", "content": "[[oauth2-client-authentication]]\n\n[[oauth2-client-authentication-client-credentials]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "client-authentication", "heading_level": 1, "file_order": 42, "section_index": 0, "content_hash": "d673726e06614844d59b3b478e363b46d63b7645a98ab174dacdb055123add1a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:112041afa17307ff1168d7ae6b7f648538036e18124e57938bd0585419eb3c81", "content": "[[oauth2-client-authentication-client-credentials-client-secret-basic]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "[[oauth2Client-client-credentials-auth]]Client Credentials", "heading_level": 2, "file_order": 42, "section_index": 1, "content_hash": "112041afa17307ff1168d7ae6b7f648538036e18124e57938bd0585419eb3c81", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:a424a0d2063b7a3a0ae0d24ed6ff8f010b6dd83966561a3d6e60dbdd71660145", "content": "Client Authentication with HTTP Basic is supported out of the box and no customization is necessary to enable it.\nThe default implementation is provided by `DefaultOAuth2TokenRequestHeadersConverter`.\n\nGiven the following Spring Boot properties for an OAuth 2.0 client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: client-id\n client-secret: client-secret\n client-authentication-method: client_secret_basic\n authorization-grant-type: authorization_code\n ...\n----\n\nThe following example shows how to configure `WebClientReactiveAuthorizationCodeTokenResponseClient` to disable URL encoding of the client credentials:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter<OAuth2AuthorizationCodeGrantRequest> headersConverter =\n new DefaultOAuth2TokenRequestHeadersConverter<>();\nheadersConverter.setEncodeClientCredentials(false);\n\nWebClientReactiveAuthorizationCodeTokenResponseClient tokenResponseClient =\n new WebClientReactiveAuthorizationCodeTokenResponseClient();\ntokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter<OAuth2AuthorizationCodeGrantRequest>()\nheadersConverter.setEncodeClientCredentials(false)\n\nval tokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()\ntokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[[oauth2-client-authentication-client-credentials-client-secret-post]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "Authenticate using `client_secret_basic`", "heading_level": 3, "file_order": 42, "section_index": 2, "content_hash": "a424a0d2063b7a3a0ae0d24ed6ff8f010b6dd83966561a3d6e60dbdd71660145", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:e77e7cf7555475d47e3c50ec59f9e94d72c6e8715c86e2e6a18f20f92d7063e5", "content": "Client Authentication with client credentials included in the request-body is supported out of the box and no customization is necessary to enable it.\n\nThe following Spring Boot properties for an OAuth 2.0 client registration demonstrate the configuration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: client-id\n client-secret: client-secret\n client-authentication-method: client_secret_post\n authorization-grant-type: authorization_code\n ...\n----\n\n[[oauth2-client-authentication-jwt-bearer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "Authenticate using `client_secret_post`", "heading_level": 3, "file_order": 42, "section_index": 3, "content_hash": "e77e7cf7555475d47e3c50ec59f9e94d72c6e8715c86e2e6a18f20f92d7063e5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:c577fa3a4cfac7d5ec137ab967a8860a6d61f9de815743e0abe907a1b55faaa5", "content": "[NOTE]\n====\nPlease refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on https://datatracker.ietf.org/doc/html/rfc7523#section-2.2[JWT Bearer] Client Authentication.\n====\n\nThe default implementation for JWT Bearer Client Authentication is `NimbusJwtClientAuthenticationParametersConverter`,\nwhich is a `Converter` that customizes the Token Request parameters by adding\na signed JSON Web Token (JWS) in the `client_assertion` parameter.\n\nThe `java.security.PrivateKey` or `javax.crypto.SecretKey` used for signing the JWS\nis supplied by the `com.nimbusds.jose.jwk.JWK` resolver associated with `NimbusJwtClientAuthenticationParametersConverter`.\n\n[[oauth2-client-authentication-jwt-bearer-private-key-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "[[oauth2Client-jwt-bearer-auth]]JWT Bearer", "heading_level": 2, "file_order": 42, "section_index": 4, "content_hash": "c577fa3a4cfac7d5ec137ab967a8860a6d61f9de815743e0abe907a1b55faaa5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:cc4cfab933965a4f2cf207d4014d17a73cd804a89a436c6b1481af2807c53b45", "content": "Given the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-authentication-method: private_key_jwt\n authorization-grant-type: authorization_code\n ...\n----\n\nThe following example shows how to configure `WebClientReactiveAuthorizationCodeTokenResponseClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nFunction<ClientRegistration, JWK> jwkResolver = (clientRegistration) -> {\n\tif (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) {\n // Assuming RSA key type\n RSAPublicKey publicKey = ...\n RSAPrivateKey privateKey = ...\n return new RSAKey.Builder(publicKey)\n .privateKey(privateKey)\n .keyID(UUID.randomUUID().toString())\n .build();\n\t}\n\treturn null;\n};\n\nWebClientReactiveAuthorizationCodeTokenResponseClient tokenResponseClient =\n new WebClientReactiveAuthorizationCodeTokenResponseClient();\ntokenResponseClient.addParametersConverter(\n new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwkResolver: Function<ClientRegistration, JWK> =\n Function<ClientRegistration, JWK> { clientRegistration ->\n if (clientRegistration.clientAuthenticationMethod.equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) {\n // Assuming RSA key type\n var publicKey: RSAPublicKey = ...\n var privateKey: RSAPrivateKey = ...\n RSAKey.Builder(publicKey)\n .privateKey(privateKey)\n .keyID(UUID.randomUUID().toString())\n .build()\n }\n null\n }\n\nval tokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()\ntokenResponseClient.addParametersConverter(\n NimbusJwtClientAuthenticationParametersConverter(jwkResolver)\n)\n----\n======\n\n[[oauth2-client-authentication-jwt-bearer-client-secret-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "Authenticate using `private_key_jwt`", "heading_level": 3, "file_order": 42, "section_index": 5, "content_hash": "cc4cfab933965a4f2cf207d4014d17a73cd804a89a436c6b1481af2807c53b45", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:7f585a4e273d562eff910c0b5cfd2a2aec09efef158fb03b9340a1161d1f45fc", "content": "Given the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n client-authentication-method: client_secret_jwt\n authorization-grant-type: client_credentials\n ...\n----\n\nThe following example shows how to configure `WebClientReactiveClientCredentialsTokenResponseClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nFunction<ClientRegistration, JWK> jwkResolver = (clientRegistration) -> {\n\tif (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.CLIENT_SECRET_JWT)) {\n SecretKeySpec secretKey = new SecretKeySpec(\n clientRegistration.getClientSecret().getBytes(StandardCharsets.UTF_8),\n \"HmacSHA256\");\n return new OctetSequenceKey.Builder(secretKey)\n .keyID(UUID.randomUUID().toString())\n .build();\n\t}\n\treturn null;\n};\n\nWebClientReactiveClientCredentialsTokenResponseClient tokenResponseClient =\n new WebClientReactiveClientCredentialsTokenResponseClient();\ntokenResponseClient.addParametersConverter(\n new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwkResolver = Function<ClientRegistration, JWK?> { clientRegistration: ClientRegistration ->\n if (clientRegistration.clientAuthenticationMethod == ClientAuthenticationMethod.CLIENT_SECRET_JWT) {\n val secretKey = SecretKeySpec(\n clientRegistration.clientSecret.toByteArray(StandardCharsets.UTF_8),\n \"HmacSHA256\"\n )\n OctetSequenceKey.Builder(secretKey)\n .keyID(UUID.randomUUID().toString())\n .build()\n }\n null\n}\n\nval tokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient()\ntokenResponseClient.addParametersConverter(\n NimbusJwtClientAuthenticationParametersConverter(jwkResolver)\n)\n----\n======\n\n[[oauth2-client-authentication-jwt-bearer-assertion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "Authenticate using `client_secret_jwt`", "heading_level": 3, "file_order": 42, "section_index": 6, "content_hash": "7f585a4e273d562eff910c0b5cfd2a2aec09efef158fb03b9340a1161d1f45fc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:62d6450842a700c27322e932ca304d3cf716b8d82576d39bdc206453a8a1be11", "content": "The JWT produced by `NimbusJwtClientAuthenticationParametersConverter` contains the `iss`, `sub`, `aud`, `jti`, `iat` and `exp` claims by default. You can customize the headers and/or claims by providing a `Consumer<NimbusJwtClientAuthenticationParametersConverter.JwtClientAuthenticationContext<T>>` to `setJwtClientAssertionCustomizer()`. The following example shows how to customize claims of the JWT:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nFunction<ClientRegistration, JWK> jwkResolver = ...\n\nNimbusJwtClientAuthenticationParametersConverter<OAuth2ClientCredentialsGrantRequest> converter =\n new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver);\nconverter.setJwtClientAssertionCustomizer((context) -> {\n\tcontext.getHeaders().header(\"custom-header\", \"header-value\");\n\tcontext.getClaims().claim(\"custom-claim\", \"claim-value\");\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwkResolver = ...\n\nval converter: NimbusJwtClientAuthenticationParametersConverter<OAuth2ClientCredentialsGrantRequest> =\n NimbusJwtClientAuthenticationParametersConverter(jwkResolver)\nconverter.setJwtClientAssertionCustomizer { context ->\n context.headers.header(\"custom-header\", \"header-value\")\n context.claims.claim(\"custom-claim\", \"claim-value\")\n}\n----\n======\n\n[[oauth2-client-authentication-public]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "Customizing the JWT assertion", "heading_level": 3, "file_order": 42, "section_index": 7, "content_hash": "62d6450842a700c27322e932ca304d3cf716b8d82576d39bdc206453a8a1be11", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:8e2580d36a07dfd49bf8c5a48dbe84e919f7d4ac485818b5e58d5736956ef2b6", "content": "Public Client Authentication is supported out of the box and no customization is necessary to enable it.\n\nThe following Spring Boot properties for an OAuth 2.0 client registration demonstrate the configuration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: client-id\n client-authentication-method: none\n authorization-grant-type: authorization_code\n ...\n----\n\n[NOTE]\n====\nPublic Clients are supported using https://tools.ietf.org/html/rfc7636[Proof Key for Code Exchange] (PKCE).\nPKCE will automatically be used when `client-authentication-method` is set to \"none\" (`ClientAuthenticationMethod.NONE`).\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "[[oauth2Client-public-auth]]Public Authentication", "heading_level": 2, "file_order": 42, "section_index": 8, "content_hash": "8e2580d36a07dfd49bf8c5a48dbe84e919f7d4ac485818b5e58d5736956ef2b6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:dca6c7d3a7859aeb2bcda4876b729a3ce67ad4655dc2a2d09d1de9ec217b10a2", "content": "[[oauth2Client-core-interface-class]]\n\n[[oauth2Client-client-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc", "title": "core", "heading": "core", "heading_level": 1, "file_order": 43, "section_index": 0, "content_hash": "dca6c7d3a7859aeb2bcda4876b729a3ce67ad4655dc2a2d09d1de9ec217b10a2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc"}}
{"id": "sha256:49c8b21bb4393e8bd85323a1f6771e13206f90f3289cc36ede607f80c475710c", "content": "`ClientRegistration` is a representation of a client registered with an OAuth 2.0 or OpenID Connect 1.0 Provider.\n\nA client registration holds information, such as client id, client secret, authorization grant type, redirect URI, scope(s), authorization URI, token URI, and other details.\n\n`ClientRegistration` and its properties are defined as follows:\n\n[source,java]\n----\npublic final class ClientRegistration {\n\tprivate String registrationId;\t<1>\n\tprivate String clientId;\t<2>\n\tprivate String clientSecret;\t<3>\n\tprivate ClientAuthenticationMethod clientAuthenticationMethod;\t<4>\n\tprivate AuthorizationGrantType authorizationGrantType;\t<5>\n\tprivate String redirectUri;\t<6>\n\tprivate Set<String> scopes;\t<7>\n\tprivate ProviderDetails providerDetails;\n\tprivate String clientName;\t<8>\n\n\tpublic class ProviderDetails {\n private String authorizationUri;\t<9>\n private String tokenUri;\t<10>\n private UserInfoEndpoint userInfoEndpoint;\n private String jwkSetUri;\t<11>\n private String issuerUri;\t<12>\n private Map<String, Object> configurationMetadata; <13>\n\n public class UserInfoEndpoint {\n private String uri;\t<14>\n private AuthenticationMethod authenticationMethod; <15>\n private String userNameAttributeName;\t<16>\n\n }\n\t}\n\n\tpublic static final class ClientSettings {\n private boolean requireProofKey; // <17>\n\t}\n}\n----\n<1> `registrationId`: The ID that uniquely identifies the `ClientRegistration`.\n<2> `clientId`: The client identifier.\n<3> `clientSecret`: The client secret.\n<4> `clientAuthenticationMethod`: The method used to authenticate the Client with the Provider.\nThe supported values are *client_secret_basic*, *client_secret_post*, *private_key_jwt*, *client_secret_jwt* and *none* https://tools.ietf.org/html/rfc6749#section-2.1[(public clients)].\n<5> `authorizationGrantType`: The OAuth 2.0 Authorization Framework defines four https://tools.ietf.org/html/rfc6749#section-1.3[Authorization Grant] types.\n The supported values are `authorization_code`, `client_credentials`, as well as, extension grant type `urn:ietf:params:oauth:grant-type:jwt-bearer`.\n<6> `redirectUri`: The client's registered redirect URI that the _Authorization Server_ redirects the end-user's user-agent\n to after the end-user has authenticated and authorized access to the client.\n<7> `scopes`: The scope(s) requested by the client during the Authorization Request flow, such as openid, email, or profile.\n<8> `clientName`: A descriptive name used for the client.\nThe name may be used in certain scenarios, such as when displaying the name of the client in the auto-generated login page.\n<9> `authorizationUri`: The Authorization Endpoint URI for the Authorization Server.\n<10> `tokenUri`: The Token Endpoint URI for the Authorization Server.\n<11> `jwkSetUri`: The URI used to retrieve the https://tools.ietf.org/html/rfc7517[JSON Web Key (JWK)] Set from the Authorization Server,\n which contains the cryptographic key(s) used to verify the https://tools.ietf.org/html/rfc7515[JSON Web Signature (JWS)] of the ID Token and optionally the UserInfo Response.\n<12> `issuerUri`: Returns the issuer identifier uri for the OpenID Connect 1.0 provider or the OAuth 2.0 Authorization Server.\n<13> `configurationMetadata`: The https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[OpenID Provider Configuration Information].\n This information will only be available if the Spring Boot property `spring.security.oauth2.client.provider.[providerId].issuerUri` is configured.\n<14> `(userInfoEndpoint)uri`: The UserInfo Endpoint URI used to access the claims/attributes of the authenticated end-user.\n<15> `(userInfoEndpoint)authenticationMethod`: The authentication method used when sending the access token to the UserInfo Endpoint.\nThe supported values are *header*, *form* and *query*.\n<16> `userNameAttributeName`: The name of the attribute returned in the UserInfo Response that references the Name or Identifier of the end-user.\n<17> [[oauth2Client-client-registration-requireProofKey]]`requireProofKey`: If `true` or if `clientAuthenticationMethod` is `none`, then PKCE will be enabled. Defaults to `true` for `authorization_code` grant type and `false` for other grant types.\n\nA `ClientRegistration` can be initially configured using discovery of an OpenID Connect Provider's https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[Configuration endpoint] or an Authorization Server's https://tools.ietf.org/html/rfc8414#section-3[Metadata endpoint].\n\n`ClientRegistrations` provides convenience methods for configuring a `ClientRegistration` in this way, as can be seen in the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nClientRegistration clientRegistration =\n\tClientRegistrations.fromIssuerLocation(\"https://idp.example.com/issuer\").build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval clientRegistration = ClientRegistrations.fromIssuerLocation(\"https://idp.example.com/issuer\").build()\n----\n======\n\nThe above code will query in series `https://idp.example.com/issuer/.well-known/openid-configuration`, and then `https://idp.example.com/.well-known/openid-configuration/issuer`, and finally `https://idp.example.com/.well-known/oauth-authorization-server/issuer`, stopping at the first to return a 200 response.\n\nAs an alternative, you can use `ClientRegistrations.fromOidcIssuerLocation()` to only query the OpenID Connect Provider's Configuration endpoint.\n\n[[oauth2Client-client-registration-repo]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc", "title": "core", "heading": "ClientRegistration", "heading_level": 2, "file_order": 43, "section_index": 1, "content_hash": "49c8b21bb4393e8bd85323a1f6771e13206f90f3289cc36ede607f80c475710c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc"}}
{"id": "sha256:a0c90f5a98fa5e52aebca04d2554be4eaad3277b8c3eb2345ee064a9f62fb84f", "content": "The `ReactiveClientRegistrationRepository` serves as a repository for OAuth 2.0 / OpenID Connect 1.0 `ClientRegistration`(s).\n\n[NOTE]\n====\nClient registration information is ultimately stored and owned by the associated Authorization Server.\nThis repository provides the ability to retrieve a sub-set of the primary client registration information, which is stored with the Authorization Server.\n====\n\nSpring Boot auto-configuration binds each of the properties under `spring.security.oauth2.client.registration._[registrationId]_` to an instance of `ClientRegistration` and then composes each of the `ClientRegistration` instance(s) within a `ReactiveClientRegistrationRepository`.\n\n[NOTE]\n====\nThe default implementation of `ReactiveClientRegistrationRepository` is `InMemoryReactiveClientRegistrationRepository`.\n====\n\nThe auto-configuration also registers the `ReactiveClientRegistrationRepository` as a `@Bean` in the `ApplicationContext` so that it is available for dependency-injection, if needed by the application.\n\nThe following listing shows an example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class OAuth2ClientController {\n\n\t@Autowired\n\tprivate ReactiveClientRegistrationRepository clientRegistrationRepository;\n\n\t@GetMapping(\"/\")\n\tpublic Mono<String> index() {\n return this.clientRegistrationRepository.findByRegistrationId(\"okta\")\n ...\n .thenReturn(\"index\");\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nclass OAuth2ClientController {\n\n @Autowired\n private lateinit var clientRegistrationRepository: ReactiveClientRegistrationRepository\n\n @GetMapping(\"/\")\n fun index(): Mono<String> {\n return this.clientRegistrationRepository.findByRegistrationId(\"okta\")\n ...\n .thenReturn(\"index\")\n }\n}\n----\n======\n\n[[oauth2Client-authorized-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc", "title": "core", "heading": "ReactiveClientRegistrationRepository", "heading_level": 2, "file_order": 43, "section_index": 2, "content_hash": "a0c90f5a98fa5e52aebca04d2554be4eaad3277b8c3eb2345ee064a9f62fb84f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc"}}
{"id": "sha256:b85b207094b7c81fe73d402a5d491022966a9a33d09c611709a34ba59cd9d2b8", "content": "`OAuth2AuthorizedClient` is a representation of an Authorized Client.\nA client is considered to be authorized when the end-user (Resource Owner) has granted authorization to the client to access its protected resources.\n\n`OAuth2AuthorizedClient` serves the purpose of associating an `OAuth2AccessToken` (and optional `OAuth2RefreshToken`) to a `ClientRegistration` (client) and resource owner, who is the `Principal` end-user that granted the authorization.\n\n[[oauth2Client-authorized-repo-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc", "title": "core", "heading": "OAuth2AuthorizedClient", "heading_level": 2, "file_order": 43, "section_index": 3, "content_hash": "b85b207094b7c81fe73d402a5d491022966a9a33d09c611709a34ba59cd9d2b8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc"}}
{"id": "sha256:2ba38b8b935bfab254ef60167215ee4ab7d473b6fcb33db7423158f9419539f3", "content": "`ServerOAuth2AuthorizedClientRepository` is responsible for persisting `OAuth2AuthorizedClient`(s) between web requests.\nWhereas, the primary role of `ReactiveOAuth2AuthorizedClientService` is to manage `OAuth2AuthorizedClient`(s) at the application-level.\n\nFrom a developer perspective, the `ServerOAuth2AuthorizedClientRepository` or `ReactiveOAuth2AuthorizedClientService` provides the capability to lookup an `OAuth2AccessToken` associated with a client so that it may be used to initiate a protected resource request.\n\nThe following listing shows an example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class OAuth2ClientController {\n\n\t@Autowired\n\tprivate ReactiveOAuth2AuthorizedClientService authorizedClientService;\n\n\t@GetMapping(\"/\")\n\tpublic Mono<String> index(Authentication authentication) {\n return this.authorizedClientService.loadAuthorizedClient(\"okta\", authentication.getName())\n .map(OAuth2AuthorizedClient::getAccessToken)\n ...\n .thenReturn(\"index\");\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nclass OAuth2ClientController {\n\n @Autowired\n private lateinit var authorizedClientService: ReactiveOAuth2AuthorizedClientService\n\n @GetMapping(\"/\")\n fun index(authentication: Authentication): Mono<String> {\n return this.authorizedClientService.loadAuthorizedClient<OAuth2AuthorizedClient>(\"okta\", authentication.name)\n .map { it.accessToken }\n ...\n .thenReturn(\"index\")\n }\n}\n----\n======\n\n[NOTE]\n====\nSpring Boot auto-configuration registers an `ServerOAuth2AuthorizedClientRepository` and/or `ReactiveOAuth2AuthorizedClientService` `@Bean` in the `ApplicationContext`.\nHowever, the application may choose to override and register a custom `ServerOAuth2AuthorizedClientRepository` or `ReactiveOAuth2AuthorizedClientService` `@Bean`.\n====\n\nThe default implementation of `ReactiveOAuth2AuthorizedClientService` is `InMemoryReactiveOAuth2AuthorizedClientService`, which stores `OAuth2AuthorizedClient`(s) in-memory.\n\nAlternatively, the R2DBC implementation `R2dbcReactiveOAuth2AuthorizedClientService` may be configured for persisting `OAuth2AuthorizedClient`(s) in a database.\n\n[NOTE]\n====\n`R2dbcReactiveOAuth2AuthorizedClientService` depends on the table definition described in xref:servlet/appendix/database-schema.adoc#dbschema-oauth2-client[ OAuth 2.0 Client Schema].\n====\n\n[[oauth2Client-authorized-manager-provider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc", "title": "core", "heading": "ServerOAuth2AuthorizedClientRepository / ReactiveOAuth2AuthorizedClientService", "heading_level": 2, "file_order": 43, "section_index": 4, "content_hash": "2ba38b8b935bfab254ef60167215ee4ab7d473b6fcb33db7423158f9419539f3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc"}}
{"id": "sha256:9290ebac95d4d4558420160670ce1e13337b0570151d8f2e74b5b51402495bd5", "content": "The `ReactiveOAuth2AuthorizedClientManager` is responsible for the overall management of `OAuth2AuthorizedClient`(s).\n\nThe primary responsibilities include:\n\n* Authorizing (or re-authorizing) an OAuth 2.0 Client, using a `ReactiveOAuth2AuthorizedClientProvider`.\n* Delegating the persistence of an `OAuth2AuthorizedClient`, typically using a `ReactiveOAuth2AuthorizedClientService` or `ServerOAuth2AuthorizedClientRepository`.\n* Delegating to a `ReactiveOAuth2AuthorizationSuccessHandler` when an OAuth 2.0 Client has been successfully authorized (or re-authorized).\n* Delegating to a `ReactiveOAuth2AuthorizationFailureHandler` when an OAuth 2.0 Client fails to authorize (or re-authorize).\n\nA `ReactiveOAuth2AuthorizedClientProvider` implements a strategy for authorizing (or re-authorizing) an OAuth 2.0 Client.\nImplementations will typically implement an authorization grant type, e.g. `authorization_code`, `client_credentials`, etc.\n\nThe default implementation of `ReactiveOAuth2AuthorizedClientManager` is `DefaultReactiveOAuth2AuthorizedClientManager`, which is associated with a `ReactiveOAuth2AuthorizedClientProvider` that may support multiple authorization grant types using a delegation-based composite.\nThe `ReactiveOAuth2AuthorizedClientProviderBuilder` may be used to configure and build the delegation-based composite.\n\nThe following code shows an example of how to configure and build a `ReactiveOAuth2AuthorizedClientProvider` composite that provides support for the `authorization_code`, `refresh_token` and `client_credentials` authorization grant types:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveOAuth2AuthorizedClientManager authorizedClientManager(\n ReactiveClientRegistrationRepository clientRegistrationRepository,\n ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .build();\n\n\tDefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ReactiveClientRegistrationRepository,\n authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {\n val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .build()\n val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======\n\nWhen an authorization attempt succeeds, the `DefaultReactiveOAuth2AuthorizedClientManager` will delegate to the `ReactiveOAuth2AuthorizationSuccessHandler`, which (by default) will save the `OAuth2AuthorizedClient` via the `ServerOAuth2AuthorizedClientRepository`.\nIn the case of a re-authorization failure, e.g. a refresh token is no longer valid, the previously saved `OAuth2AuthorizedClient` will be removed from the `ServerOAuth2AuthorizedClientRepository` via the `RemoveAuthorizedClientReactiveOAuth2AuthorizationFailureHandler`.\nThe default behaviour may be customized via `setAuthorizationSuccessHandler(ReactiveOAuth2AuthorizationSuccessHandler)` and `setAuthorizationFailureHandler(ReactiveOAuth2AuthorizationFailureHandler)`.\n\nThe `DefaultReactiveOAuth2AuthorizedClientManager` is also associated with a `contextAttributesMapper` of type `Function<OAuth2AuthorizeRequest, Mono<Map<String, Object>>>`, which is responsible for mapping attribute(s) from the `OAuth2AuthorizeRequest` to a `Map` of attributes to be associated to the `OAuth2AuthorizationContext`.\nThis can be useful when you need to supply a `ReactiveOAuth2AuthorizedClientProvider` with required (supported) attribute(s).\n\nThe following code shows an example of the `contextAttributesMapper`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveOAuth2AuthorizedClientManager authorizedClientManager(\n ReactiveClientRegistrationRepository clientRegistrationRepository,\n ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .build();\n\n\tDefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\t// Assuming the attributes are supplied as `ServerHttpRequest` parameters,\n\t// map the `ServerHttpRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`\n\tauthorizedClientManager.setContextAttributesMapper(contextAttributesMapper());\n\n\treturn authorizedClientManager;\n}\n\nprivate Function<OAuth2AuthorizeRequest, Mono<Map<String, Object>>> contextAttributesMapper() {\n\treturn authorizeRequest -> {\n Map<String, Object> contextAttributes = Collections.emptyMap();\n ServerWebExchange exchange = authorizeRequest.getAttribute(ServerWebExchange.class.getName());\n ServerHttpRequest request = exchange.getRequest();\n String param1 = request.getQueryParams().getFirst(\"param1\");\n String param2 = request.getQueryParams().getFirst(\"param2\");\n if (StringUtils.hasText(param1) && StringUtils.hasText(param2)) {\n contextAttributes = new HashMap<>();\n contextAttributes.put(\"param1\", param1);\n contextAttributes.put(\"param2\", param2);\n }\n return Mono.just(contextAttributes);\n\t};\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ReactiveClientRegistrationRepository,\n authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {\n val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .build()\n val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n\n\t// Assuming the attributes are supplied as `ServerHttpRequest` parameters,\n\t// map the `ServerHttpRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`\n authorizedClientManager.setContextAttributesMapper(contextAttributesMapper())\n return authorizedClientManager\n}\n\nprivate fun contextAttributesMapper(): Function<OAuth2AuthorizeRequest, Mono<MutableMap<String, Any>>> {\n return Function { authorizeRequest ->\n var contextAttributes: MutableMap<String, Any> = mutableMapOf()\n val exchange: ServerWebExchange = authorizeRequest.getAttribute(ServerWebExchange::class.java.name)!!\n val request: ServerHttpRequest = exchange.request\n val param1: String? = request.queryParams.getFirst(\"param1\")\n val param2: String? = request.queryParams.getFirst(\"param2\")\n if (StringUtils.hasText(param1) && StringUtils.hasText(param2)) {\n contextAttributes = hashMapOf()\n contextAttributes[\"param1\"] = param1!!\n contextAttributes[\"param2\"] = param2!!\n }\n Mono.just(contextAttributes)\n }\n}\n----\n======\n\nThe `DefaultReactiveOAuth2AuthorizedClientManager` is designed to be used *_within_* the context of a `ServerWebExchange`.\nWhen operating *_outside_* of a `ServerWebExchange` context, use `AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager` instead.\n\nA _service application_ is a common use case for when to use an `AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager`.\nService applications often run in the background, without any user interaction, and typically run under a system-level account instead of a user account.\nAn OAuth 2.0 Client configured with the `client_credentials` grant type can be considered a type of service application.\n\nThe following code shows an example of how to configure an `AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager` that provides support for the `client_credentials` grant type:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveOAuth2AuthorizedClientManager authorizedClientManager(\n ReactiveClientRegistrationRepository clientRegistrationRepository,\n ReactiveOAuth2AuthorizedClientService authorizedClientService) {\n\n\tReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials()\n .build();\n\n\tAuthorizedClientServiceReactiveOAuth2AuthorizedClientManager authorizedClientManager =\n new AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientService);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ReactiveClientRegistrationRepository,\n authorizedClientService: ReactiveOAuth2AuthorizedClientService): ReactiveOAuth2AuthorizedClientManager {\n val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials()\n .build()\n val authorizedClientManager = AuthorizedClientServiceReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientService)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc", "title": "core", "heading": "ReactiveOAuth2AuthorizedClientManager / ReactiveOAuth2AuthorizedClientProvider", "heading_level": 2, "file_order": 43, "section_index": 5, "content_hash": "9290ebac95d4d4558420160670ce1e13337b0570151d8f2e74b5b51402495bd5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/core.adoc"}}
{"id": "sha256:0f094fc08c993974848edb1f0252d6dbe3436ca22be2813b916a79b0134c6db5", "content": "[[webflux-oauth2-client]]\n\nThe OAuth 2.0 Client features provide support for the Client role as defined in the https://tools.ietf.org/html/rfc6749#section-1.1[OAuth 2.0 Authorization Framework].\n\nAt a high-level, the core features available are:\n\n.Authorization Grant support\n* xref:reactive/oauth2/client/authorization-grants.adoc#oauth2-client-authorization-code[Authorization Code]\n* xref:reactive/oauth2/client/authorization-grants.adoc#oauth2-client-refresh-token[Refresh Token]\n* xref:reactive/oauth2/client/authorization-grants.adoc#oauth2-client-client-credentials[Client Credentials]\n* xref:reactive/oauth2/client/authorization-grants.adoc#oauth2-client-jwt-bearer[JWT Bearer]\n* xref:reactive/oauth2/client/authorization-grants.adoc#oauth2-client-token-exchange[Token Exchange]\n\n.Client Authentication support\n* xref:reactive/oauth2/client/client-authentication.adoc#oauth2-client-authentication-jwt-bearer[JWT Bearer]\n\n.HTTP Client support\n* xref:reactive/oauth2/client/authorized-clients.adoc#oauth2-client-web-client[`WebClient` integration for Reactive Environments] (for requesting protected resources)\n\nThe `ServerHttpSecurity.oauth2Client()` DSL provides a number of configuration options for customizing the core components used by OAuth 2.0 Client.\n\nThe following code shows the complete configuration options provided by the `ServerHttpSecurity.oauth2Client()` DSL:\n\n.OAuth2 Client Configuration Options\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2ClientSecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .oauth2Client((oauth2) -> oauth2\n .clientRegistrationRepository(this.clientRegistrationRepository())\n .authorizedClientRepository(this.authorizedClientRepository())\n .authorizationRequestRepository(this.authorizationRequestRepository())\n .authorizationRequestResolver(this.authorizationRequestResolver())\n .authenticationConverter(this.authenticationConverter())\n .authenticationManager(this.authenticationManager())\n );\n\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2ClientSecurityConfig {\n\n @Bean\n fun securityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n oauth2Client {\n clientRegistrationRepository = clientRegistrationRepository()\n authorizedClientRepository = authorizedClientRepository()\n authorizationRequestRepository = authorizedRequestRepository()\n authorizationRequestResolver = authorizationRequestResolver()\n authenticationConverter = authenticationConverter()\n authenticationManager = authenticationManager()\n }\n }\n\n return http.build()\n }\n}\n----\n======\n\nThe `ReactiveOAuth2AuthorizedClientManager` is responsible for managing the authorization (or re-authorization) of an OAuth 2.0 Client, in collaboration with one or more `ReactiveOAuth2AuthorizedClientProvider`(s).\n\nThe following code shows an example of how to register a `ReactiveOAuth2AuthorizedClientManager` `@Bean` and associate it with a `ReactiveOAuth2AuthorizedClientProvider` composite that provides support for the `authorization_code`, `refresh_token` and `client_credentials` authorization grant types:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveOAuth2AuthorizedClientManager authorizedClientManager(\n ReactiveClientRegistrationRepository clientRegistrationRepository,\n ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .build();\n\n\tDefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ReactiveClientRegistrationRepository,\n authorizedClientRepository: ServerOAuth2AuthorizedClientRepository): ReactiveOAuth2AuthorizedClientManager {\n val authorizedClientProvider: ReactiveOAuth2AuthorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .build()\n val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/client/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 44, "section_index": 0, "content_hash": "0f094fc08c993974848edb1f0252d6dbe3436ca22be2813b916a79b0134c6db5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/client/index.adoc"}}
{"id": "sha256:0d23890316d942c716c8616e6b28f930c825b014322f0205f61021e7799eb59d", "content": "[[webflux-oauth2-login-advanced]]\n\nThe OAuth 2.0 Authorization Framework defines the https://tools.ietf.org/html/rfc6749#section-3[Protocol Endpoints] as follows:\n\nThe authorization process utilizes two authorization server endpoints (HTTP resources):\n\n* Authorization Endpoint: Used by the client to obtain authorization from the resource owner via user-agent redirection.\n* Token Endpoint: Used by the client to exchange an authorization grant for an access token, typically with client authentication.\n\nAs well as one client endpoint:\n\n* Redirection Endpoint: Used by the authorization server to return responses containing authorization credentials to the client via the resource owner user-agent.\n\nThe OpenID Connect Core 1.0 specification defines the https://openid.net/specs/openid-connect-core-1_0.html#UserInfo[UserInfo Endpoint] as follows:\n\nThe UserInfo Endpoint is an OAuth 2.0 Protected Resource that returns claims about the authenticated end-user.\nTo obtain the requested claims about the end-user, the client makes a request to the UserInfo Endpoint by using an access token obtained through OpenID Connect Authentication.\nThese claims are normally represented by a JSON object that contains a collection of name-value pairs for the claims.\n\n`ServerHttpSecurity.oauth2Login()` provides a number of configuration options for customizing OAuth 2.0 Login.\n\nThe following code shows the complete configuration options available for the `oauth2Login()` DSL:\n\n.OAuth2 Login Configuration Options\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n http\n .oauth2Login((oauth2) -> oauth2\n .authenticationConverter(this.authenticationConverter())\n .authenticationMatcher(this.authenticationMatcher())\n .authenticationManager(this.authenticationManager())\n .authenticationSuccessHandler(this.authenticationSuccessHandler())\n .authenticationFailureHandler(this.authenticationFailureHandler())\n .clientRegistrationRepository(this.clientRegistrationRepository())\n .authorizedClientRepository(this.authorizedClientRepository())\n .authorizedClientService(this.authorizedClientService())\n .authorizationRequestResolver(this.authorizationRequestResolver())\n .authorizationRequestRepository(this.authorizationRequestRepository())\n .securityContextRepository(this.securityContextRepository())\n );\n\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n oauth2Login {\n authenticationConverter = authenticationConverter()\n authenticationMatcher = authenticationMatcher()\n authenticationManager = authenticationManager()\n authenticationSuccessHandler = authenticationSuccessHandler()\n authenticationFailureHandler = authenticationFailureHandler()\n clientRegistrationRepository = clientRegistrationRepository()\n authorizedClientRepository = authorizedClientRepository()\n authorizedClientService = authorizedClientService()\n authorizationRequestResolver = authorizationRequestResolver()\n authorizationRequestRepository = authorizationRequestRepository()\n securityContextRepository = securityContextRepository()\n }\n }\n\n return http.build()\n }\n}\n----\n======\n\nThe following sections go into more detail on each of the configuration options available:\n\n* <<webflux-oauth2-login-advanced-login-page, OAuth 2.0 Login Page>>\n* <<webflux-oauth2-login-advanced-redirection-endpoint, Redirection Endpoint>>\n* <<webflux-oauth2-login-advanced-userinfo-endpoint, UserInfo Endpoint>>\n* <<webflux-oauth2-login-advanced-idtoken-verify, ID Token Signature Verification>>\n* <<webflux-oauth2-login-advanced-oidc-logout, OpenID Connect 1.0 Logout>>\n\n[[webflux-oauth2-login-advanced-login-page]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc", "title": "advanced", "heading": "advanced", "heading_level": 1, "file_order": 45, "section_index": 0, "content_hash": "0d23890316d942c716c8616e6b28f930c825b014322f0205f61021e7799eb59d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc"}}
{"id": "sha256:866eff1c95170b7715fafe0a05693fb74e1e5743914481dd251773bdf2e486e3", "content": "By default, the OAuth 2.0 Login Page is auto-generated by the `LoginPageGeneratingWebFilter`.\nThe default login page shows each configured OAuth Client with its `ClientRegistration.clientName` as a link, which is capable of initiating the Authorization Request (or OAuth 2.0 Login).\n\n[NOTE]\nIn order for `LoginPageGeneratingWebFilter` to show links for configured OAuth Clients, the registered `ReactiveClientRegistrationRepository` needs to also implement `Iterable<ClientRegistration>`.\nSee `InMemoryReactiveClientRegistrationRepository` for reference.\n\nThe link's destination for each OAuth Client defaults to the following:\n\n`+\"/oauth2/authorization/{registrationId}\"+`\n\nThe following line shows an example:\n\n[source,html]\n----\n<a href=\"/oauth2/authorization/google\">Google</a>\n----\n\nTo override the default login page, configure the `exceptionHandling().authenticationEntryPoint()` and (optionally) `oauth2Login().authorizationRequestResolver()`.\n\nThe following listing shows an example:\n\n.OAuth2 Login Page Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"-attributes\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .exceptionHandling((exceptionHandling) -> exceptionHandling\n .authenticationEntryPoint(new RedirectServerAuthenticationEntryPoint(\"/login/oauth2\"))\n )\n .oauth2Login((oauth2) -> oauth2\n .authorizationRequestResolver(this.authorizationRequestResolver())\n );\n\n return http.build();\n\t}\n\n\tprivate ServerOAuth2AuthorizationRequestResolver authorizationRequestResolver() {\n ServerWebExchangeMatcher authorizationRequestMatcher =\n new PathPatternParserServerWebExchangeMatcher(\n \"/login/oauth2/authorization/{registrationId}\");\n\n return new DefaultServerOAuth2AuthorizationRequestResolver(\n this.clientRegistrationRepository(), authorizationRequestMatcher);\n\t}\n\n\t...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"-attributes\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n exceptionHandling {\n authenticationEntryPoint = RedirectServerAuthenticationEntryPoint(\"/login/oauth2\")\n }\n oauth2Login {\n authorizationRequestResolver = authorizationRequestResolver()\n }\n }\n\n return http.build()\n }\n\n private fun authorizationRequestResolver(): ServerOAuth2AuthorizationRequestResolver {\n val authorizationRequestMatcher: ServerWebExchangeMatcher = PathPatternParserServerWebExchangeMatcher(\n \"/login/oauth2/authorization/{registrationId}\"\n )\n\n return DefaultServerOAuth2AuthorizationRequestResolver(\n clientRegistrationRepository(), authorizationRequestMatcher\n )\n }\n\n ...\n}\n----\n======\n\n[IMPORTANT]\nYou need to provide a `@Controller` with a `@RequestMapping(\"/login/oauth2\")` that is capable of rendering the custom login page.\n\n[TIP]\n====\nAs noted earlier, configuring `oauth2Login().authorizationRequestResolver()` is optional.\nHowever, if you choose to customize it, ensure the link to each OAuth Client matches the pattern provided through the `ServerWebExchangeMatcher`.\n\nThe following line shows an example:\n\n[source,html]\n----\n<a href=\"/login/oauth2/authorization/google\">Google</a>\n----\n====\n\n[[webflux-oauth2-login-advanced-redirection-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc", "title": "advanced", "heading": "OAuth 2.0 Login Page", "heading_level": 2, "file_order": 45, "section_index": 1, "content_hash": "866eff1c95170b7715fafe0a05693fb74e1e5743914481dd251773bdf2e486e3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc"}}
{"id": "sha256:0d1e11c2b462d544ee64bb3c19dfe70fc09daf633659436d24bf3291cdc33478", "content": "The Redirection Endpoint is used by the Authorization Server for returning the Authorization Response (which contains the authorization credentials) to the client via the Resource Owner user-agent.\n\n[TIP]\nOAuth 2.0 Login leverages the Authorization Code Grant.\nTherefore, the authorization credential is the authorization code.\n\nThe default Authorization Response redirection endpoint is `+/login/oauth2/code/{registrationId}+`.\n\nIf you would like to customize the Authorization Response redirection endpoint, configure it as shown in the following example:\n\n.Redirection Endpoint Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"-attributes\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .oauth2Login((oauth2) -> oauth2\n .authenticationMatcher(new PathPatternParserServerWebExchangeMatcher(\"/login/oauth2/callback/{registrationId}\"))\n );\n\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"-attributes\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n oauth2Login {\n authenticationMatcher = PathPatternParserServerWebExchangeMatcher(\"/login/oauth2/callback/{registrationId}\")\n }\n }\n\n return http.build()\n }\n}\n----\n======\n\n[IMPORTANT]\n====\nYou also need to ensure the `ClientRegistration.redirectUri` matches the custom Authorization Response redirection endpoint.\n\nThe following listing shows an example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"-attributes\"]\n----\nreturn CommonOAuth2Provider.GOOGLE.getBuilder(\"google\")\n\t.clientId(\"google-client-id\")\n\t.clientSecret(\"google-client-secret\")\n\t.redirectUri(\"{baseUrl}/login/oauth2/callback/{registrationId}\")\n\t.build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"-attributes\"]\n----\nreturn CommonOAuth2Provider.GOOGLE.getBuilder(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .redirectUri(\"{baseUrl}/login/oauth2/callback/{registrationId}\")\n .build()\n----\n======\n====\n\n[[webflux-oauth2-login-advanced-userinfo-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc", "title": "advanced", "heading": "Redirection Endpoint", "heading_level": 2, "file_order": 45, "section_index": 2, "content_hash": "0d1e11c2b462d544ee64bb3c19dfe70fc09daf633659436d24bf3291cdc33478", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc"}}
{"id": "sha256:5c0f938f12685a9e8a4662387260448b41be6895b45823918ec1d6f076de6967", "content": "The UserInfo Endpoint includes a number of configuration options, as described in the following sub-sections:\n\n* <<webflux-oauth2-login-advanced-map-authorities, Mapping User Authorities>>\n* <<webflux-oauth2-login-advanced-oauth2-user-service, OAuth 2.0 UserService>>\n* <<webflux-oauth2-login-advanced-oidc-user-service, OpenID Connect 1.0 UserService>>\n\n[[webflux-oauth2-login-advanced-map-authorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc", "title": "advanced", "heading": "UserInfo Endpoint", "heading_level": 2, "file_order": 45, "section_index": 3, "content_hash": "5c0f938f12685a9e8a4662387260448b41be6895b45823918ec1d6f076de6967", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc"}}
{"id": "sha256:524812c75210f489b63b00e7fec94e2550043dc765a57135a7f2d54dd1c7663a", "content": "After the user successfully authenticates with the OAuth 2.0 Provider, the `OAuth2User.getAuthorities()` (or `OidcUser.getAuthorities()`) contains a list of granted authorities populated from `OAuth2UserRequest.getAccessToken().getScopes()` and prefixed with `SCOPE_`.\nThese granted authorities may be mapped to a new set of `GrantedAuthority` instances, which will be supplied to `OAuth2AuthenticationToken` when completing the authentication.\n\n[TIP]\n`OAuth2AuthenticationToken.getAuthorities()` is used for authorizing requests, such as in `hasRole('USER')` or `hasRole('ADMIN')`.\n\nThere are a couple of options to choose from when mapping user authorities:\n\n* <<webflux-oauth2-login-advanced-map-authorities-grantedauthoritiesmapper, Using a GrantedAuthoritiesMapper>>\n* <<webflux-oauth2-login-advanced-map-authorities-reactiveoauth2userservice, Delegation-based strategy with ReactiveOAuth2UserService>>\n\n[[webflux-oauth2-login-advanced-map-authorities-grantedauthoritiesmapper]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc", "title": "advanced", "heading": "Mapping User Authorities", "heading_level": 3, "file_order": 45, "section_index": 4, "content_hash": "524812c75210f489b63b00e7fec94e2550043dc765a57135a7f2d54dd1c7663a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc"}}
{"id": "sha256:98f0ce22123b1f6607d9b4bb33cdef23757f3fbf250e296647f8bf502f4d731a", "content": "The `GrantedAuthoritiesMapper` is given a list of granted authorities which contains a special authority of type `OAuth2UserAuthority` and the authority string `OAUTH2_USER` (or `OidcUserAuthority` and the authority string `OIDC_USER`).\n\nRegister a `GrantedAuthoritiesMapper` `@Bean` to have it automatically applied to the configuration, as shown in the following example:\n\n.Granted Authorities Mapper Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n ...\n .oauth2Login(withDefaults());\n\n return http.build();\n\t}\n\n\t@Bean\n\tpublic GrantedAuthoritiesMapper userAuthoritiesMapper() {\n return (authorities) -> {\n Set<GrantedAuthority> mappedAuthorities = new HashSet<>();\n\n authorities.forEach(authority -> {\n if (OidcUserAuthority.class.isInstance(authority)) {\n OidcUserAuthority oidcUserAuthority = (OidcUserAuthority)authority;\n\n OidcIdToken idToken = oidcUserAuthority.getIdToken();\n OidcUserInfo userInfo = oidcUserAuthority.getUserInfo();\n\n // Map the claims found in idToken and/or userInfo\n // to one or more GrantedAuthority's and add it to mappedAuthorities\n\n } else if (OAuth2UserAuthority.class.isInstance(authority)) {\n OAuth2UserAuthority oauth2UserAuthority = (OAuth2UserAuthority)authority;\n\n Map<String, Object> userAttributes = oauth2UserAuthority.getAttributes();\n\n // Map the attributes found in userAttributes\n // to one or more GrantedAuthority's and add it to mappedAuthorities\n\n }\n });\n\n return mappedAuthorities;\n };\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n oauth2Login { }\n }\n\n return http.build()\n }\n\n @Bean\n fun userAuthoritiesMapper(): GrantedAuthoritiesMapper = GrantedAuthoritiesMapper { authorities: Collection<GrantedAuthority> ->\n val mappedAuthorities = emptySet<GrantedAuthority>()\n\n authorities.forEach { authority ->\n if (authority is OidcUserAuthority) {\n val idToken = authority.idToken\n val userInfo = authority.userInfo\n // Map the claims found in idToken and/or userInfo\n // to one or more GrantedAuthority's and add it to mappedAuthorities\n } else if (authority is OAuth2UserAuthority) {\n val userAttributes = authority.attributes\n // Map the attributes found in userAttributes\n // to one or more GrantedAuthority's and add it to mappedAuthorities\n }\n }\n\n mappedAuthorities\n }\n}\n----\n======\n\n[[webflux-oauth2-login-advanced-map-authorities-reactiveoauth2userservice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc", "title": "advanced", "heading": "Using a GrantedAuthoritiesMapper", "heading_level": 4, "file_order": 45, "section_index": 5, "content_hash": "98f0ce22123b1f6607d9b4bb33cdef23757f3fbf250e296647f8bf502f4d731a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc"}}
{"id": "sha256:d905659297b0b06dd2778da71469d6cab56d0bced572e4ff1f8819341e412f60", "content": "This strategy is advanced compared to using a `GrantedAuthoritiesMapper`, however, it's also more flexible as it gives you access to the `OAuth2UserRequest` and `OAuth2User` (when using an OAuth 2.0 UserService) or `OidcUserRequest` and `OidcUser` (when using an OpenID Connect 1.0 UserService).\n\nThe `OAuth2UserRequest` (and `OidcUserRequest`) provides you access to the associated `OAuth2AccessToken`, which is very useful in the cases where the _delegator_ needs to fetch authority information from a protected resource before it can map the custom authorities for the user.\n\nThe following example shows how to implement and configure a delegation-based strategy using an OpenID Connect 1.0 UserService:\n\n.ReactiveOAuth2UserService Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n ...\n .oauth2Login(withDefaults());\n\n return http.build();\n\t}\n\n\t@Bean\n\tpublic ReactiveOAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() {\n final OidcReactiveOAuth2UserService delegate = new OidcReactiveOAuth2UserService();\n\n return (userRequest) -> {\n // Delegate to the default implementation for loading a user\n return delegate.loadUser(userRequest)\n .flatMap((oidcUser) -> {\n OAuth2AccessToken accessToken = userRequest.getAccessToken();\n Set<GrantedAuthority> mappedAuthorities = new HashSet<>();\n\n // TODO\n // 1) Fetch the authority information from the protected resource using accessToken\n // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities\n\n // 3) Create a copy of oidcUser but use the mappedAuthorities instead\n ProviderDetails providerDetails = userRequest.getClientRegistration().getProviderDetails();\n String userNameAttributeName = providerDetails.getUserInfoEndpoint().getUserNameAttributeName();\n if (StringUtils.hasText(userNameAttributeName)) {\n oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo(), userNameAttributeName);\n } else {\n oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo());\n }\n\n return Mono.just(oidcUser);\n });\n };\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n oauth2Login { }\n }\n\n return http.build()\n }\n\n @Bean\n fun oidcUserService(): ReactiveOAuth2UserService<OidcUserRequest, OidcUser> {\n val delegate = OidcReactiveOAuth2UserService()\n\n return ReactiveOAuth2UserService { userRequest ->\n // Delegate to the default implementation for loading a user\n delegate.loadUser(userRequest)\n .flatMap { oidcUser ->\n val accessToken = userRequest.accessToken\n val mappedAuthorities = mutableSetOf<GrantedAuthority>()\n\n // TODO\n // 1) Fetch the authority information from the protected resource using accessToken\n // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities\n // 3) Create a copy of oidcUser but use the mappedAuthorities instead\n val providerDetails = userRequest.getClientRegistration().getProviderDetails()\n val userNameAttributeName = providerDetails.getUserInfoEndpoint().getUserNameAttributeName()\n val mappedOidcUser = if (StringUtils.hasText(userNameAttributeName)) {\n DefaultOidcUser(mappedAuthorities, oidcUser.idToken, oidcUser.userInfo, userNameAttributeName)\n } else {\n DefaultOidcUser(mappedAuthorities, oidcUser.idToken, oidcUser.userInfo)\n }\n\n Mono.just(mappedOidcUser)\n }\n }\n }\n}\n----\n======\n\n[[webflux-oauth2-login-advanced-oauth2-user-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc", "title": "advanced", "heading": "Delegation-based strategy with ReactiveOAuth2UserService", "heading_level": 4, "file_order": 45, "section_index": 6, "content_hash": "d905659297b0b06dd2778da71469d6cab56d0bced572e4ff1f8819341e412f60", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc"}}
{"id": "sha256:ca022cd66a7bff4e413476cf0c46930f2178dca773143589af60bea61e4b12e8", "content": "`DefaultReactiveOAuth2UserService` is an implementation of a `ReactiveOAuth2UserService` that supports standard OAuth 2.0 Provider's.\n\n[NOTE]\n`ReactiveOAuth2UserService` obtains the user attributes of the end-user (the resource owner) from the UserInfo Endpoint (by using the access token granted to the client during the authorization flow) and returns an `AuthenticatedPrincipal` in the form of an `OAuth2User`.\n\n`DefaultReactiveOAuth2UserService` uses a `WebClient` when requesting the user attributes at the UserInfo Endpoint.\n\nIf you need to customize the pre-processing of the UserInfo Request and/or the post-handling of the UserInfo Response, you will need to provide `DefaultReactiveOAuth2UserService.setWebClient()` with a custom configured `WebClient`.\n\nWhether you customize `DefaultReactiveOAuth2UserService` or provide your own implementation of `ReactiveOAuth2UserService`, you'll need to configure it as shown in the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n ...\n .oauth2Login(withDefaults());\n\n return http.build();\n\t}\n\n\t@Bean\n\tpublic ReactiveOAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService() {\n ...\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n oauth2Login { }\n }\n\n return http.build()\n }\n\n @Bean\n fun oauth2UserService(): ReactiveOAuth2UserService<OAuth2UserRequest, OAuth2User> {\n // ...\n }\n}\n----\n======\n\n[[webflux-oauth2-login-advanced-oidc-user-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc", "title": "advanced", "heading": "OAuth 2.0 UserService", "heading_level": 3, "file_order": 45, "section_index": 7, "content_hash": "ca022cd66a7bff4e413476cf0c46930f2178dca773143589af60bea61e4b12e8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc"}}
{"id": "sha256:730862d4dd613e4d5322ad27c733e7c86bb99803d9ef259e1d8be6efb2f5c03c", "content": "`OidcReactiveOAuth2UserService` is an implementation of a `ReactiveOAuth2UserService` that supports OpenID Connect 1.0 Provider's.\n\nThe `OidcReactiveOAuth2UserService` leverages the `DefaultReactiveOAuth2UserService` when requesting the user attributes at the UserInfo Endpoint.\n\nIf you need to customize the pre-processing of the UserInfo Request and/or the post-handling of the UserInfo Response, you will need to provide `OidcReactiveOAuth2UserService.setOauth2UserService()` with a custom configured `ReactiveOAuth2UserService`.\n\nWhether you customize `OidcReactiveOAuth2UserService` or provide your own implementation of `ReactiveOAuth2UserService` for OpenID Connect 1.0 Provider's, you'll need to configure it as shown in the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n ...\n .oauth2Login(withDefaults());\n\n return http.build();\n\t}\n\n\t@Bean\n\tpublic ReactiveOAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() {\n ...\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n oauth2Login { }\n }\n\n return http.build()\n }\n\n @Bean\n fun oidcUserService(): ReactiveOAuth2UserService<OidcUserRequest, OidcUser> {\n // ...\n }\n}\n----\n======\n\n[[webflux-oauth2-login-advanced-idtoken-verify]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc", "title": "advanced", "heading": "OpenID Connect 1.0 UserService", "heading_level": 3, "file_order": 45, "section_index": 8, "content_hash": "730862d4dd613e4d5322ad27c733e7c86bb99803d9ef259e1d8be6efb2f5c03c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc"}}
{"id": "sha256:f884ab709a64d9365869cbf9dc0546e97b329d31f3c08bd55f4625841c311926", "content": "OpenID Connect 1.0 Authentication introduces the https://openid.net/specs/openid-connect-core-1_0.html#IDToken[ID Token], which is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when used by a Client.\n\nThe ID Token is represented as a https://tools.ietf.org/html/rfc7519[JSON Web Token] (JWT) and MUST be signed using https://tools.ietf.org/html/rfc7515[JSON Web Signature] (JWS).\n\nThe `ReactiveOidcIdTokenDecoderFactory` provides a `ReactiveJwtDecoder` used for `OidcIdToken` signature verification. The default algorithm is `RS256` but may be different when assigned during client registration.\nFor these cases, a resolver may be configured to return the expected JWS algorithm assigned for a specific client.\n\nThe JWS algorithm resolver is a `Function` that accepts a `ClientRegistration` and returns the expected `JwsAlgorithm` for the client, e.g. `SignatureAlgorithm.RS256` or `MacAlgorithm.HS256`\n\nThe following code shows how to configure the `OidcIdTokenDecoderFactory` `@Bean` to default to `MacAlgorithm.HS256` for all `ClientRegistration`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveJwtDecoderFactory<ClientRegistration> idTokenDecoderFactory() {\n\tReactiveOidcIdTokenDecoderFactory idTokenDecoderFactory = new ReactiveOidcIdTokenDecoderFactory();\n\tidTokenDecoderFactory.setJwsAlgorithmResolver((clientRegistration) -> clientRegistration.HS256);\n\treturn idTokenDecoderFactory;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun idTokenDecoderFactory(): ReactiveJwtDecoderFactory<ClientRegistration> {\n val idTokenDecoderFactory = ReactiveOidcIdTokenDecoderFactory()\n idTokenDecoderFactory.setJwsAlgorithmResolver { MacAlgorithm.HS256 }\n return idTokenDecoderFactory\n}\n----\n======\n\n[NOTE]\nFor MAC based algorithms such as `HS256`, `HS384` or `HS512`, the `client-secret` corresponding to the `client-id` is used as the symmetric key for signature verification.\n\n[TIP]\nIf more than one `ClientRegistration` is configured for OpenID Connect 1.0 Authentication, the JWS algorithm resolver may evaluate the provided `ClientRegistration` to determine which algorithm to return.\n\n[[webflux-oauth2-login-advanced-oidc-logout]]\nThen, you can proceed to configure xref:reactive/oauth2/login/logout.adoc[logout].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc", "title": "advanced", "heading": "ID Token Signature Verification", "heading_level": 2, "file_order": 45, "section_index": 9, "content_hash": "f884ab709a64d9365869cbf9dc0546e97b329d31f3c08bd55f4625841c311926", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/advanced.adoc"}}
{"id": "sha256:be5dc12928d14bf0fa3b5eeba29e9a9a6f0f2b7bfc1eb621a9d1db1b69f4227d", "content": "[[webflux-oauth2-login-sample]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Core Configuration", "heading_level": 1, "file_order": 46, "section_index": 0, "content_hash": "be5dc12928d14bf0fa3b5eeba29e9a9a6f0f2b7bfc1eb621a9d1db1b69f4227d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:e0e047d2e1ee9abb094a1f6159ac0c077dce25033eb1281b300711c1721d3dde", "content": "Spring Boot brings full auto-configuration capabilities for OAuth 2.0 Login.\n\nThis section shows how to configure the {gh-samples-url}/boot/oauth2login-webflux[*OAuth 2.0 Login WebFlux sample*] by using _Google_ as the _Authentication Provider_ and covers the following topics:\n\n* <<webflux-oauth2-login-sample-setup>>\n* <<webflux-oauth2-login-sample-redirect>>\n* <<webflux-oauth2-login-sample-config>>\n* <<webflux-oauth2-login-sample-start>>\n\n[[webflux-oauth2-login-sample-setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Spring Boot Sample", "heading_level": 2, "file_order": 46, "section_index": 1, "content_hash": "e0e047d2e1ee9abb094a1f6159ac0c077dce25033eb1281b300711c1721d3dde", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:ce94ac02ac504610435cc0ec2627accc4aa7d987eb8b64a2a6b70f34b06babf6", "content": "To use Google's OAuth 2.0 authentication system for login, you must set up a project in the Google API Console to obtain OAuth 2.0 credentials.\n\n[NOTE]\n====\nhttps://developers.google.com/identity/protocols/OpenIDConnect[Google's OAuth 2.0 implementation] for authentication conforms to the https://openid.net/connect/[OpenID Connect 1.0] specification and is https://openid.net/certification/[OpenID Certified].\n====\n\nFollow the instructions on the https://developers.google.com/identity/protocols/OpenIDConnect[OpenID Connect] page, starting in the \"`Setting up OAuth 2.0`\" section.\n\nAfter completing the \"`Obtain OAuth 2.0 credentials`\" instructions, you should have a new OAuth Client with credentials that consist of a Client ID and a Client Secret.\n\n[[webflux-oauth2-login-sample-redirect]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Initial Setup", "heading_level": 3, "file_order": 46, "section_index": 2, "content_hash": "ce94ac02ac504610435cc0ec2627accc4aa7d987eb8b64a2a6b70f34b06babf6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:21bf7b598f408cffb32d3040e18fb87010f0fa9e669b881c846d005db83431f5", "content": "The redirect URI is the path in the application that the end-user's user-agent is redirected back to after they have authenticated with Google and have been granted access to the OAuth Client (<<webflux-oauth2-login-sample-setup,created in the previous step>>) on the consent page.\n\nIn the \"`Set a redirect URI`\" sub-section, ensure that the *Authorized redirect URIs* field is set to `http://localhost:8080/login/oauth2/code/google`.\n\n[TIP]\n====\nThe default redirect URI template is `+{baseUrl}/login/oauth2/code/{registrationId}+`.\nThe *_registrationId_* is a unique identifier for the xref:reactive/oauth2/client/core.adoc#oauth2Client-client-registration[ClientRegistration].\nFor our example, the `registrationId` is `google`.\n====\n\n[IMPORTANT]\n====\nIf the OAuth Client is running behind a proxy server, it is recommended to check xref:features/exploits/http.adoc#http-proxy-server[Proxy Server Configuration] to ensure the application is correctly configured.\nAlso, see the supported xref:reactive/oauth2/client/authorization-grants.adoc#oauth2Client-auth-code-redirect-uri[ `URI` template variables] for `redirect-uri`.\n====\n\n[[webflux-oauth2-login-sample-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Setting the Redirect URI", "heading_level": 3, "file_order": 46, "section_index": 3, "content_hash": "21bf7b598f408cffb32d3040e18fb87010f0fa9e669b881c846d005db83431f5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:abf7e82f3c9c536ac35d7a7c9dc690a9638983f7eadbd56d2eda3d91683c8b5c", "content": "Now that you have a new OAuth Client with Google, you need to configure the application to use the OAuth Client for the _authentication flow_.\nTo do so:\n\n. Go to `application.yml` and set the following configuration:\n+\n.OAuth Client properties\n====\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\t<1>\n google:\t<2>\n client-id: google-client-id\n client-secret: google-client-secret\n----\n\n<1> `spring.security.oauth2.client.registration` is the base property prefix for OAuth Client properties.\n<2> Following the base property prefix is the ID for the xref:reactive/oauth2/client/core.adoc#oauth2Client-client-registration[`ClientRegistration`], such as google.\n====\n\n. Replace the values in the `client-id` and `client-secret` property with the OAuth 2.0 credentials you created earlier.\n\n[[webflux-oauth2-login-sample-start]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Configure `application.yml`", "heading_level": 3, "file_order": 46, "section_index": 4, "content_hash": "abf7e82f3c9c536ac35d7a7c9dc690a9638983f7eadbd56d2eda3d91683c8b5c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:2b0622a2f7141828f364945fc1a68118100cd1da9ca9e7572caa3f0fb0f23ede", "content": "Launch the Spring Boot sample and go to `http://localhost:8080`.\nYou are then redirected to the default _auto-generated_ login page, which displays a link for Google.\n\nClick on the Google link, and you are then redirected to Google for authentication.\n\nAfter authenticating with your Google account credentials, the next page presented to you is the Consent screen.\nThe Consent screen asks you to either allow or deny access to the OAuth Client you created earlier.\nClick *Allow* to authorize the OAuth Client to access your email address and basic profile information.\n\nAt this point, the OAuth Client retrieves your email address and basic profile information from the https://openid.net/specs/openid-connect-core-1_0.html#UserInfo[UserInfo Endpoint] and establishes an authenticated session.\n\n[[oauth2login-boot-property-mappings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Boot the Application", "heading_level": 3, "file_order": 46, "section_index": 5, "content_hash": "2b0622a2f7141828f364945fc1a68118100cd1da9ca9e7572caa3f0fb0f23ede", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:6d1f6555a8db4c982d46fea6850158528dbebb27ba0222cef29676abbcadd685", "content": "The following table outlines the mapping of the Spring Boot OAuth Client properties to the xref:reactive/oauth2/client/core.adoc#oauth2Client-client-registration[ClientRegistration] properties.\n\n|===\n|Spring Boot |ClientRegistration\n\n|`spring.security.oauth2.client.registration._[registrationId]_`\n|`registrationId`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.client-id`\n|`clientId`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.client-secret`\n|`clientSecret`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.client-authentication-method`\n|`clientAuthenticationMethod`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.authorization-grant-type`\n|`authorizationGrantType`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.redirect-uri`\n|`redirectUri`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.scope`\n|`scopes`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.client-name`\n|`clientName`\n\n|`spring.security.oauth2.client.provider._[providerId]_.authorization-uri`\n|`providerDetails.authorizationUri`\n\n|`spring.security.oauth2.client.provider._[providerId]_.token-uri`\n|`providerDetails.tokenUri`\n\n|`spring.security.oauth2.client.provider._[providerId]_.jwk-set-uri`\n|`providerDetails.jwkSetUri`\n\n|`spring.security.oauth2.client.provider._[providerId]_.issuer-uri`\n|`providerDetails.issuerUri`\n\n|`spring.security.oauth2.client.provider._[providerId]_.user-info-uri`\n|`providerDetails.userInfoEndpoint.uri`\n\n|`spring.security.oauth2.client.provider._[providerId]_.user-info-authentication-method`\n|`providerDetails.userInfoEndpoint.authenticationMethod`\n\n|`spring.security.oauth2.client.provider._[providerId]_.user-name-attribute`\n|`providerDetails.userInfoEndpoint.userNameAttributeName`\n|===\n\n[TIP]\nA `ClientRegistration` can be initially configured using discovery of an OpenID Connect Provider's https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[Configuration endpoint] or an Authorization Server's https://tools.ietf.org/html/rfc8414#section-3[Metadata endpoint], by specifying the `spring.security.oauth2.client.provider._[providerId]_.issuer-uri` property.\n\n[[webflux-oauth2-login-common-oauth2-provider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Spring Boot Property Mappings", "heading_level": 2, "file_order": 46, "section_index": 6, "content_hash": "6d1f6555a8db4c982d46fea6850158528dbebb27ba0222cef29676abbcadd685", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:7062f230f60884b2b2b24f47f4962489291d75ec37001f94025e2ff23e98aef6", "content": "`CommonOAuth2Provider` pre-defines a set of default client properties for a number of well known providers: Google, GitHub, Facebook, X, and Okta.\n\nFor example, the `authorization-uri`, `token-uri`, and `user-info-uri` do not change often for a Provider.\nTherefore, it makes sense to provide default values in order to reduce the required configuration.\n\nAs demonstrated previously, when we <<webflux-oauth2-login-sample-config,configured a Google client>>, only the `client-id` and `client-secret` properties are required.\n\nThe following listing shows an example:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n google:\n client-id: google-client-id\n client-secret: google-client-secret\n----\n\n[TIP]\nThe auto-defaulting of client properties works seamlessly here because the `registrationId` (`google`) matches the `GOOGLE` `enum` (case-insensitive) in `CommonOAuth2Provider`.\n\nFor cases where you may want to specify a different `registrationId`, such as `google-login`, you can still leverage auto-defaulting of client properties by configuring the `provider` property.\n\nThe following listing shows an example:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n google-login:\t<1>\n provider: google\t<2>\n client-id: google-client-id\n client-secret: google-client-secret\n----\n<1> The `registrationId` is set to `google-login`.\n<2> The `provider` property is set to `google`, which will leverage the auto-defaulting of client properties set in `CommonOAuth2Provider.GOOGLE.getBuilder()`.\n\n[[webflux-oauth2-login-custom-provider-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "CommonOAuth2Provider", "heading_level": 2, "file_order": 46, "section_index": 7, "content_hash": "7062f230f60884b2b2b24f47f4962489291d75ec37001f94025e2ff23e98aef6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:4cfa8074c00fb5696e877228a235cfae74bc05b4bbcfa488b8c588ed0f6da6bd", "content": "There are some OAuth 2.0 Providers that support multi-tenancy, which results in different protocol endpoints for each tenant (or sub-domain).\n\nFor example, an OAuth Client registered with Okta is assigned to a specific sub-domain and have their own protocol endpoints.\n\nFor these cases, Spring Boot provides the following base property for configuring custom provider properties: `spring.security.oauth2.client.provider._[providerId]_`.\n\nThe following listing shows an example:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n provider:\n okta:\t<1>\n authorization-uri: https://your-subdomain.oktapreview.com/oauth2/v1/authorize\n token-uri: https://your-subdomain.oktapreview.com/oauth2/v1/token\n user-info-uri: https://your-subdomain.oktapreview.com/oauth2/v1/userinfo\n user-name-attribute: sub\n jwk-set-uri: https://your-subdomain.oktapreview.com/oauth2/v1/keys\n----\n\n<1> The base property (`spring.security.oauth2.client.provider.okta`) allows for custom configuration of protocol endpoint locations.\n\n[[webflux-oauth2-login-override-boot-autoconfig]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Configuring Custom Provider Properties", "heading_level": 2, "file_order": 46, "section_index": 8, "content_hash": "4cfa8074c00fb5696e877228a235cfae74bc05b4bbcfa488b8c588ed0f6da6bd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:2c272aafbd9376399e2e1d9eeafa4d622c5b787609bc1e11fc6372a7125f7c0e", "content": "The Spring Boot auto-configuration class for OAuth Client support is `ReactiveOAuth2ClientAutoConfiguration`.\n\nIt performs the following tasks:\n\n* Registers a `ReactiveClientRegistrationRepository` `@Bean` composed of `ClientRegistration`(s) from the configured OAuth Client properties.\n* Registers a `SecurityWebFilterChain` `@Bean` and enables OAuth 2.0 Login through `serverHttpSecurity.oauth2Login()`.\n\nIf you need to override the auto-configuration based on your specific requirements, you may do so in the following ways:\n\n* <<webflux-oauth2-login-register-reactiveclientregistrationrepository-bean,Register a ReactiveClientRegistrationRepository @Bean>>\n* <<webflux-oauth2-login-register-securitywebfilterchain-bean,Register a SecurityWebFilterChain @Bean>>\n* <<webflux-oauth2-login-completely-override-autoconfiguration,Completely Override the Auto-configuration>>\n\n[[webflux-oauth2-login-register-reactiveclientregistrationrepository-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Overriding Spring Boot Auto-configuration", "heading_level": 2, "file_order": 46, "section_index": 9, "content_hash": "2c272aafbd9376399e2e1d9eeafa4d622c5b787609bc1e11fc6372a7125f7c0e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:9896ada284545b5c1a5d623cc1bdd8c924bf8d0a508ac2d2e4e7a3d039daa6aa", "content": "The following example shows how to register a `ReactiveClientRegistrationRepository` `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",attrs=\"-attributes\"]\n----\n@Configuration\npublic class OAuth2LoginConfig {\n\n\t@Bean\n\tpublic ReactiveClientRegistrationRepository clientRegistrationRepository() {\n return new InMemoryReactiveClientRegistrationRepository(this.googleClientRegistration());\n\t}\n\n\tprivate ClientRegistration googleClientRegistration() {\n return ClientRegistration.withRegistrationId(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n .scope(\"openid\", \"profile\", \"email\", \"address\", \"phone\")\n .authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth\")\n .tokenUri(\"https://www.googleapis.com/oauth2/v4/token\")\n .userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n .userNameAttributeName(IdTokenClaimNames.SUB)\n .jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n .clientName(\"Google\")\n .build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",attrs=\"-attributes\"]\n----\n@Configuration\nclass OAuth2LoginConfig {\n\n @Bean\n fun clientRegistrationRepository(): ReactiveClientRegistrationRepository {\n return InMemoryReactiveClientRegistrationRepository(googleClientRegistration())\n }\n\n private fun googleClientRegistration(): ClientRegistration {\n return ClientRegistration.withRegistrationId(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n .scope(\"openid\", \"profile\", \"email\", \"address\", \"phone\")\n .authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth\")\n .tokenUri(\"https://www.googleapis.com/oauth2/v4/token\")\n .userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n .userNameAttributeName(IdTokenClaimNames.SUB)\n .jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n .clientName(\"Google\")\n .build()\n }\n}\n----\n======\n\n[[webflux-oauth2-login-register-securitywebfilterchain-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Register a ReactiveClientRegistrationRepository @Bean", "heading_level": 3, "file_order": 46, "section_index": 10, "content_hash": "9896ada284545b5c1a5d623cc1bdd8c924bf8d0a508ac2d2e4e7a3d039daa6aa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:2e8e37a7f2db8b964b8e3f061758400aa162a34d081fc440af6fb59c502fded5", "content": "The following example shows how to register a `SecurityWebFilterChain` `@Bean` with `@EnableWebFluxSecurity` and enable OAuth 2.0 login through `serverHttpSecurity.oauth2Login()`:\n\n.OAuth2 Login Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2Login(withDefaults());\n\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2Login { }\n }\n\n return http.build()\n }\n}\n----\n======\n\n[[webflux-oauth2-login-completely-override-autoconfiguration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Register a SecurityWebFilterChain @Bean", "heading_level": 3, "file_order": 46, "section_index": 11, "content_hash": "2e8e37a7f2db8b964b8e3f061758400aa162a34d081fc440af6fb59c502fded5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:b65ddf345fb73ab59b096b6ed58e79e9dd5ede7fdefdb1abce9846e95a1c5a04", "content": "The following example shows how to completely override the auto-configuration by registering a `ReactiveClientRegistrationRepository` `@Bean` and a `SecurityWebFilterChain` `@Bean`.\n\n.Overriding the auto-configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",attrs=\"-attributes\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2Login(withDefaults());\n\n return http.build();\n\t}\n\n\t@Bean\n\tpublic ReactiveClientRegistrationRepository clientRegistrationRepository() {\n return new InMemoryReactiveClientRegistrationRepository(this.googleClientRegistration());\n\t}\n\n\tprivate ClientRegistration googleClientRegistration() {\n return ClientRegistration.withRegistrationId(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n .scope(\"openid\", \"profile\", \"email\", \"address\", \"phone\")\n .authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth\")\n .tokenUri(\"https://www.googleapis.com/oauth2/v4/token\")\n .userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n .userNameAttributeName(IdTokenClaimNames.SUB)\n .jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n .clientName(\"Google\")\n .build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",attrs=\"-attributes\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2LoginConfig {\n\n @Bean\n fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2Login { }\n }\n\n return http.build()\n }\n\n @Bean\n fun clientRegistrationRepository(): ReactiveClientRegistrationRepository {\n return InMemoryReactiveClientRegistrationRepository(googleClientRegistration())\n }\n\n private fun googleClientRegistration(): ClientRegistration {\n return ClientRegistration.withRegistrationId(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n .scope(\"openid\", \"profile\", \"email\", \"address\", \"phone\")\n .authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth\")\n .tokenUri(\"https://www.googleapis.com/oauth2/v4/token\")\n .userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n .userNameAttributeName(IdTokenClaimNames.SUB)\n .jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n .clientName(\"Google\")\n .build()\n }\n}\n----\n======\n\n[[webflux-oauth2-login-javaconfig-wo-boot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Completely Override the Auto-configuration", "heading_level": 3, "file_order": 46, "section_index": 12, "content_hash": "b65ddf345fb73ab59b096b6ed58e79e9dd5ede7fdefdb1abce9846e95a1c5a04", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:d4fb589d4944117194a1bdbbf27b8db712f260c4bc7cc1c7b00c78f7103e8f45", "content": "If you are not able to use Spring Boot and would like to configure one of the pre-defined providers in `CommonOAuth2Provider` (for example, Google), apply the following configuration:\n\n.OAuth2 Login Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2Login(withDefaults());\n\n return http.build();\n\t}\n\n\t@Bean\n\tpublic ReactiveClientRegistrationRepository clientRegistrationRepository() {\n return new InMemoryReactiveClientRegistrationRepository(this.googleClientRegistration());\n\t}\n\n\t@Bean\n\tpublic ReactiveOAuth2AuthorizedClientService authorizedClientService(\n ReactiveClientRegistrationRepository clientRegistrationRepository) {\n return new InMemoryReactiveOAuth2AuthorizedClientService(clientRegistrationRepository);\n\t}\n\n\t@Bean\n\tpublic ServerOAuth2AuthorizedClientRepository authorizedClientRepository(\n ReactiveOAuth2AuthorizedClientService authorizedClientService) {\n return new AuthenticatedPrincipalServerOAuth2AuthorizedClientRepository(authorizedClientService);\n\t}\n\n\tprivate ClientRegistration googleClientRegistration() {\n return CommonOAuth2Provider.GOOGLE.getBuilder(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2LoginConfig {\n\n @Bean\n fun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2Login { }\n }\n\n return http.build()\n }\n\n @Bean\n fun clientRegistrationRepository(): ReactiveClientRegistrationRepository {\n return InMemoryReactiveClientRegistrationRepository(googleClientRegistration())\n }\n\n @Bean\n fun authorizedClientService(\n clientRegistrationRepository: ReactiveClientRegistrationRepository\n ): ReactiveOAuth2AuthorizedClientService {\n return InMemoryReactiveOAuth2AuthorizedClientService(clientRegistrationRepository)\n }\n\n @Bean\n fun authorizedClientRepository(\n authorizedClientService: ReactiveOAuth2AuthorizedClientService\n ): ServerOAuth2AuthorizedClientRepository {\n return AuthenticatedPrincipalServerOAuth2AuthorizedClientRepository(authorizedClientService)\n }\n\n private fun googleClientRegistration(): ClientRegistration {\n return CommonOAuth2Provider.GOOGLE.getBuilder(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .build()\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Java Configuration without Spring Boot", "heading_level": 2, "file_order": 46, "section_index": 13, "content_hash": "d4fb589d4944117194a1bdbbf27b8db712f260c4bc7cc1c7b00c78f7103e8f45", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/core.adoc"}}
{"id": "sha256:a3ade23c585578aab966857db6a2d4ee1e0d2e336bc86e9728d626de1dc30700", "content": "[[webflux-oauth2-login]]\n\nThe OAuth 2.0 Login feature provides an application with the ability to have users log in to the application by using their existing account at an OAuth 2.0 Provider (such as GitHub) or OpenID Connect 1.0 Provider (such as Google).\nOAuth 2.0 Login implements the \"Login with Google\" or \"Login with GitHub\" use cases.\n\n[NOTE]\n====\nOAuth 2.0 Login is implemented by using the *Authorization Code Grant*, as specified in the https://tools.ietf.org/html/rfc6749#section-4.1[OAuth 2.0 Authorization Framework] and https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth[OpenID Connect Core 1.0].\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 47, "section_index": 0, "content_hash": "a3ade23c585578aab966857db6a2d4ee1e0d2e336bc86e9728d626de1dc30700", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/index.adoc"}}
{"id": "sha256:b1d7d1cb59ba61fb2de4417c8d490a688103945d037c450fbfc21f12cf0e6e0c", "content": "Once an end user is able to login to your application, it's important to consider how they will log out.\n\nGenerally speaking, there are three use cases for you to consider:\n\n1. I want to perform only a local logout\n2. I want to log out both my application and the OIDC Provider, initiated by my application\n3. I want to log out both my application and the OIDC Provider, initiated by the OIDC Provider\n\n[[configure-local-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "OIDC Logout", "heading_level": 1, "file_order": 48, "section_index": 0, "content_hash": "b1d7d1cb59ba61fb2de4417c8d490a688103945d037c450fbfc21f12cf0e6e0c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc"}}
{"id": "sha256:99aeee3de84f143107b6c56b9018c750d865df3e33fd6f6d862431a13e14ffda", "content": "To perform a local logout, no special OIDC configuration is needed.\nSpring Security automatically stands up a local logout endpoint, which you can xref:reactive/authentication/logout.adoc[configure through the `logout()` DSL].\n\n[[configure-client-initiated-oidc-logout]]\n[[oauth2login-advanced-oidc-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "Local Logout", "heading_level": 2, "file_order": 48, "section_index": 1, "content_hash": "99aeee3de84f143107b6c56b9018c750d865df3e33fd6f6d862431a13e14ffda", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc"}}
{"id": "sha256:6e81584b6f2e1c9f30466033be0d3a0e45cdceb09972001475c101afaf20711b", "content": "OpenID Connect Session Management 1.0 allows the ability to log out the end user at the Provider by using the Client.\nOne of the strategies available is https://openid.net/specs/openid-connect-rpinitiated-1_0.html[RP-Initiated Logout].\n\nIf the OpenID Provider supports both Session Management and https://openid.net/specs/openid-connect-discovery-1_0.html[Discovery], the client can obtain the `end_session_endpoint` `URL` from the OpenID Provider's https://openid.net/specs/openid-connect-session-1_0.html#OPMetadata[Discovery Metadata].\nYou can do so by configuring the `ClientRegistration` with the `issuer-uri`, as follows:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n ...\n provider:\n okta:\n issuer-uri: https://dev-1234.oktapreview.com\n----\n\nAlso, you should configure `OidcClientInitiatedServerLogoutSuccessHandler`, which implements RP-Initiated Logout, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Autowired\n\tprivate ReactiveClientRegistrationRepository clientRegistrationRepository;\n\n\t@Bean\n\tpublic SecurityWebFilterChain filterChain(ServerHttpSecurity http) throws Exception {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2Login(withDefaults())\n .logout((logout) -> logout\n .logoutSuccessHandler(oidcLogoutSuccessHandler())\n );\n return http.build();\n\t}\n\n\tprivate ServerLogoutSuccessHandler oidcLogoutSuccessHandler() {\n OidcClientInitiatedServerLogoutSuccessHandler oidcLogoutSuccessHandler =\n new OidcClientInitiatedServerLogoutSuccessHandler(this.clientRegistrationRepository);\n\n // Sets the location that the End-User's User Agent will be redirected to\n // after the logout has been performed at the Provider\n oidcLogoutSuccessHandler.setPostLogoutRedirectUri(\"{baseUrl}\");\n\n return oidcLogoutSuccessHandler;\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\nclass OAuth2LoginSecurityConfig {\n @Autowired\n private lateinit var clientRegistrationRepository: ReactiveClientRegistrationRepository\n\n @Bean\n open fun filterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2Login { }\n logout {\n logoutSuccessHandler = oidcLogoutSuccessHandler()\n }\n }\n return http.build()\n }\n\n private fun oidcLogoutSuccessHandler(): ServerLogoutSuccessHandler {\n val oidcLogoutSuccessHandler = OidcClientInitiatedServerLogoutSuccessHandler(clientRegistrationRepository)\n\n // Sets the location that the End-User's User Agent will be redirected to\n // after the logout has been performed at the Provider\n oidcLogoutSuccessHandler.setPostLogoutRedirectUri(\"{baseUrl}\")\n return oidcLogoutSuccessHandler\n }\n}\n----\n======\n\n[NOTE]\n====\n`OidcClientInitiatedServerLogoutSuccessHandler` supports the `+{baseUrl}+` placeholder.\nIf used, the application's base URL, such as `https://app.example.org`, replaces it at request time.\n====\n\n[NOTE]\n====\nBy default, `OidcClientInitiatedServerLogoutSuccessHandler` redirects to the logout URL using a standard HTTP redirect with the `GET` method.\nTo perform the logout using a `POST` request, set the redirect strategy to `FormPostServerRedirectStrategy`, for example with `OidcClientInitiatedServerLogoutSuccessHandler.setRedirectStrategy(new ServerFormPostRedirectStrategy())`.\n====\n\n[[configure-provider-initiated-oidc-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "OpenID Connect 1.0 Client-Initiated Logout", "heading_level": 2, "file_order": 48, "section_index": 2, "content_hash": "6e81584b6f2e1c9f30466033be0d3a0e45cdceb09972001475c101afaf20711b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc"}}
{"id": "sha256:44593003fcb8f3275f4bd7751af305bd8f288471689e5a2a2a1d9e0787251ea1", "content": "OpenID Connect Session Management 1.0 allows the ability to log out the end user at the Client by having the Provider make an API call to the Client.\nThis is referred to as https://openid.net/specs/openid-connect-backchannel-1_0.html[OIDC Back-Channel Logout].\n\nTo enable this, you can stand up the Back-Channel Logout endpoint in the DSL like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nOidcBackChannelServerLogoutHandler oidcLogoutHandler() {\n\treturn new OidcBackChannelServerLogoutHandler();\n}\n\n@Bean\npublic SecurityWebFilterChain filterChain(ServerHttpSecurity http) throws Exception {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2Login(withDefaults())\n .oidcLogout((logout) -> logout\n .backChannel(Customizer.withDefaults())\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun oidcLogoutHandler(): OidcBackChannelLogoutHandler {\n return OidcBackChannelLogoutHandler()\n}\n\n@Bean\nopen fun filterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2Login { }\n oidcLogout {\n backChannel { }\n }\n }\n return http.build()\n}\n----\n======\n\nAnd that's it!\n\nThis will stand up the endpoint `+/logout/connect/back-channel/{registrationId}+` which the OIDC Provider can request to invalidate a given session of an end user in your application.\n\n[NOTE]\n`oidcLogout` requires that `oauth2Login` also be configured.\n\n[NOTE]\n`oidcLogout` requires that the session cookie be called `JSESSIONID` in order to correctly log out each session through a backchannel.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "OpenID Connect 1.0 Back-Channel Logout", "heading_level": 2, "file_order": 48, "section_index": 3, "content_hash": "44593003fcb8f3275f4bd7751af305bd8f288471689e5a2a2a1d9e0787251ea1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc"}}
{"id": "sha256:32bd9f2838cacf32576f212a4cfa4b18b645216c1c99fe5509bf41f88f45837a", "content": "Consider a `ClientRegistration` whose identifier is `registrationId`.\n\nThe overall flow for a Back-Channel logout is like this:\n\n1. At login time, Spring Security correlates the ID Token, CSRF Token, and Provider Session ID (if any) to your application's session id in its `ReactiveOidcSessionRegistry` implementation.\n2. Then at logout time, your OIDC Provider makes an API call to `/logout/connect/back-channel/registrationId` including a Logout Token that indicates either the `sub` (the End User) or the `sid` (the Provider Session ID) to logout.\n3. Spring Security validates the token's signature and claims.\n4. If the token contains a `sid` claim, then only the Client's session that correlates to that provider session is terminated.\n5. Otherwise, if the token contains a `sub` claim, then all that Client's sessions for that End User are terminated.\n\n[NOTE]\nRemember that Spring Security's OIDC support is multi-tenant.\nThis means that it will only terminate sessions whose Client matches the `aud` claim in the Logout Token.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "Back-Channel Logout Architecture", "heading_level": 3, "file_order": 48, "section_index": 4, "content_hash": "32bd9f2838cacf32576f212a4cfa4b18b645216c1c99fe5509bf41f88f45837a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc"}}
{"id": "sha256:f6527e9f6345c847bbcb38d378d91510014f90a592e922850e3bd6a6434043ef", "content": "With `OidcBackChannelServerLogoutHandler` published, the session logout endpoint is `+{baseUrl}+/logout/connect/back-channel/+{registrationId}+`.\n\nIf `OidcBackChannelServerLogoutHandler` is not wired, then the URL is `+{baseUrl}+/logout/connect/back-channel/+{registrationId}+`, which is not recommended since it requires passing a CSRF token, which can be challenging depending on the kind of repository your application uses.\n\nIn the event that you need to customize the endpoint, you can provide the URL as follows:\n\n[tabs]\n======\nJava::\n+\n[source=java,role=\"primary\"]\n----\nhttp\n // ...\n .oidcLogout((oidc) -> oidc\n .backChannel((backChannel) -> backChannel\n .logoutUri(\"http://localhost:9000/logout/connect/back-channel/+{registrationId}+\")\n )\n );\n----\n\nKotlin::\n+\n[source=kotlin,role=\"secondary\"]\n----\nhttp {\n oidcLogout {\n backChannel {\n logoutUri = \"http://localhost:9000/logout/connect/back-channel/+{registrationId}+\"\n }\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "Customizing the Session Logout Endpoint", "heading_level": 3, "file_order": 48, "section_index": 5, "content_hash": "f6527e9f6345c847bbcb38d378d91510014f90a592e922850e3bd6a6434043ef", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc"}}
{"id": "sha256:30a574d47bb2a302d86bfb34e3257981794ccc46ce44fa43cab0bb7472670f29", "content": "By default, the session logout endpoint uses the `JSESSIONID` cookie to correlate the session to the corresponding `OidcSessionInformation`.\n\nHowever, the default cookie name in Spring Session is `SESSION`.\n\nYou can configure Spring Session's cookie name in the DSL like so:\n\n[tabs]\n======\nJava::\n+\n[source=java,role=\"primary\"]\n----\n@Bean\nOidcBackChannelServerLogoutHandler oidcLogoutHandler(ReactiveOidcSessionRegistry sessionRegistry) {\n OidcBackChannelServerLogoutHandler logoutHandler = new OidcBackChannelServerLogoutHandler(sessionRegistry);\n logoutHandler.setSessionCookieName(\"SESSION\");\n return logoutHandler;\n}\n----\n\nKotlin::\n+\n[source=kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun oidcLogoutHandler(val sessionRegistry: ReactiveOidcSessionRegistry): OidcBackChannelServerLogoutHandler {\n val logoutHandler = OidcBackChannelServerLogoutHandler(sessionRegistry)\n logoutHandler.setSessionCookieName(\"SESSION\")\n return logoutHandler\n}\n----\n======\n\n[[oidc-backchannel-logout-session-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "Customizing the Session Logout Cookie Name", "heading_level": 3, "file_order": 48, "section_index": 6, "content_hash": "30a574d47bb2a302d86bfb34e3257981794ccc46ce44fa43cab0bb7472670f29", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc"}}
{"id": "sha256:b752e2bba2b3ce921502ba098302122fcdeebb86bd00875614791766a0ce79dc", "content": "By default, Spring Security stores in-memory all links between the OIDC Provider session and the Client session.\n\nThere are a number of circumstances, like a clustered application, where it would be nice to store this instead in a separate location, like a database.\n\nYou can achieve this by configuring a custom `ReactiveOidcSessionRegistry`, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic final class MySpringDataOidcSessionRegistry implements ReactiveOidcSessionRegistry {\n private final OidcProviderSessionRepository sessions;\n\n // ...\n\n @Override\n public Mono<void> saveSessionInformation(OidcSessionInformation info) {\n return this.sessions.save(info);\n }\n\n @Override\n public Mono<OidcSessionInformation> removeSessionInformation(String clientSessionId) {\n return this.sessions.removeByClientSessionId(clientSessionId);\n }\n\n @Override\n public Flux<OidcSessionInformation> removeSessionInformation(OidcLogoutToken token) {\n return token.getSessionId() != null ?\n this.sessions.removeBySessionIdAndIssuerAndAudience(...) :\n this.sessions.removeBySubjectAndIssuerAndAudience(...);\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass MySpringDataOidcSessionRegistry: ReactiveOidcSessionRegistry {\n val sessions: OidcProviderSessionRepository\n\n // ...\n\n @Override\n fun saveSessionInformation(info: OidcSessionInformation): Mono<Void> {\n return this.sessions.save(info)\n }\n\n @Override\n fun removeSessionInformation(clientSessionId: String): Mono<OidcSessionInformation> {\n return this.sessions.removeByClientSessionId(clientSessionId);\n }\n\n @Override\n fun removeSessionInformation(token: OidcLogoutToken): Flux<OidcSessionInformation> {\n return token.getSessionId() != null ?\n this.sessions.removeBySessionIdAndIssuerAndAudience(...) :\n this.sessions.removeBySubjectAndIssuerAndAudience(...);\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "Customizing the OIDC Provider Session Registry", "heading_level": 3, "file_order": 48, "section_index": 7, "content_hash": "b752e2bba2b3ce921502ba098302122fcdeebb86bd00875614791766a0ce79dc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/login/logout.adoc"}}
{"id": "sha256:dfaf2941d9295f88c13f78fef554f9b94f9d2b278f7cdf2b4be2d5335448f084", "content": "[[webflux-oauth2resourceserver-bearertoken-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/bearer-tokens.adoc", "title": "OAuth 2.0 Resource Server Bearer Tokens", "heading": "OAuth 2.0 Resource Server Bearer Tokens", "heading_level": 1, "file_order": 49, "section_index": 0, "content_hash": "dfaf2941d9295f88c13f78fef554f9b94f9d2b278f7cdf2b4be2d5335448f084", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/bearer-tokens.adoc"}}
{"id": "sha256:0b257d3b43a5cebfe8b74e117ede89372fe73626801cbde2712c419c36e2043e", "content": "By default, Resource Server looks for a bearer token in the `Authorization` header.\nHowever, you can verify this token.\n\nFor example, you may have a need to read the bearer token from a custom header.\nTo do so, you can wire an instance of `ServerBearerTokenAuthenticationConverter` into the DSL:\n\n.Custom Bearer Token Header\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nServerBearerTokenAuthenticationConverter converter = new ServerBearerTokenAuthenticationConverter();\nconverter.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION);\nhttp\n .oauth2ResourceServer((oauth2) -> oauth2\n .bearerTokenConverter(converter)\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval converter = ServerBearerTokenAuthenticationConverter()\nconverter.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION)\nreturn http {\n oauth2ResourceServer {\n bearerTokenConverter = converter\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/bearer-tokens.adoc", "title": "OAuth 2.0 Resource Server Bearer Tokens", "heading": "Bearer Token Resolution", "heading_level": 2, "file_order": 49, "section_index": 1, "content_hash": "0b257d3b43a5cebfe8b74e117ede89372fe73626801cbde2712c419c36e2043e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/bearer-tokens.adoc"}}
{"id": "sha256:d1218ebb6b36223c663e549d808217470723b1377d0b140df0e83188cf86f8ba", "content": "Now that you have a bearer token, you can pass that to downstream services.\nThis is possible with javadoc:org.springframework.security.oauth2.server.resource.web.reactive.function.client.ServerBearerExchangeFilterFunction[]:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic WebClient rest() {\n return WebClient.builder()\n .filter(new ServerBearerExchangeFilterFunction())\n .build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun rest(): WebClient {\n return WebClient.builder()\n .filter(ServerBearerExchangeFilterFunction())\n .build()\n}\n----\n======\n\nWhen the `WebClient` shown in the preceding example performs requests, Spring Security looks up the current `Authentication` and extract any javadoc:org.springframework.security.oauth2.core.AbstractOAuth2Token[] credential.\nThen, it propagates that token in the `Authorization` header -- for example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nthis.rest.get()\n .uri(\"https://other-service.example.com/endpoint\")\n .retrieve()\n .bodyToMono(String.class)\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nthis.rest.get()\n .uri(\"https://other-service.example.com/endpoint\")\n .retrieve()\n .bodyToMono<String>()\n----\n======\n\nThe preceding example invokes the `https://other-service.example.com/endpoint`, adding the bearer token `Authorization` header for you.\n\nIn places where you need to override this behavior, you can supply the header yourself:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nthis.rest.get()\n .uri(\"https://other-service.example.com/endpoint\")\n .headers((headers) -> headers.setBearerAuth(overridingToken))\n .retrieve()\n .bodyToMono(String.class)\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nrest.get()\n .uri(\"https://other-service.example.com/endpoint\")\n .headers { it.setBearerAuth(overridingToken) }\n .retrieve()\n .bodyToMono<String>()\n----\n======\n\nIn this case, the filter falls back and forwards the request onto the rest of the web filter chain.\n\n[NOTE]\n====\nUnlike the javadoc:org.springframework.security.oauth2.client.web.reactive.function.client.ServerOAuth2AuthorizedClientExchangeFilterFunction[OAuth 2.0 Client filter function], this filter function makes no attempt to renew the token, should it be expired.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/bearer-tokens.adoc", "title": "OAuth 2.0 Resource Server Bearer Tokens", "heading": "Bearer Token Propagation", "heading_level": 2, "file_order": 49, "section_index": 2, "content_hash": "d1218ebb6b36223c663e549d808217470723b1377d0b140df0e83188cf86f8ba", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/bearer-tokens.adoc"}}
{"id": "sha256:73e9cd2c52d00a4dde528bd5ebe599fd5460e06d18b7ead86c863f914604bd4a", "content": "[[webflux-oauth2-resource-server]]\n\nSpring Security supports protecting endpoints by offering two forms of OAuth 2.0 https://tools.ietf.org/html/rfc6750.html[Bearer Tokens]:\n\n* https://tools.ietf.org/html/rfc7519[JWT]\n* Opaque Tokens\n\nThis is handy in circumstances where an application has delegated its authority management to an https://tools.ietf.org/html/rfc6749[authorization server] (for example, Okta or Ping Identity).\nResource servers can consult this authorization server to authorize requests.\n\n[NOTE]\n====\nA complete working example for {gh-samples-url}/reactive/webflux/java/oauth2/resource-server[JWT] is available in the {gh-samples-url}[Spring Security repository].\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 50, "section_index": 0, "content_hash": "73e9cd2c52d00a4dde528bd5ebe599fd5460e06d18b7ead86c863f914604bd4a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/index.adoc"}}
{"id": "sha256:b902ed93006428a6586a7f41754873b8c1552d35c43c8b28347c74b5bf4cbea8", "content": "[[webflux-oauth2resourceserver-jwt-minimaldependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "OAuth 2.0 Resource Server JWT", "heading_level": 1, "file_order": 51, "section_index": 0, "content_hash": "b902ed93006428a6586a7f41754873b8c1552d35c43c8b28347c74b5bf4cbea8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:cbb9801ba74d2718b6554968d2bfb1922f25c3763b21afadc89477fcf6404973", "content": "Most Resource Server support is collected into `spring-security-oauth2-resource-server`.\nHowever, the support for decoding and verifying JWTs is in `spring-security-oauth2-jose`, meaning that both are necessary to have a working resource server that supports JWT-encoded Bearer Tokens.\n\n[[webflux-oauth2resourceserver-jwt-minimalconfiguration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Minimal Dependencies for JWT", "heading_level": 2, "file_order": 51, "section_index": 1, "content_hash": "cbb9801ba74d2718b6554968d2bfb1922f25c3763b21afadc89477fcf6404973", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:2d07e355ec9d10cceba9d66d2a208b61df7df22008e07fd0a95b27070d61358a", "content": "When using https://spring.io/projects/spring-boot[Spring Boot], configuring an application as a resource server consists of two basic steps.\nFirst, include the needed dependencies. Second, indicate the location of the authorization server.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Minimal Configuration for JWTs", "heading_level": 2, "file_order": 51, "section_index": 2, "content_hash": "2d07e355ec9d10cceba9d66d2a208b61df7df22008e07fd0a95b27070d61358a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:9335b0d3b5963be320e14a5a4ea28c99ba48dab97a81f3d8a67c05a3e77e8240", "content": "In a Spring Boot application, you need to specify which authorization server to use:\n\n[source,yml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n issuer-uri: https://idp.example.com/issuer\n----\n\nWhere `https://idp.example.com/issuer` is the value contained in the `iss` claim for JWT tokens that the authorization server issues.\nThis resource server uses this property to further self-configure, discover the authorization server's public keys, and subsequently validate incoming JWTs.\n\n[NOTE]\n====\nTo use the `issuer-uri` property, it must also be true that one of `https://idp.example.com/issuer/.well-known/openid-configuration`, `https://idp.example.com/.well-known/openid-configuration/issuer`, or `https://idp.example.com/.well-known/oauth-authorization-server/issuer` is a supported endpoint for the authorization server.\nThis endpoint is referred to as a https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[Provider Configuration] endpoint or a https://tools.ietf.org/html/rfc8414#section-3[Authorization Server Metadata] endpoint.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Specifying the Authorization Server", "heading_level": 3, "file_order": 51, "section_index": 3, "content_hash": "9335b0d3b5963be320e14a5a4ea28c99ba48dab97a81f3d8a67c05a3e77e8240", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:63b80e8d21a54c919b04ccb518883440b19ccd70904adce7bfe2fd42d39aae2a", "content": "When this property and these dependencies are used, Resource Server automatically configures itself to validate JWT-encoded Bearer Tokens.\n\nIt achieves this through a deterministic startup process:\n\n. Hit the Provider Configuration or Authorization Server Metadata endpoint, processing the response for the `jwks_url` property.\n. Configure the validation strategy to query `jwks_url` for valid public keys.\n. Configure the validation strategy to validate each JWT's `iss` claim against `https://idp.example.com`.\n\nA consequence of this process is that the authorization server must be receiving requests in order for Resource Server to successfully start up.\n\n[NOTE]\n====\nIf the authorization server is down when Resource Server queries it (given appropriate timeouts), then startup fails.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Startup Expectations", "heading_level": 3, "file_order": 51, "section_index": 4, "content_hash": "63b80e8d21a54c919b04ccb518883440b19ccd70904adce7bfe2fd42d39aae2a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:c641a5df61631fa3c8ed2e7f86c54b5861308e1388e5befebfad1373d3eb56bf", "content": "Once the application is started up, Resource Server tries to process any request that contains an `Authorization: Bearer` header:\n\n[source,html]\n----\nGET / HTTP/1.1\nAuthorization: Bearer some-token-value # Resource Server will process this\n----\n\nSo long as this scheme is indicated, Resource Server tries to process the request according to the Bearer Token specification.\n\nGiven a well-formed JWT, Resource Server:\n\n. Validates its signature against a public key obtained from the `jwks_url` endpoint during startup and matched against the JWTs header.\n. Validates the JWTs `exp` and `nbf` timestamps and the JWTs `iss` claim.\n. Maps each scope to an authority with the prefix `SCOPE_`.\n\n[NOTE]\n====\nAs the authorization server makes available new keys, Spring Security automatically rotates the keys used to validate the JWT tokens.\n====\n\nBy default, the resulting `Authentication#getPrincipal` is a Spring Security `Jwt` object, and `Authentication#getName` maps to the JWT's `sub` property, if one is present.\n\nFrom here, consider jumping to:\n\n* <<webflux-oauth2resourceserver-jwt-jwkseturi,How to Configure without Tying Resource Server startup to an authorization server's availability>>\n* <<webflux-oauth2resourceserver-jwt-sansboot,How to Configure without Spring Boot>>\n\n[[webflux-oauth2resourceserver-jwt-jwkseturi]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Runtime Expectations", "heading_level": 3, "file_order": 51, "section_index": 5, "content_hash": "c641a5df61631fa3c8ed2e7f86c54b5861308e1388e5befebfad1373d3eb56bf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:562c67b443527b54ce7ac0f011531aa62e47fbef6aa878593ca1fadd67483fc4", "content": "If the authorization server does not support any configuration endpoints, or if Resource Server must be able to start up independently from the authorization server, you can supply `jwk-set-uri` as well:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n issuer-uri: https://idp.example.com\n jwk-set-uri: https://idp.example.com/.well-known/jwks.json\n----\n\n[NOTE]\n====\nThe JWK Set uri is not standardized, but you can typically find it in the authorization server's documentation.\n====\n\nConsequently, Resource Server does not ping the authorization server at startup.\nWe still specify the `issuer-uri` so that Resource Server still validates the `iss` claim on incoming JWTs.\n\n[NOTE]\n====\nYou can supply this property directly on the <<webflux-oauth2resourceserver-jwt-jwkseturi-dsl,DSL>>.\n====\n\n[[webflux-oauth2resourceserver-jwt-sansboot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Specifying the Authorization Server JWK Set Uri Directly", "heading_level": 3, "file_order": 51, "section_index": 6, "content_hash": "562c67b443527b54ce7ac0f011531aa62e47fbef6aa878593ca1fadd67483fc4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:b435d22573f868839d51c651c18831c076638deede924cd5429c52701c278e60", "content": "Spring Boot generates two `@Bean` objects on Resource Server's behalf.\n\nThe first bean is a `SecurityWebFilterChain` that configures the application as a resource server. When including `spring-security-oauth2-jose`, this `SecurityWebFilterChain` looks like:\n\n.Resource Server SecurityWebFilterChain\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer(OAuth2ResourceServerSpec::jwt)\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n jwt { }\n }\n }\n}\n----\n======\n\nIf the application does not expose a `SecurityWebFilterChain` bean, Spring Boot exposes the default one (shown in the preceding listing).\n\nTo replace it, expose the `@Bean` within the application:\n\n.Replacing SecurityWebFilterChain\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope;\n\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n .authorizeExchange((authorize) -> authorize\n .pathMatchers(\"/message/**\").access(hasScope(\"message:read\"))\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt(withDefaults())\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope\n\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(\"/message/**\", hasScope(\"message:read\"))\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n jwt { }\n }\n }\n}\n----\n======\n\nThe preceding configuration requires the scope of `message:read` for any URL that starts with `/messages/`.\n\nMethods on the `oauth2ResourceServer` DSL also override or replace auto configuration.\n\nFor example, the second `@Bean` Spring Boot creates is a `ReactiveJwtDecoder`, which decodes `String` tokens into validated instances of `Jwt`:\n\n.ReactiveJwtDecoder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveJwtDecoder jwtDecoder() {\n return ReactiveJwtDecoders.fromIssuerLocation(issuerUri);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n return ReactiveJwtDecoders.fromIssuerLocation(issuerUri)\n}\n----\n======\n\n[NOTE]\n====\nCalling javadoc:org.springframework.security.oauth2.jwt.ReactiveJwtDecoders#fromIssuerLocation-java.lang.String-[ReactiveJwtDecoders#fromIssuerLocation] invokes the Provider Configuration or Authorization Server Metadata endpoint to derive the JWK Set URI.\nIf the application does not expose a `ReactiveJwtDecoder` bean, Spring Boot exposes the above default one.\n====\n\nIts configuration can be overridden by using `jwkSetUri()` or replaced by using `decoder()`.\n\n[[webflux-oauth2resourceserver-jwt-jwkseturi-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Overriding or Replacing Boot Auto Configuration", "heading_level": 3, "file_order": 51, "section_index": 7, "content_hash": "b435d22573f868839d51c651c18831c076638deede924cd5429c52701c278e60", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:31eea1a2e7b70784146cf6ee84ab490b25dad50dccd6a97ab6f9e65e4b84c8f9", "content": "You can configure an authorization server's JWK Set URI <<webflux-oauth2resourceserver-jwt-jwkseturi,as a configuration property>> or supply it in the DSL:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt((jwt) -> jwt\n .jwkSetUri(\"https://idp.example.com/.well-known/jwks.json\")\n )\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n jwt {\n jwkSetUri = \"https://idp.example.com/.well-known/jwks.json\"\n }\n }\n }\n}\n----\n======\n\nUsing `jwkSetUri()` takes precedence over any configuration property.\n\n[[webflux-oauth2resourceserver-jwt-decoder-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Using `jwkSetUri()`", "heading_level": 4, "file_order": 51, "section_index": 8, "content_hash": "31eea1a2e7b70784146cf6ee84ab490b25dad50dccd6a97ab6f9e65e4b84c8f9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:c4a909b61a91cab187b8937f8bb3228371f5cc062223fd430deef97f5ab2c73a", "content": "`decoder()` is more powerful than `jwkSetUri()`, because it completely replaces any Spring Boot auto-configuration of `JwtDecoder`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt((jwt) -> jwt\n .decoder(myCustomDecoder())\n )\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n jwt {\n jwtDecoder = myCustomDecoder()\n }\n }\n }\n}\n----\n======\n\nThis is handy when you need deeper configuration, such as <<webflux-oauth2resourceserver-jwt-validation,validation>>.\n\n[[webflux-oauth2resourceserver-decoder-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Using `decoder()`", "heading_level": 4, "file_order": 51, "section_index": 9, "content_hash": "c4a909b61a91cab187b8937f8bb3228371f5cc062223fd430deef97f5ab2c73a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:c4df826bbab1fa04331a9c308dcd6a8a488427346cc9c82729ecc6bc47bb4813", "content": "Alternately, exposing a `ReactiveJwtDecoder` `@Bean` has the same effect as `decoder()`:\nYou can construct one with a `jwkSetUri` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveJwtDecoder jwtDecoder() {\n return NimbusReactiveJwtDecoder.withJwkSetUri(jwkSetUri).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n return NimbusReactiveJwtDecoder.withJwkSetUri(jwkSetUri).build()\n}\n----\n======\n\nor you can use the issuer and have `NimbusReactiveJwtDecoder` look up the `jwkSetUri` when `build()` is invoked, like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveJwtDecoder jwtDecoder() {\n return NimbusReactiveJwtDecoder.withIssuerLocation(issuer).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n return NimbusReactiveJwtDecoder.withIssuerLocation(issuer).build()\n}\n----\n======\n\nOr, if the defaults work for you, you can also use `JwtDecoders`, which does the above in addition to configuring the decoder's validator:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveJwtDecoder jwtDecoder() {\n return ReactiveJwtDecoders.fromIssuerLocation(issuer);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n return ReactiveJwtDecoders.fromIssuerLocation(issuer)\n}\n----\n======\n\n[[webflux-oauth2resourceserver-jwt-decoder-algorithm]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Exposing a `ReactiveJwtDecoder` `@Bean`", "heading_level": 4, "file_order": 51, "section_index": 10, "content_hash": "c4df826bbab1fa04331a9c308dcd6a8a488427346cc9c82729ecc6bc47bb4813", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:b4aa2cbbdaade59a32758b6f75e536dcf525fca32bc08f37ad31bc99ece344fa", "content": "By default, `NimbusReactiveJwtDecoder`, and hence Resource Server, trust and verify only tokens that use `RS256`.\n\nYou can customize this behavior with <<webflux-oauth2resourceserver-jwt-boot-algorithm,Spring Boot>> or by using <<webflux-oauth2resourceserver-jwt-decoder-builder,the NimbusJwtDecoder builder>>.\n\n[[webflux-oauth2resourceserver-jwt-boot-algorithm]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring Trusted Algorithms", "heading_level": 2, "file_order": 51, "section_index": 11, "content_hash": "b4aa2cbbdaade59a32758b6f75e536dcf525fca32bc08f37ad31bc99ece344fa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:4ab36ad0237d00d9ce09a796717065c858f5709902f3f9a14e07381e224bf3dc", "content": "The simplest way to set the algorithm is as a property:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n jws-algorithms: RS512\n jwk-set-uri: https://idp.example.org/.well-known/jwks.json\n----\n\n[[webflux-oauth2resourceserver-jwt-decoder-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Customizing Trusted Algorithms with Spring Boot", "heading_level": 3, "file_order": 51, "section_index": 12, "content_hash": "4ab36ad0237d00d9ce09a796717065c858f5709902f3f9a14e07381e224bf3dc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:d0418c51c7c0add13772e5b97156cf45dc8c6312c448b662d9c7120302a98a6b", "content": "For greater power, though, we can use a builder that ships with `NimbusReactiveJwtDecoder`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nReactiveJwtDecoder jwtDecoder() {\n return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer)\n .jwsAlgorithm(RS512).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer)\n .jwsAlgorithm(RS512).build()\n}\n----\n======\n\nCalling `jwsAlgorithm` more than once configures `NimbusReactiveJwtDecoder` to trust more than one algorithm:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nReactiveJwtDecoder jwtDecoder() {\n return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer)\n .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n return NimbusReactiveJwtDecoder.withIssuerLocation(this.issuer)\n .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build()\n}\n----\n======\n\nAlternately, you can call `jwsAlgorithms`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nReactiveJwtDecoder jwtDecoder() {\n return NimbusReactiveJwtDecoder.withIssuerLocation(this.jwkSetUri)\n .jwsAlgorithms(algorithms -> {\n algorithms.add(RS512);\n algorithms.add(ES512);\n }).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n return NimbusReactiveJwtDecoder.withIssuerLocation(this.jwkSetUri)\n .jwsAlgorithms {\n it.add(RS512)\n it.add(ES512)\n }\n .build()\n}\n----\n======\n\n[[webflux-oauth2resourceserver-jwt-decoder-public-key]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Customizing Trusted Algorithms by Using a Builder", "heading_level": 3, "file_order": 51, "section_index": 13, "content_hash": "d0418c51c7c0add13772e5b97156cf45dc8c6312c448b662d9c7120302a98a6b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:a2ee914d8791e143af36f689dcb1e1c5a6cf9ddf02998e54399bd0873ad0eb2a", "content": "Simpler than backing a Resource Server with a JWK Set endpoint is to hard-code an RSA public key.\nThe public key can be provided with <<webflux-oauth2resourceserver-jwt-decoder-public-key-boot,Spring Boot>> or by <<webflux-oauth2resourceserver-jwt-decoder-public-key-builder,Using a Builder>>.\n\n[[webflux-oauth2resourceserver-jwt-decoder-public-key-boot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Trusting a Single Asymmetric Key", "heading_level": 3, "file_order": 51, "section_index": 14, "content_hash": "a2ee914d8791e143af36f689dcb1e1c5a6cf9ddf02998e54399bd0873ad0eb2a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:65acb2df1783b0d0f0eb095d5bae2f358ed77a42937e356ae2c53a9c4450aff8", "content": "You can specify a key with Spring Boot:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n public-key-location: classpath:my-key.pub\n----\n\nAlternately, to allow for a more sophisticated lookup, you can post-process the `RsaKeyConversionServicePostProcessor`:\n\n.BeanFactoryPostProcessor\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nBeanFactoryPostProcessor conversionServiceCustomizer() {\n return beanFactory ->\n beanFactory.getBean(RsaKeyConversionServicePostProcessor.class)\n .setResourceLoader(new CustomResourceLoader());\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun conversionServiceCustomizer(): BeanFactoryPostProcessor {\n return BeanFactoryPostProcessor { beanFactory: ConfigurableListableBeanFactory ->\n beanFactory.getBean<RsaKeyConversionServicePostProcessor>()\n .setResourceLoader(CustomResourceLoader())\n }\n}\n----\n======\n\nSpecify your key's location:\n\n[source,yaml]\n----\nkey.location: hfds://my-key.pub\n----\n\nThen autowire the value:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Value(\"${key.location}\")\nRSAPublicKey key;\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Value(\"\\${key.location}\")\nval key: RSAPublicKey? = null\n----\n======\n\n[[webflux-oauth2resourceserver-jwt-decoder-public-key-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Via Spring Boot", "heading_level": 4, "file_order": 51, "section_index": 15, "content_hash": "65acb2df1783b0d0f0eb095d5bae2f358ed77a42937e356ae2c53a9c4450aff8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:dbdabb5aa192040fd0f894ff0e32a795bbeb7589aafb7984406980d728d95f73", "content": "To wire an `RSAPublicKey` directly, use the appropriate `NimbusReactiveJwtDecoder` builder:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveJwtDecoder jwtDecoder() {\n return NimbusReactiveJwtDecoder.withPublicKey(this.key).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n return NimbusReactiveJwtDecoder.withPublicKey(key).build()\n}\n----\n======\n\n[[webflux-oauth2resourceserver-jwt-decoder-secret-key]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Using a Builder", "heading_level": 4, "file_order": 51, "section_index": 16, "content_hash": "dbdabb5aa192040fd0f894ff0e32a795bbeb7589aafb7984406980d728d95f73", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:d5b8ff778fba022130e6af5cb7813977ce6b75fb60214259b108c8c4a6348a62", "content": "You can also use a single symmetric key.\nYou can load in your `SecretKey` and use the appropriate `NimbusReactiveJwtDecoder` builder:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveJwtDecoder jwtDecoder() {\n return NimbusReactiveJwtDecoder.withSecretKey(this.key).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n return NimbusReactiveJwtDecoder.withSecretKey(this.key).build()\n}\n----\n======\n\n[[webflux-oauth2resourceserver-jwt-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Trusting a Single Symmetric Key", "heading_level": 3, "file_order": 51, "section_index": 17, "content_hash": "d5b8ff778fba022130e6af5cb7813977ce6b75fb60214259b108c8c4a6348a62", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:eb908ca59ad8a14868e9878d199b8c025c056856271b61066e510eebd8d593f1", "content": "A JWT that is issued from an OAuth 2.0 Authorization Server typically has either a `scope` or an `scp` attribute, indicating the scopes (or authorities) it has been granted -- for example:\n\n[source,json]\n----\n{ ..., \"scope\" : \"messages contacts\"}\n----\n\nWhen this is the case, Resource Server tries to coerce these scopes into a list of granted authorities, prefixing each scope with the string, `SCOPE_`.\n\nThis means that, to protect an endpoint or method with a scope derived from a JWT, the corresponding expressions should include this prefix:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope;\n\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n .authorizeExchange((authorize) -> authorize\n .mvcMatchers(\"/contacts/**\").access(hasScope(\"contacts\"))\n .mvcMatchers(\"/messages/**\").access(hasScope(\"messages\"))\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer(OAuth2ResourceServerSpec::jwt);\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope\n\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(\"/contacts/**\", hasScope(\"contacts\"))\n authorize(\"/messages/**\", hasScope(\"messages\"))\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n jwt { }\n }\n }\n}\n----\n======\n\nYou can do something similar with method security:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PreAuthorize(\"hasAuthority('SCOPE_messages')\")\npublic Flux<Message> getMessages(...) {}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PreAuthorize(\"hasAuthority('SCOPE_messages')\")\nfun getMessages(): Flux<Message> { }\n----\n======\n\n[[webflux-oauth2resourceserver-jwt-authorization-extraction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring Authorization", "heading_level": 3, "file_order": 51, "section_index": 18, "content_hash": "eb908ca59ad8a14868e9878d199b8c025c056856271b61066e510eebd8d593f1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:dc18c6eebdbe601bc6c5faa739ae2fc7c7c14c7977ac653451a2962ce97af27f", "content": "However, there are a number of circumstances where this default is insufficient.\nFor example, some authorization servers do not use the `scope` attribute. Instead, they have their own custom attribute.\nAt other times, the resource server may need to adapt the attribute or a composition of attributes into internalized authorities.\n\nTo this end, the DSL exposes `jwtAuthenticationConverter()`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt((jwt) -> jwt\n .jwtAuthenticationConverter(grantedAuthoritiesExtractor())\n )\n );\n\treturn http.build();\n}\n\nConverter<Jwt, Mono<AbstractAuthenticationToken>> grantedAuthoritiesExtractor() {\n JwtAuthenticationConverter jwtAuthenticationConverter =\n new JwtAuthenticationConverter();\n jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter\n (new GrantedAuthoritiesExtractor());\n return new ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n jwt {\n jwtAuthenticationConverter = grantedAuthoritiesExtractor()\n }\n }\n }\n}\n\nfun grantedAuthoritiesExtractor(): Converter<Jwt, Mono<AbstractAuthenticationToken>> {\n val jwtAuthenticationConverter = JwtAuthenticationConverter()\n jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(GrantedAuthoritiesExtractor())\n return ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter)\n}\n----\n======\n\n`jwtAuthenticationConverter()` is responsible for converting a `Jwt` into an `Authentication`.\nAs part of its configuration, we can supply a subsidiary converter to go from `Jwt` to a `Collection` of granted authorities.\n\nThat final converter might be something like the following `GrantedAuthoritiesExtractor`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nstatic class GrantedAuthoritiesExtractor\n implements Converter<Jwt, Collection<GrantedAuthority>> {\n\n public Collection<GrantedAuthority> convert(Jwt jwt) {\n Collection<?> authorities = (Collection<?>)\n jwt.getClaims().getOrDefault(\"mycustomclaim\", Collections.emptyList());\n\n return authorities.stream()\n .map(Object::toString)\n .map(SimpleGrantedAuthority::new)\n .collect(Collectors.toList());\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ninternal class GrantedAuthoritiesExtractor : Converter<Jwt, Collection<GrantedAuthority>> {\n override fun convert(jwt: Jwt): Collection<GrantedAuthority> {\n val authorities: List<Any> = jwt.claims\n .getOrDefault(\"mycustomclaim\", emptyList<Any>()) as List<Any>\n return authorities\n .map { it.toString() }\n .map { SimpleGrantedAuthority(it) }\n }\n}\n----\n======\n\nFor more flexibility, the DSL supports entirely replacing the converter with any class that implements `Converter<Jwt, Mono<AbstractAuthenticationToken>>`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nstatic class CustomAuthenticationConverter implements Converter<Jwt, Mono<AbstractAuthenticationToken>> {\n public AbstractAuthenticationToken convert(Jwt jwt) {\n return Mono.just(jwt).map(this::doConversion);\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ninternal class CustomAuthenticationConverter : Converter<Jwt, Mono<AbstractAuthenticationToken>> {\n override fun convert(jwt: Jwt): Mono<AbstractAuthenticationToken> {\n return Mono.just(jwt).map(this::doConversion)\n }\n}\n----\n======\n\n[[webflux-oauth2resourceserver-jwt-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Extracting Authorities Manually", "heading_level": 4, "file_order": 51, "section_index": 19, "content_hash": "dc18c6eebdbe601bc6c5faa739ae2fc7c7c14c7977ac653451a2962ce97af27f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:856dfaeda7e387e93c55bd28c866cdd487d54bae502fe07f912678388db4454b", "content": "Using <<webflux-oauth2resourceserver-jwt-minimalconfiguration,minimal Spring Boot configuration>>, indicating the authorization server's issuer URI, Resource Server defaults to verifying the `iss` claim as well as the `exp` and `nbf` timestamp claims.\n\nIn circumstances where you need to customize validation needs, Resource Server ships with two standard validators and also accepts custom `OAuth2TokenValidator` instances.\n\n[[webflux-oauth2resourceserver-jwt-validation-clockskew]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring Validation", "heading_level": 3, "file_order": 51, "section_index": 20, "content_hash": "856dfaeda7e387e93c55bd28c866cdd487d54bae502fe07f912678388db4454b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:ad0345c912d85a4b732f21e591d9b40e50dddd2ee8869c127861bad1ab27133c", "content": "JWT instances typically have a window of validity, with the start of the window indicated in the `nbf` claim and the end indicated in the `exp` claim.\n\nHowever, every server can experience clock drift, which can cause tokens to appear to be expired to one server but not to another.\nThis can cause some implementation heartburn, as the number of collaborating servers increases in a distributed system.\n\nResource Server uses `JwtTimestampValidator` to verify a token's validity window, and you can configure it with a `clockSkew` to alleviate the clock drift problem:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nReactiveJwtDecoder jwtDecoder() {\n NimbusReactiveJwtDecoder jwtDecoder = (NimbusReactiveJwtDecoder)\n ReactiveJwtDecoders.fromIssuerLocation(issuerUri);\n\n OAuth2TokenValidator<Jwt> withClockSkew = new DelegatingOAuth2TokenValidator<>(\n new JwtTimestampValidator(Duration.ofSeconds(60)),\n new IssuerValidator(issuerUri));\n\n jwtDecoder.setJwtValidator(withClockSkew);\n\n return jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n val jwtDecoder = ReactiveJwtDecoders.fromIssuerLocation(issuerUri) as NimbusReactiveJwtDecoder\n val withClockSkew: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(\n JwtTimestampValidator(Duration.ofSeconds(60)),\n JwtIssuerValidator(issuerUri))\n jwtDecoder.setJwtValidator(withClockSkew)\n return jwtDecoder\n}\n----\n======\n\n[NOTE]\n====\nBy default, Resource Server configures a clock skew of 60 seconds.\n====\n\n[[webflux-oauth2resourceserver-validation-rfc9068]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Customizing Timestamp Validation", "heading_level": 4, "file_order": 51, "section_index": 21, "content_hash": "ad0345c912d85a4b732f21e591d9b40e50dddd2ee8869c127861bad1ab27133c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:a07b1af57f047f162e48a1b38aa4cea30854fdab5f692c33ba00f6efdb904def", "content": "If you need to require tokens that meet https://datatracker.ietf.org/doc/rfc9068/[RFC 9068], you can configure validation in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n NimbusReactiveJwtDecoder jwtDecoder = NimbusReactiveJwtDecoder.withIssuerLocation(issuerUri)\n .validateTypes(false).build();\n jwtDecoder.setJwtValidator(JwtValidators.createAtJwtValidator()\n .audience(\"https://audience.example.org\")\n .clientId(\"client-identifier\")\n .issuer(\"https://issuer.example.org\").build());\n return jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n val jwtDecoder = NimbusReactiveJwtDecoder.withIssuerLocation(issuerUri)\n .validateTypes(false).build()\n jwtDecoder.setJwtValidator(JwtValidators.createAtJwtValidator()\n .audience(\"https://audience.example.org\")\n .clientId(\"client-identifier\")\n .issuer(\"https://issuer.example.org\").build())\n return jwtDecoder\n}\n----\n======\n\n[[webflux-oauth2resourceserver-validation-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring RFC 9068 Validation", "heading_level": 3, "file_order": 51, "section_index": 22, "content_hash": "a07b1af57f047f162e48a1b38aa4cea30854fdab5f692c33ba00f6efdb904def", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:8eac3bc2e33864bed7848c85c8e7f7698946bd838018c9542cfd0b09e0aaebdc", "content": "You can Add a check for the `aud` claim with the `OAuth2TokenValidator` API:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class AudienceValidator implements OAuth2TokenValidator<Jwt> {\n OAuth2Error error = new OAuth2Error(\"invalid_token\", \"The required audience is missing\", null);\n\n public OAuth2TokenValidatorResult validate(Jwt jwt) {\n if (jwt.getAudience().contains(\"messaging\")) {\n return OAuth2TokenValidatorResult.success();\n } else {\n return OAuth2TokenValidatorResult.failure(error);\n }\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass AudienceValidator : OAuth2TokenValidator<Jwt> {\n var error: OAuth2Error = OAuth2Error(\"invalid_token\", \"The required audience is missing\", null)\n override fun validate(jwt: Jwt): OAuth2TokenValidatorResult {\n return if (jwt.audience.contains(\"messaging\")) {\n OAuth2TokenValidatorResult.success()\n } else {\n OAuth2TokenValidatorResult.failure(error)\n }\n }\n}\n----\n======\n\nThen, to add into a resource server, you can specify the `ReactiveJwtDecoder` instance:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nReactiveJwtDecoder jwtDecoder() {\n NimbusReactiveJwtDecoder jwtDecoder = (NimbusReactiveJwtDecoder)\n ReactiveJwtDecoders.fromIssuerLocation(issuerUri);\n\n OAuth2TokenValidator<Jwt> audienceValidator = new AudienceValidator();\n OAuth2TokenValidator<Jwt> withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);\n OAuth2TokenValidator<Jwt> withAudience = new DelegatingOAuth2TokenValidator<>(withIssuer, audienceValidator);\n\n jwtDecoder.setJwtValidator(withAudience);\n\n return jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): ReactiveJwtDecoder {\n val jwtDecoder = ReactiveJwtDecoders.fromIssuerLocation(issuerUri) as NimbusReactiveJwtDecoder\n val audienceValidator: OAuth2TokenValidator<Jwt> = AudienceValidator()\n val withIssuer: OAuth2TokenValidator<Jwt> = JwtValidators.createDefaultWithIssuer(issuerUri)\n val withAudience: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(withIssuer, audienceValidator)\n jwtDecoder.setJwtValidator(withAudience)\n return jwtDecoder\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring a Custom Validator", "heading_level": 4, "file_order": 51, "section_index": 23, "content_hash": "8eac3bc2e33864bed7848c85c8e7f7698946bd838018c9542cfd0b09e0aaebdc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:70bfae64618798f84a872dbee3515c176d57bba3679ce0a9ecf79f988b0c7013", "content": "[[webflux-oauth2resourceserver-multitenancy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/multitenancy.adoc", "title": "OAuth 2.0 Resource Server Multi-tenancy", "heading": "OAuth 2.0 Resource Server Multi-tenancy", "heading_level": 1, "file_order": 52, "section_index": 0, "content_hash": "70bfae64618798f84a872dbee3515c176d57bba3679ce0a9ecf79f988b0c7013", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/multitenancy.adoc"}}
{"id": "sha256:498860ad6175b0a8565bcf14c0cd8a31dd7e3d1ed9018c2a4f0ab9ac79477cf5", "content": "A resource server is considered multi-tenant when there are multiple strategies for verifying a bearer token, keyed by some tenant identifier.\n\nFor example, your resource server can accept bearer tokens from two different authorization servers.\nAlternately, your authorization server can represent a multiplicity of issuers.\n\nIn each case, two things need to be done and trade-offs are associated with how you choose to do them:\n\n. Resolve the tenant.\n. Propagate the tenant.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/multitenancy.adoc", "title": "OAuth 2.0 Resource Server Multi-tenancy", "heading": "Multi-tenancy", "heading_level": 2, "file_order": 52, "section_index": 1, "content_hash": "498860ad6175b0a8565bcf14c0cd8a31dd7e3d1ed9018c2a4f0ab9ac79477cf5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/multitenancy.adoc"}}
{"id": "sha256:5d9810b345a5283636338266c45eeac66c270b7fb300096e1280b61c91e650cf", "content": "One way to differentiate tenants is by the issuer claim. Since the issuer claim accompanies signed JWTs, you can do so with the `JwtIssuerReactiveAuthenticationManagerResolver`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nJwtIssuerReactiveAuthenticationManagerResolver authenticationManagerResolver = JwtIssuerReactiveAuthenticationManagerResolver\n .fromTrustedIssuers(\"https://idp.example.org/issuerOne\", \"https://idp.example.org/issuerTwo\");\n\nhttp\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .authenticationManagerResolver(authenticationManagerResolver)\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval customAuthenticationManagerResolver = JwtIssuerReactiveAuthenticationManagerResolver\n .fromTrustedIssuers(\"https://idp.example.org/issuerOne\", \"https://idp.example.org/issuerTwo\")\n\nreturn http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n authenticationManagerResolver = customAuthenticationManagerResolver\n }\n}\n----\n======\n\nThis is nice because the issuer endpoints are loaded lazily.\nIn fact, the corresponding `JwtReactiveAuthenticationManager` is instantiated only when the first request with the corresponding issuer is sent.\nThis allows for an application startup that is independent from those authorization servers being up and available.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/multitenancy.adoc", "title": "OAuth 2.0 Resource Server Multi-tenancy", "heading": "Resolving the Tenant By Claim", "heading_level": 3, "file_order": 52, "section_index": 2, "content_hash": "5d9810b345a5283636338266c45eeac66c270b7fb300096e1280b61c91e650cf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/multitenancy.adoc"}}
{"id": "sha256:368619b3b91722ecbf245d38f25cb2481864878fb3e6b232ce95f6e5f928299a", "content": "You may not want to restart the application each time a new tenant is added.\nIn this case, you can configure the `JwtIssuerReactiveAuthenticationManagerResolver` with a repository of `ReactiveAuthenticationManager` instances, which you can edit at runtime:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nprivate Mono<ReactiveAuthenticationManager> addManager(\n Map<String, ReactiveAuthenticationManager> authenticationManagers, String issuer) {\n\n\treturn Mono.fromCallable(() -> ReactiveJwtDecoders.fromIssuerLocation(issuer))\n .subscribeOn(Schedulers.boundedElastic())\n .map(JwtReactiveAuthenticationManager::new)\n .doOnNext((authenticationManager) -> authenticationManager.put(issuer, authenticationManager));\n}\n\nJwtIssuerReactiveAuthenticationManagerResolver authenticationManagerResolver =\n new JwtIssuerReactiveAuthenticationManagerResolver(authenticationManagers::get);\n\nhttp\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .authenticationManagerResolver(authenticationManagerResolver)\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nprivate fun addManager(\n authenticationManagers: MutableMap<String, ReactiveAuthenticationManager>, issuer: String): Mono<JwtReactiveAuthenticationManager> {\n return Mono.fromCallable { ReactiveJwtDecoders.fromIssuerLocation(issuer) }\n .subscribeOn(Schedulers.boundedElastic())\n .map { jwtDecoder: ReactiveJwtDecoder -> JwtReactiveAuthenticationManager(jwtDecoder) }\n .doOnNext { authenticationManager: JwtReactiveAuthenticationManager -> authenticationManagers[issuer] = authenticationManager }\n}\n\nvar customAuthenticationManagerResolver = JwtIssuerReactiveAuthenticationManagerResolver(authenticationManagers::get)\nreturn http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n authenticationManagerResolver = customAuthenticationManagerResolver\n }\n}\n----\n======\n\nIn this case, you construct `JwtIssuerReactiveAuthenticationManagerResolver` with a strategy for obtaining the `ReactiveAuthenticationManager` given to the issuer.\nThis approach lets us add and remove elements from the repository (shown as a `Map` in the preceding snippet) at runtime.\n\n[NOTE]\n====\nIt would be unsafe to simply take any issuer and construct an `ReactiveAuthenticationManager` from it.\nThe issuer should be one that the code can verify from a trusted source, such as an allowed list of issuers.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/multitenancy.adoc", "title": "OAuth 2.0 Resource Server Multi-tenancy", "heading": "Dynamic Tenants", "heading_level": 4, "file_order": 52, "section_index": 3, "content_hash": "368619b3b91722ecbf245d38f25cb2481864878fb3e6b232ce95f6e5f928299a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/multitenancy.adoc"}}
{"id": "sha256:0c80e4ec0a9c117224ecb7886c9468832c6cc1969434c4ef79deca394274ae28", "content": "[[webflux-oauth2resourceserver-opaque-minimaldependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "OAuth 2.0 Resource Server Opaque Token", "heading_level": 1, "file_order": 53, "section_index": 0, "content_hash": "0c80e4ec0a9c117224ecb7886c9468832c6cc1969434c4ef79deca394274ae28", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:d78eba7b361b5a107874544f6c067a932fca9873a0753a6fffeb6b8fccdd25cd", "content": "As described in xref:servlet/oauth2/resource-server/jwt.adoc#oauth2resourceserver-jwt-minimaldependencies[Minimal Dependencies for JWT], most Resource Server support is collected in `spring-security-oauth2-resource-server`.\nHowever, unless you provide a custom <<webflux-oauth2resourceserver-opaque-introspector-bean,`ReactiveOpaqueTokenIntrospector`>>, the Resource Server falls back to `SpringReactiveOpaqueTokenIntrospector`.\nThis means that only `spring-security-oauth2-resource-server` is necessary to have a working minimal Resource Server that supports opaque Bearer Tokens.\n\n[[webflux-oauth2resourceserver-opaque-minimalconfiguration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Minimal Dependencies for Introspection", "heading_level": 2, "file_order": 53, "section_index": 1, "content_hash": "d78eba7b361b5a107874544f6c067a932fca9873a0753a6fffeb6b8fccdd25cd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:3056389cca245931f55e8ac3b7d117e23dc8d5b47c8bea3978b9f2c7f77b0e90", "content": "Typically, you can verify an opaque token with an https://tools.ietf.org/html/rfc7662[OAuth 2.0 Introspection Endpoint], hosted by the authorization server.\nThis can be handy when revocation is a requirement.\n\nWhen using https://spring.io/projects/spring-boot[Spring Boot], configuring an application as a resource server that uses introspection consists of two steps:\n\n. Include the needed dependencies.\n. Indicate the introspection endpoint details.\n\n[[webflux-oauth2resourceserver-opaque-introspectionuri]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Minimal Configuration for Introspection", "heading_level": 2, "file_order": 53, "section_index": 2, "content_hash": "3056389cca245931f55e8ac3b7d117e23dc8d5b47c8bea3978b9f2c7f77b0e90", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:ee6033507e0b5570e15fb3585cb5166cdb1d8643d4db468d87bcd5eceedeec5c", "content": "You can specify where the introspection endpoint is:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n opaquetoken:\n introspection-uri: https://idp.example.com/introspect\n client-id: client\n client-secret: secret\n----\n\nWhere `https://idp.example.com/introspect` is the introspection endpoint hosted by your authorization server and `client-id` and `client-secret` are the credentials needed to hit that endpoint.\n\nResource Server uses these properties to further self-configure and subsequently validate incoming JWTs.\n\n[NOTE]\n====\nIf the authorization server responses that the token is valid, then it is.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Specifying the Authorization Server", "heading_level": 3, "file_order": 53, "section_index": 3, "content_hash": "ee6033507e0b5570e15fb3585cb5166cdb1d8643d4db468d87bcd5eceedeec5c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:4ecb88c333a5d10d05f616ecc479678318a986fb404df212177355e0831bba19", "content": "When this property and these dependencies are used, Resource Server automatically configures itself to validate Opaque Bearer Tokens.\n\nThis startup process is quite a bit simpler than for JWTs, since no endpoints need to be discovered and no additional validation rules get added.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Startup Expectations", "heading_level": 3, "file_order": 53, "section_index": 4, "content_hash": "4ecb88c333a5d10d05f616ecc479678318a986fb404df212177355e0831bba19", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:c8c384e359ad85286e3b30de842c60c75e92ddd0cbb331525c544d56f5188aa4", "content": "Once the application has started, Resource Server tries to process any request containing an `Authorization: Bearer` header:\n\n[source,http]\n----\nGET / HTTP/1.1\nAuthorization: Bearer some-token-value # Resource Server will process this\n----\n\nSo long as this scheme is indicated, Resource Server tries to process the request according to the Bearer Token specification.\n\nGiven an Opaque Token, Resource Server:\n\n. Queries the provided introspection endpoint by using the provided credentials and the token.\n. Inspects the response for an `{ 'active' : true }` attribute.\n. Maps each scope to an authority with a prefix of `SCOPE_`.\n\nBy default, the resulting `Authentication#getPrincipal` is a Spring Security javadoc:org.springframework.security.oauth2.core.OAuth2AuthenticatedPrincipal[] object, and `Authentication#getName` maps to the token's `sub` property, if one is present.\n\nFrom here, you may want to jump to:\n\n* <<webflux-oauth2resourceserver-opaque-attributes>>\n* <<webflux-oauth2resourceserver-opaque-authorization-extraction>>\n* <<webflux-oauth2resourceserver-opaque-jwt-introspector>>\n\n[[webflux-oauth2resourceserver-opaque-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Runtime Expectations", "heading_level": 3, "file_order": 53, "section_index": 5, "content_hash": "c8c384e359ad85286e3b30de842c60c75e92ddd0cbb331525c544d56f5188aa4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:7efddb2074c6affb19cc94c1f174fc83a25f0bb7c339aa6bb06f869065894f1a", "content": "Once a token is authenticated, an instance of `BearerTokenAuthentication` is set in the `SecurityContext`.\n\nThis means that it is available in `@Controller` methods when you use `@EnableWebFlux` in your configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/foo\")\npublic Mono<String> foo(BearerTokenAuthentication authentication) {\n return Mono.just(authentication.getTokenAttributes().get(\"sub\") + \" is the subject\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/foo\")\nfun foo(authentication: BearerTokenAuthentication): Mono<String> {\n return Mono.just(authentication.tokenAttributes[\"sub\"].toString() + \" is the subject\")\n}\n----\n======\n\nSince `BearerTokenAuthentication` holds an `OAuth2AuthenticatedPrincipal`, that also means that it's available to controller methods, too:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/foo\")\npublic Mono<String> foo(@AuthenticationPrincipal OAuth2AuthenticatedPrincipal principal) {\n return Mono.just(principal.getAttribute(\"sub\") + \" is the subject\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/foo\")\nfun foo(@AuthenticationPrincipal principal: OAuth2AuthenticatedPrincipal): Mono<String> {\n return Mono.just(principal.getAttribute<Any>(\"sub\").toString() + \" is the subject\")\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Looking Up Attributes After Authentication", "heading_level": 2, "file_order": 53, "section_index": 6, "content_hash": "7efddb2074c6affb19cc94c1f174fc83a25f0bb7c339aa6bb06f869065894f1a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:b738bb68159bcfeb094d299fb0e17b39d897aecd8eb2ac3bb30eb92dfab77981", "content": "You can access attributes with the Spring Expression Language (SpEL).\n\nFor example, if you use `@EnableReactiveMethodSecurity` so that you can use `@PreAuthorize` annotations, you can do:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PreAuthorize(\"principal?.attributes['sub'] = 'foo'\")\npublic Mono<String> forFoosEyesOnly() {\n return Mono.just(\"foo\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PreAuthorize(\"principal.attributes['sub'] = 'foo'\")\nfun forFoosEyesOnly(): Mono<String> {\n return Mono.just(\"foo\")\n}\n----\n======\n\n[[webflux-oauth2resourceserver-opaque-sansboot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Looking Up Attributes with SpEL", "heading_level": 3, "file_order": 53, "section_index": 7, "content_hash": "b738bb68159bcfeb094d299fb0e17b39d897aecd8eb2ac3bb30eb92dfab77981", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:7163c90181135f014dac2c0ec5fe8494e8db9061ec91b8a6865a557bd7f20166", "content": "Spring Boot generates two `@Bean` instances for Resource Server.\n\nThe first is a `SecurityWebFilterChain` that configures the application as a resource server.\nWhen you use an Opaque Token, this `SecurityWebFilterChain` looks like:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n\thttp\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::opaqueToken)\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken { }\n }\n }\n}\n----\n======\n\nIf the application does not expose a `SecurityWebFilterChain` bean, Spring Boot exposes the default bean (shown in the preceding listing).\n\nYou can replace it by exposing the bean within the application:\n\n.Replacing SecurityWebFilterChain\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope;\n\n@Configuration\n@EnableWebFluxSecurity\npublic class MyCustomSecurityConfiguration {\n @Bean\n SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .pathMatchers(\"/messages/**\").access(hasScope(\"message:read\"))\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .opaqueToken((opaqueToken) -> opaqueToken\n .introspector(myIntrospector())\n )\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope\n\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(\"/messages/**\", hasScope(\"message:read\"))\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken {\n introspector = myIntrospector()\n }\n }\n }\n}\n----\n======\n\nThe preceding example requires the scope of `message:read` for any URL that starts with `/messages/`.\n\nMethods on the `oauth2ResourceServer` DSL also override or replace auto configuration.\n\nFor example, the second `@Bean` Spring Boot creates is a `ReactiveOpaqueTokenIntrospector`, which decodes `String` tokens into validated instances of `OAuth2AuthenticatedPrincipal`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveOpaqueTokenIntrospector introspector() {\n return SpringReactiveOpaqueTokenIntrospector.withIntrospectionUri(introspectionUri)\n .clientId(clientId).clientSecret(clientSecret).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun introspector(): ReactiveOpaqueTokenIntrospector {\n return SpringReactiveOpaqueTokenIntrospector.withIntrospectionUri(introspectionUri)\n .clientId(clientId).clientSecret(clientSecret).build()\n}\n----\n======\n\nIf the application does not expose a `ReactiveOpaqueTokenIntrospector` bean, Spring Boot exposes the default one (shown in the preceding listing).\n\nYou can override its configuration by using `introspectionUri()` and `introspectionClientCredentials()` or replace it by using `introspector()`.\n\n[[webflux-oauth2resourceserver-opaque-introspectionuri-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Overriding or Replacing Boot Auto Configuration", "heading_level": 2, "file_order": 53, "section_index": 8, "content_hash": "7163c90181135f014dac2c0ec5fe8494e8db9061ec91b8a6865a557bd7f20166", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:1c274cd9982aba87ee9b2617a85daa3df43dbaf009de914819289aae1563153d", "content": "You can configure an authorization server's Introspection URI <<webflux-oauth2resourceserver-opaque-introspectionuri,as a configuration property>>, or you can supply in the DSL:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class DirectlyConfiguredIntrospectionUri {\n @Bean\n SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .opaqueToken((opaqueToken) -> opaqueToken\n .introspectionUri(\"https://idp.example.com/introspect\")\n .introspectionClientCredentials(\"client\", \"secret\")\n )\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken {\n introspectionUri = \"https://idp.example.com/introspect\"\n introspectionClientCredentials(\"client\", \"secret\")\n }\n }\n }\n}\n----\n======\n\nUsing `introspectionUri()` takes precedence over any configuration property.\n\n[[webflux-oauth2resourceserver-opaque-introspector-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Using `introspectionUri()`", "heading_level": 3, "file_order": 53, "section_index": 9, "content_hash": "1c274cd9982aba87ee9b2617a85daa3df43dbaf009de914819289aae1563153d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:26b984cb7492f577d4ceec42f574b2163c4a38488e5ee19c9ff3d3dcc366c09e", "content": "`introspector()` is more powerful than `introspectionUri()`. It completely replaces any Boot auto-configuration of `ReactiveOpaqueTokenIntrospector`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class DirectlyConfiguredIntrospector {\n @Bean\n SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .opaqueToken((opaqueToken) -> opaqueToken\n .introspector(myCustomIntrospector())\n )\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken {\n introspector = myCustomIntrospector()\n }\n }\n }\n}\n----\n======\n\nThis is handy when deeper configuration, such as <<webflux-oauth2resourceserver-opaque-authorization-extraction,authority mapping>> or <<webflux-oauth2resourceserver-opaque-jwt-introspector,JWT revocation>>, is necessary.\n\n[[webflux-oauth2resourceserver-opaque-introspector-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Using `introspector()`", "heading_level": 3, "file_order": 53, "section_index": 10, "content_hash": "26b984cb7492f577d4ceec42f574b2163c4a38488e5ee19c9ff3d3dcc366c09e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:5f6e180fb65eed233ce08a843093f5d235bc5785a210889e4a45fa316db34e22", "content": "Or, exposing a `ReactiveOpaqueTokenIntrospector` `@Bean` has the same effect as `introspector()`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveOpaqueTokenIntrospector introspector() {\n return SpringReactiveOpaqueTokenIntrospector.withIntrospectionUri(introspectionUri)\n .clientId(clientId).clientSecret(clientSecret).build()\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun introspector(): ReactiveOpaqueTokenIntrospector {\n return SpringReactiveOpaqueTokenIntrospector.withIntrospectionUri(introspectionUri)\n .clientId(clientId).clientSecret(clientSecret).build()\n}\n----\n======\n\n[[webflux-oauth2resourceserver-opaque-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Exposing a `ReactiveOpaqueTokenIntrospector` `@Bean`", "heading_level": 3, "file_order": 53, "section_index": 11, "content_hash": "5f6e180fb65eed233ce08a843093f5d235bc5785a210889e4a45fa316db34e22", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:5fd1889bdc3e0f0c3ece8b2bc6e4cd83617f790506ba2ee1c575ab0e49557bd1", "content": "An OAuth 2.0 Introspection endpoint typically returns a `scope` attribute, indicating the scopes (or authorities) it has been granted -- for example:\n\n[source,json]\n----\n{ ..., \"scope\" : \"messages contacts\"}\n----\n\nWhen this is the case, Resource Server tries to coerce these scopes into a list of granted authorities, prefixing each scope with a string: `SCOPE_`.\n\nThis means that, to protect an endpoint or method with a scope derived from an Opaque Token, the corresponding expressions should include this prefix:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope;\n\n@Configuration\n@EnableWebFluxSecurity\npublic class MappedAuthorities {\n @Bean\n SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .pathMatchers(\"/contacts/**\").access(hasScope(\"contacts\"))\n .pathMatchers(\"/messages/**\").access(hasScope(\"messages\"))\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::opaqueToken);\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.core.authorization.OAuth2ReactiveAuthorizationManagers.hasScope\n\n@Bean\nfun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(\"/contacts/**\", hasScope(\"contacts\"))\n authorize(\"/messages/**\", hasScope(\"messages\"))\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken { }\n }\n }\n}\n----\n======\n\nYou can do something similar with method security:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PreAuthorize(\"hasAuthority('SCOPE_messages')\")\npublic Flux<Message> getMessages(...) {}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PreAuthorize(\"hasAuthority('SCOPE_messages')\")\nfun getMessages(): Flux<Message> { }\n----\n======\n\n[[webflux-oauth2resourceserver-opaque-authorization-extraction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Configuring Authorization", "heading_level": 2, "file_order": 53, "section_index": 12, "content_hash": "5fd1889bdc3e0f0c3ece8b2bc6e4cd83617f790506ba2ee1c575ab0e49557bd1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:f90ce6a628107ff5ece75840d306a9cd06e2905b76170cf1292965fa30bc2248", "content": "By default, Opaque Token support extracts the scope claim from an introspection response and parses it into individual `GrantedAuthority` instances.\n\nConsider the following example:\n\n[source,json]\n----\n{\n \"active\" : true,\n \"scope\" : \"message:read message:write\"\n}\n----\n\nIf the introspection response were as the preceding example shows, Resource Server would generate an `Authentication` with two authorities, one for `message:read` and the other for `message:write`.\n\nYou can customize behavior by using a custom `ReactiveOpaqueTokenIntrospector` that looks at the attribute set and converts in its own way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class CustomAuthoritiesOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {\n private ReactiveOpaqueTokenIntrospector delegate = SpringReactiveOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build();\n\n public Mono<OAuth2AuthenticatedPrincipal> introspect(String token) {\n return this.delegate.introspect(token)\n .map((principal) -> principal DefaultOAuth2AuthenticatedPrincipal(\n principal.getName(), principal.getAttributes(), extractAuthorities(principal)));\n }\n\n private Collection<GrantedAuthority> extractAuthorities(OAuth2AuthenticatedPrincipal principal) {\n List<String> scopes = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE);\n return scopes.stream()\n .map(SimpleGrantedAuthority::new)\n .collect(Collectors.toList());\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass CustomAuthoritiesOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {\n private val delegate: ReactiveOpaqueTokenIntrospector = SpringReactiveOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build()\n override fun introspect(token: String): Mono<OAuth2AuthenticatedPrincipal> {\n return delegate.introspect(token)\n .map { principal: OAuth2AuthenticatedPrincipal ->\n DefaultOAuth2AuthenticatedPrincipal(\n principal.name, principal.attributes, extractAuthorities(principal))\n }\n }\n\n private fun extractAuthorities(principal: OAuth2AuthenticatedPrincipal): Collection<GrantedAuthority> {\n val scopes = principal.getAttribute<List<String>>(OAuth2IntrospectionClaimNames.SCOPE)\n return scopes\n .map { SimpleGrantedAuthority(it) }\n }\n}\n----\n======\n\nThereafter, you can configure this custom introspector by exposing it as a `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveOpaqueTokenIntrospector introspector() {\n return new CustomAuthoritiesOpaqueTokenIntrospector();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun introspector(): ReactiveOpaqueTokenIntrospector {\n return CustomAuthoritiesOpaqueTokenIntrospector()\n}\n----\n======\n\n[[webflux-oauth2resourceserver-opaque-jwt-introspector]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Extracting Authorities Manually", "heading_level": 3, "file_order": 53, "section_index": 13, "content_hash": "f90ce6a628107ff5ece75840d306a9cd06e2905b76170cf1292965fa30bc2248", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:e3087a9bb8d39c6cb6d63b2994b9e7f88755027ad6319c0461cc63900bbaf152", "content": "A common question is whether or not introspection is compatible with JWTs.\nSpring Security's Opaque Token support has been designed to not care about the format of the token. It gladly passes any token to the provided introspection endpoint.\n\nSo, suppose you need to check with the authorization server on each request, in case the JWT has been revoked.\n\nEven though you are using the JWT format for the token, your validation method is introspection, meaning you would want to do:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n opaquetoken:\n introspection-uri: https://idp.example.org/introspection\n client-id: client\n client-secret: secret\n----\n\nIn this case, the resulting `Authentication` would be `BearerTokenAuthentication`.\nAny attributes in the corresponding `OAuth2AuthenticatedPrincipal` would be whatever was returned by the introspection endpoint.\n\nHowever, suppose that, for whatever reason, the introspection endpoint returns only whether or not the token is active.\nNow what?\n\nIn this case, you can create a custom `ReactiveOpaqueTokenIntrospector` that still hits the endpoint but then updates the returned principal to have the JWTs claims as the attributes:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class JwtOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {\n\tprivate ReactiveOpaqueTokenIntrospector delegate = SpringReactiveOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build();\n\tprivate ReactiveJwtDecoder jwtDecoder = new NimbusReactiveJwtDecoder(new ParseOnlyJWTProcessor());\n\n\tpublic Mono<OAuth2AuthenticatedPrincipal> introspect(String token) {\n return this.delegate.introspect(token)\n .flatMap((principal) -> principal.jwtDecoder.decode(token))\n .map((jwt) -> jwt DefaultOAuth2AuthenticatedPrincipal(jwt.getClaims(), NO_AUTHORITIES));\n\t}\n\n\tprivate static class ParseOnlyJWTProcessor implements Converter<JWT, Mono<JWTClaimsSet>> {\n public Mono<JWTClaimsSet> convert(JWT jwt) {\n try {\n return Mono.just(jwt.getJWTClaimsSet());\n } catch (Exception ex) {\n return Mono.error(ex);\n }\n }\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass JwtOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {\n private val delegate: ReactiveOpaqueTokenIntrospector = SpringReactiveOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build()\n private val jwtDecoder: ReactiveJwtDecoder = NimbusReactiveJwtDecoder(ParseOnlyJWTProcessor())\n override fun introspect(token: String): Mono<OAuth2AuthenticatedPrincipal> {\n return delegate.introspect(token)\n .flatMap { jwtDecoder.decode(token) }\n .map { jwt: Jwt -> DefaultOAuth2AuthenticatedPrincipal(jwt.claims, NO_AUTHORITIES) }\n }\n\n private class ParseOnlyJWTProcessor : Converter<JWT, Mono<JWTClaimsSet>> {\n override fun convert(jwt: JWT): Mono<JWTClaimsSet> {\n return try {\n Mono.just(jwt.jwtClaimsSet)\n } catch (e: Exception) {\n Mono.error(e)\n }\n }\n }\n}\n----\n======\n\nThereafter, you can configure this custom introspector by exposing it as a `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ReactiveOpaqueTokenIntrospector introspector() {\n return new JwtOpaqueTokenIntropsector();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun introspector(): ReactiveOpaqueTokenIntrospector {\n return JwtOpaqueTokenIntrospector()\n}\n----\n======\n\n[[webflux-oauth2resourceserver-opaque-userinfo]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Using Introspection with JWTs", "heading_level": 2, "file_order": 53, "section_index": 14, "content_hash": "e3087a9bb8d39c6cb6d63b2994b9e7f88755027ad6319c0461cc63900bbaf152", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:0d87939ac9e75486fe39e2febc910490dafadddaa544b911364cb1443b308667", "content": "Generally speaking, a Resource Server does not care about the underlying user but, instead, cares about the authorities that have been granted.\n\nThat said, at times it can be valuable to tie the authorization statement back to a user.\n\nIf an application also uses `spring-security-oauth2-client`, having set up the appropriate `ClientRegistrationRepository`, you can do so with a custom `OpaqueTokenIntrospector`.\nThe implementation in the next listing does three things:\n\n* Delegates to the introspection endpoint, to affirm the token's validity.\n* Looks up the appropriate client registration associated with the `/userinfo` endpoint.\n* Invokes and returns the response from the `/userinfo` endpoint.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class UserInfoOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {\n\tprivate final ReactiveOpaqueTokenIntrospector delegate = SpringReactiveOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build();\n\tprivate final ReactiveOAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService =\n new DefaultReactiveOAuth2UserService();\n\n\tprivate final ReactiveClientRegistrationRepository repository;\n\n\t// ... constructor\n\n\t@Override\n\tpublic Mono<OAuth2AuthenticatedPrincipal> introspect(String token) {\n return Mono.zip(this.delegate.introspect(token), this.repository.findByRegistrationId(\"registration-id\"))\n .map(t -> {\n OAuth2AuthenticatedPrincipal authorized = t.getT1();\n ClientRegistration clientRegistration = t.getT2();\n Instant issuedAt = authorized.getAttribute(ISSUED_AT);\n Instant expiresAt = authorized.getAttribute(OAuth2IntrospectionClaimNames.EXPIRES_AT);\n OAuth2AccessToken accessToken = new OAuth2AccessToken(BEARER, token, issuedAt, expiresAt);\n return new OAuth2UserRequest(clientRegistration, accessToken);\n })\n .flatMap(this.oauth2UserService::loadUser);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass UserInfoOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {\n private val delegate: ReactiveOpaqueTokenIntrospector = SpringReactiveOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build()\n private val oauth2UserService: ReactiveOAuth2UserService<OAuth2UserRequest, OAuth2User> = DefaultReactiveOAuth2UserService()\n private val repository: ReactiveClientRegistrationRepository? = null\n\n // ... constructor\n override fun introspect(token: String?): Mono<OAuth2AuthenticatedPrincipal> {\n return Mono.zip<OAuth2AuthenticatedPrincipal, ClientRegistration>(delegate.introspect(token), repository!!.findByRegistrationId(\"registration-id\"))\n .map<OAuth2UserRequest> { t: Tuple2<OAuth2AuthenticatedPrincipal, ClientRegistration> ->\n val authorized = t.t1\n val clientRegistration = t.t2\n val issuedAt: Instant? = authorized.getAttribute(ISSUED_AT)\n val expiresAt: Instant? = authorized.getAttribute(OAuth2IntrospectionClaimNames.EXPIRES_AT)\n val accessToken = OAuth2AccessToken(BEARER, token, issuedAt, expiresAt)\n OAuth2UserRequest(clientRegistration, accessToken)\n }\n .flatMap { userRequest: OAuth2UserRequest -> oauth2UserService.loadUser(userRequest) }\n }\n}\n----\n======\n\nIf you aren't using `spring-security-oauth2-client`, it's still quite simple.\nYou will simply need to invoke the `/userinfo` with your own instance of `WebClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class UserInfoOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {\n private final ReactiveOpaqueTokenIntrospector delegate = SpringReactiveOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build();\n private final WebClient rest = WebClient.create();\n\n @Override\n public Mono<OAuth2AuthenticatedPrincipal> introspect(String token) {\n return this.delegate.introspect(token)\n .map(this::makeUserInfoRequest);\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass UserInfoOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {\n private val delegate: ReactiveOpaqueTokenIntrospector = SpringReactiveOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build()\n private val rest: WebClient = WebClient.create()\n\n override fun introspect(token: String): Mono<OAuth2AuthenticatedPrincipal> {\n return delegate.introspect(token)\n .map(this::makeUserInfoRequest)\n }\n}\n----\n======\n\nEither way, having created your `ReactiveOpaqueTokenIntrospector`, you should publish it as a `@Bean` to override the defaults:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nReactiveOpaqueTokenIntrospector introspector() {\n return new UserInfoOpaqueTokenIntrospector();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun introspector(): ReactiveOpaqueTokenIntrospector {\n return UserInfoOpaqueTokenIntrospector()\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Calling a `/userinfo` Endpoint", "heading_level": 2, "file_order": 53, "section_index": 15, "content_hash": "0d87939ac9e75486fe39e2febc910490dafadddaa544b911364cb1443b308667", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:73bf4cfd771396c204bfda2bf5c4490581c4c544bae948688e9929063134028c", "content": "[[webflux-oauth2]]\n\nSpring Security provides comprehensive OAuth 2.0 support.\nThis section discusses how to integrate OAuth 2.0 into your reactive application.\n\n[[oauth2-overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 54, "section_index": 0, "content_hash": "73bf4cfd771396c204bfda2bf5c4490581c4c544bae948688e9929063134028c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:a0251bfa37d5e52c86a1cde03f2d504be0495e4a46829acf237a9eea673c5226", "content": "Spring Security's OAuth 2.0 support consists of two primary feature sets:\n\n* <<oauth2-resource-server>>\n* <<oauth2-client>>\n\n[NOTE]\n====\n<<oauth2-client-log-users-in,OAuth2 Login>> is a very powerful OAuth2 Client feature that deserves its own section in the reference documentation.\nHowever, it does not exist as a standalone feature and requires OAuth2 Client in order to function.\n====\n\nThese feature sets cover the _resource server_ and _client_ roles defined in the https://tools.ietf.org/html/rfc6749#section-1.1[OAuth 2.0 Authorization Framework], while the _authorization server_ role is covered by https://docs.spring.io/spring-authorization-server/reference/index.html[Spring Authorization Server], which is a separate project built on xref:index.adoc[Spring Security].\n\nThe _resource server_ and _client_ roles in OAuth2 are typically represented by one or more server-side applications.\nAdditionally, the _authorization server_ role can be represented by one or more third parties (as is the case when centralizing identity management and/or authentication within an organization) *-or-* it can be represented by an application (as is the case with Spring Authorization Server).\n\nFor example, a typical OAuth2-based microservices architecture might consist of a single user-facing client application, several backend resource servers providing REST APIs and a third party authorization server for managing users and authentication concerns.\nIt is also common to have a single application representing only one of these roles with the need to integrate with one or more third parties that are providing the other roles.\n\nSpring Security handles these scenarios and more.\nThe following sections cover the roles provided by Spring Security and contain examples for common scenarios.\n\n[[oauth2-resource-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Overview", "heading_level": 2, "file_order": 54, "section_index": 1, "content_hash": "a0251bfa37d5e52c86a1cde03f2d504be0495e4a46829acf237a9eea673c5226", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:9d4469e31705a6e6d6cf2c27ef53ce260d868193c36f4db85305d88a1846ec8e", "content": "[NOTE]\n====\nThis section contains a summary of OAuth2 Resource Server features with examples.\nSee xref:reactive/oauth2/resource-server/index.adoc[OAuth 2.0 Resource Server] for complete reference documentation.\n====\n\nTo get started, add the `spring-security-oauth2-resource-server` dependency to your project.\nWhen using Spring Boot, add the following starter:\n\n.OAuth2 Client with Spring Boot\n[tabs]\n======\nGradle::\n+\n[source,gradle,role=\"primary\"]\n----\nimplementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'\n----\n\nMaven::\n+\n[source,maven,role=\"secondary\"]\n----\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-oauth2-resource-server</artifactId>\n</dependency>\n----\n======\n\n[TIP]\n====\nSee xref:getting-spring-security.adoc[] for additional options when not using Spring Boot.\n====\n\nConsider the following use cases for OAuth2 Resource Server:\n\n* I want to <<oauth2-resource-server-access-token,protect access to the API using OAuth2>> (authorization server provides JWT or opaque access token)\n* I want to <<oauth2-resource-server-custom-jwt,protect access to the API using a JWT>> (custom token)\n\n[[oauth2-resource-server-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "OAuth2 Resource Server", "heading_level": 2, "file_order": 54, "section_index": 2, "content_hash": "9d4469e31705a6e6d6cf2c27ef53ce260d868193c36f4db85305d88a1846ec8e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:7a5e71cc0bbc3279a14dd9cb3fc480be70f1a694f0b4b1fbe09ad81b7f0aecd3", "content": "It is very common to protect access to an API using OAuth2 access tokens.\nIn most cases, Spring Security requires only minimal configuration to secure an application with OAuth2.\n\nThere are two types of `Bearer` tokens supported by Spring Security which each use a different component for validation:\n\n* <<oauth2-resource-server-access-token-jwt,JWT support>> uses a `ReactiveJwtDecoder` bean to validate signatures and decode tokens\n* <<oauth2-resource-server-access-token-opaque,Opaque token support>> uses a `ReactiveOpaqueTokenIntrospector` bean to introspect tokens\n\n[[oauth2-resource-server-access-token-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Protect Access with an OAuth2 Access Token", "heading_level": 3, "file_order": 54, "section_index": 3, "content_hash": "7a5e71cc0bbc3279a14dd9cb3fc480be70f1a694f0b4b1fbe09ad81b7f0aecd3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:4246c85ac2abb2abdad46cd40e6f9dab9c9ae39a34c51a82534d7a89dca694db", "content": "The following example configures a `ReactiveJwtDecoder` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n issuer-uri: https://my-auth-server.com\n----\n\nWhen using Spring Boot, this is all that is required.\nThe default arrangement provided by Spring Boot is equivalent to the following:\n\n.Configure Resource Server with JWTs\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt(Customizer.withDefaults())\n );\n return http.build();\n\t}\n\n\t@Bean\n\tpublic ReactiveJwtDecoder jwtDecoder() {\n return ReactiveJwtDecoders.fromIssuerLocation(\"https://my-auth-server.com\");\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.web.server.invoke\n\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n jwt { }\n }\n }\n\t}\n\n\t@Bean\n\tfun jwtDecoder(): ReactiveJwtDecoder {\n return ReactiveJwtDecoders.fromIssuerLocation(\"https://my-auth-server.com\")\n\t}\n\n}\n----\n=====\n\n[[oauth2-resource-server-access-token-opaque]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "JWT Support", "heading_level": 4, "file_order": 54, "section_index": 4, "content_hash": "4246c85ac2abb2abdad46cd40e6f9dab9c9ae39a34c51a82534d7a89dca694db", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:b2e57579d6996fc7eb6d601d2b145cacb8e5e0ee2a3387278b19bf13ae56185d", "content": "The following example configures an `ReactiveOpaqueTokenIntrospector` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n opaquetoken:\n introspection-uri: https://my-auth-server.com/oauth2/introspect\n client-id: my-client-id\n client-secret: my-client-secret\n----\n\nWhen using Spring Boot, this is all that is required.\nThe default arrangement provided by Spring Boot is equivalent to the following:\n\n.Configure Resource Server with Opaque Tokens\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .opaqueToken(Customizer.withDefaults())\n );\n return http.build();\n\t}\n\n\t@Bean\n\tpublic ReactiveOpaqueTokenIntrospector opaqueTokenIntrospector() {\n return new SpringReactiveOpaqueTokenIntrospector(\n \"https://my-auth-server.com/oauth2/introspect\", \"my-client-id\", \"my-client-secret\");\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.web.server.invoke\n\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken { }\n }\n }\n\t}\n\n\t@Bean\n\tfun opaqueTokenIntrospector(): ReactiveOpaqueTokenIntrospector {\n return SpringReactiveOpaqueTokenIntrospector(\n \"https://my-auth-server.com/oauth2/introspect\", \"my-client-id\", \"my-client-secret\"\n )\n\t}\n\n}\n----\n=====\n\n[[oauth2-resource-server-custom-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Opaque Token Support", "heading_level": 4, "file_order": 54, "section_index": 5, "content_hash": "b2e57579d6996fc7eb6d601d2b145cacb8e5e0ee2a3387278b19bf13ae56185d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:9cd1ad3da60c229c85ee5e05e36575a0c78dc2a695bcb61aba6c62377f0f0860", "content": "It is a fairly common goal to protect access to an API using JWTs, particularly when the frontend is developed as a single-page application.\nThe OAuth2 Resource Server support in Spring Security can be used for any type of `Bearer` token, including a custom JWT.\n\nAll that is required to protect an API using JWTs is a `ReactiveJwtDecoder` bean, which is used to validate signatures and decode tokens.\nSpring Security will automatically use the provided bean to configure protection within the `SecurityWebFilterChain`.\n\nThe following example configures a `ReactiveJwtDecoder` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n public-key-location: classpath:my-public-key.pub\n----\n\n[NOTE]\n====\nYou can provide the public key as a classpath resource (called `my-public-key.pub` in this example).\n====\n\nWhen using Spring Boot, this is all that is required.\nThe default arrangement provided by Spring Boot is equivalent to the following:\n\n.Configure Resource Server with Custom JWTs\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt(Customizer.withDefaults())\n );\n return http.build();\n\t}\n\n\t@Bean\n\tpublic ReactiveJwtDecoder jwtDecoder() {\n return NimbusReactiveJwtDecoder.withPublicKey(publicKey()).build();\n\t}\n\n\tprivate RSAPublicKey publicKey() {\n // ...\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.web.server.invoke\n\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2ResourceServer {\n jwt { }\n }\n }\n\t}\n\n\t@Bean\n\tfun jwtDecoder(): ReactiveJwtDecoder {\n return NimbusReactiveJwtDecoder.withPublicKey(publicKey()).build()\n\t}\n\n\tprivate fun publicKey(): RSAPublicKey {\n // ...\n\t}\n\n}\n----\n=====\n\n[NOTE]\n====\nSpring Security does not provide an endpoint for minting tokens.\nHowever, Spring Security does provide the `JwtEncoder` interface along with one implementation, which is `NimbusJwtEncoder`.\n====\n\n[[oauth2-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Protect Access with a custom JWT", "heading_level": 3, "file_order": 54, "section_index": 6, "content_hash": "9cd1ad3da60c229c85ee5e05e36575a0c78dc2a695bcb61aba6c62377f0f0860", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:f46ca4bdba163ef89212e732792dbdd46ef9ef5a30c85425e4cbb61a0ab2d252", "content": "[NOTE]\n====\nThis section contains a summary of OAuth2 Client features with examples.\nSee xref:reactive/oauth2/client/index.adoc[OAuth 2.0 Client] and xref:reactive/oauth2/login/index.adoc[OAuth 2.0 Login] for complete reference documentation.\n====\n\nTo get started, add the `spring-security-oauth2-client` dependency to your project.\nWhen using Spring Boot, add the following starter:\n\n.OAuth2 Client with Spring Boot\n[tabs]\n======\nGradle::\n+\n[source,gradle,role=\"primary\"]\n----\nimplementation 'org.springframework.boot:spring-boot-starter-oauth2-client'\n----\n\nMaven::\n+\n[source,maven,role=\"secondary\"]\n----\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-oauth2-client</artifactId>\n</dependency>\n----\n======\n\n[TIP]\n====\nSee xref:getting-spring-security.adoc[] for additional options when not using Spring Boot.\n====\n\nConsider the following use cases for OAuth2 Client:\n\n* I want to <<oauth2-client-log-users-in,log users in using OAuth 2.0 or OpenID Connect 1.0>>\n* I want to <<oauth2-client-access-protected-resources,obtain an access token for users>> in order to access a third-party API\n* I want to <<oauth2-client-access-protected-resources-current-user,do both>> (log users in _and_ access a third-party API)\n* I want to <<oauth2-client-enable-extension-grant-type,enable an extension grant type>>\n* I want to <<oauth2-client-customize-existing-grant-type,customize an existing grant type>>\n* I want to <<oauth2-client-customize-request-parameters,customize token request parameters>>\n* I want to <<oauth2-client-customize-web-client,customize the `WebClient` used by OAuth2 Client components>>\n\n[[oauth2-client-log-users-in]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "OAuth2 Client", "heading_level": 2, "file_order": 54, "section_index": 7, "content_hash": "f46ca4bdba163ef89212e732792dbdd46ef9ef5a30c85425e4cbb61a0ab2d252", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:97c95e3456e61257a77058c09350caffe68b4f0fd7f89a689ccde898449f8b95", "content": "It is very common to require users to log in via OAuth2.\nhttps://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect 1.0] provides a special token called the `id_token` which is designed to provide an OAuth2 Client with the ability to perform user identity verification and log users in.\nIn certain cases, OAuth2 can be used directly to log users in (as is the case with popular social login providers that do not implement OpenID Connect such as GitHub and Facebook).\n\nThe following example configures the application to act as an OAuth2 Client capable of logging users in with OAuth2 or OpenID Connect:\n\n.Configure OAuth2 Login\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n // ...\n .oauth2Login(Customizer.withDefaults());\n return http.build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.web.server.invoke\n\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n oauth2Login { }\n }\n\t}\n\n}\n----\n=====\n\nIn addition to the above configuration, the application requires at least one `ClientRegistration` to be configured through the use of a `ReactiveClientRegistrationRepository` bean.\nThe following example configures an `InMemoryReactiveClientRegistrationRepository` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n my-oidc-client:\n provider: my-oidc-provider\n client-id: my-client-id\n client-secret: my-client-secret\n authorization-grant-type: authorization_code\n scope: openid,profile\n provider:\n my-oidc-provider:\n issuer-uri: https://my-oidc-provider.com\n----\n\nWith the above configuration, the application now supports two additional endpoints:\n\n1. The login endpoint (e.g. `/oauth2/authorization/my-oidc-client`) is used to initiate login and perform a redirect to the third party authorization server.\n2. The redirection endpoint (e.g. `/login/oauth2/code/my-oidc-client`) is used by the authorization server to redirect back to the client application, and will contain a `code` parameter used to obtain an `id_token` and/or `access_token` via the access token request.\n\n[NOTE]\n====\nThe presence of the `openid` scope in the above configuration indicates that OpenID Connect 1.0 should be used.\nThis instructs Spring Security to use OIDC-specific components (such as `OidcReactiveOAuth2UserService`) during request processing.\nWithout this scope, Spring Security will use OAuth2-specific components (such as `DefaultReactiveOAuth2UserService`) instead.\n====\n\n[[oauth2-client-access-protected-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Log Users In with OAuth2", "heading_level": 3, "file_order": 54, "section_index": 8, "content_hash": "97c95e3456e61257a77058c09350caffe68b4f0fd7f89a689ccde898449f8b95", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:a188b3180659d61381f3af0be56ca054be12e8976262061426fb87051c9a708a", "content": "Making requests to a third party API that is protected by OAuth2 is a core use case of OAuth2 Client.\nThis is accomplished by authorizing a client (represented by the `OAuth2AuthorizedClient` class in Spring Security) and accessing protected resources by placing a `Bearer` token in the `Authorization` header of an outbound request.\n\nThe following example configures the application to act as an OAuth2 Client capable of requesting protected resources from a third party API:\n\n.Configure OAuth2 Client\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n // ...\n .oauth2Client(Customizer.withDefaults());\n return http.build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.web.server.invoke\n\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n oauth2Client { }\n }\n\t}\n\n}\n----\n=====\n\n[NOTE]\n====\nThe above example does not provide a way to log users in.\nYou can use any other login mechanism (such as `formLogin()`).\nSee the <<oauth2-client-access-protected-resources-current-user,next section>> for an example combining `oauth2Client()` with `oauth2Login()`.\n====\n\nIn addition to the above configuration, the application requires at least one `ClientRegistration` to be configured through the use of a `ReactiveClientRegistrationRepository` bean.\nThe following example configures an `InMemoryReactiveClientRegistrationRepository` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n my-oauth2-client:\n provider: my-auth-server\n client-id: my-client-id\n client-secret: my-client-secret\n authorization-grant-type: authorization_code\n scope: message.read,message.write\n provider:\n my-auth-server:\n issuer-uri: https://my-auth-server.com\n----\n\nIn addition to configuring Spring Security to support OAuth2 Client features, you will also need to decide how you will be accessing protected resources and configure your application accordingly.\nSpring Security provides implementations of `ReactiveOAuth2AuthorizedClientManager` for obtaining access tokens that can be used to access protected resources.\n\n[TIP]\n====\nSpring Security registers a default `ReactiveOAuth2AuthorizedClientManager` bean for you when one does not exist.\n====\n\nThe easiest way to use a `ReactiveOAuth2AuthorizedClientManager` is via an `ExchangeFilterFunction` that intercepts requests through a `WebClient`.\n\nThe following example uses the default `ReactiveOAuth2AuthorizedClientManager` to configure a `WebClient` capable of accessing protected resources by placing `Bearer` tokens in the `Authorization` header of each request:\n\n.Configure `WebClient` with `ExchangeFilterFunction`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class WebClientConfig {\n\n\t@Bean\n\tpublic WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) {\n ServerOAuth2AuthorizedClientExchangeFilterFunction filter =\n new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);\n return WebClient.builder()\n .filter(filter)\n .build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass WebClientConfig {\n\n\t@Bean\n\tfun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient {\n val filter = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)\n return WebClient.builder()\n .filter(filter)\n .build()\n\t}\n\n}\n----\n=====\n\nThis configured `WebClient` can be used as in the following example:\n\n[[oauth2-client-accessing-protected-resources-example]]\n.Use `WebClient` to Access Protected Resources\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.client.web.reactive.function.client.ServerOAuth2AuthorizedClientExchangeFilterFunction.clientRegistrationId;\n\n@RestController\npublic class MessagesController {\n\n\tprivate final WebClient webClient;\n\n\tpublic MessagesController(WebClient webClient) {\n this.webClient = webClient;\n\t}\n\n\t@GetMapping(\"/messages\")\n\tpublic Mono<ResponseEntity<List<Message>>> messages() {\n return this.webClient.get()\n .uri(\"http://localhost:8090/messages\")\n .attributes(clientRegistrationId(\"my-oauth2-client\"))\n .retrieve()\n .toEntityList(Message.class);\n\t}\n\n\tpublic record Message(String message) {\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.client.web.reactive.function.client.ServerOAuth2AuthorizedClientExchangeFilterFunction.clientRegistrationId\n\n@RestController\nclass MessagesController(private val webClient: WebClient) {\n\n\t@GetMapping(\"/messages\")\n\tfun messages(): Mono<ResponseEntity<List<Message>>> {\n return webClient.get()\n .uri(\"http://localhost:8090/messages\")\n .attributes(clientRegistrationId(\"my-oauth2-client\"))\n .retrieve()\n .toEntityList<Message>()\n\t}\n\n\tdata class Message(val message: String)\n\n}\n----\n=====\n\n[[oauth2-client-access-protected-resources-current-user]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Access Protected Resources", "heading_level": 3, "file_order": 54, "section_index": 9, "content_hash": "a188b3180659d61381f3af0be56ca054be12e8976262061426fb87051c9a708a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:c1c7c8eb87683c3324eef2d2b4229775d7d68c1b845935c6dda2ba9da60d6eea", "content": "When a user is logged in via OAuth2 or OpenID Connect, the authorization server may provide an access token that can be used directly to access protected resources.\nThis is convenient because it only requires a single `ClientRegistration` to be configured for both use cases simultaneously.\n\n[NOTE]\n====\nThis section combines <<oauth2-client-log-users-in>> and <<oauth2-client-access-protected-resources>> into a single configuration.\nOther advanced scenarios exist, such as configuring one `ClientRegistration` for login and another for accessing protected resources.\nAll such scenarios would use the same basic configuration.\n====\n\nThe following example configures the application to act as an OAuth2 Client capable of logging the user in _and_ requesting protected resources from a third party API:\n\n.Configure OAuth2 Login and OAuth2 Client\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n http\n // ...\n .oauth2Login(Customizer.withDefaults())\n .oauth2Client(Customizer.withDefaults());\n return http.build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.web.server.invoke\n\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n return http {\n // ...\n oauth2Login { }\n oauth2Client { }\n }\n\t}\n\n}\n----\n=====\n\nIn addition to the above configuration, the application requires at least one `ClientRegistration` to be configured through the use of a `ReactiveClientRegistrationRepository` bean.\nThe following example configures an `InMemoryReactiveClientRegistrationRepository` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n my-combined-client:\n provider: my-auth-server\n client-id: my-client-id\n client-secret: my-client-secret\n authorization-grant-type: authorization_code\n scope: openid,profile,message.read,message.write\n provider:\n my-auth-server:\n issuer-uri: https://my-auth-server.com\n----\n\n[NOTE]\n====\nThe main difference between the previous examples (<<oauth2-client-log-users-in>>, <<oauth2-client-access-protected-resources>>) and this one is what is configured via the `scope` property, which combines the standard scopes `openid` and `profile` with the custom scopes `message.read` and `message.write`.\n====\n\nIn addition to configuring Spring Security to support OAuth2 Client features, you will also need to decide how you will be accessing protected resources and configure your application accordingly.\nSpring Security provides implementations of `ReactiveOAuth2AuthorizedClientManager` for obtaining access tokens that can be used to access protected resources.\n\n[TIP]\n====\nSpring Security registers a default `ReactiveOAuth2AuthorizedClientManager` bean for you when one does not exist.\n====\n\nThe easiest way to use a `ReactiveOAuth2AuthorizedClientManager` is via an `ExchangeFilterFunction` that intercepts requests through a `WebClient`.\n\nThe following example uses the default `ReactiveOAuth2AuthorizedClientManager` to configure a `WebClient` capable of accessing protected resources by placing `Bearer` tokens in the `Authorization` header of each request:\n\n.Configure `WebClient` with `ExchangeFilterFunction`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class WebClientConfig {\n\n\t@Bean\n\tpublic WebClient webClient(ReactiveOAuth2AuthorizedClientManager authorizedClientManager) {\n ServerOAuth2AuthorizedClientExchangeFilterFunction filter =\n new ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);\n return WebClient.builder()\n .filter(filter)\n .build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass WebClientConfig {\n\n\t@Bean\n\tfun webClient(authorizedClientManager: ReactiveOAuth2AuthorizedClientManager): WebClient {\n val filter = ServerOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)\n return WebClient.builder()\n .filter(filter)\n .build()\n\t}\n\n}\n----\n=====\n\nThis configured `WebClient` can be used as in the following example:\n\n[[oauth2-client-accessing-protected-resources-current-user-example]]\n.Use `WebClient` to Access Protected Resources (Current User)\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic class MessagesController {\n\n\tprivate final WebClient webClient;\n\n\tpublic MessagesController(WebClient webClient) {\n this.webClient = webClient;\n\t}\n\n\t@GetMapping(\"/messages\")\n\tpublic Mono<ResponseEntity<List<Message>>> messages() {\n return this.webClient.get()\n .uri(\"http://localhost:8090/messages\")\n .retrieve()\n .toEntityList(Message.class);\n\t}\n\n\tpublic record Message(String message) {\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RestController\nclass MessagesController(private val webClient: WebClient) {\n\n\t@GetMapping(\"/messages\")\n\tfun messages(): Mono<ResponseEntity<List<Message>>> {\n return webClient.get()\n .uri(\"http://localhost:8090/messages\")\n .retrieve()\n .toEntityList<Message>()\n\t}\n\n\tdata class Message(val message: String)\n\n}\n----\n=====\n\n[NOTE]\n====\nUnlike the <<oauth2-client-accessing-protected-resources-example,previous example>>, notice that we do not need to tell Spring Security about the `clientRegistrationId` we'd like to use.\nThis is because it can be derived from the currently logged in user.\n====\n\n[[oauth2-client-enable-extension-grant-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Access Protected Resources for the Current User", "heading_level": 3, "file_order": 54, "section_index": 10, "content_hash": "c1c7c8eb87683c3324eef2d2b4229775d7d68c1b845935c6dda2ba9da60d6eea", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:e108c412b5d345f102e0f62e17128c081221f334a8771269cee1b7054a860572", "content": "A common use case involves enabling and/or configuring an extension grant type.\nFor example, Spring Security provides support for the `jwt-bearer` and `token-exchange` grant types, but does not enable them by default because they are not part of the core OAuth 2.0 specification.\n\nWith Spring Security 6.3 and later, we can simply publish a bean for one or more `ReactiveOAuth2AuthorizedClientProvider` and they will be picked up automatically.\nThe following example simply enables the `jwt-bearer` grant type:\n\n.Enable `jwt-bearer` Grant Type\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic ReactiveOAuth2AuthorizedClientProvider jwtBearer() {\n return new JwtBearerReactiveOAuth2AuthorizedClientProvider();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun jwtBearer(): ReactiveOAuth2AuthorizedClientProvider {\n return JwtBearerReactiveOAuth2AuthorizedClientProvider()\n\t}\n\n}\n----\n=====\n\nA default `ReactiveOAuth2AuthorizedClientManager` will be published automatically by Spring Security when one is not already provided.\n\n[TIP]\n====\nAny custom `OAuth2AuthorizedClientProvider` bean will also be picked up and applied to the provided `ReactiveOAuth2AuthorizedClientManager` after the default grant types.\n====\n\nIn order to achieve the above configuration prior to Spring Security 6.3, we had to publish this bean ourselves and ensure we re-enabled default grant types as well.\nTo understand what is being configured behind the scenes, here's what the configuration might have looked like:\n\n.Enable `jwt-bearer` Grant Type (prior to 6.3)\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic ReactiveOAuth2AuthorizedClientManager authorizedClientManager(\n ReactiveClientRegistrationRepository clientRegistrationRepository,\n ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .provider(new JwtBearerReactiveOAuth2AuthorizedClientProvider())\n .build();\n\n DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n return authorizedClientManager;\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun authorizedClientManager(\n clientRegistrationRepository: ReactiveClientRegistrationRepository,\n authorizedClientRepository: ServerOAuth2AuthorizedClientRepository\n\t): ReactiveOAuth2AuthorizedClientManager {\n val authorizedClientProvider = ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .provider(JwtBearerReactiveOAuth2AuthorizedClientProvider())\n .build()\n\n val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository\n )\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n\n return authorizedClientManager\n\t}\n\n}\n----\n=====\n\n[[oauth2-client-customize-existing-grant-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Enable an Extension Grant Type", "heading_level": 3, "file_order": 54, "section_index": 11, "content_hash": "e108c412b5d345f102e0f62e17128c081221f334a8771269cee1b7054a860572", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:1ada87df9be47585b6f6e088e4ad99a1aaf07be2442e28fa0d2c26bf6c3fca1d", "content": "The ability to <<oauth2-client-enable-extension-grant-type,enable extension grant types>> by publishing a bean also provides the opportunity for customizing an existing grant type without the need to re-define the defaults.\nFor example, if we want to customize the clock skew of the `ReactiveOAuth2AuthorizedClientProvider` for the `client_credentials` grant, we can simply publish a bean like so:\n\n.Customize Client Credentials Grant Type\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic ReactiveOAuth2AuthorizedClientProvider clientCredentials() {\n ClientCredentialsReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n new ClientCredentialsReactiveOAuth2AuthorizedClientProvider();\n authorizedClientProvider.setClockSkew(Duration.ofMinutes(5));\n\n return authorizedClientProvider;\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun clientCredentials(): ReactiveOAuth2AuthorizedClientProvider {\n val authorizedClientProvider = ClientCredentialsReactiveOAuth2AuthorizedClientProvider()\n authorizedClientProvider.setClockSkew(Duration.ofMinutes(5))\n return authorizedClientProvider\n\t}\n\n}\n----\n=====\n\n[[oauth2-client-customize-request-parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Customize an Existing Grant Type", "heading_level": 3, "file_order": 54, "section_index": 12, "content_hash": "1ada87df9be47585b6f6e088e4ad99a1aaf07be2442e28fa0d2c26bf6c3fca1d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:66e9992a475a80b3b31ec4e0ce11b1d8bbc816750726b9fec4e5fafb5fdbec5b", "content": "The need to customize request parameters when obtaining an access token is fairly common.\nFor example, let's say we want to add a custom `audience` parameter to the token request because the provider requires this parameter for the `authorization_code` grant.\n\nWe can simply publish a bean of type `ReactiveOAuth2AccessTokenResponseClient` with the generic type `OAuth2AuthorizationCodeGrantRequest` and it will be used by Spring Security to configure OAuth2 Client components.\n\nThe following example customizes token request parameters for the `authorization_code` grant:\n\n.Customize Token Request Parameters for Authorization Code Grant\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() {\n WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient =\n new WebClientReactiveAuthorizationCodeTokenResponseClient();\n accessTokenResponseClient.addParametersConverter(parametersConverter());\n\n return accessTokenResponseClient;\n\t}\n\n\tprivate static Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> parametersConverter() {\n return (grantRequest) -> {\n MultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n parameters.set(\"audience\", \"xyz_value\");\n\n return parameters;\n };\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun authorizationCodeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {\n val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()\n accessTokenResponseClient.addParametersConverter(parametersConverter())\n\n return accessTokenResponseClient\n\t}\n\n\tprivate fun parametersConverter(): Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> {\n return Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> { grantRequest ->\n LinkedMultiValueMap<String, String>().also { parameters ->\n parameters[\"audience\"] = \"xyz_value\"\n }\n }\n\t}\n\n}\n----\n=====\n\n[TIP]\n====\nNotice that we don't need to customize the `SecurityWebFilterChain` bean in this case, and can stick with the defaults.\nIf using Spring Boot with no additional customizations, we can actually omit the `SecurityWebFilterChain` bean entirely.\n====\n\nAs you can see, providing the `ReactiveOAuth2AccessTokenResponseClient` as a bean is quite convenient.\nWhen using the Spring Security DSL directly, we need to ensure that this customization is applied for both OAuth2 Login (if we are using this feature) and OAuth2 Client components.\nTo understand what is being configured behind the scenes, here's what the configuration would look like with the DSL:\n\n.Customize Token Request Parameters for Authorization Code Grant using the DSL\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {\n WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient =\n new WebClientReactiveAuthorizationCodeTokenResponseClient();\n accessTokenResponseClient.addParametersConverter(parametersConverter());\n\n http\n .authorizeExchange((authorize) -> authorize\n .anyExchange().authenticated()\n )\n .oauth2Login((oauth2Login) -> oauth2Login\n .authenticationManager(new DelegatingReactiveAuthenticationManager(\n new OidcAuthorizationCodeReactiveAuthenticationManager(\n accessTokenResponseClient, new OidcReactiveOAuth2UserService()\n ),\n new OAuth2LoginReactiveAuthenticationManager(\n accessTokenResponseClient, new DefaultReactiveOAuth2UserService()\n )\n ))\n )\n .oauth2Client((oauth2Client) -> oauth2Client\n .authenticationManager(new OAuth2AuthorizationCodeReactiveAuthenticationManager(\n accessTokenResponseClient\n ))\n );\n\n return http.build();\n\t}\n\n\tprivate static Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> parametersConverter() {\n // ...\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.web.server.invoke\n\n@Configuration\n@EnableWebFluxSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()\n accessTokenResponseClient.addParametersConverter(parametersConverter())\n\n return http {\n authorizeExchange {\n authorize(anyExchange, authenticated)\n }\n oauth2Login {\n authenticationManager = DelegatingReactiveAuthenticationManager(\n OidcAuthorizationCodeReactiveAuthenticationManager(\n accessTokenResponseClient, OidcReactiveOAuth2UserService()\n ),\n OAuth2LoginReactiveAuthenticationManager(\n accessTokenResponseClient, DefaultReactiveOAuth2UserService()\n )\n )\n }\n oauth2Client {\n authenticationManager = OAuth2AuthorizationCodeReactiveAuthenticationManager(\n accessTokenResponseClient\n )\n }\n }\n\t}\n\n\tprivate fun parametersConverter(): Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> {\n // ...\n\t}\n\n}\n----\n=====\n\nFor other grant types we can publish additional `ReactiveOAuth2AccessTokenResponseClient` beans to override the defaults.\nFor example, to customize token requests for the `client_credentials` grant we can publish the following bean:\n\n.Customize Token Request Parameters for Client Credentials Grant\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsAccessTokenResponseClient() {\n WebClientReactiveClientCredentialsTokenResponseClient accessTokenResponseClient =\n new WebClientReactiveClientCredentialsTokenResponseClient();\n accessTokenResponseClient.addParametersConverter(parametersConverter());\n\n return accessTokenResponseClient;\n\t}\n\n\tprivate static Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> parametersConverter() {\n // ...\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun clientCredentialsAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> {\n val accessTokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient()\n accessTokenResponseClient.addParametersConverter(parametersConverter())\n\n return accessTokenResponseClient\n\t}\n\n\tprivate fun parametersConverter(): Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> {\n // ...\n\t}\n\n}\n----\n=====\n\nSpring Security automatically resolves the following generic types of `ReactiveOAuth2AccessTokenResponseClient` beans:\n\n* `OAuth2AuthorizationCodeGrantRequest` (see `WebClientReactiveAuthorizationCodeTokenResponseClient`)\n* `OAuth2RefreshTokenGrantRequest` (see `WebClientReactiveRefreshTokenTokenResponseClient`)\n* `OAuth2ClientCredentialsGrantRequest` (see `WebClientReactiveClientCredentialsTokenResponseClient`)\n* `JwtBearerGrantRequest` (see `WebClientReactiveJwtBearerTokenResponseClient`)\n* `TokenExchangeGrantRequest` (see `WebClientReactiveTokenExchangeTokenResponseClient`)\n\n[TIP]\n====\nPublishing a bean of type `ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest>` will automatically enable the `jwt-bearer` grant type without the need to <<oauth2-client-enable-extension-grant-type,configure it separately>>.\n====\n\n[TIP]\n====\nPublishing a bean of type `ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest>` will automatically enable the `token-exchange` grant type without the need to <<oauth2-client-enable-extension-grant-type,configure it separately>>.\n====\n\n[[oauth2-client-customize-web-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Customize Token Request Parameters", "heading_level": 3, "file_order": 54, "section_index": 13, "content_hash": "66e9992a475a80b3b31ec4e0ce11b1d8bbc816750726b9fec4e5fafb5fdbec5b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:e8f25bf929736e76bc2440e610698ae04637bffb78dfeb4776a4c6141551e387", "content": "Another common use case is the need to customize the `WebClient` used when obtaining an access token.\nWe might need to do this to customize the underlying HTTP client library (via a custom `ClientHttpConnector`) to configure SSL settings or to apply proxy settings for a corporate network.\n\nWith Spring Security 6.3 and later, we can simply publish beans of type `ReactiveOAuth2AccessTokenResponseClient` and Spring Security will configure and publish a `ReactiveOAuth2AuthorizedClientManager` bean for us.\n\nThe following example customizes the `WebClient` for all of the supported grant types:\n\n.Customize `WebClient` for OAuth2 Client\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() {\n WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient =\n new WebClientReactiveAuthorizationCodeTokenResponseClient();\n accessTokenResponseClient.setWebClient(webClient());\n\n return accessTokenResponseClient;\n\t}\n\n\t@Bean\n\tpublic ReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> refreshTokenAccessTokenResponseClient() {\n WebClientReactiveRefreshTokenTokenResponseClient accessTokenResponseClient =\n new WebClientReactiveRefreshTokenTokenResponseClient();\n accessTokenResponseClient.setWebClient(webClient());\n\n return accessTokenResponseClient;\n\t}\n\n\t@Bean\n\tpublic ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsAccessTokenResponseClient() {\n WebClientReactiveClientCredentialsTokenResponseClient accessTokenResponseClient =\n new WebClientReactiveClientCredentialsTokenResponseClient();\n accessTokenResponseClient.setWebClient(webClient());\n\n return accessTokenResponseClient;\n\t}\n\n\t@Bean\n\tpublic ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> jwtBearerAccessTokenResponseClient() {\n WebClientReactiveJwtBearerTokenResponseClient accessTokenResponseClient =\n new WebClientReactiveJwtBearerTokenResponseClient();\n accessTokenResponseClient.setWebClient(webClient());\n\n return accessTokenResponseClient;\n\t}\n\n\t@Bean\n\tpublic ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> tokenExchangeAccessTokenResponseClient() {\n WebClientReactiveTokenExchangeTokenResponseClient accessTokenResponseClient =\n new WebClientReactiveTokenExchangeTokenResponseClient();\n accessTokenResponseClient.setWebClient(webClient());\n\n return accessTokenResponseClient;\n\t}\n\n\t@Bean\n\tpublic WebClient webClient() {\n // ...\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun authorizationCodeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {\n val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()\n accessTokenResponseClient.setWebClient(webClient())\n\n return accessTokenResponseClient\n\t}\n\n\t@Bean\n\tfun refreshTokenAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> {\n val accessTokenResponseClient = WebClientReactiveRefreshTokenTokenResponseClient()\n accessTokenResponseClient.setWebClient(webClient())\n\n return accessTokenResponseClient\n\t}\n\n\t@Bean\n\tfun clientCredentialsAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> {\n val accessTokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient()\n accessTokenResponseClient.setWebClient(webClient())\n\n return accessTokenResponseClient\n\t}\n\n\t@Bean\n\tfun jwtBearerAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> {\n val accessTokenResponseClient = WebClientReactiveJwtBearerTokenResponseClient()\n accessTokenResponseClient.setWebClient(webClient())\n\n return accessTokenResponseClient\n\t}\n\n\t@Bean\n\tfun tokenExchangeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> {\n val accessTokenResponseClient = WebClientReactiveTokenExchangeTokenResponseClient()\n accessTokenResponseClient.setWebClient(webClient())\n\n return accessTokenResponseClient\n\t}\n\n\t@Bean\n\tfun webClient(): WebClient {\n // ...\n\t}\n\n}\n----\n=====\n\nA default `ReactiveOAuth2AuthorizedClientManager` will be published automatically by Spring Security when one is not already provided.\n\n[TIP]\n====\nNotice that we don't need to customize the `SecurityWebFilterChain` bean in this case, and can stick with the defaults.\nIf using Spring Boot with no additional customizations, we can actually omit the `SecurityWebFilterChain` bean entirely.\n====\n\nPrior to Spring Security 6.3, we had to ensure this customization was applied to OAuth2 Client components ourselves.\nWhile we could publish a bean of type `ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest>` for the `authorization_code` grant, we had to publish a bean of type `ReactiveOAuth2AuthorizedClientManager` for other grant types.\nTo understand what is being configured behind the scenes, here's what the configuration might have looked like:\n\n.Customize `WebClient` for OAuth2 Client (prior to 6.3)\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() {\n WebClientReactiveAuthorizationCodeTokenResponseClient accessTokenResponseClient =\n new WebClientReactiveAuthorizationCodeTokenResponseClient();\n accessTokenResponseClient.setWebClient(webClient());\n\n return accessTokenResponseClient;\n\t}\n\n\t@Bean\n\tpublic ReactiveOAuth2AuthorizedClientManager authorizedClientManager(\n ReactiveClientRegistrationRepository clientRegistrationRepository,\n ServerOAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n WebClientReactiveRefreshTokenTokenResponseClient refreshTokenAccessTokenResponseClient =\n new WebClientReactiveRefreshTokenTokenResponseClient();\n refreshTokenAccessTokenResponseClient.setWebClient(webClient());\n\n WebClientReactiveClientCredentialsTokenResponseClient clientCredentialsAccessTokenResponseClient =\n new WebClientReactiveClientCredentialsTokenResponseClient();\n clientCredentialsAccessTokenResponseClient.setWebClient(webClient());\n\n WebClientReactiveJwtBearerTokenResponseClient jwtBearerAccessTokenResponseClient =\n new WebClientReactiveJwtBearerTokenResponseClient();\n jwtBearerAccessTokenResponseClient.setWebClient(webClient());\n\n JwtBearerReactiveOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider =\n new JwtBearerReactiveOAuth2AuthorizedClientProvider();\n jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerAccessTokenResponseClient);\n\n WebClientReactiveTokenExchangeTokenResponseClient tokenExchangeAccessTokenResponseClient =\n new WebClientReactiveTokenExchangeTokenResponseClient();\n tokenExchangeAccessTokenResponseClient.setWebClient(webClient());\n\n TokenExchangeReactiveOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider =\n new TokenExchangeReactiveOAuth2AuthorizedClientProvider();\n tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeAccessTokenResponseClient);\n\n ReactiveOAuth2AuthorizedClientProvider authorizedClientProvider =\n ReactiveOAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken((refreshToken) -> refreshToken\n .accessTokenResponseClient(refreshTokenAccessTokenResponseClient)\n )\n .clientCredentials((clientCredentials) -> clientCredentials\n .accessTokenResponseClient(clientCredentialsAccessTokenResponseClient)\n )\n .provider(jwtBearerAuthorizedClientProvider)\n .provider(tokenExchangeAuthorizedClientProvider)\n .build();\n\n DefaultReactiveOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n return authorizedClientManager;\n\t}\n\n\t@Bean\n\tpublic WebClient webClient() {\n // ...\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.web.server.invoke\n\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun authorizationCodeAccessTokenResponseClient(): ReactiveOAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {\n val accessTokenResponseClient = WebClientReactiveAuthorizationCodeTokenResponseClient()\n accessTokenResponseClient.setWebClient(webClient())\n\n return accessTokenResponseClient\n\t}\n\n\t@Bean\n\tfun authorizedClientManager(\n clientRegistrationRepository: ReactiveClientRegistrationRepository?,\n authorizedClientRepository: ServerOAuth2AuthorizedClientRepository?\n\t): ReactiveOAuth2AuthorizedClientManager {\n val refreshTokenAccessTokenResponseClient = WebClientReactiveRefreshTokenTokenResponseClient()\n refreshTokenAccessTokenResponseClient.setWebClient(webClient())\n\n val clientCredentialsAccessTokenResponseClient = WebClientReactiveClientCredentialsTokenResponseClient()\n clientCredentialsAccessTokenResponseClient.setWebClient(webClient())\n\n val jwtBearerAccessTokenResponseClient = WebClientReactiveJwtBearerTokenResponseClient()\n jwtBearerAccessTokenResponseClient.setWebClient(webClient())\n\n val jwtBearerAuthorizedClientProvider = JwtBearerReactiveOAuth2AuthorizedClientProvider()\n jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerAccessTokenResponseClient)\n\n val tokenExchangeAccessTokenResponseClient = WebClientReactiveTokenExchangeTokenResponseClient()\n tokenExchangeAccessTokenResponseClient.setWebClient(webClient())\n\n val tokenExchangeAuthorizedClientProvider = TokenExchangeReactiveOAuth2AuthorizedClientProvider()\n tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeAccessTokenResponseClient)\n\n val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken { refreshToken ->\n refreshToken.accessTokenResponseClient(refreshTokenAccessTokenResponseClient)\n }\n .clientCredentials { clientCredentials ->\n clientCredentials.accessTokenResponseClient(clientCredentialsAccessTokenResponseClient)\n }\n .provider(jwtBearerAuthorizedClientProvider)\n .provider(tokenExchangeAuthorizedClientProvider)\n .build()\n\n val authorizedClientManager = DefaultReactiveOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository\n )\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n\n return authorizedClientManager\n\t}\n\n\t@Bean\n\tfun webClient(): WebClient {\n // ...\n\t}\n\n}\n----\n=====\n\n[[further-reading]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Customize the `WebClient` used by OAuth2 Client Components", "heading_level": 3, "file_order": 54, "section_index": 14, "content_hash": "e8f25bf929736e76bc2440e610698ae04637bffb78dfeb4776a4c6141551e387", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:7e6306eafc3bd296cbc03d617ef000a11af1061a11311f7125a3334899d55187", "content": "The preceding sections introduced Spring Security's support for OAuth2 with examples for common scenarios.\nYou can read more about OAuth2 Client and Resource Server in the following sections of the reference documentation:\n\n* xref:reactive/oauth2/login/index.adoc[]\n* xref:reactive/oauth2/client/index.adoc[]\n* xref:reactive/oauth2/resource-server/index.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/oauth2/index.adoc", "title": "index", "heading": "Further Reading", "heading_level": 2, "file_order": 54, "section_index": 15, "content_hash": "7e6306eafc3bd296cbc03d617ef000a11af1061a11311f7125a3334899d55187", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/oauth2/index.adoc"}}
{"id": "sha256:d2a62c997e367c9d055215aa21aa1c3df581dff561f3cd6e147e5ccebb78e57b", "content": "After xref:reactive/test/web/setup.adoc[applying the Spring Security support to `WebTestClient`], we can use either annotations or `mutateWith` support -- for example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.mockUser;\n\n@Test\npublic void messageWhenNotAuthenticated() throws Exception {\n\tthis.rest\n .get()\n .uri(\"/message\")\n .exchange()\n .expectStatus().isUnauthorized();\n}\n\n@Test\n@WithMockUser\npublic void messageWhenWithMockUserThenForbidden() throws Exception {\n\tthis.rest\n .get()\n .uri(\"/message\")\n .exchange()\n .expectStatus().isEqualTo(HttpStatus.FORBIDDEN);\n}\n\n@Test\n@WithMockUser(roles = \"ADMIN\")\npublic void messageWhenWithMockAdminThenOk() throws Exception {\n\tthis.rest\n .get()\n .uri(\"/message\")\n .exchange()\n .expectStatus().isOk()\n .expectBody(String.class).isEqualTo(\"Hello World!\");\n}\n\n@Test\npublic void messageWhenMutateWithMockUserThenForbidden() throws Exception {\n\tthis.rest\n .mutateWith(mockUser())\n .get()\n .uri(\"/message\")\n .exchange()\n .expectStatus().isEqualTo(HttpStatus.FORBIDDEN);\n}\n\n@Test\npublic void messageWhenMutateWithMockAdminThenOk() throws Exception {\n\tthis.rest\n .mutateWith(mockUser().roles(\"ADMIN\"))\n .get()\n .uri(\"/message\")\n .exchange()\n .expectStatus().isOk()\n .expectBody(String.class).isEqualTo(\"Hello World!\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.test.web.reactive.server.expectBody\nimport org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.mockUser\n\n@Test\n@WithMockUser\nfun messageWhenWithMockUserThenForbidden() {\n this.rest.get().uri(\"/message\")\n .exchange()\n .expectStatus().isEqualTo(HttpStatus.FORBIDDEN)\n}\n\n@Test\n@WithMockUser(roles = [\"ADMIN\"])\nfun messageWhenWithMockAdminThenOk() {\n this.rest.get().uri(\"/message\")\n .exchange()\n .expectStatus().isOk\n .expectBody<String>().isEqualTo(\"Hello World!\")\n\n}\n\n@Test\nfun messageWhenMutateWithMockUserThenForbidden() {\n this.rest\n .mutateWith(mockUser())\n .get().uri(\"/message\")\n .exchange()\n .expectStatus().isEqualTo(HttpStatus.FORBIDDEN)\n}\n\n@Test\nfun messageWhenMutateWithMockAdminThenOk() {\n this.rest\n .mutateWith(mockUser().roles(\"ADMIN\"))\n .get().uri(\"/message\")\n .exchange()\n .expectStatus().isOk\n .expectBody<String>().isEqualTo(\"Hello World!\")\n}\n----\n======\n\nIn addition to `mockUser()`, Spring Security ships with several other convenience mutators for things like xref:reactive/test/web/csrf.adoc[CSRF] and xref:reactive/test/web/oauth2.adoc[OAuth 2.0].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/authentication.adoc", "title": "Testing Authentication", "heading": "Testing Authentication", "heading_level": 1, "file_order": 55, "section_index": 0, "content_hash": "d2a62c997e367c9d055215aa21aa1c3df581dff561f3cd6e147e5ccebb78e57b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/authentication.adoc"}}
{"id": "sha256:e1ad5951f6f2b9cca7865b7f105f8ceb6dc300c7c63674957339e3e3980f2816", "content": "Spring Security also provides support for CSRF testing with `WebTestClient` -- for example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.csrf;\n\nthis.rest\n\t// provide a valid CSRF token\n\t.mutateWith(csrf())\n\t.post()\n\t.uri(\"/login\")\n\t...\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.csrf\n\nthis.rest\n // provide a valid CSRF token\n .mutateWith(csrf())\n .post()\n .uri(\"/login\")\n ...\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/csrf.adoc", "title": "Testing with CSRF", "heading": "Testing with CSRF", "heading_level": 1, "file_order": 56, "section_index": 0, "content_hash": "e1ad5951f6f2b9cca7865b7f105f8ceb6dc300c7c63674957339e3e3980f2816", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/csrf.adoc"}}
{"id": "sha256:fc473291a2438a7de3f583748fd3046bf9675562040c3418a3edbb6289992793", "content": "[[test-webtestclient]]\n\nIn this section, we'll talk about testing web application endpoints.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 57, "section_index": 0, "content_hash": "fc473291a2438a7de3f583748fd3046bf9675562040c3418a3edbb6289992793", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/index.adoc"}}
{"id": "sha256:00fde8a073beeb331dc34c8d7ca81f7dacfec1ec6ef0cea72228882990b3eb9d", "content": "[[webflux-testing-oauth2]]\n\nWhen it comes to OAuth 2.0, xref:reactive/test/method.adoc#test-erms[the same principles covered earlier still apply]: Ultimately, it depends on what your method under test is expecting to be in the `SecurityContextHolder`.\n\nConsider the following example of a controller:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic Mono<String> foo(Principal user) {\n return Mono.just(user.getName());\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(user: Principal): Mono<String> {\n return Mono.just(user.name)\n}\n----\n======\n\nNothing about it is OAuth2-specific, so you can xref:reactive/test/method.adoc#test-erms[use `@WithMockUser`] and be fine.\n\nHowever, consider a case where your controller is bound to some aspect of Spring Security's OAuth 2.0 support:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic Mono<String> foo(@AuthenticationPrincipal OidcUser user) {\n return Mono.just(user.getIdToken().getSubject());\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(@AuthenticationPrincipal user: OidcUser): Mono<String> {\n return Mono.just(user.idToken.subject)\n}\n----\n======\n\nIn that case, Spring Security's test support is handy.\n\n[[webflux-testing-oidc-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "oauth2", "heading_level": 1, "file_order": 58, "section_index": 0, "content_hash": "00fde8a073beeb331dc34c8d7ca81f7dacfec1ec6ef0cea72228882990b3eb9d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:3dab685006e3cb20c89ccdf0c86eba67dce386bd5f6252772f3fa98a8c8508bc", "content": "Testing the method shown in the <<webflux-testing-oauth2,preceding section>> with `WebTestClient` requires simulating some kind of grant flow with an authorization server.\nThis is a daunting task, which is why Spring Security ships with support for removing this boilerplate.\n\nFor example, we can tell Spring Security to include a default `OidcUser` by using the `SecurityMockServerConfigurers#oidcLogin` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockOidcLogin()).get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockOidcLogin())\n .get().uri(\"/endpoint\")\n .exchange()\n----\n======\n\nThat line configures the associated `MockServerRequest` with an `OidcUser` that includes a simple `OidcIdToken`, an `OidcUserInfo`, and a `Collection` of granted authorities.\n\nSpecifically, it includes an `OidcIdToken` with a `sub` claim set to `user`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(user.getIdToken().getClaim(\"sub\")).isEqualTo(\"user\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(user.idToken.getClaim<String>(\"sub\")).isEqualTo(\"user\")\n----\n======\n\nIt also includes an `OidcUserInfo` with no claims set:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(user.getUserInfo().getClaims()).isEmpty();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(user.userInfo.claims).isEmpty()\n----\n======\n\nIt also includes a `Collection` of authorities with just one authority, `SCOPE_read`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(user.getAuthorities()).hasSize(1);\nassertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority(\"SCOPE_read\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(user.authorities).hasSize(1)\nassertThat(user.authorities).containsExactly(SimpleGrantedAuthority(\"SCOPE_read\"))\n----\n======\n\nSpring Security makes sure that the `OidcUser` instance is available forxref:servlet/integrations/mvc.adoc#mvc-authentication-principal[the `@AuthenticationPrincipal` annotation].\n\nFurther, it also links the `OidcUser` to a simple instance of `OAuth2AuthorizedClient` that it deposits into a mock `ServerOAuth2AuthorizedClientRepository`.\nThis can be handy if your tests <<webflux-testing-oauth2-client,use the `@RegisteredOAuth2AuthorizedClient` annotation>>..\n\n[[webflux-testing-oidc-login-authorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Testing OIDC Login", "heading_level": 2, "file_order": 58, "section_index": 1, "content_hash": "3dab685006e3cb20c89ccdf0c86eba67dce386bd5f6252772f3fa98a8c8508bc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:0a8279e58220e3cbeb7d3bb9fe3cbff6c452ca4323019dff1bf72fb927d78f5a", "content": "In many circumstances, your method is protected by filter or method security and needs your `Authentication` to have certain granted authorities to allow the request.\n\nIn those cases, you can supply what granted authorities you need by using the `authorities()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockOidcLogin()\n .authorities(new SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockOidcLogin()\n .authorities(SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\n[[webflux-testing-oidc-login-claims]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Configuring Authorities", "heading_level": 3, "file_order": 58, "section_index": 2, "content_hash": "0a8279e58220e3cbeb7d3bb9fe3cbff6c452ca4323019dff1bf72fb927d78f5a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:177493f7de4d0dd1dff021d07ab2a4f48fd7b997317d4df44e0f1988f312e68c", "content": "While granted authorities are common across all of Spring Security, we also have claims in the case of OAuth 2.0.\n\nSuppose, for example, that you have a `user_id` claim that indicates the user's ID in your system.\nYou might access it as follows in a controller:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic Mono<String> foo(@AuthenticationPrincipal OidcUser oidcUser) {\n String userId = oidcUser.getIdToken().getClaim(\"user_id\");\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(@AuthenticationPrincipal oidcUser: OidcUser): Mono<String> {\n val userId = oidcUser.idToken.getClaim<String>(\"user_id\")\n // ...\n}\n----\n======\n\nIn that case, you can specify that claim with the `idToken()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockOidcLogin()\n .idToken((token) -> token.claim(\"user_id\", \"1234\"))\n )\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockOidcLogin()\n .idToken { token -> token.claim(\"user_id\", \"1234\") }\n )\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\nThat works because `OidcUser` collects its claims from `OidcIdToken`.\n\n[[webflux-testing-oidc-login-user]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Configuring Claims", "heading_level": 3, "file_order": 58, "section_index": 3, "content_hash": "177493f7de4d0dd1dff021d07ab2a4f48fd7b997317d4df44e0f1988f312e68c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:a5afca0e7169a149883c09ef0f7089e6d9e2d9749d26382b69890ab0dfa5ac4f", "content": "There are additional methods, too, for further configuring the authentication, depending on what data your controller expects:\n\n* `userInfo(OidcUserInfo.Builder)`: Configures the `OidcUserInfo` instance\n* `clientRegistration(ClientRegistration)`: Configures the associated `OAuth2AuthorizedClient` with a given `ClientRegistration`\n* `oidcUser(OidcUser)`: Configures the complete `OidcUser` instance\n\nThat last one is handy if you:\n* Have your own implementation of `OidcUser` or\n* Need to change the name attribute\n\nFor example, suppose that your authorization server sends the principal name in the `user_name` claim instead of the `sub` claim.\nIn that case, you can configure an `OidcUser` by hand:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOidcUser oidcUser = new DefaultOidcUser(\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\"),\n OidcIdToken.withTokenValue(\"id-token\").claim(\"user_name\", \"foo_user\").build(),\n \"user_name\");\n\nclient\n .mutateWith(mockOidcLogin().oidcUser(oidcUser))\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval oidcUser: OidcUser = DefaultOidcUser(\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\"),\n OidcIdToken.withTokenValue(\"id-token\").claim(\"user_name\", \"foo_user\").build(),\n \"user_name\"\n)\n\nclient\n .mutateWith(mockOidcLogin().oidcUser(oidcUser))\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\n[[webflux-testing-oauth2-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Additional Configurations", "heading_level": 3, "file_order": 58, "section_index": 4, "content_hash": "a5afca0e7169a149883c09ef0f7089e6d9e2d9749d26382b69890ab0dfa5ac4f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:47149eb50be154813e8b0fcf34cb58b5a7a1392a0de42be84b92a7dcca44b331", "content": "As with <<webflux-testing-oidc-login,testing OIDC login>>, testing OAuth 2.0 Login presents a similar challenge: mocking a grant flow.\nBecause of that, Spring Security also has test support for non-OIDC use cases.\n\nSuppose that we have a controller that gets the logged-in user as an `OAuth2User`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic Mono<String> foo(@AuthenticationPrincipal OAuth2User oauth2User) {\n return Mono.just(oauth2User.getAttribute(\"sub\"));\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(@AuthenticationPrincipal oauth2User: OAuth2User): Mono<String> {\n return Mono.just(oauth2User.getAttribute(\"sub\"))\n}\n----\n======\n\nIn that case, we can tell Spring Security to include a default `OAuth2User` by using the `SecurityMockServerConfigurers#oauth2User` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockOAuth2Login())\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockOAuth2Login())\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\nThe preceding example configures the associated `MockServerRequest` with an `OAuth2User` that includes a simple `Map` of attributes and a `Collection` of granted authorities.\n\nSpecifically, it includes a `Map` with a key/value pair of `sub`/`user`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat((String) user.getAttribute(\"sub\")).isEqualTo(\"user\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(user.getAttribute<String>(\"sub\")).isEqualTo(\"user\")\n----\n======\n\nIt also includes a `Collection` of authorities with just one authority, `SCOPE_read`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(user.getAuthorities()).hasSize(1);\nassertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority(\"SCOPE_read\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(user.authorities).hasSize(1)\nassertThat(user.authorities).containsExactly(SimpleGrantedAuthority(\"SCOPE_read\"))\n----\n======\n\nSpring Security does the necessary work to make sure that the `OAuth2User` instance is available for xref:servlet/integrations/mvc.adoc#mvc-authentication-principal[the `@AuthenticationPrincipal` annotation].\n\nFurther, it also links that `OAuth2User` to a simple instance of `OAuth2AuthorizedClient` that it deposits in a mock `ServerOAuth2AuthorizedClientRepository`.\nThis can be handy if your tests <<webflux-testing-oauth2-client,use the `@RegisteredOAuth2AuthorizedClient` annotation>>.\n\n[[webflux-testing-oauth2-login-authorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Testing OAuth 2.0 Login", "heading_level": 2, "file_order": 58, "section_index": 5, "content_hash": "47149eb50be154813e8b0fcf34cb58b5a7a1392a0de42be84b92a7dcca44b331", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:f64703c41bae03192c218886ba4b84fb12f190c6bbdfd32e52db876d3ba7ca90", "content": "In many circumstances, your method is protected by filter or method security and needs your `Authentication` to have certain granted authorities to allow the request.\n\nIn this case, you can supply the granted authorities you need by using the `authorities()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockOAuth2Login()\n .authorities(new SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockOAuth2Login()\n .authorities(SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\n[[webflux-testing-oauth2-login-claims]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Configuring Authorities", "heading_level": 3, "file_order": 58, "section_index": 6, "content_hash": "f64703c41bae03192c218886ba4b84fb12f190c6bbdfd32e52db876d3ba7ca90", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:1121b6524b360ae480afd0bc5571544e898fb875f248c51070e00088b8182b78", "content": "While granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0.\n\nSuppose, for example, that you have a `user_id` attribute that indicates the user's ID in your system.\nYou might access it as follows in a controller:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic Mono<String> foo(@AuthenticationPrincipal OAuth2User oauth2User) {\n String userId = oauth2User.getAttribute(\"user_id\");\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(@AuthenticationPrincipal oauth2User: OAuth2User): Mono<String> {\n val userId = oauth2User.getAttribute<String>(\"user_id\")\n // ...\n}\n----\n======\n\nIn that case, you can specify that attribute with the `attributes()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockOAuth2Login()\n .attributes((attrs) -> attrs.put(\"user_id\", \"1234\"))\n )\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockOAuth2Login()\n .attributes { attrs -> attrs[\"user_id\"] = \"1234\" }\n )\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\n[[webflux-testing-oauth2-login-user]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Configuring Claims", "heading_level": 3, "file_order": 58, "section_index": 7, "content_hash": "1121b6524b360ae480afd0bc5571544e898fb875f248c51070e00088b8182b78", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:5de0a5066067a2ffede4bc41e0c681f3eed4fbb6a0ccc5446533b5759c9b950e", "content": "There are additional methods, too, for further configuring the authentication, depending on what data your controller expects:\n\n* `clientRegistration(ClientRegistration)`: Configures the associated `OAuth2AuthorizedClient` with a given `ClientRegistration`\n* `oauth2User(OAuth2User)`: Configures the complete `OAuth2User` instance\n\nThat last one is handy if you:\n* Have your own implementation of `OAuth2User` or\n* Need to change the name attribute\n\nFor example, suppose that your authorization server sends the principal name in the `user_name` claim instead of the `sub` claim.\nIn that case, you can configure an `OAuth2User` by hand:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2User oauth2User = new DefaultOAuth2User(\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\"),\n Collections.singletonMap(\"user_name\", \"foo_user\"),\n \"user_name\");\n\nclient\n .mutateWith(mockOAuth2Login().oauth2User(oauth2User))\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval oauth2User: OAuth2User = DefaultOAuth2User(\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\"),\n mapOf(Pair(\"user_name\", \"foo_user\")),\n \"user_name\"\n)\n\nclient\n .mutateWith(mockOAuth2Login().oauth2User(oauth2User))\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\n[[webflux-testing-oauth2-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Additional Configurations", "heading_level": 3, "file_order": 58, "section_index": 8, "content_hash": "5de0a5066067a2ffede4bc41e0c681f3eed4fbb6a0ccc5446533b5759c9b950e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:70e08531ae9c6a8b40a06cc2bcd4ed2cb9a40cfec0b96328b0fa850a9321a30f", "content": "Independent of how your user authenticates, you may have other tokens and client registrations that are in play for the request you are testing.\nFor example, your controller may rely on the client credentials grant to get a token that is not associated with the user at all:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic Mono<String> foo(@RegisteredOAuth2AuthorizedClient(\"my-app\") OAuth2AuthorizedClient authorizedClient) {\n return this.webClient.get()\n .attributes(oauth2AuthorizedClient(authorizedClient))\n .retrieve()\n .bodyToMono(String.class);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.web.reactive.function.client.bodyToMono\n\n@GetMapping(\"/endpoint\")\nfun foo(@RegisteredOAuth2AuthorizedClient(\"my-app\") authorizedClient: OAuth2AuthorizedClient?): Mono<String> {\n return this.webClient.get()\n .attributes(oauth2AuthorizedClient(authorizedClient))\n .retrieve()\n .bodyToMono()\n}\n----\n======\n\nSimulating this handshake with the authorization server can be cumbersome.\nInstead, you can use `SecurityMockServerConfigurers#oauth2Client` to add a `OAuth2AuthorizedClient` to a mock `ServerOAuth2AuthorizedClientRepository`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockOAuth2Client(\"my-app\"))\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockOAuth2Client(\"my-app\"))\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\nThis creates an `OAuth2AuthorizedClient` that has a simple `ClientRegistration`, a `OAuth2AccessToken`, and a resource owner name.\n\nSpecifically, it includes a `ClientRegistration` with a client ID of `test-client` and a client secret of `test-secret`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(authorizedClient.getClientRegistration().getClientId()).isEqualTo(\"test-client\");\nassertThat(authorizedClient.getClientRegistration().getClientSecret()).isEqualTo(\"test-secret\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(authorizedClient.clientRegistration.clientId).isEqualTo(\"test-client\")\nassertThat(authorizedClient.clientRegistration.clientSecret).isEqualTo(\"test-secret\")\n----\n======\n\nIt also includes a resource owner name of `user`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(authorizedClient.getPrincipalName()).isEqualTo(\"user\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(authorizedClient.principalName).isEqualTo(\"user\")\n----\n======\n\nIt also includes an `OAuth2AccessToken` with one scope, `read`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(authorizedClient.getAccessToken().getScopes()).hasSize(1);\nassertThat(authorizedClient.getAccessToken().getScopes()).containsExactly(\"read\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(authorizedClient.accessToken.scopes).hasSize(1)\nassertThat(authorizedClient.accessToken.scopes).containsExactly(\"read\")\n----\n======\n\nYou can then retrieve the client as usual by using `@RegisteredOAuth2AuthorizedClient` in a controller method.\n\n[[webflux-testing-oauth2-client-scopes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Testing OAuth 2.0 Clients", "heading_level": 2, "file_order": 58, "section_index": 9, "content_hash": "70e08531ae9c6a8b40a06cc2bcd4ed2cb9a40cfec0b96328b0fa850a9321a30f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:a0bdc78f44ca7466d4cb9dc9a92675135a02ff6abfa0bab4d9ca4901522fdaf9", "content": "In many circumstances, the OAuth 2.0 access token comes with a set of scopes.\nConsider the following example of how a controller can inspect the scopes:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic Mono<String> foo(@RegisteredOAuth2AuthorizedClient(\"my-app\") OAuth2AuthorizedClient authorizedClient) {\n Set<String> scopes = authorizedClient.getAccessToken().getScopes();\n if (scopes.contains(\"message:read\")) {\n return this.webClient.get()\n .attributes(oauth2AuthorizedClient(authorizedClient))\n .retrieve()\n .bodyToMono(String.class);\n }\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.web.reactive.function.client.bodyToMono\n\n@GetMapping(\"/endpoint\")\nfun foo(@RegisteredOAuth2AuthorizedClient(\"my-app\") authorizedClient: OAuth2AuthorizedClient): Mono<String> {\n val scopes = authorizedClient.accessToken.scopes\n if (scopes.contains(\"message:read\")) {\n return webClient.get()\n .attributes(oauth2AuthorizedClient(authorizedClient))\n .retrieve()\n .bodyToMono()\n }\n // ...\n}\n----\n======\n\nGiven a controller that inspects scopes, you can configure the scope by using the `accessToken()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockOAuth2Client(\"my-app\")\n .accessToken(new OAuth2AccessToken(BEARER, \"token\", null, null, Collections.singleton(\"message:read\")))\n )\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockOAuth2Client(\"my-app\")\n .accessToken(OAuth2AccessToken(BEARER, \"token\", null, null, setOf(\"message:read\")))\n)\n.get().uri(\"/endpoint\").exchange()\n----\n======\n\n[[webflux-testing-oauth2-client-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Configuring Scopes", "heading_level": 3, "file_order": 58, "section_index": 10, "content_hash": "a0bdc78f44ca7466d4cb9dc9a92675135a02ff6abfa0bab4d9ca4901522fdaf9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:1cec583509211d8772bf180ef81db70b99607deb98d0aeb72dc47b3bbb0cac2e", "content": "You can also use additional methods to further configure the authentication depending on what data your controller expects:\n\n* `principalName(String)`; Configures the resource owner name\n* `clientRegistration(Consumer<ClientRegistration.Builder>)`: Configures the associated `ClientRegistration`\n* `clientRegistration(ClientRegistration)`: Configures the complete `ClientRegistration`\n\nThat last one is handy if you want to use a real `ClientRegistration`\n\nFor example, suppose that you want to use one of your application's `ClientRegistration` definitions, as specified in your `application.yml`.\n\nIn that case, your test can autowire the `ReactiveClientRegistrationRepository` and look up the one your test needs:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nReactiveClientRegistrationRepository clientRegistrationRepository;\n\nclient\n .mutateWith(mockOAuth2Client()\n .clientRegistration(this.clientRegistrationRepository.findByRegistrationId(\"facebook\").block())\n )\n .get().uri(\"/exchange\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Autowired\nlateinit var clientRegistrationRepository: ReactiveClientRegistrationRepository\n\nclient\n .mutateWith(mockOAuth2Client()\n .clientRegistration(this.clientRegistrationRepository.findByRegistrationId(\"facebook\").block())\n )\n .get().uri(\"/exchange\").exchange()\n----\n======\n\n[[webflux-testing-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Additional Configurations", "heading_level": 3, "file_order": 58, "section_index": 11, "content_hash": "1cec583509211d8772bf180ef81db70b99607deb98d0aeb72dc47b3bbb0cac2e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:298560965fc585d00e79370c153eac4e7054e2a6de1369885e8aa02deee29d50", "content": "To make an authorized request on a resource server, you need a bearer token.\nIf your resource server is configured for JWTs, the bearer token needs to be signed and then encoded according to the JWT specification.\nAll of this can be quite daunting, especially when this is not the focus of your test.\n\nFortunately, there are a number of simple ways in which you can overcome this difficulty and let your tests focus on authorization and not on representing bearer tokens.\nWe look at two of them in the next two subsections.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Testing JWT Authentication", "heading_level": 2, "file_order": 58, "section_index": 12, "content_hash": "298560965fc585d00e79370c153eac4e7054e2a6de1369885e8aa02deee29d50", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:5fe5feaad5c5b75d462c54a66f2da4721a7f638f7531b68414906aca121145b8", "content": "The first way is with a `WebTestClientConfigurer`.\nThe simplest of these would be to use the `SecurityMockServerConfigurers#mockJwt` method like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockJwt()).get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockJwt()).get().uri(\"/endpoint\").exchange()\n----\n======\n\nThis example creates a mock `Jwt` and passes it through any authentication APIs so that it is available for your authorization mechanisms to verify.\n\nBy default, the `JWT` that it creates has the following characteristics:\n\n[source,json]\n----\n{\n \"headers\" : { \"alg\" : \"none\" },\n \"claims\" : {\n \"sub\" : \"user\",\n \"scope\" : \"read\"\n }\n}\n----\n\nThe resulting `Jwt`, were it tested, would pass in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(jwt.getTokenValue()).isEqualTo(\"token\");\nassertThat(jwt.getHeaders().get(\"alg\")).isEqualTo(\"none\");\nassertThat(jwt.getSubject()).isEqualTo(\"sub\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(jwt.tokenValue).isEqualTo(\"token\")\nassertThat(jwt.headers[\"alg\"]).isEqualTo(\"none\")\nassertThat(jwt.subject).isEqualTo(\"sub\")\n----\n======\n\nNote that you configure these values.\n\nYou can also configure any headers or claims with their corresponding methods:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n\t.mutateWith(mockJwt().jwt((jwt) -> jwt.header(\"kid\", \"one\")\n .claim(\"iss\", \"https://idp.example.org\")))\n\t.get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockJwt().jwt { jwt -> jwt.header(\"kid\", \"one\")\n .claim(\"iss\", \"https://idp.example.org\")\n })\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n\t.mutateWith(mockJwt().jwt((jwt) -> jwt.claims((claims) -> claims.remove(\"scope\"))))\n\t.get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockJwt().jwt { jwt ->\n jwt.claims { claims -> claims.remove(\"scope\") }\n })\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\nThe `scope` and `scp` claims are processed the same way here as they are in a normal bearer token request.\nHowever, this can be overridden simply by providing the list of `GrantedAuthority` instances that you need for your test:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n\t.mutateWith(mockJwt().authorities(new SimpleGrantedAuthority(\"SCOPE_messages\")))\n\t.get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockJwt().authorities(SimpleGrantedAuthority(\"SCOPE_messages\")))\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\nAlternatively, if you have a custom `Jwt` to `Collection<GrantedAuthority>` converter, you can also use that to derive the authorities:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n\t.mutateWith(mockJwt().authorities(new MyConverter()))\n\t.get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockJwt().authorities(MyConverter()))\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\nYou can also specify a complete `Jwt`, for which javadoc:org.springframework.security.oauth2.jwt.Jwt$Builder[] is quite handy:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nJwt jwt = Jwt.withTokenValue(\"token\")\n .header(\"alg\", \"none\")\n .claim(\"sub\", \"user\")\n .claim(\"scope\", \"read\")\n .build();\n\nclient\n\t.mutateWith(mockJwt().jwt(jwt))\n\t.get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwt: Jwt = Jwt.withTokenValue(\"token\")\n .header(\"alg\", \"none\")\n .claim(\"sub\", \"user\")\n .claim(\"scope\", \"read\")\n .build()\n\nclient\n .mutateWith(mockJwt().jwt(jwt))\n .get().uri(\"/endpoint\").exchange()\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "`mockJwt() WebTestClientConfigurer`", "heading_level": 3, "file_order": 58, "section_index": 13, "content_hash": "5fe5feaad5c5b75d462c54a66f2da4721a7f638f7531b68414906aca121145b8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:560957e42751c6d8f7d03032f71adcf0f633e84534f9a0d943b94c29aec39508", "content": "The second way is by using the `authentication()` `Mutator`.\nYou can instantiate your own `JwtAuthenticationToken` and provide it in your test:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nJwt jwt = Jwt.withTokenValue(\"token\")\n .header(\"alg\", \"none\")\n .claim(\"sub\", \"user\")\n .build();\nCollection<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList(\"SCOPE_read\");\nJwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities);\n\nclient\n\t.mutateWith(mockAuthentication(token))\n\t.get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwt = Jwt.withTokenValue(\"token\")\n .header(\"alg\", \"none\")\n .claim(\"sub\", \"user\")\n .build()\nval authorities: Collection<GrantedAuthority> = AuthorityUtils.createAuthorityList(\"SCOPE_read\")\nval token = JwtAuthenticationToken(jwt, authorities)\n\nclient\n .mutateWith(mockAuthentication<JwtMutator>(token))\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\nNote that, as an alternative to these, you can also mock the `ReactiveJwtDecoder` bean itself with a `@MockBean` annotation.\n\n[[webflux-testing-opaque-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "`authentication()` and `WebTestClientConfigurer`", "heading_level": 3, "file_order": 58, "section_index": 14, "content_hash": "560957e42751c6d8f7d03032f71adcf0f633e84534f9a0d943b94c29aec39508", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:65775cbc8748b593e03c543d49c968b14cc5030dd4f20e4efdf0984268ce03b8", "content": "Similar to <<webflux-testing-jwt,JWTs>>, opaque tokens require an authorization server in order to verify their validity, which can make testing more difficult.\nTo help with that, Spring Security has test support for opaque tokens.\n\nSuppose you have a controller that retrieves the authentication as a `BearerTokenAuthentication`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic Mono<String> foo(BearerTokenAuthentication authentication) {\n return Mono.just((String) authentication.getTokenAttributes().get(\"sub\"));\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(authentication: BearerTokenAuthentication): Mono<String?> {\n return Mono.just(authentication.tokenAttributes[\"sub\"] as String?)\n}\n----\n======\n\nIn that case, you can tell Spring Security to include a default `BearerTokenAuthentication` by using the `SecurityMockServerConfigurers#opaqueToken` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockOpaqueToken())\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockOpaqueToken())\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\nThis example configures the associated `MockHttpServletRequest` with a `BearerTokenAuthentication` that includes a simple `OAuth2AuthenticatedPrincipal`, a `Map` of attributes, and a `Collection` of granted authorities.\n\nSpecifically, it includes a `Map` with a key/value pair of `sub`/`user`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat((String) token.getTokenAttributes().get(\"sub\")).isEqualTo(\"user\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(token.tokenAttributes[\"sub\"] as String?).isEqualTo(\"user\")\n----\n======\n\nIt also includes a `Collection` of authorities with just one authority, `SCOPE_read`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(token.getAuthorities()).hasSize(1);\nassertThat(token.getAuthorities()).containsExactly(new SimpleGrantedAuthority(\"SCOPE_read\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(token.authorities).hasSize(1)\nassertThat(token.authorities).containsExactly(SimpleGrantedAuthority(\"SCOPE_read\"))\n----\n======\n\nSpring Security does the necessary work to make sure that the `BearerTokenAuthentication` instance is available for your controller methods.\n\n[[webflux-testing-opaque-token-authorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Testing Opaque Token Authentication", "heading_level": 2, "file_order": 58, "section_index": 15, "content_hash": "65775cbc8748b593e03c543d49c968b14cc5030dd4f20e4efdf0984268ce03b8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:3957cd7a80075049495492d8221427c420d2292a573b3070d7937d70568d72b2", "content": "In many circumstances, your method is protected by filter or method security and needs your `Authentication` to have certain granted authorities to allow the request.\n\nIn this case, you can supply what granted authorities you need using the `authorities()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockOpaqueToken()\n .authorities(new SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockOpaqueToken()\n .authorities(SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\n[[webflux-testing-opaque-token-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Configuring Authorities", "heading_level": 3, "file_order": 58, "section_index": 16, "content_hash": "3957cd7a80075049495492d8221427c420d2292a573b3070d7937d70568d72b2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:af3fc4d45eea322052bdd261c32481a8d2a715fcf3ba83aacc22068266605ea1", "content": "While granted authorities are quite common across all of Spring Security, we also have attributes in the case of OAuth 2.0.\n\nSuppose, for example, that you have a `user_id` attribute that indicates the user's ID in your system.\nYou might access it as follows in a controller:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic Mono<String> foo(BearerTokenAuthentication authentication) {\n String userId = (String) authentication.getTokenAttributes().get(\"user_id\");\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(authentication: BearerTokenAuthentication): Mono<String?> {\n val userId = authentication.tokenAttributes[\"user_id\"] as String?\n // ...\n}\n----\n======\n\nIn that case, you can specify that attribute with the `attributes()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclient\n .mutateWith(mockOpaqueToken()\n .attributes((attrs) -> attrs.put(\"user_id\", \"1234\"))\n )\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclient\n .mutateWith(mockOpaqueToken()\n .attributes { attrs -> attrs[\"user_id\"] = \"1234\" }\n )\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\n[[webflux-testing-opaque-token-principal]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Configuring Claims", "heading_level": 3, "file_order": 58, "section_index": 17, "content_hash": "af3fc4d45eea322052bdd261c32481a8d2a715fcf3ba83aacc22068266605ea1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:fbe0f4d26c9bfa59030496edcaa68177a6f9316c3f46e8ba83f1efd49d3b6e48", "content": "You can also use additional methods to further configure the authentication, depending on what data your controller expects.\n\nOne such method is `principal(OAuth2AuthenticatedPrincipal)`, which you can use to configure the complete `OAuth2AuthenticatedPrincipal` instance that underlies the `BearerTokenAuthentication`.\n\nIt is handy if you:\n* Have your own implementation of `OAuth2AuthenticatedPrincipal` or\n* Want to specify a different principal name\n\nFor example, suppose that your authorization server sends the principal name in the `user_name` attribute instead of the `sub` attribute.\nIn that case, you can configure an `OAuth2AuthenticatedPrincipal` by hand:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nMap<String, Object> attributes = Collections.singletonMap(\"user_name\", \"foo_user\");\nOAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal(\n (String) attributes.get(\"user_name\"),\n attributes,\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\"));\n\nclient\n .mutateWith(mockOpaqueToken().principal(principal))\n .get().uri(\"/endpoint\").exchange();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval attributes: Map<String, Any> = mapOf(Pair(\"user_name\", \"foo_user\"))\nval principal: OAuth2AuthenticatedPrincipal = DefaultOAuth2AuthenticatedPrincipal(\n attributes[\"user_name\"] as String?,\n attributes,\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\")\n)\n\nclient\n .mutateWith(mockOpaqueToken().principal(principal))\n .get().uri(\"/endpoint\").exchange()\n----\n======\n\nNote that, as an alternative to using `mockOpaqueToken()` test support, you can also mock the `OpaqueTokenIntrospector` bean itself with a `@MockBean` annotation.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc", "title": "oauth2", "heading": "Additional Configurations", "heading_level": 3, "file_order": 58, "section_index": 18, "content_hash": "fbe0f4d26c9bfa59030496edcaa68177a6f9316c3f46e8ba83f1efd49d3b6e48", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/oauth2.adoc"}}
{"id": "sha256:d9daba725152f182f164261215235abd1bf8e38be4bf96c838514d2054f8e5e0", "content": "The basic setup looks like this:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.springSecurity;\nimport static org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication;\n\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = HelloWebfluxMethodApplication.class)\npublic class HelloWebfluxMethodApplicationTests {\n\t@Autowired\n\tApplicationContext context;\n\n\tWebTestClient rest;\n\n\t@BeforeEach\n\tpublic void setup() {\n this.rest = WebTestClient\n .bindToApplicationContext(this.context)\n // add Spring Security test Support\n .apply(springSecurity())\n .configureClient()\n .filter(basicAuthentication(\"user\", \"password\"))\n .build();\n\t}\n\t// ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.test.web.reactive.server.SecurityMockServerConfigurers.springSecurity\nimport org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication\n\n@ExtendWith(SpringExtension::class)\n@ContextConfiguration(classes = [HelloWebfluxMethodApplication::class])\nclass HelloWebfluxMethodApplicationTests {\n @Autowired\n lateinit var context: ApplicationContext\n\n lateinit var rest: WebTestClient\n\n @BeforeEach\n fun setup() {\n this.rest = WebTestClient\n .bindToApplicationContext(this.context)\n // add Spring Security test Support\n .apply(springSecurity())\n .configureClient()\n .filter(basicAuthentication(\"user\", \"password\"))\n .build()\n }\n // ...\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/setup.adoc", "title": "WebTestClient Security Setup", "heading": "WebTestClient Security Setup", "heading_level": 1, "file_order": 59, "section_index": 0, "content_hash": "d9daba725152f182f164261215235abd1bf8e38be4bf96c838514d2054f8e5e0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/setup.adoc"}}
{"id": "sha256:50cff4df733bb32f463263ee1c8b147693602d2d89eca061811b4ee03d21ecea", "content": "Spring Framework provides first class support for testing X509 with `WebTestClient`.\nFor details refer to javadoc:{spring-framework-api-url}org.springframework.test.web.reactive.server.UserWebTestClientConfigurer[].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/web/x509.adoc", "title": "X509", "heading": "X509", "heading_level": 1, "file_order": 60, "section_index": 0, "content_hash": "50cff4df733bb32f463263ee1c8b147693602d2d89eca061811b4ee03d21ecea", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/web/x509.adoc"}}
{"id": "sha256:ca82abe9b083fdbb385fa77a908557c4ffae70e70e5fde2ecb11d91e71053dad", "content": "[[test-webflux]]\n\nSpring Security supports two basic modes for testing reactive applications.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 61, "section_index": 0, "content_hash": "ca82abe9b083fdbb385fa77a908557c4ffae70e70e5fde2ecb11d91e71053dad", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/index.adoc"}}
{"id": "sha256:3c552e42159005943f42b65fc8eafafa05d4a7cdd24a787dcf0daec4c0f2e78e", "content": "[[test-erms]]\n\nFor example, we can test our example from xref:reactive/authorization/method.adoc#jc-erms[EnableReactiveMethodSecurity] by using the same setup and annotations that we used in xref:servlet/test/method.adoc#test-method[Testing Method Security].\nThe following minimal sample shows what we can do:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = HelloWebfluxMethodApplication.class)\npublic class HelloWorldMessageServiceTests {\n\t@Autowired\n\tHelloWorldMessageService messages;\n\n\t@Test\n\tpublic void messagesWhenNotAuthenticatedThenDenied() {\n StepVerifier.create(this.messages.findMessage())\n .expectError(AccessDeniedException.class)\n .verify();\n\t}\n\n\t@Test\n\t@WithMockUser\n\tpublic void messagesWhenUserThenDenied() {\n StepVerifier.create(this.messages.findMessage())\n .expectError(AccessDeniedException.class)\n .verify();\n\t}\n\n\t@Test\n\t@WithMockUser(roles = \"ADMIN\")\n\tpublic void messagesWhenAdminThenOk() {\n StepVerifier.create(this.messages.findMessage())\n .expectNext(\"Hello World!\")\n .verifyComplete();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = [HelloWebfluxMethodApplication::class])\nclass HelloWorldMessageServiceTests {\n @Autowired\n lateinit var messages: HelloWorldMessageService\n\n @Test\n fun messagesWhenNotAuthenticatedThenDenied() {\n StepVerifier.create(messages.findMessage())\n .expectError(AccessDeniedException::class.java)\n .verify()\n }\n\n @Test\n @WithMockUser\n fun messagesWhenUserThenDenied() {\n StepVerifier.create(messages.findMessage())\n .expectError(AccessDeniedException::class.java)\n .verify()\n }\n\n @Test\n @WithMockUser(roles = [\"ADMIN\"])\n fun messagesWhenAdminThenOk() {\n StepVerifier.create(messages.findMessage())\n .expectNext(\"Hello World!\")\n .verifyComplete()\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/test/method.adoc", "title": "method", "heading": "method", "heading_level": 1, "file_order": 62, "section_index": 0, "content_hash": "3c552e42159005943f42b65fc8eafafa05d4a7cdd24a787dcf0daec4c0f2e78e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/test/method.adoc"}}
{"id": "sha256:135b6252e010579805206edcccb8fd890f8dfef4608ecb29ba25d1e4f5085857", "content": "[[getting-started]]\n\nThis section covers the minimum setup for how to use Spring Security with Spring Boot in a reactive application.\n\n[NOTE]\n====\nThe completed application can be found {gh-samples-url}/reactive/webflux/java/hello-security[in our samples repository].\nFor your convenience, you can download a minimal Reactive Spring Boot + Spring Security application by https://start.spring.io/starter.zip?type=maven-project&language=java&packaging=jar&jvmVersion=1.8&groupId=example&artifactId=hello-security&name=hello-security&description=Hello%20Security&packageName=example.hello-security&dependencies=webflux,security[clicking here].\n====\n\n[[dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/getting-started.adoc", "title": "getting-started", "heading": "getting-started", "heading_level": 1, "file_order": 63, "section_index": 0, "content_hash": "135b6252e010579805206edcccb8fd890f8dfef4608ecb29ba25d1e4f5085857", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/getting-started.adoc"}}
{"id": "sha256:d8c722dbf159610e0f151ac64e2f18df2024dc7241c782da8ea75aeaaa2924c3", "content": "You can add Spring Security to your Spring Boot project by adding `spring-boot-starter-security`.\n\n[tabs]\n======\nMaven::\n+\n[source,xml,role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,role=\"secondary\"]\n----\n implementation 'org.springframework.boot:spring-boot-starter-security'\n----\n======\n\n[[servlet-hello-starting]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/getting-started.adoc", "title": "getting-started", "heading": "Updating Dependencies", "heading_level": 2, "file_order": 63, "section_index": 1, "content_hash": "d8c722dbf159610e0f151ac64e2f18df2024dc7241c782da8ea75aeaaa2924c3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/getting-started.adoc"}}
{"id": "sha256:afe8c2861a1180e7518199a9e1873e58c70a60cb8c39a1cef66ab2a9c431a8ca", "content": "You can now https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-running-with-the-maven-plugin[run the Spring Boot application] by using the Maven Plugin's `run` goal.\nThe following example shows how to do so (and the beginning of the output from doing so):\n\n.Running Spring Boot Application\n[tabs]\n======\nMaven::\n+\n[source,bash,role=\"primary\"]\n----\n$ ./mvnw spring-boot:run\n...\nINFO 23689 --- [ restartedMain] .s.s.UserDetailsServiceAutoConfiguration :\n\nUsing generated security password: 8e557245-73e2-4286-969a-ff57fe326336\n\n...\n----\n\nGradle::\n+\n[source,bash,role=\"secondary\"]\n----\n$ ./gradlew bootRun\n...\nINFO 23689 --- [ restartedMain] .s.s.UserDetailsServiceAutoConfiguration :\n\nUsing generated security password: 8e557245-73e2-4286-969a-ff57fe326336\n\n...\n----\n======\n\n[[authenticating]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/getting-started.adoc", "title": "getting-started", "heading": "Starting Hello Spring Security Boot", "heading_level": 2, "file_order": 63, "section_index": 2, "content_hash": "afe8c2861a1180e7518199a9e1873e58c70a60cb8c39a1cef66ab2a9c431a8ca", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/getting-started.adoc"}}
{"id": "sha256:b564835d35eb314c0921f7b92fdd2b1b31e0f2282fea0be2f0bfa33567445899", "content": "You can access the application at http://localhost:8080/ which will redirect the browser to the default log in page. You can provide the default username of `user` with the randomly generated password that is logged to the console. The browser is then taken to the originally requested page.\n\nTo log out you can visit http://localhost:8080/logout and then confirming you wish to log out.\n\n[[auto-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/getting-started.adoc", "title": "getting-started", "heading": "Authenticating", "heading_level": 2, "file_order": 63, "section_index": 3, "content_hash": "b564835d35eb314c0921f7b92fdd2b1b31e0f2282fea0be2f0bfa33567445899", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/getting-started.adoc"}}
{"id": "sha256:6f3bf5e9ffdfa343f379dc7763f6b075e4ca2d904707bdff348ff4126558dc57", "content": "Spring Boot automatically adds Spring Security which requires all requests be authenticated. It also generates a user with a randomly generated password that is logged to the console which can be used to authenticate using form or basic authentication.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/getting-started.adoc", "title": "getting-started", "heading": "Spring Boot Auto Configuration", "heading_level": 2, "file_order": 63, "section_index": 4, "content_hash": "6f3bf5e9ffdfa343f379dc7763f6b075e4ca2d904707bdff348ff4126558dc57", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/getting-started.adoc"}}
{"id": "sha256:78997fbbec9f296738c3ea790b1fc592077b0cef52387a5bbc5cf8ebb1d7df9d", "content": "Reactive applications work very differently than xref:servlet/index.adoc#servlet-applications[Servlet Applications].\nThis section discusses how Spring Security works with reactive applications which are typically written using Spring's WebFlux.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/reactive/index.adoc", "title": "Reactive Applications", "heading": "Reactive Applications", "heading_level": 1, "file_order": 64, "section_index": 0, "content_hash": "78997fbbec9f296738c3ea790b1fc592077b0cef52387a5bbc5cf8ebb1d7df9d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/reactive/index.adoc"}}
{"id": "sha256:4cde07d66f6f005a93c0cadfe2cd166d2b127fc66b8127eb66e607d6cb42a7b5", "content": "[[nsa-authentication]]\nBefore Spring Security 3.0, an `AuthenticationManager` was automatically registered internally.\nNow you must register one explicitly using the `<authentication-manager>` element.\nThis creates an instance of Spring Security's `ProviderManager` class, which needs to be configured with a list of one or more `AuthenticationProvider` instances.\nThese can either be created using syntax elements provided by the namespace, or they can be standard bean definitions, marked for addition to the list using the `authentication-provider` element.\n\n[[nsa-authentication-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "authentication-manager", "heading_level": 1, "file_order": 65, "section_index": 0, "content_hash": "4cde07d66f6f005a93c0cadfe2cd166d2b127fc66b8127eb66e607d6cb42a7b5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:637f5e87b2a06163ee7383b354e74c0230ed31b242c49d97460232604cc37e8e", "content": "Every Spring Security application which uses the namespace must have include this element somewhere.\nIt is responsible for registering the `AuthenticationManager` which provides authentication services to the application.\nAll elements which create `AuthenticationProvider` instances should be children of this element.\n\n[[nsa-authentication-manager-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<authentication-manager>", "heading_level": 2, "file_order": 65, "section_index": 1, "content_hash": "637f5e87b2a06163ee7383b354e74c0230ed31b242c49d97460232604cc37e8e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:9bda67a39ed2878f34b412e0322cd02041daa187ffc351420b3c86c8808e3ce6", "content": "[[nsa-authentication-manager-alias]]\n* **alias**\nThis attribute allows you to define an alias name for the internal instance for use in your own configuration.\n\n[[nsa-authentication-manager-erase-credentials]]\n* **erase-credentials**\nIf set to true, the AuthenticationManager will attempt to clear any credentials data in the returned Authentication object, once the user has been authenticated.\nLiterally it maps to the `eraseCredentialsAfterAuthentication` property of the xref:servlet/authentication/architecture.adoc#servlet-authentication-providermanager[`ProviderManager`].\n\n[[nsa-authentication-manager-observation-registry-ref]]\n* **observation-registry-ref**\nA reference to the `ObservationRegistry` used for the `FilterChain` and related components\n\n[[nsa-authentication-manager-id]]\n* **id**\nThis attribute allows you to define an id for the internal instance for use in your own configuration.\nIt is the same as the alias element, but provides a more consistent experience with elements that use the id attribute.\n\n[[nsa-authentication-manager-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<authentication-manager> Attributes", "heading_level": 3, "file_order": 65, "section_index": 2, "content_hash": "9bda67a39ed2878f34b412e0322cd02041daa187ffc351420b3c86c8808e3ce6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:862a37acef292c45a239a1848b09b2d0241c2c60f886352f965c0c47fb82415f", "content": "* <<nsa-authentication-provider,authentication-provider>>\n* xref:servlet/appendix/namespace/ldap.adoc#nsa-ldap-authentication-provider[ldap-authentication-provider]\n\n[[nsa-authentication-provider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "Child Elements of <authentication-manager>", "heading_level": 3, "file_order": 65, "section_index": 3, "content_hash": "862a37acef292c45a239a1848b09b2d0241c2c60f886352f965c0c47fb82415f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:b05abb4423edc90a52c232acb7379ec406db6284c808cba587ce3d755dadce50", "content": "Unless used with a `ref` attribute, this element is shorthand for configuring a `DaoAuthenticationProvider`.\n`DaoAuthenticationProvider` loads user information from a `UserDetailsService` and compares the username/password combination with the values supplied at login.\nThe `UserDetailsService` instance can be defined either by using an available namespace element (`jdbc-user-service` or by using the `user-service-ref` attribute to point to a bean defined elsewhere in the application context).\n\n[[nsa-authentication-provider-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<authentication-provider>", "heading_level": 2, "file_order": 65, "section_index": 4, "content_hash": "b05abb4423edc90a52c232acb7379ec406db6284c808cba587ce3d755dadce50", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:45a91e73f7bf18e1b180db95f8533e6ff52eccbc5d7d7b412ba53900cd736fac", "content": "* <<nsa-authentication-manager,authentication-manager>>\n\n[[nsa-authentication-provider-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "Parent Elements of <authentication-provider>", "heading_level": 3, "file_order": 65, "section_index": 5, "content_hash": "45a91e73f7bf18e1b180db95f8533e6ff52eccbc5d7d7b412ba53900cd736fac", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:46c53be412cc4d036b2a930a3a903d2e687c8760ee6bfc2f81bbcb96f8f07920", "content": "[[nsa-authentication-provider-ref]]\n* **ref**\nDefines a reference to a Spring bean that implements `AuthenticationProvider`.\n\nIf you have written your own `AuthenticationProvider` implementation (or want to configure one of Spring Security's own implementations as a traditional bean for some reason, then you can use the following syntax to add it to the internal list of `ProviderManager`:\n\n[source,xml]\n----\n\n<security:authentication-manager>\n <security:authentication-provider ref=\"myAuthenticationProvider\" />\n</security:authentication-manager>\n<bean id=\"myAuthenticationProvider\" class=\"com.something.MyAuthenticationProvider\"/>\n\n----\n\n[[nsa-authentication-provider-user-service-ref]]\n* **user-service-ref**\nA reference to a bean that implements UserDetailsService that may be created using the standard bean element or the custom user-service element.\n\n[[nsa-authentication-provider-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<authentication-provider> Attributes", "heading_level": 3, "file_order": 65, "section_index": 6, "content_hash": "46c53be412cc4d036b2a930a3a903d2e687c8760ee6bfc2f81bbcb96f8f07920", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:f74ec9f4a97cb0107c65fb02be8b29b608e1e626d150f027e65d11b6eb55f29a", "content": "* <<nsa-jdbc-user-service,jdbc-user-service>>\n* xref:servlet/appendix/namespace/ldap.adoc#nsa-ldap-user-service[ldap-user-service]\n* <<nsa-password-encoder,password-encoder>>\n* <<nsa-user-service,user-service>>\n\n[[nsa-jdbc-user-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "Child Elements of <authentication-provider>", "heading_level": 3, "file_order": 65, "section_index": 7, "content_hash": "f74ec9f4a97cb0107c65fb02be8b29b608e1e626d150f027e65d11b6eb55f29a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:709bcc37ad5d59964a3c9cbd324987e8b409256d7d5e05f47e7f607171a29fa5", "content": "Causes creation of a JDBC-based UserDetailsService.\n\n[[nsa-jdbc-user-service-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<jdbc-user-service>", "heading_level": 2, "file_order": 65, "section_index": 8, "content_hash": "709bcc37ad5d59964a3c9cbd324987e8b409256d7d5e05f47e7f607171a29fa5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:7bb8b94d86f78c16baea4df226057226d4e01e7d3e848c32254daf3d84008230", "content": "[[nsa-jdbc-user-service-authorities-by-username-query]]\n* **authorities-by-username-query**\nAn SQL statement to query for a user's granted authorities given a username.\n\nThe default is\n\n[source]\n----\nselect username, authority from authorities where username = ?\n----\n\n[[nsa-jdbc-user-service-cache-ref]]\n* **cache-ref**\nDefines a reference to a cache for use with a UserDetailsService.\n\n[[nsa-jdbc-user-service-data-source-ref]]\n* **data-source-ref**\nThe bean ID of the DataSource which provides the required tables.\n\n[[nsa-jdbc-user-service-group-authorities-by-username-query]]\n* **group-authorities-by-username-query**\nAn SQL statement to query user's group authorities given a username.\nThe default is\n\n+\n\n[source]\n----\nselect\ng.id, g.group_name, ga.authority\nfrom\ngroups g, group_members gm, group_authorities ga\nwhere\ngm.username = ? and g.id = ga.group_id and g.id = gm.group_id\n----\n\n[[nsa-jdbc-user-service-id]]\n* **id**\nA bean identifier, used for referring to the bean elsewhere in the context.\n\n[[nsa-jdbc-user-service-role-prefix]]\n* **role-prefix**\nA non-empty string prefix that will be added to role strings loaded from persistent storage (default is \"ROLE_\").\nUse the value \"none\" for no prefix in cases where the default is non-empty.\n\n[[nsa-jdbc-user-service-users-by-username-query]]\n* **users-by-username-query**\nAn SQL statement to query a username, password, and enabled status given a username.\nThe default is\n\n+\n\n[source]\n----\nselect username, password, enabled from users where username = ?\n----\n\n[[nsa-password-encoder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<jdbc-user-service> Attributes", "heading_level": 3, "file_order": 65, "section_index": 9, "content_hash": "7bb8b94d86f78c16baea4df226057226d4e01e7d3e848c32254daf3d84008230", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:ac84ef931c128c11841c1c9a5cbbfbf865c26c7effaf71673e34c43d49d2c74c", "content": "Authentication providers can optionally be configured to use a password encoder as described in the xref:features/authentication/password-storage.adoc#authentication-password-storage[Password Storage].\nThis will result in the bean being injected with the appropriate `PasswordEncoder` instance.\n\n[[nsa-password-encoder-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<password-encoder>", "heading_level": 2, "file_order": 65, "section_index": 10, "content_hash": "ac84ef931c128c11841c1c9a5cbbfbf865c26c7effaf71673e34c43d49d2c74c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:2af9e609b5bb5d7bd673f42c972f0663c02d3c2afd3c3c59982bd780f1197e1d", "content": "* <<nsa-authentication-provider,authentication-provider>>\n* xref:servlet/appendix/namespace/authentication-manager.adoc#nsa-password-compare[password-compare]\n\n[[nsa-password-encoder-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "Parent Elements of <password-encoder>", "heading_level": 3, "file_order": 65, "section_index": 11, "content_hash": "2af9e609b5bb5d7bd673f42c972f0663c02d3c2afd3c3c59982bd780f1197e1d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:3a2af968adea1ba7e326ed9e353d3ff163d5d29ef1c583043e1038a8beb2b932", "content": "[[nsa-password-encoder-hash]]\n* **hash**\nDefines the hashing algorithm used on user passwords.\nWe recommend strongly against using MD4, as it is a very weak hashing algorithm.\n\n[[nsa-password-encoder-ref]]\n* **ref**\nDefines a reference to a Spring bean that implements `PasswordEncoder`.\n\n[[nsa-user-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<password-encoder> Attributes", "heading_level": 3, "file_order": 65, "section_index": 12, "content_hash": "3a2af968adea1ba7e326ed9e353d3ff163d5d29ef1c583043e1038a8beb2b932", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:456b6f5036088beece11e11598a6175e29815800bf81df6719767a676fff9226", "content": "Creates an in-memory UserDetailsService from a properties file or a list of \"user\" child elements.\nUsernames are converted to lower-case internally to allow for case-insensitive lookups, so this should not be used if case-sensitivity is required.\n\n[[nsa-user-service-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<user-service>", "heading_level": 2, "file_order": 65, "section_index": 13, "content_hash": "456b6f5036088beece11e11598a6175e29815800bf81df6719767a676fff9226", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:600056383d174c9f70394a91a2072e7be7173fdfe264f10d34aaaa4c92849d87", "content": "[[nsa-user-service-id]]\n* **id**\nA bean identifier, used for referring to the bean elsewhere in the context.\n\n[[nsa-user-service-properties]]\n* **properties**\nThe location of a Properties file where each line is in the format of\n\n+\n\n[source]\n----\nusername=password,grantedAuthority[,grantedAuthority][,enabled|disabled]\n----\n\n[[nsa-user-service-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<user-service> Attributes", "heading_level": 3, "file_order": 65, "section_index": 14, "content_hash": "600056383d174c9f70394a91a2072e7be7173fdfe264f10d34aaaa4c92849d87", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:dd442f1c4e8d5ebf52d1bdf694117710c989643b34f9f30ee787f37da47ed7ee", "content": "* <<nsa-user,user>>\n\n[[nsa-user]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "Child Elements of <user-service>", "heading_level": 3, "file_order": 65, "section_index": 15, "content_hash": "dd442f1c4e8d5ebf52d1bdf694117710c989643b34f9f30ee787f37da47ed7ee", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:8c5c39b9a4f5acdc70b408ec0f933fd1cd609a886ddaa63d89341413106da811", "content": "Represents a user in the application.\n\n[[nsa-user-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<user>", "heading_level": 2, "file_order": 65, "section_index": 16, "content_hash": "8c5c39b9a4f5acdc70b408ec0f933fd1cd609a886ddaa63d89341413106da811", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:df1704a2eb8a2746f94fa153c6b0931b894b67c99868545daf6493c00723df82", "content": "* <<nsa-user-service,user-service>>\n\n[[nsa-user-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "Parent Elements of <user>", "heading_level": 3, "file_order": 65, "section_index": 17, "content_hash": "df1704a2eb8a2746f94fa153c6b0931b894b67c99868545daf6493c00723df82", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:f2ca6e33848bfd97a28e510587a86f2d9391bbfb20e76e730529093f53841295", "content": "[[nsa-user-authorities]]\n* **authorities**\nOne of more authorities granted to the user.\nSeparate authorities with a comma (but no space).\nFor example, \"ROLE_USER,ROLE_ADMINISTRATOR\"\n\n[[nsa-user-disabled]]\n* **disabled**\nCan be set to \"true\" to mark an account as disabled and unusable.\n\n[[nsa-user-locked]]\n* **locked**\nCan be set to \"true\" to mark an account as locked and unusable.\n\n[[nsa-user-name]]\n* **name**\nThe username assigned to the user.\n\n[[nsa-user-password]]\n* **password**\nThe password assigned to the user.\nThis may be hashed if the corresponding authentication provider supports hashing (remember to set the \"hash\" attribute of the \"user-service\" element).\nThis attribute be omitted in the case where the data will not be used for authentication, but only for accessing authorities.\nIf omitted, the namespace will generate a random value, preventing its accidental use for authentication.\nCannot be empty.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc", "title": "authentication-manager", "heading": "<user> Attributes", "heading_level": 3, "file_order": 65, "section_index": 18, "content_hash": "f2ca6e33848bfd97a28e510587a86f2d9391bbfb20e76e730529093f53841295", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/authentication-manager.adoc"}}
{"id": "sha256:639fbf14d1fde80ecf1e0ebbe3e24c5356a7650c475a02542051382dc3c6d2d8", "content": "[[nsa-web]]\n\n[[nsa-debug]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "http", "heading_level": 1, "file_order": 66, "section_index": 0, "content_hash": "639fbf14d1fde80ecf1e0ebbe3e24c5356a7650c475a02542051382dc3c6d2d8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:17f33b46fc68e6be4b9b472b992082545a40461861286194217d686ea1fb2486", "content": "Enables Spring Security debugging infrastructure.\nThis will provide human-readable (multi-line) debugging information to monitor requests coming into the security filters.\nThis may include sensitive information, such as request parameters or headers, and should only be used in a development environment.\n\n[[nsa-http]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<debug>", "heading_level": 2, "file_order": 66, "section_index": 1, "content_hash": "17f33b46fc68e6be4b9b472b992082545a40461861286194217d686ea1fb2486", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:c7b6563ff49868679cfacdde0c1a3091c030438a9a219fc64d1b2e8f9ada5b9a", "content": "If you use an `<http>` element within your application, a `FilterChainProxy` bean named \"springSecurityFilterChain\" is created and the configuration within the element is used to build a filter chain within\n`FilterChainProxy`.\nAs of Spring Security 3.1, additional `http` elements can be used to add extra filter chains footnote:[See the pass:specialcharacters,macros[xref:servlet/configuration/xml-namespace.adoc#ns-web-xml[introductory chapter]] for how to set up the mapping from your `web.xml` ].\nSome core filters are always created in a filter chain and others will be added to the stack depending on the attributes and child elements which are present.\nThe positions of the standard filters are fixed (see\nxref:servlet/configuration/xml-namespace.adoc#filter-stack[the filter order table] in the namespace introduction), removing a common source of errors with previous versions of the framework when users had to configure the filter chain explicitly in the\n`FilterChainProxy` bean.\nYou can, of course, still do this if you need full control of the configuration.\n\nAll filters which require a reference to the xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationmanager[`AuthenticationManager`] will be automatically injected with the internal instance created by the namespace configuration.\n\nEach `<http>` namespace block always creates an `SecurityContextPersistenceFilter`, an `ExceptionTranslationFilter` and a `FilterSecurityInterceptor`.\nThese are fixed and cannot be replaced with alternatives.\n\n[[nsa-http-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<http>", "heading_level": 2, "file_order": 66, "section_index": 2, "content_hash": "c7b6563ff49868679cfacdde0c1a3091c030438a9a219fc64d1b2e8f9ada5b9a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:e7395a0f7b6727927301bf5bb9661e83fce3032904822381177a657fc9f14f8d", "content": "The attributes on the `<http>` element control some of the properties on the core filters.\n\n[[nsa-http-use-authorization-manager]]\n* **use-authorization-manager**\nUse AuthorizationManager API instead of SecurityMetadataSource (defaults to true)\n\n[[nsa-http-authorization-manager-ref]]\n* **authorization-manager-ref**\nUse this AuthorizationManager instead of deriving one from <intercept-url> elements\n\n[[nsa-http-access-decision-manager-ref]]\n* **access-decision-manager-ref**\nOptional attribute specifying the ID of the `AccessDecisionManager` implementation which should be used for authorizing HTTP requests.\nBy default an `AffirmativeBased` implementation is used for with a `RoleVoter` and an `AuthenticatedVoter`.\n\n[[nsa-http-authentication-manager-ref]]\n* **authentication-manager-ref**\nA reference to the `AuthenticationManager` used for the `FilterChain` created by this http element.\n\n[[nsa-http-observation-registry-ref]]\n* **observation-registry-ref**\nA reference to the `ObservationRegistry` used for the `FilterChain` and related components\n\n[[nsa-http-auto-config]]\n* **auto-config**\nAutomatically registers a login form, BASIC authentication, logout services.\nIf set to \"true\", all of these capabilities are added (although you can still customize the configuration of each by providing the respective element).\nIf unspecified, defaults to \"false\".\nUse of this attribute is not recommended.\nUse explicit configuration elements instead to avoid confusion.\n\n[[nsa-http-create-session]]\n* **create-session**\nControls the eagerness with which an HTTP session is created by Spring Security classes.\nOptions include:\n\n** `always` - Spring Security will proactively create a session if one does not exist.\n** `ifRequired` - Spring Security will only create a session only if one is required (default value).\n** `never` - Spring Security will never create a session, but will make use of one if the application does.\n** `stateless` - Spring Security will not create a session and ignore the session for obtaining a Spring `Authentication`.\n\n[[nsa-http-disable-url-rewriting]]\n* **disable-url-rewriting**\nPrevents session IDs from being appended to URLs in the application.\nClients must use cookies if this attribute is set to `true`.\nThe default is `true`.\n\n[[nsa-http-entry-point-ref]]\n* **entry-point-ref**\nNormally the `AuthenticationEntryPoint` used will be set depending on which authentication mechanisms have been configured.\nThis attribute allows this behaviour to be overridden by defining a customized `AuthenticationEntryPoint` bean which will start the authentication process.\n\n[[nsa-http-jaas-api-provision]]\n* **jaas-api-provision**\nIf available, runs the request as the `Subject` acquired from the `JaasAuthenticationToken` which is implemented by adding a `JaasApiIntegrationFilter` bean to the stack.\nDefaults to `false`.\n\n[[nsa-http-name]]\n* **name**\nA bean identifier, used for referring to the bean elsewhere in the context.\n\n[[nsa-http-once-per-request]]\n* **once-per-request**\nCorresponds to the `observeOncePerRequest` property of `FilterSecurityInterceptor`.\nDefaults to `false`.\n\n[[nsa-http-filter-all-dispatcher-types]]\n* **filter-all-dispatcher-types**\nCorresponds to the `shouldFilterAllDispatcherTypes` property of the `AuthorizationFilter`. Does not work when `use-authorization-manager=false`.\nDefaults to `true`.\n\n[[nsa-http-pattern]]\n* **pattern**\nDefining a pattern for the <<nsa-http,http>> element controls the requests which will be filtered through the list of filters which it defines.\nThe interpretation is dependent on the configured <<nsa-http-request-matcher,request-matcher>>.\nIf no pattern is defined, all requests will be matched, so the most specific patterns should be declared first.\n\n[[nsa-http-realm]]\n* **realm**\nSets the realm name used for basic authentication (if enabled).\nCorresponds to the `realmName` property on `BasicAuthenticationEntryPoint`.\n\n[[nsa-http-redirect-to-https-request-matcher-ref]]\n* **redirect-to-https-request-matcher-ref**\nA reference to a bean that implements `RequestMatcher` that will determine which requests must redirect to HTTPS.\nThis is helpful when, for example, wanting to run HTTP locally and HTTPS in production using a request header.\n\n[[nsa-http-request-matcher]]\n* **request-matcher**\nDefines the `RequestMatcher` strategy used in the `FilterChainProxy` and the beans created by the `intercept-url` to match incoming requests.\nOptions are currently `mvc`, `ant`, `regex` and `ciRegex`, for Spring MVC, ant, regular-expression and case-insensitive regular-expression respectively.\nA separate instance is created for each <<nsa-intercept-url,intercept-url>> element using its <<nsa-intercept-url-pattern,pattern>>, <<nsa-intercept-url-method,method>> and <<nsa-intercept-url-servlet-path,servlet-path>> attributes.\nBy default, paths are matched using a `PathPatternRequestMatcher`; however, regular expressions are matched using a `RegexRequestMatcher`.\nSee the Javadoc for these classes for more details on exactly how the matching is performed.\nMVC is the default strategy if Spring MVC is present in the classpath, if not, Ant paths are used.\n\n[[nsa-http-request-matcher-ref]]\n* **request-matcher-ref**\nA reference to a bean that implements `RequestMatcher` that will determine if this `FilterChain` should be used.\nThis is a more powerful alternative to <<nsa-http-pattern,pattern>>.\n\n[[nsa-http-security]]\n* **security**\nA request pattern can be mapped to an empty filter chain, by setting this attribute to `none`.\nNo security will be applied and none of Spring Security's features will be available.\n\n[[nsa-http-security-context-holder-strategy-ref]]\n* **security-context-repository-ref**\nAllows injection of a custom `SecurityContextHolderStrategy` into `SecurityContextPersistenceFilter`, `SecurityContextHolderFilter`, `BasicAuthenticationFilter`, `UsernamePasswordAuthenticationFilter`, `ExceptionTranslationFilter`, `LogoutFilter`, and others.\n\n[[nsa-http-security-context-explicit-save]]\n* **security-context-explicit-save**\nIf true, use `SecurityContextHolderFilter` instead of `SecurityContextPersistenceFilter`.\nRequires explicit save\n\n[[nsa-http-security-context-repository-ref]]\n* **security-context-repository-ref**\nAllows injection of a custom `SecurityContextRepository` into the `SecurityContextPersistenceFilter`.\n\n[[nsa-http-servlet-api-provision]]\n* **servlet-api-provision**\nProvides versions of `HttpServletRequest` security methods such as `isUserInRole()` and `getPrincipal()` which are implemented by adding a `SecurityContextHolderAwareRequestFilter` bean to the stack.\nDefaults to `true`.\n\n[[nsa-http-use-expressions]]\n* **use-expressions**\nEnables EL-expressions in the `access` attribute, as described in the chapter on xref:servlet/authorization/authorize-http-requests.adoc#authorization-expressions[expression-based access-control].\nThe default value is true.\n\n[[nsa-http-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<http> Attributes", "heading_level": 3, "file_order": 66, "section_index": 3, "content_hash": "e7395a0f7b6727927301bf5bb9661e83fce3032904822381177a657fc9f14f8d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:52ccc3e2cb3e394f37052ee6bfd35a17d03e4e1e7d19aca744c70ef273c8c2bc", "content": "* <<nsa-access-denied-handler,access-denied-handler>>\n* <<nsa-anonymous,anonymous>>\n* <<nsa-cors,cors>>\n* <<nsa-csrf,csrf>>\n* <<nsa-custom-filter,custom-filter>>\n* <<nsa-expression-handler,expression-handler>>\n* <<nsa-form-login,form-login>>\n* <<nsa-headers,headers>>\n* <<nsa-http-basic,http-basic>>\n* <<nsa-intercept-url,intercept-url>>\n* <<nsa-jee,jee>>\n* <<nsa-logout,logout>>\n* <<nsa-oauth2-client,oauth2-client>>\n* <<nsa-oauth2-login,oauth2-login>>\n* <<nsa-oauth2-resource-server,oauth2-resource-server>>\n* <<nsa-password-management,password-management>>\n* <<nsa-port-mappings,port-mappings>>\n* <<nsa-remember-me,remember-me>>\n* <<nsa-request-cache,request-cache>>\n* <<nsa-saml2-login,saml2-login>>\n* <<nsa-saml2-logout,saml2-logout>>\n* <<nsa-session-management,session-management>>\n* <<nsa-x509,x509>>\n\n[[nsa-access-denied-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <http>", "heading_level": 3, "file_order": 66, "section_index": 4, "content_hash": "52ccc3e2cb3e394f37052ee6bfd35a17d03e4e1e7d19aca744c70ef273c8c2bc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:ace86b7c1fb9a8651f5589e42199530d03ebfd3794475f730baa12deb9452ae1", "content": "This element allows you to set the `errorPage` property for the default `AccessDeniedHandler` used by the `ExceptionTranslationFilter`, using the <<nsa-access-denied-handler-error-page,error-page>> attribute, or to supply your own implementation using the <<nsa-access-denied-handler-ref,ref>> attribute.\nThis is discussed in more detail in the section on the xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[ExceptionTranslationFilter].\n\n[[nsa-access-denied-handler-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<access-denied-handler>", "heading_level": 2, "file_order": 66, "section_index": 5, "content_hash": "ace86b7c1fb9a8651f5589e42199530d03ebfd3794475f730baa12deb9452ae1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:3789436db475b4f94b4484a6e5081499b08bc2ddafb2106aeee3d235548c35d5", "content": "* <<nsa-http,http>>\n\n[[nsa-access-denied-handler-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <access-denied-handler>", "heading_level": 3, "file_order": 66, "section_index": 6, "content_hash": "3789436db475b4f94b4484a6e5081499b08bc2ddafb2106aeee3d235548c35d5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:0b21dd44ac3823c3eb6ff0b91e6ec722448b7b06168de7e7f1830131c9b89270", "content": "[[nsa-access-denied-handler-error-page]]\n* **error-page**\nThe access denied page that an authenticated user will be redirected to if they request a page which they don't have the authority to access.\n\n[[nsa-access-denied-handler-ref]]\n* **ref**\nDefines a reference to a Spring bean of type `AccessDeniedHandler`.\n\n[[nsa-cors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<access-denied-handler> Attributes", "heading_level": 3, "file_order": 66, "section_index": 7, "content_hash": "0b21dd44ac3823c3eb6ff0b91e6ec722448b7b06168de7e7f1830131c9b89270", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:72b2207eb54ba44aac67bc36a8564fd75a298b7763e3ace660ef729e84b3c0f1", "content": "This element allows for configuring a `CorsFilter`.\nEither a `CorsFilter` or a `CorsConfigurationSource` must be specified.\nIf Spring MVC is present, then it will attempt to look up its `CorsConfigurationSource`.\n\n[[nsa-cors-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<cors>", "heading_level": 2, "file_order": 66, "section_index": 8, "content_hash": "72b2207eb54ba44aac67bc36a8564fd75a298b7763e3ace660ef729e84b3c0f1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:de0d87f1cf0fcb9a108d4c1c4f51f296e5bdd8f1f563cebc3049659851913570", "content": "The attributes on the `<cors>` element control the headers element.\n\n[[nsa-cors-ref]]\n* **ref**\nOptional attribute that specifies the bean name of a `CorsFilter`.\n\n[[nsa-cors-configuration-source-ref]]\n* **cors-configuration-source-ref**\nOptional attribute that specifies the bean name of a `CorsConfigurationSource` to be injected into a `CorsFilter` created by the XML namespace.\n\n[[nsa-cors-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<cors> Attributes", "heading_level": 3, "file_order": 66, "section_index": 9, "content_hash": "de0d87f1cf0fcb9a108d4c1c4f51f296e5bdd8f1f563cebc3049659851913570", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:eb6a61888516bf70093999b98940025e90b922fd0af5b8367b5ccf835b0d49b6", "content": "* <<nsa-http,http>>\n\n[[nsa-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <cors>", "heading_level": 3, "file_order": 66, "section_index": 10, "content_hash": "eb6a61888516bf70093999b98940025e90b922fd0af5b8367b5ccf835b0d49b6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5e7342d3a63f1c72faae2f0780cb75e646fba4389231b8f634305e2704904362", "content": "This element allows for configuring additional (security) headers to be sent with the response.\nIt enables easy configuration for several headers and also allows for setting custom headers through the <<nsa-header,header>> element.\nAdditional information, can be found in the xref:features/exploits/headers.adoc#headers[Security Headers] section of the reference.\n\n** `Cache-Control`, `Pragma`, and `Expires` - Can be set using the <<nsa-cache-control,cache-control>> element.\nThis ensures that the browser does not cache your secured pages.\n** `Strict-Transport-Security` - Can be set using the <<nsa-hsts,hsts>> element.\nThis ensures that the browser automatically requests HTTPS for future requests.\n** `X-Frame-Options` - Can be set using the <<nsa-frame-options,frame-options>> element.\nThe https://en.wikipedia.org/wiki/Clickjacking#X-Frame-Options[X-Frame-Options] header can be used to prevent clickjacking attacks.\n** `X-XSS-Protection` - Can be set using the <<nsa-xss-protection,xss-protection>> element.\nThe https://en.wikipedia.org/wiki/Cross-site_scripting[X-XSS-Protection ] header can be used by browser to do basic control.\n** `X-Content-Type-Options` - Can be set using the <<nsa-content-type-options,content-type-options>> element.\nThe https://blogs.msdn.com/b/ie/archive/2008/09/02/ie8-security-part-vi-beta-2-update.aspx[X-Content-Type-Options] header prevents Internet Explorer from MIME-sniffing a response away from the declared content-type.\nThis also applies to Google Chrome, when downloading extensions.\n** `Public-Key-Pinning` or `Public-Key-Pinning-Report-Only` - Can be set using the <<nsa-hpkp,hpkp>> element.\nThis allows HTTPS websites to resist impersonation by attackers using mis-issued or otherwise fraudulent certificates.\n** `Content-Security-Policy` or `Content-Security-Policy-Report-Only` - Can be set using the <<nsa-content-security-policy,content-security-policy>> element.\nhttps://www.w3.org/TR/CSP2/[Content Security Policy (CSP)] is a mechanism that web applications can leverage to mitigate content injection vulnerabilities, such as cross-site scripting (XSS).\n** `Referrer-Policy` - Can be set using the <<nsa-referrer-policy,referrer-policy>> element, https://www.w3.org/TR/referrer-policy/[Referrer-Policy] is a mechanism that web applications can leverage to manage the referrer field, which contains the last page the user was on.\n** `Feature-Policy` - Can be set using the <<nsa-feature-policy,feature-policy>> element, https://wicg.github.io/feature-policy/[Feature-Policy] is a mechanism that allows web developers to selectively enable, disable, and modify the behavior of certain APIs and web features in the browser.\n** `Cross-Origin-Opener-Policy` - Can be set using the <<nsa-cross-origin-opener-policy,cross-origin-opener-policy>> element, https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy[Cross-Origin-Opener-Policy] is a mechanism that allows you to ensure a top-level document does not share a browsing context group with cross-origin documents.\n** `Cross-Origin-Embedder-Policy` - Can be set using the <<nsa-cross-origin-embedder-policy,cross-origin-embedder-policy>> element, https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy[Cross-Origin-Embedder-Policy] is a mechanism that prevents a document from loading any cross-origin resources that don't explicitly grant the document permission.\n** `Cross-Origin-Resource-Policy` - Can be set using the <<nsa-cross-origin-resource-policy,cross-origin-resource-policy>> element, https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Resource-Policy[Cross-Origin-Resource-Policy] is a mechanism that conveys a desire that the browser blocks no-cors cross-origin/cross-site requests to the given resource.\n\n[[nsa-headers-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<headers>", "heading_level": 2, "file_order": 66, "section_index": 11, "content_hash": "5e7342d3a63f1c72faae2f0780cb75e646fba4389231b8f634305e2704904362", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:7fd6c636be2853173726a7dfbcaf818ecf1499d83e07663f8519d721e030f359", "content": "The attributes on the `<headers>` element control the headers element.\n\n[[nsa-headers-defaults-disabled]]\n* **defaults-disabled**\nOptional attribute that specifies to disable the default Spring Security's HTTP response headers.\nThe default is false (the default headers are included).\n\n[[nsa-headers-disabled]]\n* **disabled**\nOptional attribute that specifies to disable Spring Security's HTTP response headers.\nThe default is false (the headers are enabled).\n\n[[nsa-headers-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<headers> Attributes", "heading_level": 3, "file_order": 66, "section_index": 12, "content_hash": "7fd6c636be2853173726a7dfbcaf818ecf1499d83e07663f8519d721e030f359", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:16b1850fad928a2d9f950bb70140cf4bdeec9db6838c293153b446d2002fde29", "content": "* <<nsa-http,http>>\n\n[[nsa-headers-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <headers>", "heading_level": 3, "file_order": 66, "section_index": 13, "content_hash": "16b1850fad928a2d9f950bb70140cf4bdeec9db6838c293153b446d2002fde29", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:e0d3f60d72e0d1b0649c7814c993198d0fbc15bcb91c5e1844f9c3901d481f69", "content": "* <<nsa-cache-control,cache-control>>\n* <<nsa-content-security-policy,content-security-policy>>\n* <<nsa-content-type-options,content-type-options>>\n* <<nsa-cross-origin-embedder-policy,cross-origin-embedder-policy>>\n* <<nsa-cross-origin-opener-policy,cross-origin-opener-policy>>\n* <<nsa-cross-origin-resource-policy,cross-origin-resource-policy>>\n* <<nsa-feature-policy,feature-policy>>\n* <<nsa-frame-options,frame-options>>\n* <<nsa-header,header>>\n* <<nsa-hpkp,hpkp>>\n* <<nsa-hsts,hsts>>\n* <<nsa-permissions-policy,permission-policy>>\n* <<nsa-referrer-policy,referrer-policy>>\n* <<nsa-xss-protection,xss-protection>>\n\n[[nsa-cache-control]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <headers>", "heading_level": 3, "file_order": 66, "section_index": 14, "content_hash": "e0d3f60d72e0d1b0649c7814c993198d0fbc15bcb91c5e1844f9c3901d481f69", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:a62c9473e14efaff848aed9eea824ae31a391385a96c41afb27d639b2353a0ae", "content": "Adds `Cache-Control`, `Pragma`, and `Expires` headers to ensure that the browser does not cache your secured pages.\n\n[[nsa-cache-control-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<cache-control>", "heading_level": 2, "file_order": 66, "section_index": 15, "content_hash": "a62c9473e14efaff848aed9eea824ae31a391385a96c41afb27d639b2353a0ae", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:7bf901edb5e68e42c9f95ba5fd09f6e7e1763544651d1600d7e42372cd1541ed", "content": "[[nsa-cache-control-disabled]]\n* **disabled**\nSpecifies if Cache Control should be disabled.\nDefault false.\n\n[[nsa-cache-control-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<cache-control> Attributes", "heading_level": 3, "file_order": 66, "section_index": 16, "content_hash": "7bf901edb5e68e42c9f95ba5fd09f6e7e1763544651d1600d7e42372cd1541ed", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:4ef7e99d258621864f4e0a89556be2cf5be8eb13a5407b1cf3f95ea76c856c19", "content": "* <<nsa-headers,headers>>\n\n[[nsa-hsts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <cache-control>", "heading_level": 3, "file_order": 66, "section_index": 17, "content_hash": "4ef7e99d258621864f4e0a89556be2cf5be8eb13a5407b1cf3f95ea76c856c19", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:85a15e3e2900e031d899e267ca551380288f5a7e2f9d8839300cd8cd9b85e550", "content": "When enabled adds the https://tools.ietf.org/html/rfc6797[Strict-Transport-Security] header to the response for any secure request.\nThis allows the server to instruct browsers to automatically use HTTPS for future requests.\n\n[[nsa-hsts-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<hsts>", "heading_level": 2, "file_order": 66, "section_index": 18, "content_hash": "85a15e3e2900e031d899e267ca551380288f5a7e2f9d8839300cd8cd9b85e550", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:39ee4c1934091dcd7a315df2eb1cf4fd5c3cfa44dc8b8fd98509b0a0f38cd773", "content": "[[nsa-hsts-disabled]]\n* **disabled**\nSpecifies if Strict-Transport-Security should be disabled.\nDefault false.\n\n[[nsa-hsts-include-subdomains]]\n* **include-sub-domains**\nSpecifies if subdomains should be included.\nDefault true.\n\n[[nsa-hsts-max-age-seconds]]\n* **max-age-seconds**\nSpecifies the maximum amount of time the host should be considered a Known HSTS Host.\nDefault one year.\n\n[[nsa-hsts-request-matcher-ref]]\n* **request-matcher-ref**\nThe RequestMatcher instance to be used to determine if the header should be set.\nDefault is if HttpServletRequest.isSecure() is true.\n\n[[nsa-hsts-preload]]\n* **preload**\nSpecifies if preload should be included.\nDefault false.\n\n[[nsa-hsts-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<hsts> Attributes", "heading_level": 3, "file_order": 66, "section_index": 19, "content_hash": "39ee4c1934091dcd7a315df2eb1cf4fd5c3cfa44dc8b8fd98509b0a0f38cd773", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:c4af2a07034a8b6701fdd4a7a4dc4803fb081b2dd7962b415df220d443daca48", "content": "* <<nsa-headers,headers>>\n\n[[nsa-hpkp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <hsts>", "heading_level": 3, "file_order": 66, "section_index": 20, "content_hash": "c4af2a07034a8b6701fdd4a7a4dc4803fb081b2dd7962b415df220d443daca48", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:cc70a4d4daebc41bc3bbe48778bac14ae9cea52c0e06c92dd68fa7cefad2390d", "content": "When enabled adds the https://tools.ietf.org/html/rfc7469[Public Key Pinning Extension for HTTP] header to the response for any secure request.\nThis allows HTTPS websites to resist impersonation by attackers using mis-issued or otherwise fraudulent certificates.\n\n[[nsa-hpkp-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<hpkp>", "heading_level": 2, "file_order": 66, "section_index": 21, "content_hash": "cc70a4d4daebc41bc3bbe48778bac14ae9cea52c0e06c92dd68fa7cefad2390d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:3f0de8f6fc5fc9106f3c05efd6804f90f5ed592312eb6b4beaa32df87bb04a25", "content": "[[nsa-hpkp-disabled]]\n* **disabled**\nSpecifies if HTTP Public Key Pinning (HPKP) should be disabled.\nDefault true.\n\n[[nsa-hpkp-include-subdomains]]\n* **include-sub-domains**\nSpecifies if subdomains should be included.\nDefault false.\n\n[[nsa-hpkp-max-age-seconds]]\n* **max-age-seconds**\nSets the value for the max-age directive of the Public-Key-Pins header.\nDefault 60 days.\n\n[[nsa-hpkp-report-only]]\n* **report-only**\nSpecifies if the browser should only report pin validation failures.\nDefault true.\n\n[[nsa-hpkp-report-uri]]\n* **report-uri**\nSpecifies the URI to which the browser should report pin validation failures.\n\n[[nsa-hpkp-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<hpkp> Attributes", "heading_level": 3, "file_order": 66, "section_index": 22, "content_hash": "3f0de8f6fc5fc9106f3c05efd6804f90f5ed592312eb6b4beaa32df87bb04a25", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5a87d4ecdd10f9a89de25949d842d6436e17b1b61391154a2e1cc328a90a73c5", "content": "* <<nsa-headers,headers>>\n\n[[nsa-pins]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <hpkp>", "heading_level": 3, "file_order": 66, "section_index": 23, "content_hash": "5a87d4ecdd10f9a89de25949d842d6436e17b1b61391154a2e1cc328a90a73c5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:0ebbd9569ef4724b8556347af0ea66a4b5f2d66eea172d914a54e6324a044673", "content": "The list of pins\n\n[[nsa-pins-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<pins>", "heading_level": 2, "file_order": 66, "section_index": 24, "content_hash": "0ebbd9569ef4724b8556347af0ea66a4b5f2d66eea172d914a54e6324a044673", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:3e0b68e4ae743e5868f8fee7acddaca35a5f413d715dc58e984f203cda0168ab", "content": "* <<nsa-pin,pin>>\n\n[[nsa-pin]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <pins>", "heading_level": 3, "file_order": 66, "section_index": 25, "content_hash": "3e0b68e4ae743e5868f8fee7acddaca35a5f413d715dc58e984f203cda0168ab", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:a16f0c768dc0e03df39cdf7eb6d271a510017fa0a7d81e17c5069ef5a8d28574", "content": "A pin is specified using the base64-encoded SPKI fingerprint as value and the cryptographic hash algorithm as attribute\n\n[[nsa-pin-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<pin>", "heading_level": 2, "file_order": 66, "section_index": 26, "content_hash": "a16f0c768dc0e03df39cdf7eb6d271a510017fa0a7d81e17c5069ef5a8d28574", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:cb5e2a90959842c240d6466581f545db6a78b0dd16a0157f863aef03a19b95f1", "content": "[[nsa-pin-algorithm]]\n* **algorithm**\nThe cryptographic hash algorithm.\nDefault is SHA256.\n\n[[nsa-pin-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<pin> Attributes", "heading_level": 3, "file_order": 66, "section_index": 27, "content_hash": "cb5e2a90959842c240d6466581f545db6a78b0dd16a0157f863aef03a19b95f1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:29e1c297f133491eace0eec39f5e2a13ebef98347d774be63a63b548b283f46f", "content": "* <<nsa-pins,pins>>\n\n[[nsa-content-security-policy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <pin>", "heading_level": 3, "file_order": 66, "section_index": 28, "content_hash": "29e1c297f133491eace0eec39f5e2a13ebef98347d774be63a63b548b283f46f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:d2b9ad22fe43b0da9553bc6097969ed7f9d0e7bc5b3f2863d41c337075817f8f", "content": "When enabled adds the https://www.w3.org/TR/CSP2/[Content Security Policy (CSP)] header to the response.\nCSP is a mechanism that web applications can leverage to mitigate content injection vulnerabilities, such as cross-site scripting (XSS).\n\n[[nsa-content-security-policy-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<content-security-policy>", "heading_level": 2, "file_order": 66, "section_index": 29, "content_hash": "d2b9ad22fe43b0da9553bc6097969ed7f9d0e7bc5b3f2863d41c337075817f8f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:14f9e9810b4792616025009484dd69f3000d8f74ae3ccec17c9d6a5d312b08bc", "content": "[[nsa-content-security-policy-policy-directives]]\n* **policy-directives**\nThe security policy directive(s) for the Content-Security-Policy header or if report-only is set to true, then the Content-Security-Policy-Report-Only header is used.\n\n[[nsa-content-security-policy-report-only]]\n* **report-only**\nSet to true, to enable the Content-Security-Policy-Report-Only header for reporting policy violations only.\nDefaults to false.\n\n[[nsa-content-security-policy-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<content-security-policy> Attributes", "heading_level": 3, "file_order": 66, "section_index": 30, "content_hash": "14f9e9810b4792616025009484dd69f3000d8f74ae3ccec17c9d6a5d312b08bc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:e3b2cbc92f08e9705d689da5031317abe747ba987993142c27ee48463654baed", "content": "* <<nsa-headers,headers>>\n\n[[nsa-referrer-policy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <content-security-policy>", "heading_level": 3, "file_order": 66, "section_index": 31, "content_hash": "e3b2cbc92f08e9705d689da5031317abe747ba987993142c27ee48463654baed", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:1e57e6680f366b8794cf9828a8ad2feb26348ecfb33354e702f4d20cd2ce3b6f", "content": "When enabled adds the https://www.w3.org/TR/referrer-policy/[Referrer Policy] header to the response.\n\n[[nsa-referrer-policy-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<referrer-policy>", "heading_level": 2, "file_order": 66, "section_index": 32, "content_hash": "1e57e6680f366b8794cf9828a8ad2feb26348ecfb33354e702f4d20cd2ce3b6f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:4a40270e5f4c1f227a3ab5d1716dee284c1b852e6c10804d3ae152adc301e184", "content": "[[nsa-referrer-policy-policy]]\n* **policy**\nThe policy for the Referrer-Policy header.\nDefault \"no-referrer\".\n\n[[nsa-referrer-policy-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<referrer-policy> Attributes", "heading_level": 3, "file_order": 66, "section_index": 33, "content_hash": "4a40270e5f4c1f227a3ab5d1716dee284c1b852e6c10804d3ae152adc301e184", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5077ee007aef29ca5cbdb30c43f6bda9047beb28a1e9dadc1b3ff9a72634ab10", "content": "* <<nsa-headers,headers>>\n\n[[nsa-feature-policy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <referrer-policy>", "heading_level": 3, "file_order": 66, "section_index": 34, "content_hash": "5077ee007aef29ca5cbdb30c43f6bda9047beb28a1e9dadc1b3ff9a72634ab10", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:4343c52805b852e0d5819d5ec64d44a484555d3e70ea13d38404e58eba20c3fa", "content": "When enabled adds the https://wicg.github.io/feature-policy/[Feature Policy] header to the response.\n\n[[nsa-feature-policy-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<feature-policy>", "heading_level": 2, "file_order": 66, "section_index": 35, "content_hash": "4343c52805b852e0d5819d5ec64d44a484555d3e70ea13d38404e58eba20c3fa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:67640aaf6fdf93a268f7f825b22f1c6d18cd4fa1a64e4361d0ed0182a567f252", "content": "[[nsa-feature-policy-policy-directives]]\n* **policy-directives**\nThe security policy directive(s) for the Feature-Policy header.\n\n[[nsa-feature-policy-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<feature-policy> Attributes", "heading_level": 3, "file_order": 66, "section_index": 36, "content_hash": "67640aaf6fdf93a268f7f825b22f1c6d18cd4fa1a64e4361d0ed0182a567f252", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:b39400b4359bd7e093c8c3d86437522941b5d0690d0c20f57f4ff2a0bbee351f", "content": "* <<nsa-headers,headers>>\n\n[[nsa-frame-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <feature-policy>", "heading_level": 3, "file_order": 66, "section_index": 37, "content_hash": "b39400b4359bd7e093c8c3d86437522941b5d0690d0c20f57f4ff2a0bbee351f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:f99c7f641f8a050a24722c8e14baf952b32353fdfee09e6587f0b97ff25d70ee", "content": "When enabled adds the https://tools.ietf.org/html/draft-ietf-websec-x-frame-options[X-Frame-Options header] to the response, this allows newer browsers to do some security checks and prevent https://en.wikipedia.org/wiki/Clickjacking[clickjacking] attacks.\n\n[[nsa-frame-options-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<frame-options>", "heading_level": 2, "file_order": 66, "section_index": 38, "content_hash": "f99c7f641f8a050a24722c8e14baf952b32353fdfee09e6587f0b97ff25d70ee", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:099da6a5d5ac200452753f3a2f31720310bc747b214b14bc09b8b92a1b5ae28a", "content": "[[nsa-frame-options-disabled]]\n* **disabled**\nIf disabled, the X-Frame-Options header will not be included.\nDefault false.\n\n[[nsa-frame-options-policy]]\n* **policy**\n** `DENY` The page cannot be displayed in a frame, regardless of the site attempting to do so.\nThis is the default when frame-options-policy is specified.\n** `SAMEORIGIN` The page can only be displayed in a frame on the same origin as the page itself\n\n+\n\nIn other words, if you specify DENY, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site.\nOn the other hand, if you specify SAMEORIGIN, you can still use the page in a frame as long as the site including it in a frame it is the same as the one serving the page.\n\n[[nsa-frame-options-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<frame-options> Attributes", "heading_level": 3, "file_order": 66, "section_index": 39, "content_hash": "099da6a5d5ac200452753f3a2f31720310bc747b214b14bc09b8b92a1b5ae28a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:18d6814de7ef3665e51b5751a2e9f2533e2ad388cb1e7e45785b3a29ad854b30", "content": "* <<nsa-headers,headers>>\n\n[[nsa-permissions-policy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <frame-options>", "heading_level": 3, "file_order": 66, "section_index": 40, "content_hash": "18d6814de7ef3665e51b5751a2e9f2533e2ad388cb1e7e45785b3a29ad854b30", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:1b000d3edea7f5d25313efb958a6224d098e2951e69fae92d45cb9fba173fe1c", "content": "Adds the https://w3c.github.io/webappsec-permissions-policy/[Permissions-Policy header] to the response.\n\n[[nsa-permissions-policy-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<permissions-policy>", "heading_level": 2, "file_order": 66, "section_index": 41, "content_hash": "1b000d3edea7f5d25313efb958a6224d098e2951e69fae92d45cb9fba173fe1c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:916439a028e18f13208b406b438284e8e7d91edc231aab0ed5ad593d9dfb1f17", "content": "[[nsa-permissions-policy-policy]]\n* **policy**\nThe policy value to write for the `Permissions-Policy` header\n\n[[nsa-permissions-policy-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<permissions-policy> Attributes", "heading_level": 3, "file_order": 66, "section_index": 42, "content_hash": "916439a028e18f13208b406b438284e8e7d91edc231aab0ed5ad593d9dfb1f17", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:e07179a35be1f4a9cf915d16414d0b00e83c0ca9e93e860f05b3f018dbe6f40d", "content": "* <<nsa-headers,headers>>\n\n[[nsa-xss-protection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <permissions-policy>", "heading_level": 3, "file_order": 66, "section_index": 43, "content_hash": "e07179a35be1f4a9cf915d16414d0b00e83c0ca9e93e860f05b3f018dbe6f40d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:b111794711f9e6a4b016382c5bb486c50c3ecb29983fea9fcdd6202bbab29792", "content": "Adds the https://blogs.msdn.com/b/ie/archive/2008/07/02/ie8-security-part-iv-the-xss-filter.aspx[X-XSS-Protection header] to the response to assist in protecting against https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent[reflected / Type-1 Cross-Site Scripting (XSS)] attacks.\nThis is in no-way a full protection to XSS attacks!\n\n[[nsa-xss-protection-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<xss-protection>", "heading_level": 2, "file_order": 66, "section_index": 44, "content_hash": "b111794711f9e6a4b016382c5bb486c50c3ecb29983fea9fcdd6202bbab29792", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:f144ce9ec5eee1e874787c1f72c80d57f24215760555b61083f85a1b2c28c2f3", "content": "[[nsa-xss-protection-disabled]]\n* **xss-protection-disabled**\nDo not include the header for https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent[reflected / Type-1 Cross-Site Scripting (XSS)] protection.\n\n[[nsa-xss-protection-header-value]]\n* **xss-protection-header-value**\nExplicitly set the value for https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent[reflected / Type-1 Cross-Site Scripting (XSS)] header.\nOne of: \"0\", \"1\", \"1; mode=block\". Defaults to \"0\".\n\n[[nsa-xss-protection-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<xss-protection> Attributes", "heading_level": 3, "file_order": 66, "section_index": 45, "content_hash": "f144ce9ec5eee1e874787c1f72c80d57f24215760555b61083f85a1b2c28c2f3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:9c91605105c5e4bd2e6df935bc615b956ac39efae784a22157c8b1609b65cdf9", "content": "* <<nsa-headers,headers>>\n\n[[nsa-content-type-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <xss-protection>", "heading_level": 3, "file_order": 66, "section_index": 46, "content_hash": "9c91605105c5e4bd2e6df935bc615b956ac39efae784a22157c8b1609b65cdf9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:04f3a642f737df077aefdb64b38ba2d20010a1533b75f7bee34ed4b40953021b", "content": "Add the X-Content-Type-Options header with the value of nosniff to the response.\nThis https://blogs.msdn.com/b/ie/archive/2008/09/02/ie8-security-part-vi-beta-2-update.aspx[disables MIME-sniffing] for IE8+ and Chrome extensions.\n\n[[nsa-content-type-options-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<content-type-options>", "heading_level": 2, "file_order": 66, "section_index": 47, "content_hash": "04f3a642f737df077aefdb64b38ba2d20010a1533b75f7bee34ed4b40953021b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:d1c60555d487ebe9474bbb69de2dd4352ed732e963d9cd48f962f48cf7c0c011", "content": "[[nsa-content-type-options-disabled]]\n* **disabled**\nSpecifies if Content Type Options should be disabled.\nDefault false.\n\n[[nsa-content-type-options-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<content-type-options> Attributes", "heading_level": 3, "file_order": 66, "section_index": 48, "content_hash": "d1c60555d487ebe9474bbb69de2dd4352ed732e963d9cd48f962f48cf7c0c011", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:8968d45f01f89d3007abb7406c9b415570f3cd4a9c36a36de67ca79ca6c0292a", "content": "* <<nsa-headers,headers>>\n\n[[nsa-cross-origin-embedder-policy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <content-type-options>", "heading_level": 3, "file_order": 66, "section_index": 49, "content_hash": "8968d45f01f89d3007abb7406c9b415570f3cd4a9c36a36de67ca79ca6c0292a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:96b5402afe66753c70cd498319dfd37dcb55de13529661cff8c2bbc4d5381a87", "content": "When enabled adds the https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy[Cross-Origin-Embedder-Policy] header to the response.\n\n[[nsa-cross-origin-embedder-policy-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<cross-origin-embedder-policy>", "heading_level": 4, "file_order": 66, "section_index": 50, "content_hash": "96b5402afe66753c70cd498319dfd37dcb55de13529661cff8c2bbc4d5381a87", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:fae6333df6afd868cf71d3840761a02a30f3747c588fb3c20281b6449dbf8b7e", "content": "[[nsa-cross-origin-embedder-policy-policy]]\n* **policy**\nThe policy for the `Cross-Origin-Embedder-Policy` header.\n\n[[nsa-cross-origin-embedder-policy-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<cross-origin-embedder-policy> Attributes", "heading_level": 5, "file_order": 66, "section_index": 51, "content_hash": "fae6333df6afd868cf71d3840761a02a30f3747c588fb3c20281b6449dbf8b7e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:320a59c30673075d2073dca661ded2449b166a01cd11c832142bf532e237ecc8", "content": "* <<nsa-headers,headers>>\n\n[[nsa-cross-origin-opener-policy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <cross-origin-embedder-policy>", "heading_level": 5, "file_order": 66, "section_index": 52, "content_hash": "320a59c30673075d2073dca661ded2449b166a01cd11c832142bf532e237ecc8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:57c5b3eafe0dfb7413335f0a3ba42ee9554abbc33ead53db769921a66fe8af60", "content": "When enabled adds the https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy[Cross-Origin-Opener-Policy] header to the response.\n\n[[nsa-cross-origin-opener-policy-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<cross-origin-opener-policy>", "heading_level": 4, "file_order": 66, "section_index": 53, "content_hash": "57c5b3eafe0dfb7413335f0a3ba42ee9554abbc33ead53db769921a66fe8af60", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5081787f1c71e6eb7e6d6e67ee158a804b2c1fa89d0b650d237da9163d9076db", "content": "[[nsa-cross-origin-opener-policy-policy]]\n* **policy**\nThe policy for the `Cross-Origin-Opener-Policy` header.\n\n[[nsa-cross-origin-opener-policy-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<cross-origin-opener-policy> Attributes", "heading_level": 5, "file_order": 66, "section_index": 54, "content_hash": "5081787f1c71e6eb7e6d6e67ee158a804b2c1fa89d0b650d237da9163d9076db", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:78537d43032dffc07d63f231d98747c5b0c5343acbced4095951ab4f8f962722", "content": "* <<nsa-headers,headers>>\n\n[[nsa-cross-origin-resource-policy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <cross-origin-opener-policy>", "heading_level": 5, "file_order": 66, "section_index": 55, "content_hash": "78537d43032dffc07d63f231d98747c5b0c5343acbced4095951ab4f8f962722", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:73b04ee45d9aec52fd08e6f342bbfa35e0150ad5d8bac29c5063ccde3df664a1", "content": "When enabled adds the https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Resource-Policy[Cross-Origin-Resource-Policy] header to the response.\n\n[[nsa-cross-origin-resource-policy-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<cross-origin-resource-policy>", "heading_level": 4, "file_order": 66, "section_index": 56, "content_hash": "73b04ee45d9aec52fd08e6f342bbfa35e0150ad5d8bac29c5063ccde3df664a1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:b316c334aacbfc931cce6221d0ee0eff607cb069ecf539707368442a1b1ade19", "content": "[[nsa-cross-origin-resource-policy-policy]]\n* **policy**\nThe policy for the `Cross-Origin-Resource-Policy` header.\n\n[[nsa-cross-origin-resource-policy-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<cross-origin-resource-policy> Attributes", "heading_level": 5, "file_order": 66, "section_index": 57, "content_hash": "b316c334aacbfc931cce6221d0ee0eff607cb069ecf539707368442a1b1ade19", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5a440bc2391158e59820619022a503a85b5fb215d07cd508b3475bfb1226cb2a", "content": "* <<nsa-headers,headers>>\n\n[[nsa-header]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <cross-origin-resource-policy>", "heading_level": 5, "file_order": 66, "section_index": 58, "content_hash": "5a440bc2391158e59820619022a503a85b5fb215d07cd508b3475bfb1226cb2a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:7bf0b4dcaae1a84febbde1cda08809cb8f4e309188a8c9021ad62f3be8f3e0bb", "content": "Add additional headers to the response, both the name and value need to be specified.\n\n[[nsa-header-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<header>", "heading_level": 2, "file_order": 66, "section_index": 59, "content_hash": "7bf0b4dcaae1a84febbde1cda08809cb8f4e309188a8c9021ad62f3be8f3e0bb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:9a2da34f90e219f8a29c461ac67ed58284943933f67b5f97c9aecb084efc55e0", "content": "[[nsa-header-name]]\n* **header-name**\nThe `name` of the header.\n\n[[nsa-header-value]]\n* **value**\nThe `value` of the header to add.\n\n[[nsa-header-ref]]\n* **ref**\nReference to a custom implementation of the `HeaderWriter` interface.\n\n[[nsa-header-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<header-attributes> Attributes", "heading_level": 3, "file_order": 66, "section_index": 60, "content_hash": "9a2da34f90e219f8a29c461ac67ed58284943933f67b5f97c9aecb084efc55e0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:207da659ea67dbbbc16ed09faa5e44e8cf433fcfb80d4c2e03beb86c34ee9fb0", "content": "* <<nsa-headers,headers>>\n\n[[nsa-anonymous]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <header>", "heading_level": 3, "file_order": 66, "section_index": 61, "content_hash": "207da659ea67dbbbc16ed09faa5e44e8cf433fcfb80d4c2e03beb86c34ee9fb0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:eb2b87b5481265cc1c198543a504e6b3a3a223fdab2671e963ba3f493721455b", "content": "Adds an `AnonymousAuthenticationFilter` to the stack and an `AnonymousAuthenticationProvider`.\nRequired if you are using the `IS_AUTHENTICATED_ANONYMOUSLY` attribute.\n\n[[nsa-anonymous-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<anonymous>", "heading_level": 2, "file_order": 66, "section_index": 62, "content_hash": "eb2b87b5481265cc1c198543a504e6b3a3a223fdab2671e963ba3f493721455b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:7d86d4ddb482762c86aa0c3c5ab5d5fa93c4068886ff07e6f4bf69226d2d8821", "content": "* <<nsa-http,http>>\n\n[[nsa-anonymous-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <anonymous>", "heading_level": 3, "file_order": 66, "section_index": 63, "content_hash": "7d86d4ddb482762c86aa0c3c5ab5d5fa93c4068886ff07e6f4bf69226d2d8821", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:0e069bba878839f786da7463cc716c05fa0465f4973dfaa20a77bf420f889f0f", "content": "[[nsa-anonymous-enabled]]\n* **enabled**\nWith the default namespace setup, the anonymous \"authentication\" facility is automatically enabled.\nYou can disable it using this property.\n\n[[nsa-anonymous-granted-authority]]\n* **granted-authority**\nThe granted authority that should be assigned to the anonymous request.\nCommonly this is used to assign the anonymous request particular roles, which can subsequently be used in authorization decisions.\nIf unset, defaults to `ROLE_ANONYMOUS`.\n\n[[nsa-anonymous-key]]\n* **key**\nThe key shared between the provider and filter.\nThis generally does not need to be set.\nIf unset, it will default to a secure randomly generated value.\nThis means setting this value can improve startup time when using the anonymous functionality since secure random values can take a while to be generated.\n\n[[nsa-anonymous-username]]\n* **username**\nThe username that should be assigned to the anonymous request.\nThis allows the principal to be identified, which may be important for logging and auditing.\nif unset, defaults to `anonymousUser`.\n\n[[nsa-csrf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<anonymous> Attributes", "heading_level": 3, "file_order": 66, "section_index": 64, "content_hash": "0e069bba878839f786da7463cc716c05fa0465f4973dfaa20a77bf420f889f0f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:3d43db3261899ae2f81aabfda4f0aa8676535ebf35ad66a629b022ab2fd5ec84", "content": "This element will add https://en.wikipedia.org/wiki/Cross-site_request_forgery[Cross Site Request Forger (CSRF)] protection to the application.\nIt also updates the default RequestCache to only replay \"GET\" requests upon successful authentication.\nAdditional information can be found in the xref:features/exploits/csrf.adoc#csrf[Cross Site Request Forgery (CSRF)] section of the reference.\n\n[[nsa-csrf-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<csrf>", "heading_level": 2, "file_order": 66, "section_index": 65, "content_hash": "3d43db3261899ae2f81aabfda4f0aa8676535ebf35ad66a629b022ab2fd5ec84", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:e0aabfe552baa768deb3172b665c859c35688a5c6b2905b126bbf21ca4ffbf70", "content": "* <<nsa-http,http>>\n\n[[nsa-csrf-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <csrf>", "heading_level": 3, "file_order": 66, "section_index": 66, "content_hash": "e0aabfe552baa768deb3172b665c859c35688a5c6b2905b126bbf21ca4ffbf70", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:031edb77d56d0d8e4b4ba00115f728515810c1f44c2e1ef313ab98bc90dbcfbf", "content": "[[nsa-csrf-disabled]]\n* **disabled**\nOptional attribute that specifies to disable Spring Security's CSRF protection.\nThe default is false (CSRF protection is enabled).\nIt is highly recommended to leave CSRF protection enabled.\n\n[[nsa-csrf-token-repository-ref]]\n* **token-repository-ref**\nThe CsrfTokenRepository to use.\nThe default is `HttpSessionCsrfTokenRepository`.\n\n[[nsa-csrf-request-handler-ref]]\n* **request-handler-ref**\nThe optional `CsrfTokenRequestHandler` to use. The default is `CsrfTokenRequestAttributeHandler`.\n\n[[nsa-csrf-request-matcher-ref]]\n* **request-matcher-ref**\nThe RequestMatcher instance to be used to determine if CSRF should be applied.\nDefault is any HTTP method except \"GET\", \"TRACE\", \"HEAD\", \"OPTIONS\".\n\n[[nsa-custom-filter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<csrf> Attributes", "heading_level": 3, "file_order": 66, "section_index": 67, "content_hash": "031edb77d56d0d8e4b4ba00115f728515810c1f44c2e1ef313ab98bc90dbcfbf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:404b7a7dbcb709b1f6c4745ee179212ff32b0d176ef4ba4de7d8f77e71047489", "content": "This element is used to add a filter to the filter chain.\nIt doesn't create any additional beans but is used to select a bean of type `jakarta.servlet.Filter` which is already defined in the application context and add that at a particular position in the filter chain maintained by Spring Security.\nFull details can be found in the xref:servlet/configuration/xml-namespace.adoc#ns-custom-filters[ namespace chapter].\n\n[[nsa-custom-filter-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<custom-filter>", "heading_level": 2, "file_order": 66, "section_index": 68, "content_hash": "404b7a7dbcb709b1f6c4745ee179212ff32b0d176ef4ba4de7d8f77e71047489", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:ebc35e1d03082dd99dd61931bda1ab42a3dce6f364af80d56868364b5665b39d", "content": "* <<nsa-http,http>>\n\n[[nsa-custom-filter-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <custom-filter>", "heading_level": 3, "file_order": 66, "section_index": 69, "content_hash": "ebc35e1d03082dd99dd61931bda1ab42a3dce6f364af80d56868364b5665b39d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:242dea0c1fd61c4d5b189b53e1e6dbf97cd2e7628620398a81f9bb08388aca42", "content": "[[nsa-custom-filter-after]]\n* **after**\nThe filter immediately after which the custom-filter should be placed in the chain.\nThis feature will only be needed by advanced users who wish to mix their own filters into the security filter chain and have some knowledge of the standard Spring Security filters.\nThe filter names map to specific Spring Security implementation filters.\n\n[[nsa-custom-filter-before]]\n* **before**\nThe filter immediately before which the custom-filter should be placed in the chain\n\n[[nsa-custom-filter-position]]\n* **position**\nThe explicit position at which the custom-filter should be placed in the chain.\nUse if you are replacing a standard filter.\n\n[[nsa-custom-filter-ref]]\n* **ref**\nDefines a reference to a Spring bean that implements `Filter`.\n\n[[nsa-expression-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<custom-filter> Attributes", "heading_level": 3, "file_order": 66, "section_index": 70, "content_hash": "242dea0c1fd61c4d5b189b53e1e6dbf97cd2e7628620398a81f9bb08388aca42", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:713b20818ee62cb678b91f374b8279b38c46343d8f4dbb03fb2532566768c120", "content": "Defines the `SecurityExpressionHandler` instance which will be used if expression-based access-control is enabled.\nA default implementation (with no ACL support) will be used if not supplied.\n\n[[nsa-expression-handler-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<expression-handler>", "heading_level": 2, "file_order": 66, "section_index": 71, "content_hash": "713b20818ee62cb678b91f374b8279b38c46343d8f4dbb03fb2532566768c120", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:90f456af01c83d63b579e7ad11b4f79b2a13963ad827c397aa0601f9dde8705c", "content": "* xref:servlet/appendix/namespace/method-security.adoc#nsa-global-method-security[global-method-security]\n* <<nsa-http,http>>\n* xref:servlet/appendix/namespace/method-security.adoc#nsa-method-security[method-security]\n* xref:servlet/appendix/namespace/websocket.adoc#nsa-websocket-message-broker[websocket-message-broker]\n\n[[nsa-expression-handler-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <expression-handler>", "heading_level": 3, "file_order": 66, "section_index": 72, "content_hash": "90f456af01c83d63b579e7ad11b4f79b2a13963ad827c397aa0601f9dde8705c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:4e55fb049d6d7bc37fe726ecd8381512bf7c2e53d7fbda2c571204d80559833f", "content": "[[nsa-expression-handler-ref]]\n* **ref**\nDefines a reference to a Spring bean that implements `SecurityExpressionHandler`.\n\n[[nsa-form-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<expression-handler> Attributes", "heading_level": 3, "file_order": 66, "section_index": 73, "content_hash": "4e55fb049d6d7bc37fe726ecd8381512bf7c2e53d7fbda2c571204d80559833f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:43c8749b5041fef37e813b96d89bcbe471145f0fb42a0ba3b0e5d6df39362f5a", "content": "Used to add an `UsernamePasswordAuthenticationFilter` to the filter stack and an `LoginUrlAuthenticationEntryPoint` to the application context to provide authentication on demand.\nThis will always take precedence over other namespace-created entry points.\nIf no attributes are supplied, a login page will be generated automatically at the URL \"/login\" footnote:[\nThis feature is really just provided for convenience and is not intended for production (where a view technology will have been chosen and can be used to render a customized login page).\nThe class `DefaultLoginPageGeneratingFilter` is responsible for rendering the login page and will provide login forms for both normal form login and/or OIDC if required.\n] The behaviour can be customized using the <<nsa-form-login-attributes, `<form-login>` Attributes>>.\n\n[[nsa-form-login-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<form-login>", "heading_level": 2, "file_order": 66, "section_index": 74, "content_hash": "43c8749b5041fef37e813b96d89bcbe471145f0fb42a0ba3b0e5d6df39362f5a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:08ad3ff4723d08dac16a26fb7a4b90465e77e22aadb8d6c0ea6d01b525d2b542", "content": "* <<nsa-http,http>>\n\n[[nsa-form-login-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <form-login>", "heading_level": 3, "file_order": 66, "section_index": 75, "content_hash": "08ad3ff4723d08dac16a26fb7a4b90465e77e22aadb8d6c0ea6d01b525d2b542", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:9b5da33877be34cddae421f28b0d8c16c1f14dcb968920886f74e7f461d088b6", "content": "[[nsa-form-login-always-use-default-target]]\n* **always-use-default-target**\nIf set to `true`, the user will always start at the value given by <<nsa-form-login-default-target-url,default-target-url>>, regardless of how they arrived at the login page.\nMaps to the `alwaysUseDefaultTargetUrl` property of `UsernamePasswordAuthenticationFilter`.\nDefault value is `false`.\n\n[[nsa-form-login-authentication-details-source-ref]]\n* **authentication-details-source-ref**\nReference to an `AuthenticationDetailsSource` which will be used by the authentication filter\n\n[[nsa-form-login-authentication-failure-handler-ref]]\n* **authentication-failure-handler-ref**\nCan be used as an alternative to <<nsa-form-login-authentication-failure-url,authentication-failure-url>>, giving you full control over the navigation flow after an authentication failure.\nThe value should be the name of an `AuthenticationFailureHandler` bean in the application context.\n\n[[nsa-form-login-authentication-failure-url]]\n* **authentication-failure-url**\nMaps to the `authenticationFailureUrl` property of `UsernamePasswordAuthenticationFilter`.\nDefines the URL the browser will be redirected to on login failure.\nDefaults to `/login?error`, which will be automatically handled by the automatic login page generator, re-rendering the login page with an error message.\n\n[[nsa-form-login-authentication-success-handler-ref]]\n* **authentication-success-handler-ref**\nThis can be used as an alternative to <<nsa-form-login-default-target-url,default-target-url>> and <<nsa-form-login-always-use-default-target,always-use-default-target>>, giving you full control over the navigation flow after a successful authentication.\nThe value should be the name of an `AuthenticationSuccessHandler` bean in the application context.\nBy default, an implementation of `SavedRequestAwareAuthenticationSuccessHandler` is used and injected with the <<nsa-form-login-default-target-url,default-target-url >>.\n\n[[nsa-form-login-default-target-url]]\n* **default-target-url**\nMaps to the `defaultTargetUrl` property of `UsernamePasswordAuthenticationFilter`.\nIf not set, the default value is \"/\" (the application root).\nA user will be taken to this URL after logging in, provided they were not asked to login while attempting to access a secured resource, when they will be taken to the originally requested URL.\n\n[[nsa-form-login-login-page]]\n* **login-page**\nThe URL that should be used to render the login page.\nMaps to the `loginFormUrl` property of the `LoginUrlAuthenticationEntryPoint`.\nDefaults to \"/login\".\n\n[[nsa-form-login-login-processing-url]]\n* **login-processing-url**\nMaps to the `filterProcessesUrl` property of `UsernamePasswordAuthenticationFilter`.\nThe default value is \"/login\".\n\n[[nsa-form-login-password-parameter]]\n* **password-parameter**\nThe name of the request parameter which contains the password.\nDefaults to \"password\".\n\n[[nsa-form-login-username-parameter]]\n* **username-parameter**\nThe name of the request parameter which contains the username.\nDefaults to \"username\".\n\n[[nsa-form-login-authentication-success-forward-url]]\n* **authentication-success-forward-url**\nMaps a `ForwardAuthenticationSuccessHandler` to `authenticationSuccessHandler` property of `UsernamePasswordAuthenticationFilter`.\n\n[[nsa-form-login-authentication-failure-forward-url]]\n* **authentication-failure-forward-url**\nMaps a `ForwardAuthenticationFailureHandler` to `authenticationFailureHandler` property of `UsernamePasswordAuthenticationFilter`.\n\n[[nsa-oauth2-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<form-login> Attributes", "heading_level": 3, "file_order": 66, "section_index": 76, "content_hash": "9b5da33877be34cddae421f28b0d8c16c1f14dcb968920886f74e7f461d088b6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:86fc4149c1e5002bdf31dbadd8f756e2103bdf5a5dbc07dc00c791a29503a270", "content": "The xref:servlet/oauth2/login/index.adoc#oauth2login[OAuth 2.0 Login] feature configures authentication support using an OAuth 2.0 and/or OpenID Connect 1.0 Provider.\n\n[[nsa-oauth2-login-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<oauth2-login>", "heading_level": 2, "file_order": 66, "section_index": 77, "content_hash": "86fc4149c1e5002bdf31dbadd8f756e2103bdf5a5dbc07dc00c791a29503a270", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:b86d8b49a3617b7b8e02f87045e6f19a3bfb57f6e9964c1b21780e3d3406ff42", "content": "* <<nsa-http,http>>\n\n[[nsa-oauth2-login-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <oauth2-login>", "heading_level": 3, "file_order": 66, "section_index": 78, "content_hash": "b86d8b49a3617b7b8e02f87045e6f19a3bfb57f6e9964c1b21780e3d3406ff42", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:6638c960de95db2fcd1482ce7a231bb213413f2b55371c174d40fb37635fb483", "content": "[[nsa-oauth2-login-client-registration-repository-ref]]\n* **client-registration-repository-ref**\nReference to the `ClientRegistrationRepository`.\n\n[[nsa-oauth2-login-authorized-client-repository-ref]]\n* **authorized-client-repository-ref**\nReference to the `OAuth2AuthorizedClientRepository`.\n\n[[nsa-oauth2-login-authorized-client-service-ref]]\n* **authorized-client-service-ref**\nReference to the `OAuth2AuthorizedClientService`.\n\n[[nsa-oauth2-login-authorization-request-repository-ref]]\n* **authorization-request-repository-ref**\nReference to the `AuthorizationRequestRepository`.\n\n[[nsa-oauth2-login-authorization-request-resolver-ref]]\n* **authorization-request-resolver-ref**\nReference to the `OAuth2AuthorizationRequestResolver`.\n\n[[nsa-oauth2-login-authorization-redirect-strategy-ref]]\n* **authorization-redirect-strategy-ref**\nReference to the authorization `RedirectStrategy`.\n\n[[nsa-oauth2-login-access-token-response-client-ref]]\n* **access-token-response-client-ref**\nReference to the `OAuth2AccessTokenResponseClient`.\n\n[[nsa-oauth2-login-user-authorities-mapper-ref]]\n* **user-authorities-mapper-ref**\nReference to the `GrantedAuthoritiesMapper`.\n\n[[nsa-oauth2-login-user-service-ref]]\n* **user-service-ref**\nReference to the `OAuth2UserService`.\n\n[[nsa-oauth2-login-oidc-user-service-ref]]\n* **oidc-user-service-ref**\nReference to the OpenID Connect `OAuth2UserService`.\n\n[[nsa-oauth2-login-login-processing-url]]\n* **login-processing-url**\nThe URI where the filter processes authentication requests.\n\n[[nsa-oauth2-login-login-page]]\n* **login-page**\nThe URI to send users to login.\n\n[[nsa-oauth2-login-authentication-success-handler-ref]]\n* **authentication-success-handler-ref**\nReference to the `AuthenticationSuccessHandler`.\n\n[[nsa-oauth2-login-authentication-failure-handler-ref]]\n* **authentication-failure-handler-ref**\nReference to the `AuthenticationFailureHandler`.\n\n[[nsa-oauth2-login-jwt-decoder-factory-ref]]\n* **jwt-decoder-factory-ref**\nReference to the `JwtDecoderFactory` used by `OidcAuthorizationCodeAuthenticationProvider`.\n\n[[nsa-oauth2-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<oauth2-login> Attributes", "heading_level": 3, "file_order": 66, "section_index": 79, "content_hash": "6638c960de95db2fcd1482ce7a231bb213413f2b55371c174d40fb37635fb483", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:a472f2dfc526d74af6931db3db9175e55f7d22810795861fbeef187d421b7477", "content": "Configures xref:servlet/oauth2/client/index.adoc#oauth2client[OAuth 2.0 Client] support.\n\n[[nsa-oauth2-client-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<oauth2-client>", "heading_level": 2, "file_order": 66, "section_index": 80, "content_hash": "a472f2dfc526d74af6931db3db9175e55f7d22810795861fbeef187d421b7477", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:ae1a117b414290d3647f2aeeca04b836ad09de58334366fd4879bac2dde43ba2", "content": "* <<nsa-http,http>>\n\n[[nsa-oauth2-client-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <oauth2-client>", "heading_level": 3, "file_order": 66, "section_index": 81, "content_hash": "ae1a117b414290d3647f2aeeca04b836ad09de58334366fd4879bac2dde43ba2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:2e12a2ee830b33b03a00dfff140d98739e1ee623cfda28b92d5b925ba66d5f7e", "content": "[[nsa-oauth2-client-client-registration-repository-ref]]\n* **client-registration-repository-ref**\nReference to the `ClientRegistrationRepository`.\n\n[[nsa-oauth2-client-authorized-client-repository-ref]]\n* **authorized-client-repository-ref**\nReference to the `OAuth2AuthorizedClientRepository`.\n\n[[nsa-oauth2-client-authorized-client-service-ref]]\n* **authorized-client-service-ref**\nReference to the `OAuth2AuthorizedClientService`.\n\n[[nsa-oauth2-client-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<oauth2-client> Attributes", "heading_level": 3, "file_order": 66, "section_index": 82, "content_hash": "2e12a2ee830b33b03a00dfff140d98739e1ee623cfda28b92d5b925ba66d5f7e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5478f28aea7fec72d31d1f70eaa1b0073bae5af576227716f696919d62cf046a", "content": "* <<nsa-authorization-code-grant,authorization-code-grant>>\n\n[[nsa-authorization-code-grant]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <oauth2-client>", "heading_level": 3, "file_order": 66, "section_index": 83, "content_hash": "5478f28aea7fec72d31d1f70eaa1b0073bae5af576227716f696919d62cf046a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:f2e57b03b1168700a8b1817d910a6b3184d19f90d88b53731b58ec71eb7584ff", "content": "Configures xref:servlet/oauth2/client/authorization-grants.adoc#oauth2Client-auth-grant-support[OAuth 2.0 Authorization Code Grant].\n\n[[nsa-authorization-code-grant-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<authorization-code-grant>", "heading_level": 2, "file_order": 66, "section_index": 84, "content_hash": "f2e57b03b1168700a8b1817d910a6b3184d19f90d88b53731b58ec71eb7584ff", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:1319c0598febc62dfefd039b863b4fb1336d49f5255f776ff51cd8baf25229be", "content": "* <<nsa-oauth2-client,oauth2-client>>\n\n[[nsa-authorization-code-grant-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <authorization-code-grant>", "heading_level": 3, "file_order": 66, "section_index": 85, "content_hash": "1319c0598febc62dfefd039b863b4fb1336d49f5255f776ff51cd8baf25229be", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:d4c10cd9859cd5c9fc6f3811ffe85aa4356dcbab60bde33d5b4916335c1b089f", "content": "[[nsa-authorization-code-grant-authorization-request-repository-ref]]\n* **authorization-request-repository-ref**\nReference to the `AuthorizationRequestRepository`.\n\n[[nsa-authorization-code-grant-authorization-redirect-strategy-ref]]\n* **authorization-redirect-strategy-ref**\nReference to the authorization `RedirectStrategy`.\n\n[[nsa-authorization-code-grant-authorization-request-resolver-ref]]\n* **authorization-request-resolver-ref**\nReference to the `OAuth2AuthorizationRequestResolver`.\n\n[[nsa-authorization-code-grant-access-token-response-client-ref]]\n* **access-token-response-client-ref**\nReference to the `OAuth2AccessTokenResponseClient`.\n\n[[nsa-client-registrations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<authorization-code-grant> Attributes", "heading_level": 3, "file_order": 66, "section_index": 86, "content_hash": "d4c10cd9859cd5c9fc6f3811ffe85aa4356dcbab60bde33d5b4916335c1b089f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:7826f57348a1ddff803e63ebe733e40ab621ba501d04c616e876298b836891b3", "content": "A container element for client(s) registered (xref:servlet/oauth2/client/index.adoc#oauth2Client-client-registration[ClientRegistration]) with an OAuth 2.0 or OpenID Connect 1.0 Provider.\n\n[[nsa-client-registrations-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<client-registrations>", "heading_level": 2, "file_order": 66, "section_index": 87, "content_hash": "7826f57348a1ddff803e63ebe733e40ab621ba501d04c616e876298b836891b3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:cf3ae600822b424cec10aa1bf23afee4660f18548366ff9e6d93e3a27a9098a4", "content": "* <<nsa-client-registration,client-registration>>\n* <<nsa-provider,provider>>\n\n[[nsa-client-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <client-registrations>", "heading_level": 3, "file_order": 66, "section_index": 88, "content_hash": "cf3ae600822b424cec10aa1bf23afee4660f18548366ff9e6d93e3a27a9098a4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:e32f715cd64171aefdf05adb89abb723d21480f29c51176fa141811720ae81b6", "content": "Represents a client registered with an OAuth 2.0 or OpenID Connect 1.0 Provider.\n\n[[nsa-client-registration-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<client-registration>", "heading_level": 2, "file_order": 66, "section_index": 89, "content_hash": "e32f715cd64171aefdf05adb89abb723d21480f29c51176fa141811720ae81b6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5b1c975e274269aea501df3997c4a71f444daa50489ae32febf512c7a4b78ea3", "content": "* <<nsa-client-registrations,client-registrations>>\n\n[[nsa-client-registration-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <client-registration>", "heading_level": 3, "file_order": 66, "section_index": 90, "content_hash": "5b1c975e274269aea501df3997c4a71f444daa50489ae32febf512c7a4b78ea3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:d69a7166ecea4ec7c417a175b88caeb3cf8aa47315447afbec143a1a34e4be23", "content": "[[nsa-client-registration-registration-id]]\n* **registration-id**\nThe ID that uniquely identifies the `ClientRegistration`.\n\n[[nsa-client-registration-client-id]]\n* **client-id**\nThe client identifier.\n\n[[nsa-client-registration-client-secret]]\n* **client-secret**\nThe client secret.\n\n[[nsa-client-registration-client-authentication-method]]\n* **client-authentication-method**\nThe method used to authenticate the Client with the Provider.\nThe supported values are *client_secret_basic*, *client_secret_post*, *private_key_jwt*, *client_secret_jwt* and *none* https://tools.ietf.org/html/rfc6749#section-2.1[(public clients)].\n\n[[nsa-client-registration-authorization-grant-type]]\n* **authorization-grant-type**\nThe OAuth 2.0 Authorization Framework defines four https://tools.ietf.org/html/rfc6749#section-1.3[Authorization Grant] types.\nThe supported values are `authorization_code`, `client_credentials`, `password`, as well as, extension grant type `urn:ietf:params:oauth:grant-type:jwt-bearer`.\n\n[[nsa-client-registration-redirect-uri]]\n* **redirect-uri**\nThe client's registered redirect URI that the _Authorization Server_ redirects the end-user's user-agent to after the end-user has authenticated and authorized access to the client.\n\n[[nsa-client-registration-scope]]\n* **scope**\nThe scope(s) requested by the client during the Authorization Request flow, such as openid, email, or profile.\n\n[[nsa-client-registration-client-name]]\n* **client-name**\nA descriptive name used for the client.\nThe name may be used in certain scenarios, such as when displaying the name of the client in the auto-generated login page.\n\n[[nsa-client-registration-provider-id]]\n* **provider-id**\nA reference to the associated provider. May reference a `<provider>` element or use one of the common providers (google, github, facebook, okta).\n\n[[nsa-provider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<client-registration> Attributes", "heading_level": 3, "file_order": 66, "section_index": 91, "content_hash": "d69a7166ecea4ec7c417a175b88caeb3cf8aa47315447afbec143a1a34e4be23", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5e9890c512304be8c6c26ebaa01e768edd185a955d242aed01224fc54c806973", "content": "The configuration information for an OAuth 2.0 or OpenID Connect 1.0 Provider.\n\n[[nsa-provider-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<provider>", "heading_level": 2, "file_order": 66, "section_index": 92, "content_hash": "5e9890c512304be8c6c26ebaa01e768edd185a955d242aed01224fc54c806973", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:4adf500116f966f79c0e345293f4e93076497fd4d6eb3f9346b8dd44002106da", "content": "* <<nsa-client-registrations,client-registrations>>\n\n[[nsa-provider-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <provider>", "heading_level": 3, "file_order": 66, "section_index": 93, "content_hash": "4adf500116f966f79c0e345293f4e93076497fd4d6eb3f9346b8dd44002106da", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:505f676db5040c0f6bbf989401a793faa69f7d7ac509cdf9497f30c32747b2cb", "content": "[[nsa-provider-provider-id]]\n* **provider-id**\nThe ID that uniquely identifies the provider.\n\n[[nsa-provider-authorization-uri]]\n* **authorization-uri**\nThe Authorization Endpoint URI for the Authorization Server.\n\n[[nsa-provider-token-uri]]\n* **token-uri**\nThe Token Endpoint URI for the Authorization Server.\n\n[[nsa-provider-user-info-uri]]\n* **user-info-uri**\nThe UserInfo Endpoint URI used to access the claims/attributes of the authenticated end-user.\n\n[[nsa-provider-user-info-authentication-method]]\n* **user-info-authentication-method**\nThe authentication method used when sending the access token to the UserInfo Endpoint.\nThe supported values are *header*, *form* and *query*.\n\n[[nsa-provider-user-info-user-name-attribute]]\n* **user-info-user-name-attribute**\nThe name of the attribute returned in the UserInfo Response that references the Name or Identifier of the end-user.\n\n[[nsa-provider-jwk-set-uri]]\n* **jwk-set-uri**\nThe URI used to retrieve the https://tools.ietf.org/html/rfc7517[JSON Web Key (JWK)] Set from the Authorization Server, which contains the cryptographic key(s) used to verify the https://tools.ietf.org/html/rfc7515[JSON Web Signature (JWS)] of the ID Token and optionally the UserInfo Response.\n\n[[nsa-provider-issuer-uri]]\n* **issuer-uri**\nThe URI used to initially configure a `ClientRegistration` using discovery of an OpenID Connect Provider's https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[Configuration endpoint] or an Authorization Server's https://tools.ietf.org/html/rfc8414#section-3[Metadata endpoint].\n\n[[nsa-oauth2-resource-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<provider> Attributes", "heading_level": 3, "file_order": 66, "section_index": 94, "content_hash": "505f676db5040c0f6bbf989401a793faa69f7d7ac509cdf9497f30c32747b2cb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:3bef70659c228c22f14691a82c98ad74ca348f0bc11e2257e14875caec50664a", "content": "Adds a `BearerTokenAuthenticationFilter`, `BearerTokenAuthenticationEntryPoint`, and `BearerTokenAccessDeniedHandler` to the configuration.\nIn addition, either `<jwt>` or `<opaque-token>` must be specified.\n\n[[nsa-oauth2-resource-server-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<oauth2-resource-server>", "heading_level": 2, "file_order": 66, "section_index": 95, "content_hash": "3bef70659c228c22f14691a82c98ad74ca348f0bc11e2257e14875caec50664a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:854d9b56f978c4aba961f4241c2eb8c8ef2662350b17f5eded733182fb796586", "content": "* <<nsa-http,http>>\n\n[[nsa-oauth2-resource-server-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parents Elements of <oauth2-resource-server>", "heading_level": 3, "file_order": 66, "section_index": 96, "content_hash": "854d9b56f978c4aba961f4241c2eb8c8ef2662350b17f5eded733182fb796586", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:4642919b446dd8fa9882df5d003053fefe5ebb11ce39f788075ee0b838c0a68c", "content": "* <<nsa-jwt,jwt>>\n* <<nsa-opaque-token,opaque-token>>\n\n[[nsa-oauth2-resource-server-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <oauth2-resource-server>", "heading_level": 3, "file_order": 66, "section_index": 97, "content_hash": "4642919b446dd8fa9882df5d003053fefe5ebb11ce39f788075ee0b838c0a68c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:e22f833c01e45c6e8061fdc1746a34279f9c070e7fff0ac509e5aeb3abe7169b", "content": "[[nsa-oauth2-resource-server-authentication-manager-resolver-ref]]\n* **authentication-manager-resolver-ref**\nReference to an `AuthenticationManagerResolver` which will resolve the `AuthenticationManager` at request time\n\n[[nsa-oauth2-resource-server-bearer-token-resolver-ref]]\n* **bearer-token-resolver-ref**\nReference to a `BearerTokenResolver` which will retrieve the bearer token from the request.\nThis cannot be used in conjunction with `authentication-converter-ref`\n\n[[nsa-oauth2-resource-server-entry-point-ref]]\n* **entry-point-ref**\nReference to a `AuthenticationEntryPoint` which will handle unauthorized requests\n\n[[nsa-oauth2-resource-server-authentication-converter-ref]]\n* **authentication-converter-ref**\nReference to a `AuthenticationConverter` which convert request to authentication.\nThis cannot be used in conjunction with `bearer-token-resolver-ref`\n\n[[nsa-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<oauth2-resource-server> Attributes", "heading_level": 3, "file_order": 66, "section_index": 98, "content_hash": "e22f833c01e45c6e8061fdc1746a34279f9c070e7fff0ac509e5aeb3abe7169b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:0701d736cd96729d21f5c3be22d54b0c2e3d01521e9b83b039b3b7f1ec017407", "content": "Represents an OAuth 2.0 Resource Server that will authorize JWTs\n\n[[nsa-jwt-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<jwt>", "heading_level": 2, "file_order": 66, "section_index": 99, "content_hash": "0701d736cd96729d21f5c3be22d54b0c2e3d01521e9b83b039b3b7f1ec017407", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:a5d2620d604afaa21da9fbe367ae6d62ade4e0fd459cb2d9da3cf6d64b24fffb", "content": "* <<nsa-oauth2-resource-server,oauth2-resource-server>>\n\n[[nsa-jwt-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <jwt>", "heading_level": 3, "file_order": 66, "section_index": 100, "content_hash": "a5d2620d604afaa21da9fbe367ae6d62ade4e0fd459cb2d9da3cf6d64b24fffb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:c62c37489cd5db130b7def2baced430887ac64c6eb56db430a1064339565d30c", "content": "[[nsa-jwt-jwt-authentication-converter-ref]]\n* **jwt-authentication-converter-ref**\nReference to a `Converter<Jwt, AbstractAuthenticationToken>`\n\n[[nsa-jwt-decoder-ref]]\n* **jwt-decoder-ref**\nReference to a `JwtDecoder`. This is a larger component that overrides `jwk-set-uri`\n\n[[nsa-jwt-jwk-set-uri]]\n* **jwk-set-uri**\nThe JWK Set Uri used to load signing verification keys from an OAuth 2.0 Authorization Server\n\n[[nsa-opaque-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<jwt> Attributes", "heading_level": 3, "file_order": 66, "section_index": 101, "content_hash": "c62c37489cd5db130b7def2baced430887ac64c6eb56db430a1064339565d30c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:bab41d6cda15f24d2c368997850e05d79574b987ac4b507d8efb78982ce32e00", "content": "Represents an OAuth 2.0 Resource Server that will authorize opaque tokens\n\n[[nsa-opaque-token-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<opaque-token>", "heading_level": 2, "file_order": 66, "section_index": 102, "content_hash": "bab41d6cda15f24d2c368997850e05d79574b987ac4b507d8efb78982ce32e00", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5a7f800195c3c8541f559716f66e7084846855a91b0a53fc2604d7e153fe2b1e", "content": "* <<nsa-oauth2-resource-server,oauth2-resource-server>>\n\n[[nsa-opaque-token-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <opaque-token>", "heading_level": 3, "file_order": 66, "section_index": 103, "content_hash": "5a7f800195c3c8541f559716f66e7084846855a91b0a53fc2604d7e153fe2b1e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:41aa40059513258277857d46cc499e2938d8b61ffaead11cf4e0d3321abba151", "content": "[[nsa-opaque-token-introspector-ref]]\n* **introspector-ref**\nReference to an `OpaqueTokenIntrospector`. This is a larger component that overrides `introspection-uri`, `client-id`, and `client-secret`.\n\n[[nsa-opaque-token-introspection-uri]]\n* **introspection-uri**\nThe Introspection Uri used to introspect the details of an opaque token. Should be accompanied with a `client-id` and `client-secret`.\n\n[[nsa-opaque-token-client-id]]\n* **client-id**\nThe Client Id to use for client authentication against the provided `introspection-uri`.\n\n[[nsa-opaque-token-client-secret]]\n* **client-secret**\nThe Client Secret to use for client authentication against the provided `introspection-uri`.\n\n[[nsa-opaque-token-authentication-converter-ref]]\n* **authentication-converter-ref**\nReference to an `OpaqueTokenAuthenticationConverter`. Responsible for converting successful introspection result into an `Authentication` instance.\n\n[[nsa-relying-party-registrations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<opaque-token> Attributes", "heading_level": 3, "file_order": 66, "section_index": 104, "content_hash": "41aa40059513258277857d46cc499e2938d8b61ffaead11cf4e0d3321abba151", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:e20fa2d47e441f0fcad985069f146994d0730d101ed36816f7e41068a6d9c817", "content": "The container element for relying party(ies) registered (xref:servlet/saml2/login/overview.adoc#servlet-saml2login-relyingpartyregistration[ClientRegistration]) with a SAML 2.0 Identity Provider.\n\n[[nsa-relying-party-registrations-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<relying-party-registrations>", "heading_level": 2, "file_order": 66, "section_index": 105, "content_hash": "e20fa2d47e441f0fcad985069f146994d0730d101ed36816f7e41068a6d9c817", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:dd51e0e41fc170b6ac023e39470f3ea1c71d0b690da5ac74d66e2bb4e24b739e", "content": "[[nsa-relying-party-registrations-id]]\n* **id**\nThe ID that uniquely identifies the `RelyingPartyRegistrationRepository`.\n\n[[nsa-relying-party-registrations-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<relying-party-registrations> Attributes", "heading_level": 3, "file_order": 66, "section_index": 106, "content_hash": "dd51e0e41fc170b6ac023e39470f3ea1c71d0b690da5ac74d66e2bb4e24b739e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:ef49a667a053bbb3462d2df92d5819ac171d46fa2c1acd9f9d15ee271877bdfa", "content": "* <<nsa-asserting-party,asserting-party>>\n* <<nsa-relying-party-registration,relying-party-registration>>\n\n[[nsa-relying-party-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <relying-party-registrations>", "heading_level": 3, "file_order": 66, "section_index": 107, "content_hash": "ef49a667a053bbb3462d2df92d5819ac171d46fa2c1acd9f9d15ee271877bdfa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:bf9fb7808ba4a0f43141c973dfd4c26a108588728f72229f47e47a9d3e01d2a6", "content": "Represents a relying party registered with a SAML 2.0 Identity Provider\n\n[[nsa-relying-party-registration-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<relying-party-registration>", "heading_level": 2, "file_order": 66, "section_index": 108, "content_hash": "bf9fb7808ba4a0f43141c973dfd4c26a108588728f72229f47e47a9d3e01d2a6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:23cb68520f8febd14e3cd3269baa0cd926fadc5dfc02bd110fc9b8e104864393", "content": "* <<nsa-relying-party-registrations,relying-party-registrations>>\n\n[[nsa-relying-party-registration-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <relying-party-registration>", "heading_level": 3, "file_order": 66, "section_index": 109, "content_hash": "23cb68520f8febd14e3cd3269baa0cd926fadc5dfc02bd110fc9b8e104864393", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:88191d9d75ff01f6e93bcf84b74f2ecd228406891f68406e4fe7e1ea6ea9d878", "content": "[[nsa-relying-party-registration-registration-id]]\n* **registration-id**\nThe ID that uniquely identifies the `RelyingPartyRegistration`.\n\n[[nsa-relying-party-registration-metadata-location]]\n* **metadata-location**\nThe asserting party metadata location.\n\n[[nsa-relying-party-registration-entity-id]]\n* **client-id**\nThe relying party's https://www.oasis-open.org/committees/download.php/51890/SAML%20MD%20simplified%20overview.pdf#2.9%20EntityDescriptor[EntityID].\n\n[[nsa-relying-party-registration-assertion-consumer-service-location]]\n* **assertion-consumer-service-location**\nThe AssertionConsumerService Location. Equivalent to the value found in `&lt;AssertionConsumerService Location=\"...\"/&gt;` in the relying party's `&lt;SPSSODescriptor&gt;`.\n\n[[nsa-relying-party-registration-assertion-consumer-service-binding]]\n* **assertion-consumer-service-binding**\nthe AssertionConsumerService Binding. Equivalent to the value found in `&lt;AssertionConsumerService Binding=\"...\"/&gt;` in the relying party's `&lt;SPSSODescriptor&gt;`.\nThe supported values are *POST* and *REDIRECT*.\n\n[[nsa-relying-party-registration-single-logout-service-location]]\n* **single-logout-service-location**\nThe SingleLogoutService Location. Equivalent to the value found in &lt;SingleLogoutService Location=\"...\"/&gt; in the relying party's &lt;SPSSODescriptor&gt;.\n\n[[nsa-relying-party-registration-single-logout-service-response-location]]\n* **single-logout-service-response-location**\nThe SingleLogoutService ResponseLocation. Equivalent to the value found in &lt;SingleLogoutService ResponseLocation=\"...\"/&gt; in the relying party's &lt;SPSSODescriptor&gt;.\n\n[[nsa-relying-party-registration-single-logout-service-binding]]\n* **single-logout-service-binding**\nThe SingleLogoutService Binding. Equivalent to the value found in &lt;SingleLogoutService Binding=\"...\"/&gt; in the relying party's &lt;SPSSODescriptor&gt;.\nThe supported values are *POST* and *REDIRECT*.\n\n[[nsa-relying-party-registration-asserting-party-id]]\n* **asserting-party-id**\nA reference to the associated asserting party. Must reference an `<asserting-party>` element.\n\n[[nsa-relying-party-registration-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<relying-party-registration> Attributes", "heading_level": 3, "file_order": 66, "section_index": 110, "content_hash": "88191d9d75ff01f6e93bcf84b74f2ecd228406891f68406e4fe7e1ea6ea9d878", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:47b3662c7ed19e54b676028b9c3cd48097011a0ab0c89b6ca0b74a0172b8cd20", "content": "* <<nsa-decryption-credential,decryption-credential>>\n* <<nsa-signing-credential,signing-credential>>\n\n[[nsa-decryption-credential]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <relying-party-registration>", "heading_level": 3, "file_order": 66, "section_index": 111, "content_hash": "47b3662c7ed19e54b676028b9c3cd48097011a0ab0c89b6ca0b74a0172b8cd20", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:2269c34cf4fdde4ec3bb2c357764119059df066199327ab384605a417ab75c02", "content": "The decryption credentials associated with the relying party.\n\n[[nsa-decryption-credential-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<decryption-credential>", "heading_level": 2, "file_order": 66, "section_index": 112, "content_hash": "2269c34cf4fdde4ec3bb2c357764119059df066199327ab384605a417ab75c02", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:f1f336b0b2427ab3242b4c30286a0113cecab4f46227264a47bffe1ba76eb9e0", "content": "* <<nsa-relying-party-registration,relying-party-registration>>\n\n[[nsa-decryption-credential-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <decryption-credential>", "heading_level": 3, "file_order": 66, "section_index": 113, "content_hash": "f1f336b0b2427ab3242b4c30286a0113cecab4f46227264a47bffe1ba76eb9e0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:f11d2e6733986c545f98a5ddc25baa9d9cef49cc44e039651471e6043c87a100", "content": "[[nsa-decryption-credential-certificate-location]]\n* **certificate-location**\nThe location to get the certificate\n\n[[nsa-decryption-credential-private-key-location]]\n* **private-key-location**\nThe location to get the Relying Party's private key\n\n[[nsa-signing-credential]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<decryption-credential> Attributes", "heading_level": 3, "file_order": 66, "section_index": 114, "content_hash": "f11d2e6733986c545f98a5ddc25baa9d9cef49cc44e039651471e6043c87a100", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:94ffba5e2be6420926830ccda9fb6f7161135e5daa9a399d6e14af381678d3fe", "content": "The signing credentials associated with the relying party.\n\n[[nsa-signing-credential-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<signing-credential>", "heading_level": 2, "file_order": 66, "section_index": 115, "content_hash": "94ffba5e2be6420926830ccda9fb6f7161135e5daa9a399d6e14af381678d3fe", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:cd4b22b5e39e1215ed59d48c6289a29fb68e89991f9b4e19d911a066c9029ba7", "content": "* <<nsa-relying-party-registration,relying-party-registration>>\n\n[[nsa-signing-credential-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <verification-credential>", "heading_level": 3, "file_order": 66, "section_index": 116, "content_hash": "cd4b22b5e39e1215ed59d48c6289a29fb68e89991f9b4e19d911a066c9029ba7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:343d88ddeb290a477c4a9e8742f743e261ddbc2e6ffad6ec1905b554244eb164", "content": "[[nsa-signing-credential-certificate-location]]\n* **certificate-location**\nThe location to get this certificate\n\n[[nsa-signing-credential-private-key-location]]\n* **private-key-location**\nThe location to get the Relying Party's private key\n\n[[nsa-asserting-party]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<verification-credential> Attributes", "heading_level": 3, "file_order": 66, "section_index": 117, "content_hash": "343d88ddeb290a477c4a9e8742f743e261ddbc2e6ffad6ec1905b554244eb164", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:4f4c3679a9ed90a54c39efa17a5b22ed2b46102d4520652bff30d385b6b2a782", "content": "The configuration information for a SAML 2.0 Asserting Party.\n\n[[nsa-asserting-party-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<asserting-party>", "heading_level": 2, "file_order": 66, "section_index": 118, "content_hash": "4f4c3679a9ed90a54c39efa17a5b22ed2b46102d4520652bff30d385b6b2a782", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:bab0d67e2977cd7913405a1fb88b6b66a333413d23cf8d3734fd3448592d6ba2", "content": "* <<nsa-relying-party-registrations,relying-party-registrations>>\n\n[[nsa-asserting-party-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <asserting-party>", "heading_level": 3, "file_order": 66, "section_index": 119, "content_hash": "bab0d67e2977cd7913405a1fb88b6b66a333413d23cf8d3734fd3448592d6ba2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:c5135565c24880ef295d5d050dd8e5a5ec99e01da4b804de37d286c9487bd6c4", "content": "[[nsa-asserting-party-asserting-party-id]]\n* **asserting-party-id**\nThe ID that uniquely identifies the asserting party.\n\n[[nsa-asserting-party-entity-id]]\n* **entity-id**\nThe EntityID of the Asserting Party\n\n[[nsa-asserting-party-want-authn-requests-signed]]\n* **want-authn-requests-signed**\nThe `WantAuthnRequestsSigned` setting, indicating the asserting party's preference that relying parties should sign the `AuthnRequest` before sending.\n\n[[nsa-asserting-party-single-sign-on-service-location]]\n* **single-sign-on-service-location**\nThe https://www.oasis-open.org/committees/download.php/51890/SAML%20MD%20simplified%20overview.pdf#2.5%20Endpoint[SingleSignOnService] Location.\n\n[[nsa-asserting-party-single-sign-on-service-binding]]\n* **single-sign-on-service-binding**\nThe https://www.oasis-open.org/committees/download.php/51890/SAML%20MD%20simplified%20overview.pdf#2.5%20Endpoint[SingleSignOnService] Binding.\nThe supported values are *POST* and *REDIRECT*.\n\n[[nsa-asserting-party-signing-algorithms]]\n* **signing-algorithms**\nThe list of `org.opensaml.saml.ext.saml2alg.SigningMethod` Algorithms for this asserting party, in preference order.\n\n[[nsa-asserting-party-single-logout-service-location]]\n* **single-logout-service-location**\nThe SingleLogoutService Location. Equivalent to the value found in &lt;SingleLogoutService Location=\"...\"/&gt; in the asserting party's &lt;IDPSSODescriptor&gt;.\n\n[[nsa-asserting-party-single-logout-service-response-location]]\n* **single-logout-service-response-location**\nThe SingleLogoutService ResponseLocation. Equivalent to the value found in &lt;SingleLogoutService ResponseLocation=\"...\"/&gt; in the asserting party's &lt;IDPSSODescriptor&gt;.\n\n[[nsa-asserting-party-single-logout-service-binding]]\n* **single-logout-service-binding**\nThe SingleLogoutService Binding. Equivalent to the value found in &lt;SingleLogoutService Binding=\"...\"/&gt; in the asserting party's &lt;IDPSSODescriptor&gt;.\nThe supported values are *POST* and *REDIRECT*.\n\n[[nsa-asserting-party-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<asserting-party> Attributes", "heading_level": 3, "file_order": 66, "section_index": 120, "content_hash": "c5135565c24880ef295d5d050dd8e5a5ec99e01da4b804de37d286c9487bd6c4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:e0e308dccd21b29dad750120396fb835cf871ec9436615058395fcac949dd296", "content": "* <<nsa-encryption-credential,encryption-credential>>\n* <<nsa-verification-credential,verification-credential>>\n\n[[nsa-encryption-credential]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <asserting-party>", "heading_level": 3, "file_order": 66, "section_index": 121, "content_hash": "e0e308dccd21b29dad750120396fb835cf871ec9436615058395fcac949dd296", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:713cddf337917b1906eeece7599175a9dda11b1279fa8a9ba860550ec3358d8e", "content": "The encryption credentials associated with the asserting party.\n\n[[nsa-encryption-credential-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<encryption-credential>", "heading_level": 2, "file_order": 66, "section_index": 122, "content_hash": "713cddf337917b1906eeece7599175a9dda11b1279fa8a9ba860550ec3358d8e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:010b2a6cf37d9813eeeb5acffabf9d52fbda67b067935728a3f29c9498241910", "content": "* <<nsa-asserting-party,asserting-party>>\n\n[[nsa-encryption-credential-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <encryption-credential>", "heading_level": 3, "file_order": 66, "section_index": 123, "content_hash": "010b2a6cf37d9813eeeb5acffabf9d52fbda67b067935728a3f29c9498241910", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:66a8deb01508ca36f05413146567325df93ff0de2b81bdcf625ae210af7132e6", "content": "[[nsa-encryption-credential-certificate-location]]\n* **certificate-location**\nThe location to get the certificate\n\n[[nsa-encryption-credential-private-key-location]]\n* **private-key-location**\nThe location to get the Relying Party's private key\n\n[[nsa-verification-credential]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<encryption-credential> Attributes", "heading_level": 3, "file_order": 66, "section_index": 124, "content_hash": "66a8deb01508ca36f05413146567325df93ff0de2b81bdcf625ae210af7132e6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5d36d8dd1f640defad30280472fe25c3b284748f0f96551e64af7b8d3d80a745", "content": "The verification credentials associated with the asserting party.\n\n[[nsa-verification-credential-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<verification-credential>", "heading_level": 2, "file_order": 66, "section_index": 125, "content_hash": "5d36d8dd1f640defad30280472fe25c3b284748f0f96551e64af7b8d3d80a745", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:d1e4afd1b9f6dfb8c3104a4d8b4d8c6ade59e0d88bc2eb5ac6de9c5238436f86", "content": "* <<nsa-asserting-party,asserting-party>>\n\n[[nsa-verification-credential-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <verification-credential>", "heading_level": 3, "file_order": 66, "section_index": 126, "content_hash": "d1e4afd1b9f6dfb8c3104a4d8b4d8c6ade59e0d88bc2eb5ac6de9c5238436f86", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:8e89466da860acbdf812e47a0a032642e163d0eb3284887c2ef618df41647c01", "content": "[[nsa-verification-credential-certificate-location]]\n* **certificate-location**\nThe location to get this certificate\n\n[[nsa-verification-credential-private-key-location]]\n* **private-key-location**\nThe location to get the Relying Party's private key\n\n[[nsa-http-basic]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<verification-credential> Attributes", "heading_level": 3, "file_order": 66, "section_index": 127, "content_hash": "8e89466da860acbdf812e47a0a032642e163d0eb3284887c2ef618df41647c01", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:eb1e4bef56d33def3aefcd44d36eb16d52df49de34e8b97ed878a23b43572426", "content": "Adds a `BasicAuthenticationFilter` and `BasicAuthenticationEntryPoint` to the configuration.\nThe latter will only be used as the configuration entry point if form-based login is not enabled.\n\n[[nsa-http-basic-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<http-basic>", "heading_level": 2, "file_order": 66, "section_index": 128, "content_hash": "eb1e4bef56d33def3aefcd44d36eb16d52df49de34e8b97ed878a23b43572426", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:e1a8fd0fa16ff213f29c891ba33fd94351801ab2a7ae34eab3ca0d5ed912241f", "content": "* <<nsa-http,http>>\n\n[[nsa-http-basic-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <http-basic>", "heading_level": 3, "file_order": 66, "section_index": 129, "content_hash": "e1a8fd0fa16ff213f29c891ba33fd94351801ab2a7ae34eab3ca0d5ed912241f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:205129814129be0a954c8e7e9709f43fc116e5e8dfef19f5cf7a5ba702a33036", "content": "[[nsa-http-basic-authentication-details-source-ref]]\n* **authentication-details-source-ref**\nReference to an `AuthenticationDetailsSource` which will be used by the authentication filter\n\n[[nsa-http-basic-entry-point-ref]]\n* **entry-point-ref**\nSets the `AuthenticationEntryPoint` which is used by the `BasicAuthenticationFilter`.\n\n[[nsa-http-firewall]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<http-basic> Attributes", "heading_level": 3, "file_order": 66, "section_index": 130, "content_hash": "205129814129be0a954c8e7e9709f43fc116e5e8dfef19f5cf7a5ba702a33036", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:7cc8804f15cd0cd57d768673d1411b924d5ceb8029c50eaf867cb428a9a535f6", "content": "This is a top-level element which can be used to inject a custom implementation of `HttpFirewall` into the `FilterChainProxy` created by the namespace.\nThe default implementation should be suitable for most applications.\n\n[[nsa-http-firewall-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<http-firewall> Element", "heading_level": 2, "file_order": 66, "section_index": 131, "content_hash": "7cc8804f15cd0cd57d768673d1411b924d5ceb8029c50eaf867cb428a9a535f6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:c05b687852b4f174564d9ace8bb222826e0620fd0d41e1a2fa905ec126125551", "content": "[[nsa-http-firewall-ref]]\n* **ref**\nDefines a reference to a Spring bean that implements `HttpFirewall`.\n\n[[nsa-intercept-url]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<http-firewall> Attributes", "heading_level": 3, "file_order": 66, "section_index": 132, "content_hash": "c05b687852b4f174564d9ace8bb222826e0620fd0d41e1a2fa905ec126125551", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:32c9f7509f222c6ed2b6049414c72969a207c6d0e4effd8ec61ddc0bcf57f5ed", "content": "This element is used to define the set of URL patterns that the application is interested in and to configure how they should be handled.\nIt is used to construct the `FilterInvocationSecurityMetadataSource` used by the `FilterSecurityInterceptor`.\nIt is also responsible for configuring a `ChannelProcessingFilter` if particular URLs need to be accessed by HTTPS, for example.\nWhen matching the specified patterns against an incoming request, the matching is done in the order in which the elements are declared.\nSo the most specific patterns should come first and the most general should come last.\n\n[[nsa-intercept-url-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<intercept-url>", "heading_level": 2, "file_order": 66, "section_index": 133, "content_hash": "32c9f7509f222c6ed2b6049414c72969a207c6d0e4effd8ec61ddc0bcf57f5ed", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:ba4d6d1691c9ccb0872d2c5293335b188a0fcc82d92bb4decb2a73821ed38250", "content": "* <<nsa-filter-security-metadata-source,filter-security-metadata-source>>\n* <<nsa-http,http>>\n\n[[nsa-intercept-url-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <intercept-url>", "heading_level": 3, "file_order": 66, "section_index": 134, "content_hash": "ba4d6d1691c9ccb0872d2c5293335b188a0fcc82d92bb4decb2a73821ed38250", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:d050f6b976dbd9a722be4fcffa3cc3d0e7d0d535a8801d09f0bdb351197cd227", "content": "[[nsa-intercept-url-access]]\n* **access**\nLists the access attributes which will be stored in the `FilterInvocationSecurityMetadataSource` for the defined URL pattern/method combination.\nThis should be a comma-separated list of the security configuration attributes (such as role names).\n\n[[nsa-intercept-url-method]]\n* **method**\nThe HTTP Method which will be used in combination with the pattern and servlet path (optional) to match an incoming request.\nIf omitted, any method will match.\nIf an identical pattern is specified with and without a method, the method-specific match will take precedence.\n\n[[nsa-intercept-url-pattern]]\n* **pattern**\nThe pattern which defines the URL path.\nThe content will depend on the `request-matcher` attribute from the containing http element, so will default to MVC matcher if Spring MVC is in the classpath.\n\n[[nsa-intercept-url-request-matcher-ref]]\n* **request-matcher-ref**\nA reference to a `RequestMatcher` that will be used to determine if this `<intercept-url>` is used.\n\n[[nsa-intercept-url-requires-channel]]\n* **requires-channel**\nCan be \"http\" or \"https\" depending on whether a particular URL pattern should be accessed over HTTP or HTTPS respectively.\nAlternatively the value \"any\" can be used when there is no preference.\nIf this attribute is present on any `<intercept-url>` element, then a `ChannelProcessingFilter` will be added to the filter stack and its additional dependencies added to the application context.\n\nIf a `<port-mappings>` configuration is added, this will be used to by the `SecureChannelProcessor` and `InsecureChannelProcessor` beans to determine the ports used for redirecting to HTTP/HTTPS.\n\nNOTE: This property is invalid for <<nsa-filter-security-metadata-source,filter-security-metadata-source>>\n\n[[nsa-intercept-url-servlet-path]]\n* **servlet-path**\nThe servlet path which will be used in combination with the pattern and HTTP method to match an incoming request.\nThis attribute is only applicable when <<nsa-http-request-matcher,request-matcher>> is 'mvc'.\nIn addition, the value is only required in the following 2 use cases: 1) There are 2 or more `HttpServlet` 's registered in the `ServletContext` that have mappings starting with `'/'` and are different; 2) The pattern starts with the same value of a registered `HttpServlet` path, excluding the default (root) `HttpServlet` `'/'`.\n\nNOTE: This property is invalid for <<nsa-filter-security-metadata-source,filter-security-metadata-source>>\n\n[[nsa-jee]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<intercept-url> Attributes", "heading_level": 3, "file_order": 66, "section_index": 135, "content_hash": "d050f6b976dbd9a722be4fcffa3cc3d0e7d0d535a8801d09f0bdb351197cd227", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:86fa27c4025f8f14dfc8f745b9b82d812bccd9dded5bfa6c3c35480a0c9b0bbb", "content": "Adds a J2eePreAuthenticatedProcessingFilter to the filter chain to provide integration with container authentication.\n\n[[nsa-jee-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<jee>", "heading_level": 2, "file_order": 66, "section_index": 136, "content_hash": "86fa27c4025f8f14dfc8f745b9b82d812bccd9dded5bfa6c3c35480a0c9b0bbb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:689216e465481d88cb2363701f08cd8feca31ee4aed02aa38a6d3bcb4457e86d", "content": "* <<nsa-http,http>>\n\n[[nsa-jee-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <jee>", "heading_level": 3, "file_order": 66, "section_index": 137, "content_hash": "689216e465481d88cb2363701f08cd8feca31ee4aed02aa38a6d3bcb4457e86d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:ba40873a4e6851f167cc42e2e4086adf7fcc823d9773d2866b67bae674ecf5b5", "content": "[[nsa-jee-mappable-roles]]\n* **mappable-roles**\nA comma-separate list of roles to look for in the incoming HttpServletRequest.\n\n[[nsa-jee-user-service-ref]]\n* **user-service-ref**\nA reference to a user-service (or UserDetailsService bean) Id\n\n[[nsa-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<jee> Attributes", "heading_level": 3, "file_order": 66, "section_index": 138, "content_hash": "ba40873a4e6851f167cc42e2e4086adf7fcc823d9773d2866b67bae674ecf5b5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:ef16b5eae13eaae4c23cb13a43ec53ae83f9eb91a13500f0e1e2593500f35306", "content": "Adds a `LogoutFilter` to the filter stack.\nThis is configured with a `SecurityContextLogoutHandler`.\n\n[[nsa-logout-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<logout>", "heading_level": 2, "file_order": 66, "section_index": 139, "content_hash": "ef16b5eae13eaae4c23cb13a43ec53ae83f9eb91a13500f0e1e2593500f35306", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:1717913eeb9640a2052cfe13f90b51628633677fca85ac247de3becc9f99f3a2", "content": "* <<nsa-http,http>>\n\n[[nsa-logout-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <logout>", "heading_level": 3, "file_order": 66, "section_index": 140, "content_hash": "1717913eeb9640a2052cfe13f90b51628633677fca85ac247de3becc9f99f3a2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:be99129ae465948b72535dd9fc8c469c5c882f277ab1dbcfcffff037326d0849", "content": "[[nsa-logout-delete-cookies]]\n* **delete-cookies**\nA comma-separated list of the names of cookies which should be deleted when the user logs out.\n\n[[nsa-logout-invalidate-session]]\n* **invalidate-session**\nMaps to the `invalidateHttpSession` of the `SecurityContextLogoutHandler`.\nDefaults to \"true\", so the session will be invalidated on logout.\n\n[[nsa-logout-logout-success-url]]\n* **logout-success-url**\nThe destination URL which the user will be taken to after logging out.\nDefaults to <form-login-login-page>/?logout (i.e. /login?logout)\n\n+\n\nSetting this attribute will inject the `SessionManagementFilter` with a `SimpleRedirectInvalidSessionStrategy` configured with the attribute value.\nWhen an invalid session ID is submitted, the strategy will be invoked, redirecting to the configured URL.\n\n[[nsa-logout-logout-url]]\n* **logout-url**\nThe URL which will cause a logout (i.e. which will be processed by the filter).\nDefaults to \"/logout\".\n\n[[nsa-logout-success-handler-ref]]\n* **success-handler-ref**\nMay be used to supply an instance of `LogoutSuccessHandler` which will be invoked to control the navigation after logging out.\n\n[[nsa-saml2-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<logout> Attributes", "heading_level": 3, "file_order": 66, "section_index": 141, "content_hash": "be99129ae465948b72535dd9fc8c469c5c882f277ab1dbcfcffff037326d0849", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:58287643858e0631ced15958d935f95ff041f69c96018910fdebfa7bcd6b9562", "content": "The xref:servlet/saml2/login/index.adoc#servlet-saml2login[SAML 2.0 Login] feature configures authentication support using an SAML 2.0 Service Provider.\n\n[[nsa-saml2-login-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<saml2-login>", "heading_level": 2, "file_order": 66, "section_index": 142, "content_hash": "58287643858e0631ced15958d935f95ff041f69c96018910fdebfa7bcd6b9562", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:2d1802b8ad8d94d539b87841bf2e7e799f9b1a9c623ecd842079630eaa0905ad", "content": "* <<nsa-http,http>>\n\n[[nsa-saml2-login-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <saml2-login>", "heading_level": 3, "file_order": 66, "section_index": 143, "content_hash": "2d1802b8ad8d94d539b87841bf2e7e799f9b1a9c623ecd842079630eaa0905ad", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:a5f5dc765985e4aefdda5a47bcba209723030dff315ac2f919c54deffd4f2a31", "content": "[[nsa-saml2-login-relying-party-registration-repository-ref]]\n* **relying-party-registration-repository-ref**\nReference to the `RelyingPartyRegistrationRepository`.\n\n[[nsa-saml2-login-authentication-request-repository-ref]]\n* **authentication-request-repository-ref**\nReference to the `Saml2AuthenticationRequestRepository`.\n\n[[nsa-saml2-login-authentication-request-resolver-ref]]\n* **authentication-request-context-resolver-ref**\nReference to the `Saml2AuthenticationRequestResolver`.\n\n[[nsa-saml2-login-authentication-converter-ref]]\n* **authentication-converter-ref**\nReference to the `AuthenticationConverter`.\n\n[[nsa-saml2-login-login-processing-url]]\n* **login-processing-url**\nThe URI where the filter processes authentication requests.\n\n[[nsa-saml2-login-login-page]]\n* **login-page**\nThe URI to send users to login.\n\n[[nsa-saml2-login-authentication-success-handler-ref]]\n* **authentication-success-handler-ref**\nReference to the `AuthenticationSuccessHandler`.\n\n[[nsa-saml2-login-authentication-failure-handler-ref]]\n* **authentication-failure-handler-ref**\nReference to the `AuthenticationFailureHandler`.\n\n[[nsa-saml2-login-authentication-manager-ref]]\n* **authentication-manager-ref**\nReference to the `AuthenticationManager`.\n\n[[nsa-saml2-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<saml2-login> Attributes", "heading_level": 3, "file_order": 66, "section_index": 144, "content_hash": "a5f5dc765985e4aefdda5a47bcba209723030dff315ac2f919c54deffd4f2a31", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:f8a052bb61eac679f45c74e1287633c9b99ce836d72608e6fc32934c13c9ec13", "content": "The xref:servlet/saml2/logout.adoc#servlet-saml2login-logout[SAML 2.0 Single Logout] feature configures support for RP- and AP-initiated SAML 2.0 Single Logout.\n\n[[nsa-saml2-logout-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<saml2-logout>", "heading_level": 2, "file_order": 66, "section_index": 145, "content_hash": "f8a052bb61eac679f45c74e1287633c9b99ce836d72608e6fc32934c13c9ec13", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:a746841682103ed5f23c433e195cefe7adbf3caa3dc1a83b65af14bc2514048a", "content": "* <<nsa-http,http>>\n\n[[nsa-saml2-logout-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <saml2-logout>", "heading_level": 3, "file_order": 66, "section_index": 146, "content_hash": "a746841682103ed5f23c433e195cefe7adbf3caa3dc1a83b65af14bc2514048a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:64dbb66e318c32a4ac3ad589e64bdbdc74edfc5bccfc604fbc1e0e9a8c894395", "content": "[[nsa-saml2-logout-logout-url]]\n* **logout-url**\nThe URL by which the relying or asserting party can trigger logout.\n\n[[nsa-saml2-logout-logout-request-url]]\n* **logout-request-url**\nThe URL by which the asserting party can send a SAML 2.0 Logout Request.\n\n[[nsa-saml2-logout-logout-response-url]]\n* **logout-response-url**\nThe URL by which the asserting party can send a SAML 2.0 Logout Response.\n\n[[nsa-saml2-logout-relying-party-registration-repository-ref]]\n* **relying-party-registration-repository-ref**\nReference to the `RelyingPartyRegistrationRepository`.\n\n[[nsa-saml2-logout-logout-request-validator-ref]]\n* **logout-request-validator-ref**\nReference to the `Saml2LogoutRequestValidator`.\n\n[[nsa-saml2-logout-logout-request-resolver-ref]]\n* **logout-request-resolver-ref**\nReference to the `Saml2LogoutRequestResolver`.\n\n[[nsa-saml2-logout-logout-request-repository-ref]]\n* **logout-request-repository-ref**\nReference to the `Saml2LogoutRequestRepository`.\n\n[[nsa-saml2-logout-logout-response-validator-ref]]\n* **logout-response-validator-ref**\nReference to the `Saml2LogoutResponseValidator`.\n\n[[nsa-saml2-logout-logout-response-resolver-ref]]\n* **logout-response-resolver-ref**\nReference to the `Saml2LogoutResponseResolver`.\n\n[[nsa-password-management]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<saml2-logout> Attributes", "heading_level": 3, "file_order": 66, "section_index": 147, "content_hash": "64dbb66e318c32a4ac3ad589e64bdbdc74edfc5bccfc604fbc1e0e9a8c894395", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:bb741a059bd3aabd1471ff1da415dcaec1c0413d516fc617ca4d86942da18575", "content": "This element configures password management.\n\n[[nsa-password-management-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<password-management>", "heading_level": 2, "file_order": 66, "section_index": 148, "content_hash": "bb741a059bd3aabd1471ff1da415dcaec1c0413d516fc617ca4d86942da18575", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:0cf1812db3c07a8fc9e9899a74b04820cee43fd260c3216e744d893f64af4329", "content": "* <<nsa-http,http>>\n\n[[nsa-password-management-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <password-management>", "heading_level": 3, "file_order": 66, "section_index": 149, "content_hash": "0cf1812db3c07a8fc9e9899a74b04820cee43fd260c3216e744d893f64af4329", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:70bd292b3c77b388096ddd1ea632a126a1756a29d2be91e35c9229f10561dcab", "content": "[[nsa-password-management-change-password-page]]\n* **change-password-page**\nThe change password page. Defaults to \"/change-password\".\n\n[[nsa-port-mappings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<password-management> Attributes", "heading_level": 3, "file_order": 66, "section_index": 150, "content_hash": "70bd292b3c77b388096ddd1ea632a126a1756a29d2be91e35c9229f10561dcab", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:9febcc5bc2152031ffecc7d9cc74c6686f720b0e93be0a41f9312c81024000fa", "content": "By default, an instance of `PortMapperImpl` will be added to the configuration for use in redirecting to secure and insecure URLs.\nThis element can optionally be used to override the default mappings which that class defines.\nEach child `<port-mapping>` element defines a pair of HTTP:HTTPS ports.\nThe default mappings are 80:443 and 8080:8443.\nAn example of overriding these can be found in xref:servlet/exploits/http.adoc#servlet-http-redirect[Redirect to HTTPS].\n\n[[nsa-port-mappings-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<port-mappings>", "heading_level": 2, "file_order": 66, "section_index": 151, "content_hash": "9febcc5bc2152031ffecc7d9cc74c6686f720b0e93be0a41f9312c81024000fa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:4b5a7628c978654981d3c6006716fe36718fefdd1d05ea5830da1bd35f4d60a4", "content": "* <<nsa-http,http>>\n\n[[nsa-port-mappings-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <port-mappings>", "heading_level": 3, "file_order": 66, "section_index": 152, "content_hash": "4b5a7628c978654981d3c6006716fe36718fefdd1d05ea5830da1bd35f4d60a4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:00191e242ced62f0f5cbab2dff8e513167f3a15f09b6decaba8098f1281ca6c5", "content": "* <<nsa-port-mapping,port-mapping>>\n\n[[nsa-port-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <port-mappings>", "heading_level": 3, "file_order": 66, "section_index": 153, "content_hash": "00191e242ced62f0f5cbab2dff8e513167f3a15f09b6decaba8098f1281ca6c5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:04ddd6cb482558b056dd96b735df9ac9033bcf5e3871d63586b437fcf2843e18", "content": "Provides a method to map http ports to https ports when forcing a redirect.\n\n[[nsa-port-mapping-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<port-mapping>", "heading_level": 2, "file_order": 66, "section_index": 154, "content_hash": "04ddd6cb482558b056dd96b735df9ac9033bcf5e3871d63586b437fcf2843e18", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:a40fd3d88c4c6e2d9caf766fd84124129f27b6bc9f8b0465dda39a6dacfd2831", "content": "* <<nsa-port-mappings,port-mappings>>\n\n[[nsa-port-mapping-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <port-mapping>", "heading_level": 3, "file_order": 66, "section_index": 155, "content_hash": "a40fd3d88c4c6e2d9caf766fd84124129f27b6bc9f8b0465dda39a6dacfd2831", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:4c38087c039853e1d2c7bb20c97d1c95289080ff15e90aba18b597c0f367c4aa", "content": "[[nsa-port-mapping-http]]\n* **http**\nThe http port to use.\n\n[[nsa-port-mapping-https]]\n* **https**\nThe https port to use.\n\n[[nsa-remember-me]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<port-mapping> Attributes", "heading_level": 3, "file_order": 66, "section_index": 156, "content_hash": "4c38087c039853e1d2c7bb20c97d1c95289080ff15e90aba18b597c0f367c4aa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:ccc99c07e74ff584d2dda012b7160e812f3392b2c88b44b8d01c179305773743", "content": "Adds the `RememberMeAuthenticationFilter` to the stack.\nThis in turn will be configured with either a `TokenBasedRememberMeServices`, a `PersistentTokenBasedRememberMeServices` or a user-specified bean implementing `RememberMeServices` depending on the attribute settings.\n\n[[nsa-remember-me-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<remember-me>", "heading_level": 2, "file_order": 66, "section_index": 157, "content_hash": "ccc99c07e74ff584d2dda012b7160e812f3392b2c88b44b8d01c179305773743", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:bc6f25205a8d10b9601b1c883b6220446ac8b67cd26eb3cdd174d56deee90564", "content": "* <<nsa-http,http>>\n\n[[nsa-remember-me-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <remember-me>", "heading_level": 3, "file_order": 66, "section_index": 158, "content_hash": "bc6f25205a8d10b9601b1c883b6220446ac8b67cd26eb3cdd174d56deee90564", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:4e395adcef1332e2f7c26838c9a7620753f1dabbb3496b5a13159c13689ef50f", "content": "[[nsa-remember-me-authentication-success-handler-ref]]\n* **authentication-success-handler-ref**\nSets the `authenticationSuccessHandler` property on the `RememberMeAuthenticationFilter` if custom navigation is required.\nThe value should be the name of a `AuthenticationSuccessHandler` bean in the application context.\n\n[[nsa-remember-me-data-source-ref]]\n* **data-source-ref**\nA reference to a `DataSource` bean.\nIf this is set, `PersistentTokenBasedRememberMeServices` will be used and configured with a `JdbcTokenRepositoryImpl` instance.\n\n[[nsa-remember-me-remember-me-parameter]]\n* **remember-me-parameter**\nThe name of the request parameter which toggles remember-me authentication.\nDefaults to \"remember-me\".\nMaps to the \"parameter\" property of `AbstractRememberMeServices`.\n\n[[nsa-remember-me-remember-me-cookie]]\n* **remember-me-cookie**\nThe name of cookie which store the token for remember-me authentication.\nDefaults to \"remember-me\".\nMaps to the \"cookieName\" property of `AbstractRememberMeServices`.\n\n[[nsa-remember-me-key]]\n* **key**\nMaps to the \"key\" property of `AbstractRememberMeServices`.\nShould be set to a unique value to ensure that remember-me cookies are only valid within the one application footnote:[\nThis doesn't affect the use of `PersistentTokenBasedRememberMeServices`, where the tokens are stored on the server side.\n].\nIf this is not set a secure random value will be generated.\nSince generating secure random values can take a while, setting this value explicitly can help improve startup times when using the remember-me functionality.\n\n[[nsa-remember-me-services-alias]]\n* **services-alias**\nExports the internally defined `RememberMeServices` as a bean alias, allowing it to be used by other beans in the application context.\n\n[[nsa-remember-me-services-ref]]\n* **services-ref**\nAllows complete control of the `RememberMeServices` implementation that will be used by the filter.\nThe value should be the `id` of a bean in the application context which implements this interface.\nShould also implement `LogoutHandler` if a logout filter is in use.\n\n[[nsa-remember-me-token-repository-ref]]\n* **token-repository-ref**\nConfigures a `PersistentTokenBasedRememberMeServices` but allows the use of a custom `PersistentTokenRepository` bean.\n\n[[nsa-remember-me-token-validity-seconds]]\n* **token-validity-seconds**\nMaps to the `tokenValiditySeconds` property of `AbstractRememberMeServices`.\nSpecifies the period in seconds for which the remember-me cookie should be valid.\nBy default it will be valid for 14 days.\n\n[[nsa-remember-me-use-secure-cookie]]\n* **use-secure-cookie**\nIt is recommended that remember-me cookies are only submitted over HTTPS and thus should be flagged as \"secure\".\nBy default, a secure cookie will be used if the connection over which the login request is made is secure (as it should be).\nIf you set this property to `false`, secure cookies will not be used.\nSetting it to `true` will always set the secure flag on the cookie.\nThis attribute maps to the `useSecureCookie` property of `AbstractRememberMeServices`.\n\n[[nsa-remember-me-user-service-ref]]\n* **user-service-ref**\nThe remember-me services implementations require access to a `UserDetailsService`, so there has to be one defined in the application context.\nIf there is only one, it will be selected and used automatically by the namespace configuration.\nIf there are multiple instances, you can specify a bean `id` explicitly using this attribute.\n\n[[nsa-request-cache]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<remember-me> Attributes", "heading_level": 3, "file_order": 66, "section_index": 159, "content_hash": "4e395adcef1332e2f7c26838c9a7620753f1dabbb3496b5a13159c13689ef50f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:7486c009f639664da65185be40c22d114d090ee3e49c0cc528597b76f84e14fa", "content": "Sets the `RequestCache` instance which will be used by the `ExceptionTranslationFilter` to store request information before invoking an `AuthenticationEntryPoint`.\n\n[[nsa-request-cache-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<request-cache> Element", "heading_level": 2, "file_order": 66, "section_index": 160, "content_hash": "7486c009f639664da65185be40c22d114d090ee3e49c0cc528597b76f84e14fa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5ffd4c0ff895370d79b120f59ed0dd78f2ab5c91343127adb5d5adb2640a4683", "content": "* <<nsa-http,http>>\n\n[[nsa-request-cache-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <request-cache>", "heading_level": 3, "file_order": 66, "section_index": 161, "content_hash": "5ffd4c0ff895370d79b120f59ed0dd78f2ab5c91343127adb5d5adb2640a4683", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:fade67c784d9b1e2a502d4f42234e39d7fc3e7908ec5e9b05a2a5e12e6e0a2a1", "content": "[[nsa-request-cache-ref]]\n* **ref**\nDefines a reference to a Spring bean that is a `RequestCache`.\n\n[[nsa-session-management]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<request-cache> Attributes", "heading_level": 3, "file_order": 66, "section_index": 162, "content_hash": "fade67c784d9b1e2a502d4f42234e39d7fc3e7908ec5e9b05a2a5e12e6e0a2a1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:c19ad63ce9d8e57ef04d5ccc81623045b883d1885397bc06837db12dbaa97865", "content": "Session-management related functionality is implemented by the addition of a `SessionManagementFilter` to the filter stack.\n\n[[nsa-session-management-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<session-management>", "heading_level": 2, "file_order": 66, "section_index": 163, "content_hash": "c19ad63ce9d8e57ef04d5ccc81623045b883d1885397bc06837db12dbaa97865", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5e16181fbe6d597955378c8799b8aed6bf55471633ee6adb2e6148aee5d2c47c", "content": "* <<nsa-http,http>>\n\n[[nsa-session-management-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <session-management>", "heading_level": 3, "file_order": 66, "section_index": 164, "content_hash": "5e16181fbe6d597955378c8799b8aed6bf55471633ee6adb2e6148aee5d2c47c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:e85874df51d54d49894aee78dc305f63df59bb0e652bf1c8a0754caee805527d", "content": "[[nsa-session-management-authentication-strategy-explicit-invocation]]\n* **authentication-strategy-explicit-invocation**\nSetting this attribute to true will mean that `SessionManagementFilter` will not be injected and explicit invocation of SessionAuthenticationStrategy is required.\n\n[[nsa-session-management-invalid-session-url]]\n* **invalid-session-url**\nSetting this attribute will inject the `SessionManagementFilter` with a `SimpleRedirectInvalidSessionStrategy` configured with the attribute value.\nWhen an invalid session ID is submitted, the strategy will be invoked, redirecting to the configured URL.\n\n[[nsa-session-management-invalid-session-strategy-ref]]\n* **invalid-session-url**\nAllows injection of the InvalidSessionStrategy instance used by the SessionManagementFilter.\nUse either this or the `invalid-session-url` attribute but not both.\n\n[[nsa-session-management-session-authentication-error-url]]\n* **session-authentication-error-url**\nDefines the URL of the error page which should be shown when the SessionAuthenticationStrategy raises an exception.\nIf not set, an unauthorized (401) error code will be returned to the client.\nNote that this attribute doesn't apply if the error occurs during a form-based login, where the URL for authentication failure will take precedence.\n\n[[nsa-session-management-session-authentication-strategy-ref]]\n* **session-authentication-strategy-ref**\nAllows injection of the SessionAuthenticationStrategy instance used by the SessionManagementFilter\n\n[[nsa-session-management-session-fixation-protection]]\n* **session-fixation-protection**\nIndicates how session fixation protection will be applied when a user authenticates.\nIf set to \"none\", no protection will be applied.\n\"newSession\" will create a new empty session, with only Spring Security-related attributes migrated.\n\"migrateSession\" will create a new session and copy all session attributes to the new session.\nIn Servlet 3.1 (Java EE 7) and newer containers, specifying \"changeSessionId\" will keep the existing session and use the container-supplied session fixation protection (HttpServletRequest#changeSessionId()).\nDefaults to \"changeSessionId\" in Servlet 3.1 and newer containers, \"migrateSession\" in older containers.\nThrows an exception if \"changeSessionId\" is used in older containers.\n\n+\n\nIf session fixation protection is enabled, the `SessionManagementFilter` is injected with an appropriately configured `DefaultSessionAuthenticationStrategy`.\nSee the Javadoc for this class for more details.\n\n[[nsa-session-management-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<session-management> Attributes", "heading_level": 3, "file_order": 66, "section_index": 165, "content_hash": "e85874df51d54d49894aee78dc305f63df59bb0e652bf1c8a0754caee805527d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:847f8181f0f2e0cf050d6ebc214c8fabc7884cca80c9f8d4bc8a4a10c0891121", "content": "* <<nsa-concurrency-control,concurrency-control>>\n\n[[nsa-concurrency-control]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <session-management>", "heading_level": 3, "file_order": 66, "section_index": 166, "content_hash": "847f8181f0f2e0cf050d6ebc214c8fabc7884cca80c9f8d4bc8a4a10c0891121", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:5017ce81e11ffbd55beb65e980cdbfdcde256c21037218d8656f5282db295a8d", "content": "Adds support for concurrent session control, allowing limits to be placed on the number of active sessions a user can have.\nA `ConcurrentSessionFilter` will be created, and a `ConcurrentSessionControlAuthenticationStrategy` will be used with the `SessionManagementFilter`.\nIf a `form-login` element has been declared, the strategy object will also be injected into the created authentication filter.\nAn instance of `SessionRegistry` (a `SessionRegistryImpl` instance unless the user wishes to use a custom bean) will be created for use by the strategy.\n\n[[nsa-concurrency-control-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<concurrency-control>", "heading_level": 2, "file_order": 66, "section_index": 167, "content_hash": "5017ce81e11ffbd55beb65e980cdbfdcde256c21037218d8656f5282db295a8d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:850079cd3ad0fe7471eb8f853d06c779b619e95e6324526e1b87aee6f2a2534a", "content": "* <<nsa-session-management,session-management>>\n\n[[nsa-concurrency-control-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <concurrency-control>", "heading_level": 3, "file_order": 66, "section_index": 168, "content_hash": "850079cd3ad0fe7471eb8f853d06c779b619e95e6324526e1b87aee6f2a2534a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:153ee6d1f1d00e2bd3e5a9721bb8be807f00a6637baa61956b390a982abb72e2", "content": "[[nsa-concurrency-control-error-if-maximum-exceeded]]\n* **error-if-maximum-exceeded**\nIf set to \"true\" a `SessionAuthenticationException` will be raised when a user attempts to exceed the maximum allowed number of sessions.\nThe default behaviour is to expire the original session.\n\n[[nsa-concurrency-control-expired-url]]\n* **expired-url**\nThe URL a user will be redirected to if they attempt to use a session which has been \"expired\" by the concurrent session controller because the user has exceeded the number of allowed sessions and has logged in again elsewhere.\nShould be set unless `exception-if-maximum-exceeded` is set.\nIf no value is supplied, an expiry message will just be written directly back to the response.\n\n[[nsa-concurrency-control-expired-session-strategy-ref]]\n* **expired-url**\nAllows injection of the ExpiredSessionStrategy instance used by the ConcurrentSessionFilter\n\n[[nsa-concurrency-control-max-sessions]]\n* **max-sessions**\nMaps to the `maximumSessions` property of `ConcurrentSessionControlAuthenticationStrategy`.\nSpecify `-1` as the value to support unlimited sessions.\n\n[[nsa-concurrency-control-max-sessions-ref]]\n* **max-sessions-ref**\nAllows injection of the SessionLimit instance used by the ConcurrentSessionControlAuthenticationStrategy\n\n[[nsa-concurrency-control-session-registry-alias]]\n* **session-registry-alias**\nIt can also be useful to have a reference to the internal session registry for use in your own beans or an admin interface.\nYou can expose the internal bean using the `session-registry-alias` attribute, giving it a name that you can use elsewhere in your configuration.\n\n[[nsa-concurrency-control-session-registry-ref]]\n* **session-registry-ref**\nThe user can supply their own `SessionRegistry` implementation using the `session-registry-ref` attribute.\nThe other concurrent session control beans will be wired up to use it.\n\n[[nsa-x509]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<concurrency-control> Attributes", "heading_level": 3, "file_order": 66, "section_index": 169, "content_hash": "153ee6d1f1d00e2bd3e5a9721bb8be807f00a6637baa61956b390a982abb72e2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:b422aa8fdcddb4273380d6b568cf06203433249c8782a8ba99ac29eaa13ee9e7", "content": "Adds support for X.509 authentication.\nAn `X509AuthenticationFilter` will be added to the stack and an `Http403ForbiddenEntryPoint` bean will be created.\nThe latter will only be used if no other authentication mechanisms are in use (its only functionality is to return an HTTP 403 error code).\nA `PreAuthenticatedAuthenticationProvider` will also be created which delegates the loading of user authorities to a `UserDetailsService`.\n\n[[nsa-x509-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<x509>", "heading_level": 2, "file_order": 66, "section_index": 170, "content_hash": "b422aa8fdcddb4273380d6b568cf06203433249c8782a8ba99ac29eaa13ee9e7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:721671a3a4cf441729c9a199b95129763a1fdd0e1d7a965c3695b53b371fe8f8", "content": "* <<nsa-http,http>>\n\n[[nsa-x509-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <x509>", "heading_level": 3, "file_order": 66, "section_index": 171, "content_hash": "721671a3a4cf441729c9a199b95129763a1fdd0e1d7a965c3695b53b371fe8f8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:dc02f7fa241be4769105b634b6499fe6de44fc6ab9e5e26179deddc1f1d804bf", "content": "[[nsa-x509-authentication-details-source-ref]]\n* **authentication-details-source-ref**\nA reference to an `AuthenticationDetailsSource`\n\n[[nsa-x509-principal-extractor-ref]]\n* **principal-extractor-ref**\nReference to an `X509PrincipalExtractor` which will be used by the authentication filter.\n\n[[nsa-x509-subject-principal-regex]]\n* **subject-principal-regex**\nDefines a regular expression which will be used to extract the username from the certificate (for use with the `UserDetailsService`).\n\n[[nsa-x509-user-service-ref]]\n* **user-service-ref**\nAllows a specific `UserDetailsService` to be used with X.509 in the case where multiple instances are configured.\nIf not set, an attempt will be made to locate a suitable instance automatically and use that.\n\n[[nsa-filter-chain-map]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<x509> Attributes", "heading_level": 3, "file_order": 66, "section_index": 172, "content_hash": "dc02f7fa241be4769105b634b6499fe6de44fc6ab9e5e26179deddc1f1d804bf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:693837ec929371c8845607e880083fb34e829c98e8c58de3ba8df715f6587775", "content": "Used to explicitly configure a FilterChainProxy instance with a FilterChainMap\n\n[[nsa-filter-chain-map-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<filter-chain-map>", "heading_level": 2, "file_order": 66, "section_index": 173, "content_hash": "693837ec929371c8845607e880083fb34e829c98e8c58de3ba8df715f6587775", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:ea962b229aa4c23c09b0b803406c9e97c9594ae5ab7f437d15db8c2a4b19cb44", "content": "[[nsa-filter-chain-map-request-matcher]]\n* **request-matcher**\nDefines the strategy to use for matching incoming requests.\nCurrently the options are 'ant' (for ant path patterns), 'regex' for regular expressions and 'ciRegex' for case-insensitive regular expressions.\n\n[[nsa-filter-chain-map-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<filter-chain-map> Attributes", "heading_level": 3, "file_order": 66, "section_index": 174, "content_hash": "ea962b229aa4c23c09b0b803406c9e97c9594ae5ab7f437d15db8c2a4b19cb44", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:897f2120a2de1def0d58f65a44c018f3f1bd465f4c71a84e72c92fa97df2ccb0", "content": "* <<nsa-filter-chain,filter-chain>>\n\n[[nsa-filter-chain]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <filter-chain-map>", "heading_level": 3, "file_order": 66, "section_index": 175, "content_hash": "897f2120a2de1def0d58f65a44c018f3f1bd465f4c71a84e72c92fa97df2ccb0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:350d185744866e68c5590008a4b8d77de6f19bfb4bc312742c38f0ccfa7eee47", "content": "Used within to define a specific URL pattern and the list of filters which apply to the URLs matching that pattern.\nWhen multiple filter-chain elements are assembled in a list in order to configure a FilterChainProxy, the most specific patterns must be placed at the top of the list, with most general ones at the bottom.\n\n[[nsa-filter-chain-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<filter-chain>", "heading_level": 2, "file_order": 66, "section_index": 176, "content_hash": "350d185744866e68c5590008a4b8d77de6f19bfb4bc312742c38f0ccfa7eee47", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:87d4a7b424da32268e5e6f91eb82cd4f8c947b159a7f443f811cd601affd6885", "content": "* <<nsa-filter-chain-map,filter-chain-map>>\n\n[[nsa-filter-chain-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Parent Elements of <filter-chain>", "heading_level": 3, "file_order": 66, "section_index": 177, "content_hash": "87d4a7b424da32268e5e6f91eb82cd4f8c947b159a7f443f811cd601affd6885", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:d645dc7c2ff6c310666eaf78a1a61ca5574c9f4897a91f1720a109524f26a798", "content": "[[nsa-filter-chain-filters]]\n* **filters**\nA comma separated list of references to Spring beans that implement `Filter`.\nThe value \"none\" means that no `Filter` should be used for this `FilterChain`.\n\n[[nsa-filter-chain-pattern]]\n* **pattern**\nA pattern that creates RequestMatcher in combination with the <<nsa-filter-chain-map-request-matcher,request-matcher>>\n\n[[nsa-filter-chain-request-matcher-ref]]\n* **request-matcher-ref**\nA reference to a `RequestMatcher` that will be used to determine if any `Filter` from the `filters` attribute should be invoked.\n\n[[nsa-filter-security-metadata-source]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<filter-chain> Attributes", "heading_level": 3, "file_order": 66, "section_index": 178, "content_hash": "d645dc7c2ff6c310666eaf78a1a61ca5574c9f4897a91f1720a109524f26a798", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:209e90cc6eeab78a722c869255eba647e51161a9f3633e8cac4ea14788ccff8a", "content": "Used to explicitly configure a FilterSecurityMetadataSource bean for use with a FilterSecurityInterceptor.\nUsually only needed if you are configuring a FilterChainProxy explicitly, rather than using the<http> element.\nThe intercept-url elements used should only contain pattern, method and access attributes.\nAny others will result in a configuration error.\n\n[[nsa-filter-security-metadata-source-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<filter-security-metadata-source>", "heading_level": 2, "file_order": 66, "section_index": 179, "content_hash": "209e90cc6eeab78a722c869255eba647e51161a9f3633e8cac4ea14788ccff8a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:764867d05f3afd4222ce94d592f6fd33d36584966e8746ef0d89df7bc5580786", "content": "[[nsa-filter-security-metadata-source-id]]\n* **id**\nA bean identifier, used for referring to the bean elsewhere in the context.\n\n[[nsa-filter-security-metadata-source-request-matcher]]\n* **request-matcher**\nDefines the strategy use for matching incoming requests.\nCurrently the options are 'ant' (for ant path patterns), 'regex' for regular expressions and 'ciRegex' for case-insensitive regular expressions.\n\n[[nsa-filter-security-metadata-source-use-expressions]]\n* **use-expressions**\nEnables the use of expressions in the 'access' attributes in <intercept-url> elements rather than the traditional list of configuration attributes.\nDefaults to 'true'.\nIf enabled, each attribute should contain a single Boolean expression.\nIf the expression evaluates to 'true', access will be granted.\n\n[[nsa-filter-security-metadata-source-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "<filter-security-metadata-source> Attributes", "heading_level": 3, "file_order": 66, "section_index": 180, "content_hash": "764867d05f3afd4222ce94d592f6fd33d36584966e8746ef0d89df7bc5580786", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:71c0dd08f73648109e8b0c5ed8eff277197e7b50eca535abc6c806384d244f98", "content": "* <<nsa-intercept-url,intercept-url>>", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc", "title": "http", "heading": "Child Elements of <filter-security-metadata-source>", "heading_level": 3, "file_order": 66, "section_index": 181, "content_hash": "71c0dd08f73648109e8b0c5ed8eff277197e7b50eca535abc6c806384d244f98", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/http.adoc"}}
{"id": "sha256:035fb2f34c18b452a1b412a4584819c67d63f48111906c78e40ab5b4f471ce3c", "content": "[[appendix-namespace]]\n\nThis appendix provides a reference to the elements available in the security namespace and information on the underlying beans they create (a knowledge of the individual classes and how they work together is assumed - you can find more information in the project Javadoc and elsewhere in this document).\nIf you haven't used the namespace before, please read the xref:servlet/configuration/xml-namespace.adoc#ns-config[introductory chapter] on namespace configuration, as this is intended as a supplement to the information there.\nUsing a good quality XML editor while editing a configuration based on the schema is recommended as this will provide contextual information on which elements and attributes are available as well as comments explaining their purpose.\nThe namespace is written in https://relaxng.org/[RELAX NG] Compact format and later converted into an XSD schema.\nIf you are familiar with this format, you may wish to examine the https://raw.githubusercontent.com/spring-projects/spring-security/main/config/src/main/resources/org/springframework/security/config/spring-security-7.0.rnc[schema file] directly.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 67, "section_index": 0, "content_hash": "035fb2f34c18b452a1b412a4584819c67d63f48111906c78e40ab5b4f471ce3c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/index.adoc"}}
{"id": "sha256:e6804a9fa95f47d7ce2b007f1174619e6ce623e51d88d7c00d3f00134266ff02", "content": "[[nsa-ldap]]\nLDAP is covered in some details in xref:servlet/authentication/passwords/ldap.adoc#servlet-authentication-ldap[its own chapter].\nWe will expand on that here with some explanation of how the namespace options map to Spring beans.\nThe LDAP implementation uses Spring LDAP extensively, so some familiarity with that project's API may be useful.\n\n[[nsa-ldap-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "ldap", "heading_level": 1, "file_order": 68, "section_index": 0, "content_hash": "e6804a9fa95f47d7ce2b007f1174619e6ce623e51d88d7c00d3f00134266ff02", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:b720851621b6b3f68b04879daa62466ef37266f103fb68e4c8dcdddafc65c817", "content": "`<ldap-server>` Element\nThis element sets up a Spring LDAP `ContextSource` for use by the other LDAP beans, defining the location of the LDAP server and other information (such as a username and password, if it doesn't allow anonymous access) for connecting to it.\nIt can also be used to create an embedded server for testing.\nDetails of the syntax for both options are covered in the xref:servlet/authentication/passwords/ldap.adoc#servlet-authentication-ldap[LDAP chapter].\nThe actual `ContextSource` implementation is `DefaultSpringSecurityContextSource` which extends Spring LDAP's `LdapContextSource` class.\nThe `manager-dn` and `manager-password` attributes map to the latter's `userDn` and `password` properties respectively.\n\nIf you only have one server defined in your application context, the other LDAP namespace-defined beans will use it automatically.\nOtherwise, you can give the element an \"id\" attribute and refer to it from other namespace beans using the `server-ref` attribute.\nThis is actually the bean `id` of the `ContextSource` instance, if you want to use it in other traditional Spring beans.\n\n[[nsa-ldap-server-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "Defining the LDAP Server using the", "heading_level": 2, "file_order": 68, "section_index": 1, "content_hash": "b720851621b6b3f68b04879daa62466ef37266f103fb68e4c8dcdddafc65c817", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:65cec77acd91d718fad8a87dfc186b68110ee4c5ce8f32bcc70de9fc68966c30", "content": "[[nsa-ldap-server-mode]]\n* **mode**\nExplicitly specifies which embedded ldap server should use. The only supported value is `unboundid`. By default, it will depends if the library is available in the classpath.\n\n[[nsa-ldap-server-id]]\n* **id**\nA bean identifier, used for referring to the bean elsewhere in the context.\n\n[[nsa-ldap-server-ldif]]\n* **ldif**\nExplicitly specifies an ldif file resource to load into an embedded LDAP server.\nThe ldif should be a Spring resource pattern (i.e. classpath:init.ldif).\nThe default is classpath*:*.ldif\n\n[[nsa-ldap-server-manager-dn]]\n* **manager-dn**\nUsername (DN) of the \"manager\" user identity which will be used to authenticate to a (non-embedded) LDAP server.\nIf omitted, anonymous access will be used.\n\n[[nsa-ldap-server-manager-password]]\n* **manager-password**\nThe password for the manager DN.\nThis is required if the manager-dn is specified.\n\n[[nsa-ldap-server-port]]\n* **port**\nSpecifies an IP port number.\nUsed to configure an embedded LDAP server, for example.\nThe default value is 33389.\n\n[[nsa-ldap-server-root]]\n* **root**\nOptional root suffix for the embedded LDAP server.\nDefault is \"dc=springframework,dc=org\"\n\n[[nsa-ldap-server-url]]\n* **url**\nSpecifies the ldap server URL when not using the embedded LDAP server.\n\n[[nsa-ldap-authentication-provider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "<ldap-server> Attributes", "heading_level": 3, "file_order": 68, "section_index": 2, "content_hash": "65cec77acd91d718fad8a87dfc186b68110ee4c5ce8f32bcc70de9fc68966c30", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:b6454adaef347aeddbea16804bc5b74ad817f0a1877a27b8a73f18f9e8ba402b", "content": "This element is shorthand for the creation of an `LdapAuthenticationProvider` instance.\nBy default this will be configured with a `BindAuthenticator` instance and a `DefaultAuthoritiesPopulator`.\nAs with all namespace authentication providers, it must be included as a child of the `authentication-provider` element.\n\n[[nsa-ldap-authentication-provider-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "<ldap-authentication-provider>", "heading_level": 2, "file_order": 68, "section_index": 3, "content_hash": "b6454adaef347aeddbea16804bc5b74ad817f0a1877a27b8a73f18f9e8ba402b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:a50756d025671d6835ab5fb424a30f013015d90786b0b2a4deffbbb9085c3bbd", "content": "* xref:servlet/appendix/namespace/authentication-manager.adoc#nsa-authentication-manager[authentication-manager]\n\n[[nsa-ldap-authentication-provider-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "Parent Elements of <ldap-authentication-provider>", "heading_level": 3, "file_order": 68, "section_index": 4, "content_hash": "a50756d025671d6835ab5fb424a30f013015d90786b0b2a4deffbbb9085c3bbd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:52580fe932bc7ddf1e12a13672c85c0cffccb4cb66c3d28380611e860e0751a4", "content": "[[nsa-ldap-authentication-provider-group-role-attribute]]\n* **group-role-attribute**\nThe LDAP attribute name which contains the role name which will be used within Spring Security.\nMaps to the ``DefaultLdapAuthoritiesPopulator``'s `groupRoleAttribute` property.\nDefaults to \"cn\".\n\n[[nsa-ldap-authentication-provider-group-search-base]]\n* **group-search-base**\nSearch base for group membership searches.\nMaps to the ``DefaultLdapAuthoritiesPopulator``'s `groupSearchBase` constructor argument.\nDefaults to \"\" (searching from the root).\n\n[[nsa-ldap-authentication-provider-group-search-filter]]\n* **group-search-filter**\nGroup search filter.\nMaps to the ``DefaultLdapAuthoritiesPopulator``'s `groupSearchFilter` property.\nDefaults to `+(uniqueMember={0})+`.\nThe substituted parameter is the DN of the user.\n\n[[nsa-ldap-authentication-provider-role-prefix]]\n* **role-prefix**\nA non-empty string prefix that will be added to role strings loaded from persistent.\nMaps to the ``DefaultLdapAuthoritiesPopulator``'s `rolePrefix` property.\nDefaults to \"ROLE_\".\nUse the value \"none\" for no prefix in cases where the default is non-empty.\n\n[[nsa-ldap-authentication-provider-server-ref]]\n* **server-ref**\nThe optional server to use.\nIf omitted, and a default LDAP server is registered (using <ldap-server> with no Id), that server will be used.\n\n[[nsa-ldap-authentication-provider-user-context-mapper-ref]]\n* **user-context-mapper-ref**\nAllows explicit customization of the loaded user object by specifying a UserDetailsContextMapper bean which will be called with the context information from the user's directory entry\n\n[[nsa-ldap-authentication-provider-user-details-class]]\n* **user-details-class**\nAllows the objectClass of the user entry to be specified.\nIf set, the framework will attempt to load standard attributes for the defined class into the returned UserDetails object\n\n[[nsa-ldap-authentication-provider-user-dn-pattern]]\n* **user-dn-pattern**\nIf your users are at a fixed location in the directory (i.e. you can work out the DN directly from the username without doing a directory search), you can use this attribute to map directly to the DN.\nIt maps directly to the `userDnPatterns` property of `AbstractLdapAuthenticator`.\nThe value is a specific pattern used to build the user's DN, for example `+uid={0},ou=people+`.\nThe key `+{0}+` must be present and will be substituted with the username.\n\n[[nsa-ldap-authentication-provider-user-search-base]]\n* **user-search-base**\nSearch base for user searches.\nDefaults to \"\".\nOnly used with a 'user-search-filter'.\n\n+\n\nIf you need to perform a search to locate the user in the directory, then you can set these attributes to control the search.\nThe `BindAuthenticator` will be configured with a `FilterBasedLdapUserSearch` and the attribute values map directly to the first two arguments of that bean's constructor.\nIf these attributes aren't set and no `user-dn-pattern` has been supplied as an alternative, then the default search values of `+user-search-filter=\"(uid={0})\"+` and `user-search-base=\"\"` will be used.\n\n[[nsa-ldap-authentication-provider-user-search-filter]]\n* **user-search-filter**\nThe LDAP filter used to search for users (optional).\nFor example `+(uid={0})+`.\nThe substituted parameter is the user's login name.\n\n+\n\nIf you need to perform a search to locate the user in the directory, then you can set these attributes to control the search.\nThe `BindAuthenticator` will be configured with a `FilterBasedLdapUserSearch` and the attribute values map directly to the first two arguments of that bean's constructor.\nIf these attributes aren't set and no `user-dn-pattern` has been supplied as an alternative, then the default search values of `+user-search-filter=\"(uid={0})\"+` and `user-search-base=\"\"` will be used.\n\n[[nsa-ldap-authentication-provider-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "<ldap-authentication-provider> Attributes", "heading_level": 3, "file_order": 68, "section_index": 5, "content_hash": "52580fe932bc7ddf1e12a13672c85c0cffccb4cb66c3d28380611e860e0751a4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:03bfc5811a8d6716e2b3aa6c1ffc20fffa40307c2639eee0b4d4ef546ab7f5d9", "content": "* <<nsa-password-compare,password-compare>>\n\n[[nsa-password-compare]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "Child Elements of <ldap-authentication-provider>", "heading_level": 3, "file_order": 68, "section_index": 6, "content_hash": "03bfc5811a8d6716e2b3aa6c1ffc20fffa40307c2639eee0b4d4ef546ab7f5d9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:1da4a3ff1b01ec107685dfe27c3d4d5addf41cc55dbc9454d6515da6e5b1de1d", "content": "This is used as child element to `<ldap-provider>` and switches the authentication strategy from `BindAuthenticator` to `PasswordComparisonAuthenticator`.\n\n[[nsa-password-compare-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "<password-compare>", "heading_level": 2, "file_order": 68, "section_index": 7, "content_hash": "1da4a3ff1b01ec107685dfe27c3d4d5addf41cc55dbc9454d6515da6e5b1de1d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:df6344ed03009072a2781e4f037e4b2b7c69c241222f884753425b0137c64d2d", "content": "* <<nsa-ldap-authentication-provider,ldap-authentication-provider>>\n\n[[nsa-password-compare-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "Parent Elements of <password-compare>", "heading_level": 3, "file_order": 68, "section_index": 8, "content_hash": "df6344ed03009072a2781e4f037e4b2b7c69c241222f884753425b0137c64d2d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:bc7eac22bce211b54ad4c459031b91ecd8a4f3299b3f2412f404b6346d6575fc", "content": "[[nsa-password-compare-hash]]\n* **hash**\nDefines the hashing algorithm used on user passwords.\nWe recommend strongly against using MD4, as it is a very weak hashing algorithm.\n\n[[nsa-password-compare-password-attribute]]\n* **password-attribute**\nThe attribute in the directory which contains the user password.\nDefaults to \"userPassword\".\n\n[[nsa-password-compare-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "<password-compare> Attributes", "heading_level": 3, "file_order": 68, "section_index": 9, "content_hash": "bc7eac22bce211b54ad4c459031b91ecd8a4f3299b3f2412f404b6346d6575fc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:a11920945cd7b4689cd014a7c9d79f94bd9643c450f31695c213da599836ca64", "content": "* xref:servlet/appendix/namespace/authentication-manager.adoc#nsa-password-encoder[password-encoder]\n\n[[nsa-ldap-user-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "Child Elements of <password-compare>", "heading_level": 3, "file_order": 68, "section_index": 10, "content_hash": "a11920945cd7b4689cd014a7c9d79f94bd9643c450f31695c213da599836ca64", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:74d009e6c5961821f8f2103d0eabf7dcb60b04c968ed2a1191cd4d81a03e0970", "content": "This element configures an LDAP `UserDetailsService`.\nThe class used is `LdapUserDetailsService` which is a combination of a `FilterBasedLdapUserSearch` and a `DefaultLdapAuthoritiesPopulator`.\nThe attributes it supports have the same usage as in `<ldap-provider>`.\n\n[[nsa-ldap-user-service-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "<ldap-user-service>", "heading_level": 2, "file_order": 68, "section_index": 11, "content_hash": "74d009e6c5961821f8f2103d0eabf7dcb60b04c968ed2a1191cd4d81a03e0970", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:dd46664ae5eb7688fca5dd7d5758c0d245a220b819adcbd21d4eb88d1d1a5d97", "content": "[[nsa-ldap-user-service-cache-ref]]\n* **cache-ref**\nDefines a reference to a cache for use with a UserDetailsService.\n\n[[nsa-ldap-user-service-group-role-attribute]]\n* **group-role-attribute**\nThe LDAP attribute name which contains the role name which will be used within Spring Security.\nDefaults to \"cn\".\n\n[[nsa-ldap-user-service-group-search-base]]\n* **group-search-base**\nSearch base for group membership searches.\nDefaults to \"\" (searching from the root).\n\n[[nsa-ldap-user-service-group-search-filter]]\n* **group-search-filter**\nGroup search filter.\nDefaults to `+(uniqueMember={0})+`.\nThe substituted parameter is the DN of the user.\n\n[[nsa-ldap-user-service-id]]\n* **id**\nA bean identifier, used for referring to the bean elsewhere in the context.\n\n[[nsa-ldap-user-service-role-prefix]]\n* **role-prefix**\nA non-empty string prefix that will be added to role strings loaded from persistent storage (e.g.\n\"ROLE_\").\nUse the value \"none\" for no prefix in cases where the default is non-empty.\n\n[[nsa-ldap-user-service-server-ref]]\n* **server-ref**\nThe optional server to use.\nIf omitted, and a default LDAP server is registered (using <ldap-server> with no Id), that server will be used.\n\n[[nsa-ldap-user-service-user-context-mapper-ref]]\n* **user-context-mapper-ref**\nAllows explicit customization of the loaded user object by specifying a UserDetailsContextMapper bean which will be called with the context information from the user's directory entry\n\n[[nsa-ldap-user-service-user-details-class]]\n* **user-details-class**\nAllows the objectClass of the user entry to be specified.\nIf set, the framework will attempt to load standard attributes for the defined class into the returned UserDetails object\n\n[[nsa-ldap-user-service-user-search-base]]\n* **user-search-base**\nSearch base for user searches.\nDefaults to \"\".\nOnly used with a 'user-search-filter'.\n\n[[nsa-ldap-user-service-user-search-filter]]\n* **user-search-filter**\nThe LDAP filter used to search for users (optional).\nFor example `+(uid={0})+`.\nThe substituted parameter is the user's login name.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc", "title": "ldap", "heading": "<ldap-user-service> Attributes", "heading_level": 3, "file_order": 68, "section_index": 12, "content_hash": "dd46664ae5eb7688fca5dd7d5758c0d245a220b819adcbd21d4eb88d1d1a5d97", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/ldap.adoc"}}
{"id": "sha256:7a73c22130660414afa96fdc85681e7cae3c97876f4d2ac07af7928434eb92b7", "content": "[[nsa-method-security]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Method Security", "heading_level": 1, "file_order": 69, "section_index": 0, "content_hash": "7a73c22130660414afa96fdc85681e7cae3c97876f4d2ac07af7928434eb92b7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:554899f8d228ae4c18b6d3f95d5da7d35f0bd649844c52c10c792ce822df3f85", "content": "This element is the primary means of adding support for securing methods on Spring Security beans.\nMethods can be secured by the use of annotations (defined at the interface or class level) or by defining a set of pointcuts.\n\n[[nsa-method-security-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<method-security>", "heading_level": 2, "file_order": 69, "section_index": 1, "content_hash": "554899f8d228ae4c18b6d3f95d5da7d35f0bd649844c52c10c792ce822df3f85", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:f34ee440f89d908edf99b8c84a28c0091a18f9b397e7d6e6adce3710e31fc6a8", "content": "[[nsa-method-security-pre-post-enabled]]\n* **pre-post-enabled**\nEnables Spring Security's pre and post invocation annotations (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) for this application context.\nDefaults to \"true\".\n\n[[nsa-method-security-secured-enabled]]\n* **secured-enabled**\nEnables Spring Security's @Secured annotation for this application context.\nDefaults to \"false\".\n\n[[nsa-method-security-jsr250-enabled]]\n* **jsr250-enabled**\nEnables JSR-250 authorization annotations (@RolesAllowed, @PermitAll, @DenyAll) for this application context.\nDefaults to \"false\".\n\n[[nsa-method-security-mode]]\n* **mode**\nIf set to \"aspectj\", then uses AspectJ to intercept method invocations.\n\n[[nsa-method-security-proxy-target-class]]\n* **proxy-target-class**\nIf true, class based proxying will be used instead of interface based proxying.\nDefaults to \"false\".\n\n[[nsa-method-security-security-context-holder-strategy-ref]]\n* **security-context-holder-strategy-ref**\nSpecifies a SecurityContextHolderStrategy to use when retrieving the SecurityContext.\nDefaults to the value returned by SecurityContextHolder.getContextHolderStrategy().\n\n[[nsa-method-security-observation-registry-ref]]\n* **observation-registry-ref**\nA reference to the `ObservationRegistry` used for the `FilterChain` and related components\n\n[[nsa-method-security-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<method-security> attributes", "heading_level": 3, "file_order": 69, "section_index": 2, "content_hash": "f34ee440f89d908edf99b8c84a28c0091a18f9b397e7d6e6adce3710e31fc6a8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:5e691dfa073e337150a68345f32888858b1565bf50116768391b7616fcbd1523", "content": "* xref:servlet/appendix/namespace/http.adoc#nsa-expression-handler[expression-handler]\n* <<nsa-protect-pointcut,protect-pointcut>>\n\n[[nsa-global-method-security]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Child Elements of <method-security>", "heading_level": 3, "file_order": 69, "section_index": 3, "content_hash": "5e691dfa073e337150a68345f32888858b1565bf50116768391b7616fcbd1523", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:0dd1e79cefc562d2913b88ad98a9f75643c1d731010354452709f0a181819077", "content": "This element is the primary means of adding support for securing methods on Spring Security beans.\nMethods can be secured by the use of annotations (defined at the interface or class level) or by defining a set of pointcuts as child elements, using AspectJ syntax.\n\n[[nsa-global-method-security-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<global-method-security>", "heading_level": 2, "file_order": 69, "section_index": 4, "content_hash": "0dd1e79cefc562d2913b88ad98a9f75643c1d731010354452709f0a181819077", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:31d789fd27aa4a436ab58c5fcef67c7dc2d96312007419e3068c0d418d5b9451", "content": "[NOTE]\n=====\n`<global-method-security>` is deprecated in favor of `<method-security>`.\nIf you need to use `<global-method-security>`, please include the `spring-security-access` dependency in your build configuration.\n=====\n\n[[nsa-global-method-security-access-decision-manager-ref]]\n* **access-decision-manager-ref**\nMethod security uses the same `AccessDecisionManager` configuration as web security, but this can be overridden using this attribute.\nBy default an AffirmativeBased implementation is used for with a RoleVoter and an AuthenticatedVoter.\n\n[[nsa-global-method-security-authentication-manager-ref]]\n* **authentication-manager-ref**\nA reference to an `AuthenticationManager` that should be used for method security.\n\n[[nsa-global-method-security-jsr250-annotations]]\n* **jsr250-annotations**\nSpecifies whether JSR-250 style attributes are to be used (for example \"RolesAllowed\").\nThis will require the javax.annotation.security classes on the classpath.\nSetting this to true also adds a `Jsr250Voter` to the `AccessDecisionManager`, so you need to make sure you do this if you are using a custom implementation and want to use these annotations.\n\n[[nsa-global-method-security-metadata-source-ref]]\n* **metadata-source-ref**\nAn external `MethodSecurityMetadataSource` instance can be supplied which will take priority over other sources (such as the default annotations).\n\n[[nsa-global-method-security-mode]]\n* **mode**\nThis attribute can be set to \"aspectj\" to specify that AspectJ should be used instead of the default Spring AOP.\nSecured methods must be woven with the `AnnotationSecurityAspect` from the `spring-security-aspects` module.\n\nIt is important to note that AspectJ follows Java's rule that annotations on interfaces are not inherited.\nThis means that methods that define the Security annotations on the interface will not be secured.\nInstead, you must place the Security annotation on the class when using AspectJ.\n\n[[nsa-global-method-security-order]]\n* **order**\nAllows the advice \"order\" to be set for the method security interceptor.\n\n[[nsa-global-method-security-pre-post-annotations]]\n* **pre-post-annotations**\nSpecifies whether the use of Spring Security's pre and post invocation annotations (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) should be enabled for this application context.\nDefaults to \"disabled\".\n\n[[nsa-global-method-security-proxy-target-class]]\n* **proxy-target-class**\nIf true, class based proxying will be used instead of interface based proxying.\n\n[[nsa-global-method-security-run-as-manager-ref]]\n* **run-as-manager-ref**\nA reference to an optional `RunAsManager` implementation which will be used by the configured `MethodSecurityInterceptor`\n\n[[nsa-global-method-security-secured-annotations]]\n* **secured-annotations**\nSpecifies whether the use of Spring Security's @Secured annotations should be enabled for this application context.\nDefaults to \"disabled\".\n\n[[nsa-global-method-security-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<global-method-security> Attributes", "heading_level": 3, "file_order": 69, "section_index": 5, "content_hash": "31d789fd27aa4a436ab58c5fcef67c7dc2d96312007419e3068c0d418d5b9451", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:fd01e07e41f8312e257c5455db812c8d56d243837935539b84592937ffe67d6a", "content": "* <<nsa-after-invocation-provider,after-invocation-provider>>\n* xref:servlet/appendix/namespace/http.adoc#nsa-expression-handler[expression-handler]\n* <<nsa-pre-post-annotation-handling,pre-post-annotation-handling>>\n* <<nsa-protect-pointcut,protect-pointcut>>\n\n[[nsa-after-invocation-provider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Child Elements of <global-method-security>", "heading_level": 3, "file_order": 69, "section_index": 6, "content_hash": "fd01e07e41f8312e257c5455db812c8d56d243837935539b84592937ffe67d6a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:24790e02496d5d5b9ad154c67fb35b2ce5db2801dae01322fa4e8fa9f98f9a31", "content": "This element can be used to decorate an `AfterInvocationProvider` for use by the security interceptor maintained by the `<global-method-security>` namespace.\nYou can define zero or more of these within the `global-method-security` element, each with a `ref` attribute pointing to an `AfterInvocationProvider` bean instance within your application context.\n\n[[nsa-after-invocation-provider-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<after-invocation-provider>", "heading_level": 2, "file_order": 69, "section_index": 7, "content_hash": "24790e02496d5d5b9ad154c67fb35b2ce5db2801dae01322fa4e8fa9f98f9a31", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:49d934649e6698a3d796fc06a897bc514fdc617bc13523d500b29797f98d0d94", "content": "* <<nsa-global-method-security,global-method-security>>\n\n[[nsa-after-invocation-provider-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Parent Elements of <after-invocation-provider>", "heading_level": 3, "file_order": 69, "section_index": 8, "content_hash": "49d934649e6698a3d796fc06a897bc514fdc617bc13523d500b29797f98d0d94", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:15ee56c599a002a30ee58d537ceefba11e9e2907d609eb6ffff7869d4e8191ba", "content": "[NOTE]\n=====\n`<after-invocation-provider>` is deprecated in favor of `<method-security>` and xref:servlet/authorization/method-security.adoc[`@PostFilter` and `@PostAuthorize`].\nIf you need to use `<after-invocation-provider>`, please include the `spring-security-access` dependency in your build configuration while planning to migrate to a modern option.\n=====\n\n[[nsa-after-invocation-provider-ref]]\n* **ref**\nDefines a reference to a Spring bean that implements `AfterInvocationProvider`.\n\n[[nsa-pre-post-annotation-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<after-invocation-provider> Attributes", "heading_level": 3, "file_order": 69, "section_index": 9, "content_hash": "15ee56c599a002a30ee58d537ceefba11e9e2907d609eb6ffff7869d4e8191ba", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:f2b0dc6e93700ff63712eeda5dafad7143910186d24b85b49eb27589e724138d", "content": "Allows the default expression-based mechanism for handling Spring Security's pre and post invocation annotations (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) to be replaced entirely.\nOnly applies if these annotations are enabled.\n\n[[nsa-pre-post-annotation-handling-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<pre-post-annotation-handling>", "heading_level": 2, "file_order": 69, "section_index": 10, "content_hash": "f2b0dc6e93700ff63712eeda5dafad7143910186d24b85b49eb27589e724138d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:dc029676bc0c651d225c976325463a96d8f18a5aa075f436d1f42fe33512bb59", "content": "* <<nsa-global-method-security,global-method-security>>\n\n[[nsa-pre-post-annotation-handling-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Parent Elements of <pre-post-annotation-handling>", "heading_level": 3, "file_order": 69, "section_index": 11, "content_hash": "dc029676bc0c651d225c976325463a96d8f18a5aa075f436d1f42fe33512bb59", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:3733dba92bf42cc9e7d2a6f879a102fde7b5a1966dba835a69cecec41025bf4c", "content": "* <<nsa-invocation-attribute-factory,invocation-attribute-factory>>\n* <<nsa-post-invocation-advice,post-invocation-advice>>\n* <<nsa-pre-invocation-advice,pre-invocation-advice>>\n\n[[nsa-invocation-attribute-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Child Elements of <pre-post-annotation-handling>", "heading_level": 3, "file_order": 69, "section_index": 12, "content_hash": "3733dba92bf42cc9e7d2a6f879a102fde7b5a1966dba835a69cecec41025bf4c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:dc439464ac843b442ce8ff82f887df5d85dd27473ea8351b3af8dcb5023a47b6", "content": "Defines the PrePostInvocationAttributeFactory instance which is used to generate pre and post invocation metadata from the annotated methods.\n\n[NOTE]\n=====\n`<invocation-attribute-factory>` is deprecated in favor of `<method-security>` and xref:servlet/authorization/method-security.adoc[`@PostFilter` and `@PostAuthorize`].\nIf you need to use `<invocation-attribute-factory>`, please include the `spring-security-access` dependency in your build configuration while planning to migrate to a modern option.\n=====\n\n[[nsa-invocation-attribute-factory-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<invocation-attribute-factory>", "heading_level": 2, "file_order": 69, "section_index": 13, "content_hash": "dc439464ac843b442ce8ff82f887df5d85dd27473ea8351b3af8dcb5023a47b6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:ee833b50c43769433bea6b43b4da3d4f734b3c39e5ed18a81c04f9adceb53890", "content": "* <<nsa-pre-post-annotation-handling,pre-post-annotation-handling>>\n\n[[nsa-invocation-attribute-factory-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Parent Elements of <invocation-attribute-factory>", "heading_level": 3, "file_order": 69, "section_index": 14, "content_hash": "ee833b50c43769433bea6b43b4da3d4f734b3c39e5ed18a81c04f9adceb53890", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:dd0afd556fbe16f26e0e8a6d68efffc968a77faa8cdfa8d1b2e96411355d95dc", "content": "[[nsa-invocation-attribute-factory-ref]]\n* **ref**\nDefines a reference to a Spring bean Id.\n\n[[nsa-post-invocation-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<invocation-attribute-factory> Attributes", "heading_level": 3, "file_order": 69, "section_index": 15, "content_hash": "dd0afd556fbe16f26e0e8a6d68efffc968a77faa8cdfa8d1b2e96411355d95dc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:8c4e1a1d4a71bd110fbb30e85971a834c20b3d6381f1758213990e828de3f2c7", "content": "Customizes the `PostInvocationAdviceProvider` with the ref as the `PostInvocationAuthorizationAdvice` for the <pre-post-annotation-handling> element.\n\n[NOTE]\n=====\n`<post-invocation-advice>` is deprecated in favor of `<method-security>` and xref:servlet/authorization/method-security.adoc[`@PostFilter` and `@PostAuthorize`].\nIf you need to use `<post-invocation-advice>`, please include the `spring-security-access` dependency in your build configuration while planning to migrate to a modern option.\n=====\n\n[[nsa-post-invocation-advice-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<post-invocation-advice>", "heading_level": 2, "file_order": 69, "section_index": 16, "content_hash": "8c4e1a1d4a71bd110fbb30e85971a834c20b3d6381f1758213990e828de3f2c7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:cf0c2101d46fe6d9cfb0fab3b56818070d9c160a3671b45bfc0a92a3f116136c", "content": "* <<nsa-pre-post-annotation-handling,pre-post-annotation-handling>>\n\n[[nsa-post-invocation-advice-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Parent Elements of <post-invocation-advice>", "heading_level": 3, "file_order": 69, "section_index": 17, "content_hash": "cf0c2101d46fe6d9cfb0fab3b56818070d9c160a3671b45bfc0a92a3f116136c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:3af13b13a94592a5f9b51bf5d6f81feab7dd1645b2ee0cc83b5a02c8f9de589f", "content": "[[nsa-post-invocation-advice-ref]]\n* **ref**\nDefines a reference to a Spring bean Id.\n\n[[nsa-pre-invocation-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<post-invocation-advice> Attributes", "heading_level": 3, "file_order": 69, "section_index": 18, "content_hash": "3af13b13a94592a5f9b51bf5d6f81feab7dd1645b2ee0cc83b5a02c8f9de589f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:94ec84990e8beaaaf6adb31a4f62a51c61871ac04fee396fda757b13303ce6fa", "content": "Customizes the `PreInvocationAuthorizationAdviceVoter` with the ref as the `PreInvocationAuthorizationAdviceVoter` for the <pre-post-annotation-handling> element.\n\n[NOTE]\n=====\n`<pre-invocation-advice>` is deprecated in favor of `<method-security>` and xref:servlet/authorization/method-security.adoc[`@PreFilter` and `@PreAuthorize`].\nIf you need to use `<pre-invocation-advice>`, please include the `spring-security-access` dependency in your build configuration while planning to migrate to a modern option.\n=====\n\n[[nsa-pre-invocation-advice-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<pre-invocation-advice>", "heading_level": 2, "file_order": 69, "section_index": 19, "content_hash": "94ec84990e8beaaaf6adb31a4f62a51c61871ac04fee396fda757b13303ce6fa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:4fa4703ae2f5bfe61ce4f88f109bd2d7cb94daf41c3ef34fa7ff6077229a03d6", "content": "* <<nsa-pre-post-annotation-handling,pre-post-annotation-handling>>\n\n[[nsa-pre-invocation-advice-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Parent Elements of <pre-invocation-advice>", "heading_level": 3, "file_order": 69, "section_index": 20, "content_hash": "4fa4703ae2f5bfe61ce4f88f109bd2d7cb94daf41c3ef34fa7ff6077229a03d6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:0e424c031e181e96994ec6dff67267ecd0d9033d3490743cdf59e609f2bdcde4", "content": "[[nsa-pre-invocation-advice-ref]]\n* **ref**\nDefines a reference to a Spring bean Id.\n\n[[nsa-protect-pointcut]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<pre-invocation-advice> Attributes", "heading_level": 3, "file_order": 69, "section_index": 21, "content_hash": "0e424c031e181e96994ec6dff67267ecd0d9033d3490743cdf59e609f2bdcde4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:df9f232d7ed546b8a5eb7e15cb3f1b894924bdbf095a0be557822e96dc7146b2", "content": "`<protect-pointcut>`\nRather than defining security attributes on an individual method or class basis using the `@Secured` annotation, you can define cross-cutting security constraints across whole sets of methods and interfaces in your service layer using the `<protect-pointcut>` element.\nYou can find an example in the xref:servlet/authorization/method-security.adoc#ns-protect-pointcut[namespace introduction].\n\n[[nsa-protect-pointcut-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Securing Methods using", "heading_level": 2, "file_order": 69, "section_index": 22, "content_hash": "df9f232d7ed546b8a5eb7e15cb3f1b894924bdbf095a0be557822e96dc7146b2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:b41e8f02c72eed5b6e40ce2731dd8936a656e4517ef76974c182bbcf57244059", "content": "* <<nsa-global-method-security,global-method-security>>\n* <<nsa-method-security,method-security>>\n\n[[nsa-protect-pointcut-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Parent Elements of <protect-pointcut>", "heading_level": 3, "file_order": 69, "section_index": 23, "content_hash": "b41e8f02c72eed5b6e40ce2731dd8936a656e4517ef76974c182bbcf57244059", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:e74461d69bca7e3a04ca38dad9dea085f725a9e4b113b01dc43050474108633f", "content": "[[nsa-protect-pointcut-access]]\n* **access**\nAccess configuration attributes list that applies to all methods matching the pointcut, e.g.\n\"ROLE_A,ROLE_B\"\n\n[[nsa-protect-pointcut-expression]]\n* **expression**\nAn AspectJ expression, including the `execution` keyword.\nFor example, `execution(int com.foo.TargetObject.countLength(String))`.\n\n[[nsa-intercept-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<protect-pointcut> Attributes", "heading_level": 3, "file_order": 69, "section_index": 24, "content_hash": "e74461d69bca7e3a04ca38dad9dea085f725a9e4b113b01dc43050474108633f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:58b8ffdd93cb6f2475d8724dc8f01ab8bee609ba8be1bff329c92d51c388398b", "content": "Can be used inside a bean definition to add a security interceptor to the bean and set up access configuration attributes for the bean's methods\n\n[[nsa-intercept-methods-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<intercept-methods>", "heading_level": 2, "file_order": 69, "section_index": 25, "content_hash": "58b8ffdd93cb6f2475d8724dc8f01ab8bee609ba8be1bff329c92d51c388398b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:15c80108c5c249aa69833047b67f719305e4bfe29e3b3d72a9163802f99e572a", "content": "[[nsa-intercept-methods-use-authorization-manager]]\n* **use-authorization-manager**\nUse AuthorizationManager API instead of AccessDecisionManager (defaults to true)\n\n[[nsa-intercept-methods-authorization-manager-ref]]\n* **authorization-manager-ref**\nOptional AuthorizationManager bean ID to be used instead of the default (supersedes use-authorization-manager)\n\n[[nsa-intercept-methods-access-decision-manager-ref]]\n* **access-decision-manager-ref**\nOptional AccessDecisionManager bean ID to be used by the created method security interceptor.\n\n[[nsa-intercept-methods-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<intercept-methods> Attributes", "heading_level": 3, "file_order": 69, "section_index": 26, "content_hash": "15c80108c5c249aa69833047b67f719305e4bfe29e3b3d72a9163802f99e572a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:41794a99f4cc5f5d269f908c8c2d0c9bcc02ecddd0b64f79223af2b552f8a3c4", "content": "* <<nsa-protect,protect>>\n\n[[nsa-method-security-metadata-source]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Child Elements of <intercept-methods>", "heading_level": 3, "file_order": 69, "section_index": 27, "content_hash": "41794a99f4cc5f5d269f908c8c2d0c9bcc02ecddd0b64f79223af2b552f8a3c4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:0757120ae12a64556c5f4246c46794ffaf0982581197dca30720300c78b5b526", "content": "Creates a MethodSecurityMetadataSource instance\n\n[NOTE]\n=====\n`<method-security-metadata-source>` is deprecated in favor of xref:servlet/authorization/method-security.adoc[`<method-security>`].\nIf you need to use `<method-security-metadata-source>`, please include the `spring-security-access` dependency in your build configuration while planning to migrate to a modern option.\n=====\n\n[[nsa-method-security-metadata-source-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<method-security-metadata-source>", "heading_level": 2, "file_order": 69, "section_index": 28, "content_hash": "0757120ae12a64556c5f4246c46794ffaf0982581197dca30720300c78b5b526", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:d9676bac50e2fae6f57cd3d40206cbf33267ac7b8584f1991b98640a6abe8671", "content": "[[nsa-method-security-metadata-source-id]]\n* **id**\nA bean identifier, used for referring to the bean elsewhere in the context.\n\n[[nsa-method-security-metadata-source-use-expressions]]\n* **use-expressions**\nEnables the use of expressions in the 'access' attributes in <intercept-url> elements rather than the traditional list of configuration attributes.\nDefaults to 'false'.\nIf enabled, each attribute should contain a single Boolean expression.\nIf the expression evaluates to 'true', access will be granted.\n\n[[nsa-method-security-metadata-source-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<method-security-metadata-source> Attributes", "heading_level": 3, "file_order": 69, "section_index": 29, "content_hash": "d9676bac50e2fae6f57cd3d40206cbf33267ac7b8584f1991b98640a6abe8671", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:82ab158a6240d99fc124778ffdc17858f4fcfa5695c06e0cdb84fc558c8e0dd8", "content": "* <<nsa-protect,protect>>\n\n[[nsa-protect]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Child Elements of <method-security-metadata-source>", "heading_level": 3, "file_order": 69, "section_index": 30, "content_hash": "82ab158a6240d99fc124778ffdc17858f4fcfa5695c06e0cdb84fc558c8e0dd8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:c431099bfd491c106a513ded6d0197c1d3ac9722909d71c62db4cf2b8d5a0adb", "content": "Defines a protected method and the access control configuration attributes that apply to it.\nWe strongly advise you NOT to mix \"protect\" declarations with any services provided \"global-method-security\".\n\n[[nsa-protect-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<protect>", "heading_level": 2, "file_order": 69, "section_index": 31, "content_hash": "c431099bfd491c106a513ded6d0197c1d3ac9722909d71c62db4cf2b8d5a0adb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:935ad2c12be1b04c67364a950619d36a0b42651cac16f82185b92a550932c824", "content": "* <<nsa-intercept-methods,intercept-methods>>\n* <<nsa-method-security-metadata-source,method-security-metadata-source>>\n\n[[nsa-protect-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "Parent Elements of <protect>", "heading_level": 3, "file_order": 69, "section_index": 32, "content_hash": "935ad2c12be1b04c67364a950619d36a0b42651cac16f82185b92a550932c824", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:3df7f1ac2c65f6a4b82a670a933acbb50b6cafe9bb4fcb6b24606dd7c73deb29", "content": "[[nsa-protect-access]]\n* **access**\nAccess configuration attributes list that applies to the method, e.g.\n\"ROLE_A,ROLE_B\".\n\n[[nsa-protect-method]]\n* **method**\nA method name", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc", "title": "Method Security", "heading": "<protect> Attributes", "heading_level": 3, "file_order": 69, "section_index": 33, "content_hash": "3df7f1ac2c65f6a4b82a670a933acbb50b6cafe9bb4fcb6b24606dd7c73deb29", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/method-security.adoc"}}
{"id": "sha256:09678057a29d576a9b08f75032d464f5c9e2b6f4afcc86e1defe7797769faa50", "content": "[[nsa-websocket-security]]\n\nSpring Security 4.0+ provides support for authorizing messages.\nOne concrete example of where this is useful is to provide authorization in WebSocket based applications.\n\n[[nsa-websocket-message-broker]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc", "title": "websocket", "heading": "websocket", "heading_level": 1, "file_order": 70, "section_index": 0, "content_hash": "09678057a29d576a9b08f75032d464f5c9e2b6f4afcc86e1defe7797769faa50", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc"}}
{"id": "sha256:fa32120622dd72135daf169afc576192df9a30dd900cbce95de034e749217435", "content": "The websocket-message-broker element has two different modes.\nIf the <<nsa-websocket-message-broker-id,websocket-message-broker@id>> is not specified, then it will do the following things:\n\n* Ensure that any SimpAnnotationMethodMessageHandler has the AuthenticationPrincipalArgumentResolver registered as a custom argument resolver.\nThis allows the use of `@AuthenticationPrincipal` to resolve the principal of the current `Authentication`\n* Ensures that the SecurityContextChannelInterceptor is automatically registered for the clientInboundChannel.\nThis populates the SecurityContextHolder with the user that is found in the Message\n* Ensures that a ChannelSecurityInterceptor is registered with the clientInboundChannel.\nThis allows authorization rules to be specified for a message.\n* Ensures that a CsrfChannelInterceptor is registered with the clientInboundChannel.\nThis ensures that only requests from the original domain are enabled.\n* Ensures that a CsrfTokenHandshakeInterceptor is registered with WebSocketHttpRequestHandler, TransportHandlingSockJsService, or DefaultSockJsService.\nThis ensures that the expected CsrfToken from the HttpServletRequest is copied into the WebSocket Session attributes.\n\nIf additional control is necessary, the id can be specified and a ChannelSecurityInterceptor will be assigned to the specified id.\nAll the wiring with Spring's messaging infrastructure can then be done manually.\nThis is more cumbersome, but provides greater control over the configuration.\n\n[[nsa-websocket-message-broker-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc", "title": "websocket", "heading": "<websocket-message-broker>", "heading_level": 2, "file_order": 70, "section_index": 1, "content_hash": "fa32120622dd72135daf169afc576192df9a30dd900cbce95de034e749217435", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc"}}
{"id": "sha256:aa548f4007678e7cc49def1f84b3eb7efae77c081b7d4f0fedd00fff19a02a17", "content": "[[nsa-websocket-message-broker-id]]\n* **id** A bean identifier, used for referring to the ChannelSecurityInterceptor bean elsewhere in the context.\nIf specified, Spring Security requires explicit configuration within Spring Messaging.\nIf not specified, Spring Security will automatically integrate with the messaging infrastructure as described in <<nsa-websocket-message-broker>>\n\n[[nsa-websocket-message-broker-same-origin-disabled]]\n* **same-origin-disabled** Disables the requirement for CSRF token to be present in the Stomp headers (default false).\nChanging the default is useful if it is necessary to allow other origins to make SockJS connections.\n\n[[nsa-websocket-message-broker-authorization-manager-ref]]\n* **authorization-manager-ref** Use this `AuthorizationManager` instance; when set, `use-authorization-manager` is ignored and assumed to be `true`\n\n[[nsa-websocket-message-broker-use-authorization-manager]]\n* **use-authorization-manager** Use `AuthorizationManager` API instead of `SecurityMetadataSource` API (defaults to true).\n\n[[nsa-websocket-message-broker-security-context-holder-strategy-ref]]\n* **security-context-holder-strategy-ref** Use this `SecurityContextHolderStrategy` (note only supported in conjunction with the `AuthorizationManager` API)\n\n[[nsa-websocket-message-broker-children]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc", "title": "websocket", "heading": "<websocket-message-broker> Attributes", "heading_level": 3, "file_order": 70, "section_index": 2, "content_hash": "aa548f4007678e7cc49def1f84b3eb7efae77c081b7d4f0fedd00fff19a02a17", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc"}}
{"id": "sha256:bbaa75c49748dec7757e06c31298ab9cff4605b4969a120fd7f5556534bf5cf3", "content": "* xref:servlet/appendix/namespace/http.adoc#nsa-expression-handler[expression-handler]\n* <<nsa-intercept-message,intercept-message>>\n\n[[nsa-intercept-message]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc", "title": "websocket", "heading": "Child Elements of <websocket-message-broker>", "heading_level": 3, "file_order": 70, "section_index": 3, "content_hash": "bbaa75c49748dec7757e06c31298ab9cff4605b4969a120fd7f5556534bf5cf3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc"}}
{"id": "sha256:5d8c69028dffb00faf201392be01ff6cd87449f18b43baf01f9f0ca93714c649", "content": "Defines an authorization rule for a message.\n\n[[nsa-intercept-message-parents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc", "title": "websocket", "heading": "<intercept-message>", "heading_level": 2, "file_order": 70, "section_index": 4, "content_hash": "5d8c69028dffb00faf201392be01ff6cd87449f18b43baf01f9f0ca93714c649", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc"}}
{"id": "sha256:47d381e024eb7aade69b2a45d4559f7e5ec56c103704153abe3909d9aba77435", "content": "* <<nsa-websocket-message-broker,websocket-message-broker>>\n\n[[nsa-intercept-message-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc", "title": "websocket", "heading": "Parent Elements of <intercept-message>", "heading_level": 3, "file_order": 70, "section_index": 5, "content_hash": "47d381e024eb7aade69b2a45d4559f7e5ec56c103704153abe3909d9aba77435", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc"}}
{"id": "sha256:d31fd9c4e280d3c0d1695be92862a818012fb6cc715e8c214d63f789657b8097", "content": "[[nsa-intercept-message-pattern]]\n* **pattern** An ant based pattern that matches on the Message destination.\nFor example, \"/**\" matches any Message with a destination; \"/admin/**\" matches any Message that has a destination that starts with \"/admin/**\".\n\n[[nsa-intercept-message-type]]\n* **type** The type of message to match on.\nValid values are defined in SimpMessageType (i.e. CONNECT, CONNECT_ACK, HEARTBEAT, MESSAGE, SUBSCRIBE, UNSUBSCRIBE, DISCONNECT, DISCONNECT_ACK, OTHER).\n\n[[nsa-intercept-message-access]]\n* **access** The expression used to secure the Message.\nFor example, \"denyAll\" will deny access to all of the matching Messages; \"permitAll\" will grant access to all of the matching Messages; \"hasRole('ADMIN') requires the current user to have the role 'ROLE_ADMIN' for the matching Messages.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc", "title": "websocket", "heading": "<intercept-message> Attributes", "heading_level": 3, "file_order": 70, "section_index": 6, "content_hash": "d31fd9c4e280d3c0d1695be92862a818012fb6cc715e8c214d63f789657b8097", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/namespace/websocket.adoc"}}
{"id": "sha256:d9ca71cdd5e81dfe40b24765d4e4a7de53b15e8884551a6ca39682b16a2a7178", "content": "[[appendix-schema]]\nThe framework uses various database schema. This appendix provides a single reference point to them all.\nYou need only provide the tables for the areas of functionality you require.\n\nDDL statements are given for the HSQLDB database.\nYou can use these as a guideline for defining the schema for the database you are using.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "database-schema", "heading_level": 1, "file_order": 71, "section_index": 0, "content_hash": "d9ca71cdd5e81dfe40b24765d4e4a7de53b15e8884551a6ca39682b16a2a7178", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:231d3a9fa26031903f47bd8134e7d19ab760e317b1ea39e1720ebff7dcd41115", "content": "The standard JDBC implementation of the `UserDetailsService` (`JdbcDaoImpl`) requires tables to load the password, account status (enabled or disabled) and a list of authorities (roles) for the user.\nYou can use these as a guideline for defining the schema for the database you use.\n\n[source]\n----\n\ncreate table users(\n\tusername varchar_ignorecase(50) not null primary key,\n\tpassword varchar_ignorecase(500) not null,\n\tenabled boolean not null\n);\n\ncreate table authorities (\n\tusername varchar_ignorecase(50) not null,\n\tauthority varchar_ignorecase(50) not null,\n\tconstraint fk_authorities_users foreign key(username) references users(username)\n);\ncreate unique index ix_auth_username on authorities (username,authority);\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "User Schema", "heading_level": 2, "file_order": 71, "section_index": 1, "content_hash": "231d3a9fa26031903f47bd8134e7d19ab760e317b1ea39e1720ebff7dcd41115", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:144b50ec6e36123eb4b2c0708f82e85e2ab3755adbbf58bebb4159f72b9ffa9a", "content": "The following listing shows the Oracle variant of the schema creation commands:\n\n[source]\n----\nCREATE TABLE USERS (\n USERNAME NVARCHAR2(128) PRIMARY KEY,\n PASSWORD NVARCHAR2(128) NOT NULL,\n ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL\n);\n\nCREATE TABLE AUTHORITIES (\n USERNAME NVARCHAR2(128) NOT NULL,\n AUTHORITY NVARCHAR2(128) NOT NULL\n);\nALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY);\nALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE;\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "For Oracle database", "heading_level": 3, "file_order": 71, "section_index": 2, "content_hash": "144b50ec6e36123eb4b2c0708f82e85e2ab3755adbbf58bebb4159f72b9ffa9a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:30522f29ca437698de4a6dd09d0961471b31aaa82a3970d4d94121a216572a01", "content": "Spring Security 2.0 introduced support for group authorities in `JdbcDaoImpl`.\nThe table structure if groups are enabled is as follows.\nYou need to adjust the following schema to match the database dialect you use:\n\n[source]\n----\n\ncreate table groups (\n\tid bigint generated by default as identity(start with 0) primary key,\n\tgroup_name varchar_ignorecase(50) not null\n);\n\ncreate table group_authorities (\n\tgroup_id bigint not null,\n\tauthority varchar(50) not null,\n\tconstraint fk_group_authorities_group foreign key(group_id) references groups(id)\n);\n\ncreate table group_members (\n\tid bigint generated by default as identity(start with 0) primary key,\n\tusername varchar(50) not null,\n\tgroup_id bigint not null,\n\tconstraint fk_group_members_group foreign key(group_id) references groups(id)\n);\n----\n\nRemember that these tables are required only if you use the provided JDBC `UserDetailsService` implementation.\nIf you write your own or choose to implement `AuthenticationProvider` without a `UserDetailsService`, you have complete freedom over how you store the data, as long as the interface contract is satisfied.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "Group Authorities", "heading_level": 3, "file_order": 71, "section_index": 3, "content_hash": "30522f29ca437698de4a6dd09d0961471b31aaa82a3970d4d94121a216572a01", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:4037d4ed5e2cd04908d3862cd38730392039cc08f7cd93a2de26aca4128c6950", "content": "This table is used to store the data used by the more secure <<remember-me-persistent-token,persistent token>> remember-me implementation.\nIf you use `JdbcTokenRepositoryImpl` either directly or through the namespace, you need this table.\nRemember to adjust this schema to match the database dialect you use:\n\n[source]\n----\n\ncreate table persistent_logins (\n\tusername varchar(64) not null,\n\tseries varchar(64) primary key,\n\ttoken varchar(64) not null,\n\tlast_used timestamp not null\n);\n\n----\n\n[[dbschema-acl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "Persistent Login (Remember-Me) Schema", "heading_level": 2, "file_order": 71, "section_index": 4, "content_hash": "4037d4ed5e2cd04908d3862cd38730392039cc08f7cd93a2de26aca4128c6950", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:484f4d72c39c4d378ee6ce5e551fc1cb88223e9d878f151e9d21b922997a1d59", "content": "The Spring Security xref:servlet/authorization/acls.adoc#domain-acls[ACL] implementation uses four tables.\n\n* `acl_sid` stores the security identities recognised by the ACL system.\nThese can be unique principals or authorities, which may apply to multiple principals.\n* `acl_class` defines the domain object types to which ACLs apply.\nThe `class` column stores the Java class name of the object.\n* `acl_object_identity` stores the object identity definitions of specific domain objects.\n* `acl_entry` stores the ACL permissions, each of which applies to a specific object identity and security identity.\n\nWe assume that the database auto-generates the primary keys for each of the identities.\nThe `JdbcMutableAclService` has to be able to retrieve these when it has created a new row in the `acl_sid` or `acl_class` tables.\nIt has two properties that define the SQL needed to retrieve these values `classIdentityQuery` and `sidIdentityQuery`.\nBoth of these default to `call identity()`\n\nThe ACL artifact JAR contains files for creating the ACL schema in HyperSQL (HSQLDB), PostgreSQL, MySQL/MariaDB, Microsoft SQL Server, and Oracle Database.\nThese schemas are also demonstrated in the following sections.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "ACL Schema", "heading_level": 2, "file_order": 71, "section_index": 5, "content_hash": "484f4d72c39c4d378ee6ce5e551fc1cb88223e9d878f151e9d21b922997a1d59", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:fdf8f5afd4521409169845febd6f8b9ebaa282e1b0f97f4581dcb76137bf2cc6", "content": "The default schema works with the embedded HSQLDB database that is used in unit tests within the framework.\n\n[source,ddl]\n----\ncreate table acl_sid(\n\tid bigint generated by default as identity(start with 100) not null primary key,\n\tprincipal boolean not null,\n\tsid varchar_ignorecase(100) not null,\n\tconstraint unique_uk_1 unique(sid,principal)\n);\n\ncreate table acl_class(\n\tid bigint generated by default as identity(start with 100) not null primary key,\n\tclass varchar_ignorecase(100) not null,\n\tconstraint unique_uk_2 unique(class)\n);\n\ncreate table acl_object_identity(\n\tid bigint generated by default as identity(start with 100) not null primary key,\n\tobject_id_class bigint not null,\n\tobject_id_identity varchar_ignorecase(36) not null,\n\tparent_object bigint,\n\towner_sid bigint,\n\tentries_inheriting boolean not null,\n\tconstraint unique_uk_3 unique(object_id_class,object_id_identity),\n\tconstraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),\n\tconstraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),\n\tconstraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id)\n);\n\ncreate table acl_entry(\n\tid bigint generated by default as identity(start with 100) not null primary key,\n\tacl_object_identity bigint not null,\n\tace_order int not null,\n\tsid bigint not null,\n\tmask integer not null,\n\tgranting boolean not null,\n\taudit_success boolean not null,\n\taudit_failure boolean not null,\n\tconstraint unique_uk_4 unique(acl_object_identity,ace_order),\n\tconstraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id),\n\tconstraint foreign_fk_5 foreign key(sid) references acl_sid(id)\n);\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "HyperSQL", "heading_level": 3, "file_order": 71, "section_index": 6, "content_hash": "fdf8f5afd4521409169845febd6f8b9ebaa282e1b0f97f4581dcb76137bf2cc6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:fde3de9c0f13b4401010fc01286a15c790f784810ef922dd044f45fbcf5dcf2a", "content": "For PostgreSQL, you have to set the `classIdentityQuery` and `sidIdentityQuery` properties of `JdbcMutableAclService` to the following values, respectively:\n\n* `select currval(pg_get_serial_sequence('acl_class', 'id'))`\n* `select currval(pg_get_serial_sequence('acl_sid', 'id'))`\n\n[source,ddl]\n----\ncreate table acl_sid(\n\tid bigserial not null primary key,\n\tprincipal boolean not null,\n\tsid varchar(100) not null,\n\tconstraint unique_uk_1 unique(sid,principal)\n);\n\ncreate table acl_class(\n\tid bigserial not null primary key,\n\tclass varchar(100) not null,\n\tconstraint unique_uk_2 unique(class)\n);\n\ncreate table acl_object_identity(\n\tid bigserial primary key,\n\tobject_id_class bigint not null,\n\tobject_id_identity varchar(36) not null,\n\tparent_object bigint,\n\towner_sid bigint,\n\tentries_inheriting boolean not null,\n\tconstraint unique_uk_3 unique(object_id_class,object_id_identity),\n\tconstraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),\n\tconstraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),\n\tconstraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id)\n);\n\ncreate table acl_entry(\n\tid bigserial primary key,\n\tacl_object_identity bigint not null,\n\tace_order int not null,\n\tsid bigint not null,\n\tmask integer not null,\n\tgranting boolean not null,\n\taudit_success boolean not null,\n\taudit_failure boolean not null,\n\tconstraint unique_uk_4 unique(acl_object_identity,ace_order),\n\tconstraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id),\n\tconstraint foreign_fk_5 foreign key(sid) references acl_sid(id)\n);\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "PostgreSQL", "heading_level": 3, "file_order": 71, "section_index": 7, "content_hash": "fde3de9c0f13b4401010fc01286a15c790f784810ef922dd044f45fbcf5dcf2a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:10ec05e7bb695f06c5898fc9f4a266a7a08191c07da5bae9ca92bc1dc6e44a4c", "content": "[source,ddl]\n----\nCREATE TABLE acl_sid (\n\tid BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,\n\tprincipal BOOLEAN NOT NULL,\n\tsid VARCHAR(100) NOT NULL,\n\tUNIQUE KEY unique_acl_sid (sid, principal)\n) ENGINE=InnoDB;\n\nCREATE TABLE acl_class (\n\tid BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,\n\tclass VARCHAR(100) NOT NULL,\n\tUNIQUE KEY uk_acl_class (class)\n) ENGINE=InnoDB;\n\nCREATE TABLE acl_object_identity (\n\tid BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,\n\tobject_id_class BIGINT UNSIGNED NOT NULL,\n\tobject_id_identity VARCHAR(36) NOT NULL,\n\tparent_object BIGINT UNSIGNED,\n\towner_sid BIGINT UNSIGNED,\n\tentries_inheriting BOOLEAN NOT NULL,\n\tUNIQUE KEY uk_acl_object_identity (object_id_class, object_id_identity),\n\tCONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id),\n\tCONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id),\n\tCONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id)\n) ENGINE=InnoDB;\n\nCREATE TABLE acl_entry (\n\tid BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,\n\tacl_object_identity BIGINT UNSIGNED NOT NULL,\n\tace_order INTEGER NOT NULL,\n\tsid BIGINT UNSIGNED NOT NULL,\n\tmask INTEGER UNSIGNED NOT NULL,\n\tgranting BOOLEAN NOT NULL,\n\taudit_success BOOLEAN NOT NULL,\n\taudit_failure BOOLEAN NOT NULL,\n\tUNIQUE KEY unique_acl_entry (acl_object_identity, ace_order),\n\tCONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id),\n\tCONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id)\n) ENGINE=InnoDB;\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "MySQL and MariaDB", "heading_level": 3, "file_order": 71, "section_index": 8, "content_hash": "10ec05e7bb695f06c5898fc9f4a266a7a08191c07da5bae9ca92bc1dc6e44a4c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:6737768cecc43c5d96313c5dfa961fff66b6c0be234630ef27f9bb1c10f626fd", "content": "[source,ddl]\n----\nCREATE TABLE acl_sid (\n\tid BIGINT NOT NULL IDENTITY PRIMARY KEY,\n\tprincipal BIT NOT NULL,\n\tsid VARCHAR(100) NOT NULL,\n\tCONSTRAINT unique_acl_sid UNIQUE (sid, principal)\n);\n\nCREATE TABLE acl_class (\n\tid BIGINT NOT NULL IDENTITY PRIMARY KEY,\n\tclass VARCHAR(100) NOT NULL,\n\tCONSTRAINT uk_acl_class UNIQUE (class)\n);\n\nCREATE TABLE acl_object_identity (\n\tid BIGINT NOT NULL IDENTITY PRIMARY KEY,\n\tobject_id_class BIGINT NOT NULL,\n\tobject_id_identity VARCHAR(36) NOT NULL,\n\tparent_object BIGINT,\n\towner_sid BIGINT,\n\tentries_inheriting BIT NOT NULL,\n\tCONSTRAINT uk_acl_object_identity UNIQUE (object_id_class, object_id_identity),\n\tCONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id),\n\tCONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id),\n\tCONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id)\n);\n\nCREATE TABLE acl_entry (\n\tid BIGINT NOT NULL IDENTITY PRIMARY KEY,\n\tacl_object_identity BIGINT NOT NULL,\n\tace_order INTEGER NOT NULL,\n\tsid BIGINT NOT NULL,\n\tmask INTEGER NOT NULL,\n\tgranting BIT NOT NULL,\n\taudit_success BIT NOT NULL,\n\taudit_failure BIT NOT NULL,\n\tCONSTRAINT unique_acl_entry UNIQUE (acl_object_identity, ace_order),\n\tCONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id),\n\tCONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id)\n);\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "Microsoft SQL Server", "heading_level": 3, "file_order": 71, "section_index": 9, "content_hash": "6737768cecc43c5d96313c5dfa961fff66b6c0be234630ef27f9bb1c10f626fd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:1cbfdfe8fac2976f53c39685fd1c19c830620e10a0d6627de05443e67ce1f08f", "content": "[source,ddl]\n----\nCREATE TABLE ACL_SID (\n ID NUMBER(18) PRIMARY KEY,\n PRINCIPAL NUMBER(1) NOT NULL CHECK (PRINCIPAL IN (0, 1 )),\n SID NVARCHAR2(128) NOT NULL,\n CONSTRAINT ACL_SID_UNIQUE UNIQUE (SID, PRINCIPAL)\n);\nCREATE SEQUENCE ACL_SID_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;\nCREATE OR REPLACE TRIGGER ACL_SID_SQ_TR BEFORE INSERT ON ACL_SID FOR EACH ROW\nBEGIN\n SELECT ACL_SID_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;\nEND;\n\nCREATE TABLE ACL_CLASS (\n ID NUMBER(18) PRIMARY KEY,\n CLASS NVARCHAR2(128) NOT NULL,\n CONSTRAINT ACL_CLASS_UNIQUE UNIQUE (CLASS)\n);\nCREATE SEQUENCE ACL_CLASS_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;\nCREATE OR REPLACE TRIGGER ACL_CLASS_ID_TR BEFORE INSERT ON ACL_CLASS FOR EACH ROW\nBEGIN\n SELECT ACL_CLASS_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;\nEND;\n\nCREATE TABLE ACL_OBJECT_IDENTITY(\n ID NUMBER(18) PRIMARY KEY,\n OBJECT_ID_CLASS NUMBER(18) NOT NULL,\n OBJECT_ID_IDENTITY NVARCHAR2(64) NOT NULL,\n PARENT_OBJECT NUMBER(18),\n OWNER_SID NUMBER(18),\n ENTRIES_INHERITING NUMBER(1) NOT NULL CHECK (ENTRIES_INHERITING IN (0, 1)),\n CONSTRAINT ACL_OBJECT_IDENTITY_UNIQUE UNIQUE (OBJECT_ID_CLASS, OBJECT_ID_IDENTITY),\n CONSTRAINT ACL_OBJECT_IDENTITY_PARENT_FK FOREIGN KEY (PARENT_OBJECT) REFERENCES ACL_OBJECT_IDENTITY(ID),\n CONSTRAINT ACL_OBJECT_IDENTITY_CLASS_FK FOREIGN KEY (OBJECT_ID_CLASS) REFERENCES ACL_CLASS(ID),\n CONSTRAINT ACL_OBJECT_IDENTITY_OWNER_FK FOREIGN KEY (OWNER_SID) REFERENCES ACL_SID(ID)\n);\nCREATE SEQUENCE ACL_OBJECT_IDENTITY_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;\nCREATE OR REPLACE TRIGGER ACL_OBJECT_IDENTITY_ID_TR BEFORE INSERT ON ACL_OBJECT_IDENTITY FOR EACH ROW\nBEGIN\n SELECT ACL_OBJECT_IDENTITY_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;\nEND;\n\nCREATE TABLE ACL_ENTRY (\n ID NUMBER(18) NOT NULL PRIMARY KEY,\n ACL_OBJECT_IDENTITY NUMBER(18) NOT NULL,\n ACE_ORDER INTEGER NOT NULL,\n SID NUMBER(18) NOT NULL,\n MASK INTEGER NOT NULL,\n GRANTING NUMBER(1) NOT NULL CHECK (GRANTING IN (0, 1)),\n AUDIT_SUCCESS NUMBER(1) NOT NULL CHECK (AUDIT_SUCCESS IN (0, 1)),\n AUDIT_FAILURE NUMBER(1) NOT NULL CHECK (AUDIT_FAILURE IN (0, 1)),\n CONSTRAINT ACL_ENTRY_UNIQUE UNIQUE (ACL_OBJECT_IDENTITY, ACE_ORDER),\n CONSTRAINT ACL_ENTRY_OBJECT_FK FOREIGN KEY (ACL_OBJECT_IDENTITY) REFERENCES ACL_OBJECT_IDENTITY (ID),\n CONSTRAINT ACL_ENTRY_ACL_FK FOREIGN KEY (SID) REFERENCES ACL_SID(ID)\n);\nCREATE SEQUENCE ACL_ENTRY_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;\nCREATE OR REPLACE TRIGGER ACL_ENTRY_ID_TRIGGER BEFORE INSERT ON ACL_ENTRY FOR EACH ROW\nBEGIN\n SELECT ACL_ENTRY_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;\nEND;\n----\n\n[[dbschema-oauth2-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "Oracle Database", "heading_level": 3, "file_order": 71, "section_index": 10, "content_hash": "1cbfdfe8fac2976f53c39685fd1c19c830620e10a0d6627de05443e67ce1f08f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:0863bdbef2f68aae73b0f077982a27a5e4e2cdad97dab11b93c6f7e2611c9841", "content": "The JDBC implementation of xref:servlet/oauth2/client/core.adoc#oauth2Client-authorized-repo-service[ `OAuth2AuthorizedClientService`] (`JdbcOAuth2AuthorizedClientService`) requires a table for persisting `OAuth2AuthorizedClient` instances.\nYou will need to adjust this schema to match the database dialect you use.\n\n[source,ddl]\n----\nCREATE TABLE oauth2_authorized_client (\n client_registration_id varchar(100) NOT NULL,\n principal_name varchar(200) NOT NULL,\n access_token_type varchar(100) NOT NULL,\n access_token_value blob NOT NULL,\n access_token_issued_at timestamp NOT NULL,\n access_token_expires_at timestamp NOT NULL,\n access_token_scopes varchar(1000) DEFAULT NULL,\n refresh_token_value blob DEFAULT NULL,\n refresh_token_issued_at timestamp DEFAULT NULL,\n created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n PRIMARY KEY (client_registration_id, principal_name)\n);\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc", "title": "database-schema", "heading": "OAuth 2.0 Client Schema", "heading_level": 2, "file_order": 71, "section_index": 11, "content_hash": "0863bdbef2f68aae73b0f077982a27a5e4e2cdad97dab11b93c6f7e2611c9841", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/database-schema.adoc"}}
{"id": "sha256:92db528873eb54c1951bfdb06c6c2c47fc8f0c686411c2b59b2504f2b0be0df0", "content": "[[appendix-faq]]\n\nThis FAQ has the following sections:\n\n* <<appendix-faq-general-questions>>\n* <<appendix-faq-common-problems>>\n* <<appendix-faq-architecture>>\n* <<appendix-faq-howto>>\n\n[[appendix-faq-general-questions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "faq", "heading_level": 1, "file_order": 72, "section_index": 0, "content_hash": "92db528873eb54c1951bfdb06c6c2c47fc8f0c686411c2b59b2504f2b0be0df0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:61199feef7755f173d4f58701b825ed508389752df44288ab9c97b25f2c8d8f0", "content": "This FAQ answers the following general questions:\n\n* <<appendix-faq-other-concerns>>\n* <<appendix-faq-web-xml>>\n* <<appendix-faq-requirements>>\n* <<appendix-faq-start-simple>>\n\n[[appendix-faq-other-concerns]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "General Questions", "heading_level": 2, "file_order": 72, "section_index": 1, "content_hash": "61199feef7755f173d4f58701b825ed508389752df44288ab9c97b25f2c8d8f0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:7f87766fb16dbc65108aff553cfcb41c3199d6d14b42b8984fb7a789086efa72", "content": "Spring Security provides you with a flexible framework for your authentication and authorization requirements, but there are many other considerations for building a secure application that are outside its scope.\nWeb applications are vulnerable to all kinds of attacks with which you should be familiar, preferably before you start development so that you can design and code with them in mind from the beginning.\nCheck out the https://www.owasp.org/[OWASP website] for information on the major issues that face web application developers and the countermeasures you can use against them.\n\n[[appendix-faq-web-xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "Can Spring Security take care of all my application security requirements?", "heading_level": 3, "file_order": 72, "section_index": 2, "content_hash": "7f87766fb16dbc65108aff553cfcb41c3199d6d14b42b8984fb7a789086efa72", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:975877417edb39d314034568c41a3fd5c429b9b40a719cb8e35ab621a476b07d", "content": "Suppose you are developing an enterprise application based on Spring.\nYou typically need to address four security concerns : authentication, web request security, service layer security (your methods that implement business logic), and domain object instance security (different domain objects can have different permissions). With these typical requirements in mind, we have the following considerations:\n\n* _Authentication_: The servlet specification provides an approach to authentication.\nHowever, you need to configure the container to perform authentication, which typically requires editing of container-specific \"`realm`\" settings.\nThis makes a non-portable configuration. Also, if you need to write an actual Java class to implement the container's authentication interface, it becomes even more non-portable.\nWith Spring Security, you achieve complete portability -- right down to the WAR level.\nAlso, Spring Security offers a choice of production-proven authentication providers and mechanisms, meaning you can switch your authentication approaches at deployment time.\nThis is particularly valuable for software vendors writing products that need to work in an unknown target environment.\n\n* _Web request security:_ The servlet specification provides an approach to secure your request URIs.\nHowever, these URIs can be expressed only in the servlet specification's own limited URI path format.\nSpring Security provides a far more comprehensive approach.\nFor instance, you can use Ant paths or regular expressions, you can consider parts of the URI other than simply the requested page (for example,\nyou can consider HTTP GET parameters), and you can implement your own runtime source of configuration data.\nThis means that you can dynamically change your web request security during the actual execution of your web application.\n\n* _Service layer and domain object security:_ The absence of support in the servlet specification for services layer security or domain object instance security represents serious limitations for multi-tiered applications.\nTypically, developers either ignore these requirements or implement security logic within their MVC controller code (or, even worse, inside the views). There are serious disadvantages with this approach:\n\n** _Separation of concerns:_ Authorization is a crosscutting concern and should be implemented as such.\nMVC controllers or views that implement authorization code makes it more difficult to test both the controller and the authorization logic, is more difficult to debug, and often leads to code duplication.\n\n** _Support for rich clients and web services:_ If an additional client type must ultimately be supported, any authorization code embedded within the web layer is non-reusable.\nIt should be considered that Spring remoting exporters export only service layer beans (not MVC controllers). As a result, authorization logic needs to be located in the services layer to support a multitude of client types.\n\n** _Layering issues:_ An MVC controller or view is the incorrect architectural layer in which to implement authorization decisions concerning services layer methods or domain object instances.\nWhile the principal may be passed to the services layer to enable it to make the authorization decision, doing so would introduce an additional argument on every services layer method.\nA more elegant approach is to use a `ThreadLocal` to hold the principal, although this would likely increase development time to a point where it would become more economical (on a cost-benefit basis) to use a dedicated security framework.\n\n** _Authorization code quality:_ It is often said of web frameworks that they \"`make it easier to do the right things, and harder to do the wrong things`\". Security frameworks are the same, because they are designed in an abstract manner for a wide range of purposes.\nWriting your own authorization code from scratch does not provide the \"`design check`\" a framework would offer, and in-house authorization code typically lacks the improvements that emerge from widespread deployment, peer review, and new versions.\n\nFor simple applications, servlet specification security may be enough.\nAlthough when considered within the context of web container portability, configuration requirements, limited web request security flexibility, and non-existent services layer and domain object instance security, it becomes clear why developers often look to alternative solutions.\n\n[[appendix-faq-requirements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "Why Not Use web.xml Security?", "heading_level": 3, "file_order": 72, "section_index": 3, "content_hash": "975877417edb39d314034568c41a3fd5c429b9b40a719cb8e35ab621a476b07d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:b8e63da776f1a87c8e2e7c69bda6abf88f2ce0483e5f88948148910923961c95", "content": "Spring Security 3.0 and 3.1 require at least JDK 1.5 and also require Spring 3.0.3 as a minimum.\nIdeally, you should use the latest release versions to avoid problems.\n\nSpring Security 2.0.x requires a minimum JDK version of 1.4 and is built against Spring 2.0.x.\nIt should also be compatible with applications that use Spring 2.5.x.\n\n[[appendix-faq-start-simple]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "What Java and Spring Framework versions are required?", "heading_level": 3, "file_order": 72, "section_index": 4, "content_hash": "b8e63da776f1a87c8e2e7c69bda6abf88f2ce0483e5f88948148910923961c95", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:871577b17801cc4b1403fcf7468bf90fe5f422cde475324fc627ebccaa82d8fd", "content": "(This answer address complex scenarios in general by dealing with a particular scenario.)\n\nSuppose you are new to Spring Security and need to build an application that supports CAS single sign-on over HTTPS while allowing basic authentication locally for certain URLs, authenticating against multiple back end user information sources (LDAP and JDBC). You have copied some configuration files but have found that it does not work. What could be wrong?\n\nYou need an understanding of the technologies you intend to use before you can successfully build applications with them.\nSecurity is complicated.\nSetting up a simple configuration by using a login form and some hard-coded users with Spring Security's namespace is reasonably straightforward.\nMoving to using a backed JDBC database is also easy enough.\nHowever, if you try to jump straight to a complicated deployment scenario like this scenario, you are almost certain to be frustrated.\nThere is a big jump in the learning curve required to set up systems such as CAS, configure LDAP servers, and install SSL certificates properly.\nSo you need to take things one step at a time.\n\nFrom a Spring Security perspective, the first thing you should do is follow the \"`Getting Started`\" guide on the website.\nThis will take you through a series of steps to get up and running and get some idea of how the framework operates.\nIf you use other technologies with which you are not familiar, you should do some research and try to make sure you can use them in isolation before combining them in a complex system.\n\n[[appendix-faq-common-problems]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I have a complex scenario. What could be wrong?", "heading_level": 4, "file_order": 72, "section_index": 5, "content_hash": "871577b17801cc4b1403fcf7468bf90fe5f422cde475324fc627ebccaa82d8fd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:378d4c84ff00bd515fad078af5caa0a7b4a40eddfcf53b7c9659dddab5d7125c", "content": "This section addresses the most common problems that people encounter when using Spring Security:\n\n* Authentication\n** <<appendix-faq-bad-credentials>>\n** <<appendix-faq-login-loop>>\n** <<appendix-faq-anon-access-denied>>\n** <<appendix-faq-cached-secure-page>>\n** <<auth-exception-credentials-not-found>>\n** <<appendix-faq-ldap-authentication>>\n* Session Management\n** <<appendix-faq-concurrent-session-same-browser>>\n** <<appendix-faq-new-session-on-authentication>>\n** <<appendix-faq-tomcat-https-session>>\n** <<appendix-faq-session-listener-missing>>\n** <<appendix-faq-unwanted-session-creation>>\n* Miscellaneous\n** <<appendix-faq-forbidden-csrf>>\n** <<appendix-faq-no-security-on-forward>>\n** <<appendix-faq-method-security-in-web-context>>\n** <<appendix-faq-no-filters-no-context>>\n** <<appendix-faq-method-security-with-taglib>>\n\n[[appendix-faq-bad-credentials]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "Common Problems", "heading_level": 2, "file_order": 72, "section_index": 6, "content_hash": "378d4c84ff00bd515fad078af5caa0a7b4a40eddfcf53b7c9659dddab5d7125c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:de002c42b323e8e8438364289e4f83a74f158f065ec15fdeedbae5d69e11807b", "content": "This means that authentication has failed.\nIt does not say why, as it is good practice to avoid giving details that might help an attacker guess account names or passwords.\n\nThis also means that, if you ask this question online, you should not expect an answer unless you provide additional information.\nAs with any issue, you should check the output from the debug log and note any exception stacktraces and related messages.\nYou should step through the code in a debugger to see where the authentication fails and why.\nYou should also write a test case which exercises your authentication configuration outside the application.\nIf you use hashed passwords, make sure the value stored in your database is _exactly_ the same as the value produced by the `PasswordEncoder` configured in your application.\n\n[[appendix-faq-login-loop]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "When I try to log in, I get an error message that says, \"`Bad Credentials`\". What is wrong?", "heading_level": 3, "file_order": 72, "section_index": 7, "content_hash": "de002c42b323e8e8438364289e4f83a74f158f065ec15fdeedbae5d69e11807b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:ddee09ba46cda5ae3b1b8ef0e2725163fb00b096a288b5f818bc553a4783a7c5", "content": "A common user problem with infinite loop and redirecting to the login page is caused by accidentally configuring the login page as a \"`secured`\" resource.\nMake sure your configuration allows anonymous access to the login page.\nYou can do so with the xref:servlet/authorization/authorize-http-requests.adoc[`authorizeHttpRequests`] DSL.\n\n[TIP]\n====\nWhen you use namespace- or DSL-based configuration, a check is made on loading the application context and a warning message logged if your login page appears to be protected.\n====\n\n[[appendix-faq-anon-access-denied]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "My application goes into an \"`endless loop`\" when I try to log in. What is going on?", "heading_level": 3, "file_order": 72, "section_index": 8, "content_hash": "ddee09ba46cda5ae3b1b8ef0e2725163fb00b096a288b5f818bc553a4783a7c5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:483efe6ab26f4c00bac41a449a8f1eb9e78873ae1267267bddf9c4e7d2e541da", "content": "This is a debug level message which occurs the first time an anonymous user attempts to access a protected resource.\n\n[source]\n----\nDEBUG [ExceptionTranslationFilter] - Access is denied (user is anonymous); redirecting to authentication entry point\norg.springframework.security.AccessDeniedException: Access is denied\nat org.springframework.security.vote.AffirmativeBased.decide(AffirmativeBased.java:68)\nat org.springframework.security.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:262)\n----\n\nIt is normal and shouldn't be anything to worry about.\n\n[[appendix-faq-cached-secure-page]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I get an exception with the message \"Access is denied (user is anonymous);\". What's wrong?", "heading_level": 3, "file_order": 72, "section_index": 9, "content_hash": "483efe6ab26f4c00bac41a449a8f1eb9e78873ae1267267bddf9c4e7d2e541da", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:ddfb8409fa76c404b6ecd642b63254eaab130503bffe61dc24392bd094b8dc0d", "content": "The most common reason for this is that your browser has cached the page, and you are seeing a copy that is being retrieved from the browsers cache.\nVerify this by checking whether the browser is actually sending the request (check your server access logs and the debug log or use a suitable browser debugging plugin, such as \"`Tamper Data`\" for Firefox). This has nothing to do with Spring Security, and you should configure your application or server to set the appropriate `Cache-Control` response headers.\nNote that SSL requests are never cached.\n\n[[auth-exception-credentials-not-found]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "Why can I still see a secured page even after I have logged out of my application?", "heading_level": 3, "file_order": 72, "section_index": 10, "content_hash": "ddfb8409fa76c404b6ecd642b63254eaab130503bffe61dc24392bd094b8dc0d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:320b073ef847c61721e591c62c08cfc031b148117ae2fd667c9ea5a59eaff71e", "content": "The following listing shows another debug-level message that occurs the first time an anonymous user attempts to access a protected resource. However, this listing shows what happens when you do not have an `AnonymousAuthenticationFilter` in your filter chain configuration:\n\n[source]\n----\nDEBUG [ExceptionTranslationFilter] - Authentication exception occurred; redirecting to authentication entry point\norg.springframework.security.AuthenticationCredentialsNotFoundException:\n An Authentication object was not found in the SecurityContext\nat org.springframework.security.intercept.AbstractSecurityInterceptor.credentialsNotFound(AbstractSecurityInterceptor.java:342)\nat org.springframework.security.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:254)\n----\n\nIt is normal and is not something to worry about.\n\n[[appendix-faq-ldap-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I get an exception with a message of \"An Authentication object was not found in the SecurityContext\". What is wrong?", "heading_level": 3, "file_order": 72, "section_index": 11, "content_hash": "320b073ef847c61721e591c62c08cfc031b148117ae2fd667c9ea5a59eaff71e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:7b6aa06f182ff3c2f93005b01575b484865fa509434aa31073a81f0d22089fbf", "content": "Note that the permissions for an LDAP directory often do not let you read the password for a user.\nHence, it is often not possible to use the <<appendix-faq-what-is-userdetailservice>> where Spring Security compares the stored password with the one submitted by the user.\nThe most common approach is to use LDAP \"`bind`\", which is one of the operations supported by https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol[the LDAP protocol]. With this approach, Spring Security validates the password by trying to authenticate to the directory as the user.\n\nThe most common problem with LDAP authentication is a lack of knowledge of the directory server tree structure and configuration.\nThis differs from one company to another, so you have to find it out yourself.\nBefore adding a Spring Security LDAP configuration to an application, you should write a simple test by using standard Java LDAP code (without Spring Security involved) and make sure you can get that to work first.\nFor example, to authenticate a user, you could use the following code:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n\n@Test\npublic void ldapAuthenticationIsSuccessful() throws Exception {\n Hashtable<String,String> env = new Hashtable<String,String>();\n env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n env.put(Context.SECURITY_PRINCIPAL, \"cn=joe,ou=users,dc=mycompany,dc=com\");\n env.put(Context.PROVIDER_URL, \"ldap://mycompany.com:389/dc=mycompany,dc=com\");\n env.put(Context.SECURITY_CREDENTIALS, \"joespassword\");\n env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n\n InitialLdapContext ctx = new InitialLdapContext(env, null);\n\n}\n\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Test\nfun ldapAuthenticationIsSuccessful() {\n val env = Hashtable<String, String>()\n env[Context.SECURITY_AUTHENTICATION] = \"simple\"\n env[Context.SECURITY_PRINCIPAL] = \"cn=joe,ou=users,dc=mycompany,dc=com\"\n env[Context.PROVIDER_URL] = \"ldap://mycompany.com:389/dc=mycompany,dc=com\"\n env[Context.SECURITY_CREDENTIALS] = \"joespassword\"\n env[Context.INITIAL_CONTEXT_FACTORY] = \"com.sun.jndi.ldap.LdapCtxFactory\"\n val ctx = InitialLdapContext(env, null)\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I can't get LDAP authentication to work. What's wrong with my configuration?", "heading_level": 3, "file_order": 72, "section_index": 12, "content_hash": "7b6aa06f182ff3c2f93005b01575b484865fa509434aa31073a81f0d22089fbf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:0fc5c65c2a08d14cea7b53756b847772a429c49a7565ff40e368f0884c9c8b5f", "content": "Session management issues are a common source of questions.\nIf you are developing Java web applications, you should understand how the session is maintained between the servlet container and the user's browser.\nYou should also understand the difference between secure and non-secure cookies and the implications of using HTTP and HTTPS and switching between the two.\nSpring Security has nothing to do with maintaining the session or providing session identifiers.\nThis is entirely handled by the servlet container.\n\n[[appendix-faq-concurrent-session-same-browser]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "Session Management", "heading_level": 3, "file_order": 72, "section_index": 13, "content_hash": "0fc5c65c2a08d14cea7b53756b847772a429c49a7565ff40e368f0884c9c8b5f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:8b1980ab8d6c727cdb0e0edf9d7b85754dd650d2546fab04500841f5f616a93a", "content": "Browsers generally maintain a single session per browser instance.\nYou cannot have two separate sessions at once.\nSo if you log in again in another window or tab you are just reauthenticating in the same session.\nSo, if you log in again in another window or tab, you are reauthenticating in the same session.\nThe server does not know anything about tabs, windows, or browser instances.\nAll it sees are HTTP requests, and it ties those to a particular session according to the value of the `JSESSIONID` cookie that they contain.\nWhen a user authenticates during a session, Spring Security's concurrent session control checks the number of _other authenticated sessions_ that they have.\nIf they are already authenticated with the same session, re-authenticating has no effect.\n\n[[appendix-faq-new-session-on-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I am using Spring Security's concurrent session control to prevent users from logging in more than once at the same time. When I open another browser window after logging in, it does not stop me from logging in again. Why can I log in more than once?", "heading_level": 3, "file_order": 72, "section_index": 14, "content_hash": "8b1980ab8d6c727cdb0e0edf9d7b85754dd650d2546fab04500841f5f616a93a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:9c392eb10070c511ed6c360e3012a56bd8847a5e8e699f11dd551bb900cf75e6", "content": "With the default configuration, Spring Security changes the session ID when the user authenticates.\nIf you use a Servlet 3.1 or newer container, the session ID is simply changed.\nIf you use an older container, Spring Security invalidates the existing session, creates a new session, and transfers the session data to the new session.\nChanging the session identifier in this manner prevents \"`session-fixation`\" attacks.\nYou can find more about this online and in the reference manual.\n\n[[appendix-faq-tomcat-https-session]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "Why does the session ID change when I authenticate through Spring Security?", "heading_level": 3, "file_order": 72, "section_index": 15, "content_hash": "9c392eb10070c511ed6c360e3012a56bd8847a5e8e699f11dd551bb900cf75e6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:7c7025143e3811c403f8b2df709d2ed467dbf78a38bbbfe729c7190a50469c97", "content": "It doesn't work - I just end up back at the login page after authenticating.\n\nThis happens because sessions created under HTTPS, for which the session cookie is marked as \"`secure`\", cannot subsequently be used under HTTP. The browser does not send the cookie back to the server, and any session state (including the security context information) is lost. Starting a session in HTTP first should work, as the session cookie is not marked as secure.\nHowever, Spring Security's https://docs.spring.io/spring-security/site/docs/3.1.x/reference/springsecurity-single.html#ns-session-fixation[Session Fixation Protection] can interfere with this because it results in a new session ID cookie being sent back to the user's browser, usually with the secure flag.\nTo get around this, you can disable session fixation protection. However, in newer Servlet containers, you can also configure session cookies to never use the secure flag.\n\n[IMPORTANT]\n====\nSwitching between HTTP and HTTPS is not a good idea in general, as any application that uses HTTP at all is vulnerable to man-in-the-middle attacks.\nTo be truly secure, the user should begin accessing your site in HTTPS and continue using it until they log out.\nEven clicking on an HTTPS link from a page accessed over HTTP is potentially risky.\nIf you need more convincing, check out a tool like https://github.com/moxie0/sslstrip/[sslstrip].\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I use Tomcat (or some other servlet container) and have enabled HTTPS for my login page, switching back to HTTP afterward. It does not work. I end up back at the login page after authenticating.", "heading_level": 3, "file_order": 72, "section_index": 16, "content_hash": "7c7025143e3811c403f8b2df709d2ed467dbf78a38bbbfe729c7190a50469c97", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:4436615b620e77dbf60eb1912e419ed995860a77c98b107caa7554a5905467ae", "content": "Sessions are maintained either by exchanging a session cookie or by adding a `jsessionid` parameter to URLs (this happens automatically if you use JSTL to output URLs or if you call `HttpServletResponse.encodeUrl` on URLs (before a redirect, for example). If clients have cookies disabled, and you are not rewriting URLs to include the `jsessionid`, the session is lost.\nNote that the use of cookies is preferred for security reasons, as it does not expose the session information in the URL.\n\n[[appendix-faq-session-listener-missing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I am not switching between HTTP and HTTPS, but my session is still lost. What happened?", "heading_level": 3, "file_order": 72, "section_index": 17, "content_hash": "4436615b620e77dbf60eb1912e419ed995860a77c98b107caa7554a5905467ae", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:715d23040e9aa9dd5b7a55614c12183299f7f406eac93a619492d57dda7d5fd0", "content": "Make sure you have added the listener to your `web.xml` file.\nIt is essential to make sure that the Spring Security session registry is notified when a session is destroyed.\nWithout it, the session information is not removed from the registry.\nThe following example adds a listener in a `web.xml` file:\n\n[source,xml]\n----\n<listener>\n <listener-class>org.springframework.security.web.session.HttpSessionEventPublisher</listener-class>\n</listener>\n----\n\n[[appendix-faq-unwanted-session-creation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I am trying to use the concurrent session-control support, but it does not let me log back in, even if I am sure I have logged out and have not exceeded the allowed sessions. What is wrong?", "heading_level": 3, "file_order": 72, "section_index": 18, "content_hash": "715d23040e9aa9dd5b7a55614c12183299f7f406eac93a619492d57dda7d5fd0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:592bec877fb071ae68866ca02c6ddce91abcaf0b76f236966f2df242a964db34", "content": "This usually means that the user's application is creating a session somewhere but that they are not aware of it.\nThe most common culprit is a JSP. Many people are not aware that JSPs create sessions by default.\nTo prevent a JSP from creating a session, add the `<%@ page session=\"false\" %>` directive to the top of the page.\n\nIf you have trouble working out where a session is being created, you can add some debugging code to track down the location(s). One way to do this is to add a `javax.servlet.http.HttpSessionListener`, which calls `Thread.dumpStack()` in the `sessionCreated` method, to your application.\n\n[[appendix-faq-forbidden-csrf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "Spring Security creates a session somewhere, even though I have configured it not to, by setting the create-session attribute to never. What is wrong?", "heading_level": 3, "file_order": 72, "section_index": 19, "content_hash": "592bec877fb071ae68866ca02c6ddce91abcaf0b76f236966f2df242a964db34", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:77941837ef8990d62f06401f8c977f357389c1f0d11125ca9ed6181973a10a83", "content": "If an HTTP 403 Forbidden error is returned for HTTP POST, but it works for HTTP GET, the issue is most likely related to https://docs.spring.io/spring-security/site/docs/3.2.x/reference/htmlsingle/#csrf[CSRF]. Either provide the CSRF Token or disable CSRF protection (the latter is not recommended).\n\n[[appendix-faq-no-security-on-forward]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I get a 403 Forbidden when performing a POST. What is wrong?", "heading_level": 3, "file_order": 72, "section_index": 20, "content_hash": "77941837ef8990d62f06401f8c977f357389c1f0d11125ca9ed6181973a10a83", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:1debfac4fda9c4c02e53fb17cd2fbe687e348f208974de537b80e86a9c3aef3a", "content": "By default, filters are not applied to forwards or includes.\nIf you really want the security filters to be applied to forwards or includes, you have to configure these explicitly in your `web.xml` file by using the `<dispatcher>` element, which is a child element of the `<filter-mapping>` element.\n\n[[appendix-faq-method-security-in-web-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I am forwarding a request to another URL by using the RequestDispatcher, but my security constraints are not being applied.", "heading_level": 3, "file_order": 72, "section_index": 21, "content_hash": "1debfac4fda9c4c02e53fb17cd2fbe687e348f208974de537b80e86a9c3aef3a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:1a4ede65737ef6cf463f809c04605e6380bffbd75b99c94ef38307f0baca23e5", "content": "In a Spring web application, the application context that holds the Spring MVC beans for the dispatcher servlet is often separate from the main application context.\nIt is often defined in a file called `myapp-servlet.xml`, where `myapp` is the name assigned to the Spring `DispatcherServlet` in the `web.xml` file. An application can have multiple `DispatcherServlet` instances, each with its own isolated application context.\nThe beans in these \"`child`\" contexts are not visible to the rest of the application.\nThe \"`parent`\" application context is loaded by the `ContextLoaderListener` you define in your `web.xml` file and is visible to all the child contexts.\nThis parent context is usually where you define your security configuration, including the `<global-method-security>` element. As a result, any security constraints applied to methods in these web beans are not enforced, since the beans cannot be seen from the `DispatcherServlet` context.\nYou need to either move the `<global-method-security>` declaration to the web context or move the beans you want secured into the main application context.\n\nGenerally, we recommend applying method security at the service layer rather than on individual web controllers.\n\n[[appendix-faq-no-filters-no-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I have added Spring Security's <global-method-security> element to my application context, but, if I add security annotations to my Spring MVC controller beans (Struts actions etc.), they do not seem to have an effect. Why not?", "heading_level": 3, "file_order": 72, "section_index": 22, "content_hash": "1a4ede65737ef6cf463f809c04605e6380bffbd75b99c94ef38307f0baca23e5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:249a032816a143c8a9520effc4ee48cac9b4c1e5597b67de4d3f7ed25db1adb6", "content": "Why can't I see the user information?\n\nIf you have excluded the request from the security filter chain by using the `filters='none'` attribute in the `<intercept-url>` element that matches the URL pattern, the `SecurityContextHolder` is not populated for that request.\nCheck the debug log to see whether the request is passing through the filter chain.\n(You are reading the debug log, right?)\n\n[[appendix-faq-method-security-with-taglib]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I have a user who has definitely been authenticated, but, when I try to access the SecurityContextHolder during some requests, the Authentication is null. Why can I not see the user information?", "heading_level": 3, "file_order": 72, "section_index": 23, "content_hash": "249a032816a143c8a9520effc4ee48cac9b4c1e5597b67de4d3f7ed25db1adb6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:c54bd991827dfd08428b5f7c2f38fe57649bef3cc22231a90323d17fe9a892b6", "content": "Method security does not hide links when using the `url` attribute in `<sec:authorize>`, because we cannot readily reverse engineer what URL is mapped to what controller endpoint. We are limited because controllers can rely on headers, the current user, and other details to determine what method to invoke.\n\n[[appendix-faq-architecture]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "The authorize JSP Tag does not respect my method security annotations when using the URL attribute. Why not?", "heading_level": 3, "file_order": 72, "section_index": 24, "content_hash": "c54bd991827dfd08428b5f7c2f38fe57649bef3cc22231a90323d17fe9a892b6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:f35505d59a2d7f5b22fb177cc043236e3c609d3618e005e22a3a605a4e2725a0", "content": "This section addresses common Spring Security architecture questions:\n\n. <<appendix-faq-where-is-class-x>>\n. <<appendix-faq-namespace-to-bean-mapping>>\n. <<appendix-faq-role-prefix>>\n. <<appendix-faq-what-dependencies>>\n. <<appendix-faq-unboundid-deps>>\n. <<appendix-faq-what-is-userdetailservice>>\n\n[[appendix-faq-where-is-class-x]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "Spring Security Architecture Questions", "heading_level": 2, "file_order": 72, "section_index": 25, "content_hash": "f35505d59a2d7f5b22fb177cc043236e3c609d3618e005e22a3a605a4e2725a0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:158cd56923cd03b777a3a6dcdfe0c817f160097f83cfc7b9ac58373aa4e2ee15", "content": "The best way of locating classes is by installing the Spring Security source in your IDE. The distribution includes source jars for each of the modules the project is divided up into.\nAdd these to your project source path, and then you can navigate directly to Spring Security classes (`Ctrl-Shift-T` in Eclipse). This also makes debugging easier and lets you troubleshoot exceptions by looking directly at the code where they occur to see what is going on there.\n\n[[appendix-faq-namespace-to-bean-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "How do I know which package class X is in?", "heading_level": 3, "file_order": 72, "section_index": 26, "content_hash": "158cd56923cd03b777a3a6dcdfe0c817f160097f83cfc7b9ac58373aa4e2ee15", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:abd3b0a5bbc3be1727bc5b3bca028e6d475de714a85495c4297981f3a9824636", "content": "There is a general overview of what beans are created by the namespace in the namespace appendix of the reference guide.\nThere is also a detailed blog article called \"Behind the Spring Security Namespace\" on https://spring.io/blog/2010/03/06/behind-the-spring-security-namespace/[blog.springsource.com]. If you want to know the full details, then the code is in the `spring-security-config` module within the Spring Security 3.0 distribution.\nYou should probably read the chapters on namespace parsing in the standard Spring Framework reference documentation first.\n\n[[appendix-faq-role-prefix]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "How do the namespace elements map to conventional bean configurations?", "heading_level": 3, "file_order": 72, "section_index": 27, "content_hash": "abd3b0a5bbc3be1727bc5b3bca028e6d475de714a85495c4297981f3a9824636", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:8c760262203621c25fcd5d5e82ad7531edb0949ba38c256fe3e703e46976c445", "content": "`ROLE_` is a way to identify the nature of a given authority.\nAn authority prefixed by `ROLE_` means that this authority is a role, likely derived from an RBAC authorization model.\n\nHaving a prefix allows for clear differentiation from OAuth 2.0 scopes (which use `SCOPE_`) and authorities granted from other sources as well.\n\nYou may choose to not prefix your authorities.\nModern Spring Security authorization components either allow you to supply the entire authority name, rendering the prefix unnecessary.\nAn example of this is how xref:servlet/authorization/authorize-http-requests.adoc[`authorizeHttpRequests`] and xref:servlet/authorization/method-security.adoc[`@PreAuthorize`] allow you to call `hasAuthority` or `hasRole`.\n\n[[appendix-faq-what-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "What does \"ROLE_\" mean?", "heading_level": 3, "file_order": 72, "section_index": 28, "content_hash": "8c760262203621c25fcd5d5e82ad7531edb0949ba38c256fe3e703e46976c445", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:6a55835926a983618848ed5792504fd9c2f04f08c8ffe37d833f145f1b1054e0", "content": "It depends on what features you are using and what type of application you are developing.\nWith Spring Security 3.0, the project jars are divided into clearly distinct areas of functionality, so it is straightforward to work out which Spring Security jars you need from your application requirements.\nAll applications need the `spring-security-core` jar.\nIf you are developing a web application, you need the `spring-security-web` jar.\nIf you are using security namespace configuration, you need the `spring-security-config` jar. For LDAP support, you need the `spring-security-ldap` jar. And so on.\n\nFor third-party jars, the situation is not always quite so obvious.\nA good starting point is to copy those from one of the pre-built sample applications `WEB-INF/lib` directories.\nFor a basic application, you can start with the tutorial sample.\nFor a basic application, you can start with the tutorial sample.\nIf you want to use LDAP with an embedded test server, use the LDAP sample as a starting point.\nThe reference manual also includes <<appendix-namespace,an appendix>> that lists the first-level dependencies for each Spring Security module, with some information on whether they are optional and when they are required.\n\nIf you build your project with Maven, adding the appropriate Spring Security modules as dependencies to your `pom.xml` file automatically pulls in the core jars that the framework requires.\nAny that are marked as \"`optional`\" in the Spring Security `pom.xml` files have to be added to your own `pom.xml` file if you need them.\n\n[[appendix-faq-unboundid-deps]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "How do I know which dependencies to add to my application to work with Spring Security?", "heading_level": 3, "file_order": 72, "section_index": 29, "content_hash": "6a55835926a983618848ed5792504fd9c2f04f08c8ffe37d833f145f1b1054e0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:074e0b8a92c9d89caf1b0d30ac025a9c82a99be8023bf746ea8a7302ad401b74", "content": "You need to add the following dependency to your project:\n\n[tabs]\n======\nMaven::\n+\n[source,maven,role=\"primary\"]\n----\n<dependency>\n <groupId>com.unboundid</groupId>\n <artifactId>unboundid-ldapsdk</artifactId>\n <version>7.0.1</version>\n <scope>runtime</scope>\n</dependency>\n----\n\nGradle::\n+\n[source,gradle,role=\"secondary\"]\n----\nimplementation 'com.unboundid:unboundid-ldapsdk:7.0.1'\n----\n======\n\n[[appendix-faq-apacheds-deps]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "What dependencies are needed to run an embedded UnboundID LDAP server?", "heading_level": 3, "file_order": 72, "section_index": 30, "content_hash": "074e0b8a92c9d89caf1b0d30ac025a9c82a99be8023bf746ea8a7302ad401b74", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:ffbc5dd2f9ba7d8cf6c6c225a420006a5ff50727bd7e5b174f0fe806ac12163f", "content": "Spring Security 7 removes support for Apache DS.\nPlease use <<appendix-faq-unboundid-deps,UnboundID>> instead.\n\n[[appendix-faq-what-is-userdetailservice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "What dependencies are needed to run an embedded ApacheDS LDAP server?", "heading_level": 3, "file_order": 72, "section_index": 31, "content_hash": "ffbc5dd2f9ba7d8cf6c6c225a420006a5ff50727bd7e5b174f0fe806ac12163f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:75aca44a49cf5a0f5adb9bb7e34e5b2955117990e8cbb33dd1b2c9238a01c43b", "content": "`UserDetailsService` is a DAO interface for loading data that is specific to a user account.\nIt has no function other than to load that data for use by other components within the framework.\nIt is not responsible for authenticating the user.\nAuthenticating a user with a username and password combination is most commonly performed by the `DaoAuthenticationProvider`, which is injected with a `UserDetailsService` to let it load the password (and other data) for a user, to compare it with the submitted value.\nNote that, if you use LDAP, <<appendix-faq-ldap-authentication,this approach may not work>>.\n\nIf you want to customize the authentication process, you should implement `AuthenticationProvider` yourself.\nSee this https://spring.io/blog/2010/08/02/spring-security-in-google-app-engine/[ blog article] for an example that integrate Spring Security authentication with Google App Engine.\n\n[[appendix-faq-howto]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "What is a UserDetailsService and do I need one?", "heading_level": 3, "file_order": 72, "section_index": 32, "content_hash": "75aca44a49cf5a0f5adb9bb7e34e5b2955117990e8cbb33dd1b2c9238a01c43b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:020301a4952a65656f48bf6f527910872ffdff31486d7162ce86225334b91291", "content": "This section addresses common how-to questions about Spring Security:\n\n. <<appendix-faq-extra-login-fields>>\n. <<appendix-faq-matching-url-fragments>>\n. <<appendix-faq-request-details-in-user-service>>\n. <<appendix-faq-access-session-from-user-service>>\n. <<appendix-faq-password-in-user-service>>\n. <<appendix-faq-dynamic-url-metadata>>\n. <<appendix-faq-ldap-authorities>>\n. <<appendix-faq-namespace-post-processor>>\n\n[[appendix-faq-extra-login-fields]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "Common How-to Questions", "heading_level": 2, "file_order": 72, "section_index": 33, "content_hash": "020301a4952a65656f48bf6f527910872ffdff31486d7162ce86225334b91291", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:faabaee524c0819b4877017ccd91d9cfc19d1c5685e7e5ab7e5e0ac347c286aa", "content": "This question comes up repeatedly, so you can find more information by searching online.\n\nThe submitted login information is processed by an instance of `UsernamePasswordAuthenticationFilter`. You need to customize this class to handle the extra data fields. One option is to use your own customized authentication token class (rather than the standard `UsernamePasswordAuthenticationToken`). Another option is to concatenate the extra fields with the username (for example, by using a `:` character as the separator) and pass them in the username property of `UsernamePasswordAuthenticationToken`.\n\nYou also need to customize the actual authentication process.\nIf you use a custom authentication token class, for example, you will have to write an `AuthenticationProvider` (or extend the standard `DaoAuthenticationProvider`) to handle it. If you have concatenated the fields, you can implement your own `UserDetailsService` to split them up and load the appropriate user data for authentication.\n\n[[appendix-faq-matching-url-fragments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I need to log in with more information than just the username. How do I add support for extra login fields (such as a company name)?", "heading_level": 3, "file_order": 72, "section_index": 34, "content_hash": "faabaee524c0819b4877017ccd91d9cfc19d1c5685e7e5ab7e5e0ac347c286aa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:0ee566841e8c43bfeb50e10485bb5fb33f19b1e8a7f28e5c41d03c612bb18f81", "content": "You cannot do this, since the fragment is not transmitted from the browser to the server.\nFrom the server's perspective, the URLs are identical.\nThis is a common question from GWT users.\n\n[[appendix-faq-request-details-in-user-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "How do I apply different intercept-url constraints where only the fragment value of the requested URLs differs (such as /thing1#thing2 and /thing1#thing3)?", "heading_level": 3, "file_order": 72, "section_index": 35, "content_hash": "0ee566841e8c43bfeb50e10485bb5fb33f19b1e8a7f28e5c41d03c612bb18f81", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:88cae340ca5b14c7b7df00ad2f28bdb9376c5865744001116fce6d6a4f2dbbaf", "content": "You cannot (without resorting to something like thread-local variables), since the only information supplied to the interface is the username.\nInstead of implementing `UserDetailsService`, you should implement `AuthenticationProvider` directly and extract the information from the supplied `Authentication` token.\n\nIn a standard web setup, the `getDetails()` method on the `Authentication` object will return an instance of `WebAuthenticationDetails`. If you need additional information, you can inject a custom `AuthenticationDetailsSource` into the authentication filter you are using.\nIf you are using the namespace, for example with the `<form-login>` element, then you should remove this element and replace it with a `<custom-filter>` declaration pointing to an explicitly configured `UsernamePasswordAuthenticationFilter`.\n\n[[appendix-faq-access-session-from-user-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "How do I access the user's IP Address (or other web-request data) in a UserDetailsService?", "heading_level": 3, "file_order": 72, "section_index": 36, "content_hash": "88cae340ca5b14c7b7df00ad2f28bdb9376c5865744001116fce6d6a4f2dbbaf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:a5ba53945e3dc674fe6fb8b3a71a33ed5329d52e34df08bf2c47fca46c44677d", "content": "You cannot, since the `UserDetailsService` has no awareness of the servlet API. If you want to store custom user data, you should customize the `UserDetails` object that is returned.\nThis can then be accessed at any point, through the thread-local `SecurityContextHolder`. A call to `SecurityContextHolder.getContext().getAuthentication().getPrincipal()` returns this custom object.\n\nIf you really need to access the session, you must do so by customizing the web tier.\n\n[[appendix-faq-password-in-user-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "How do I access the HttpSession from a UserDetailsService?", "heading_level": 3, "file_order": 72, "section_index": 37, "content_hash": "a5ba53945e3dc674fe6fb8b3a71a33ed5329d52e34df08bf2c47fca46c44677d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:303dde74021ae647f82f07216ddd39a3bc247ef9433c1dc5a460a9470f80b926", "content": "You cannot (and should not, even if you find a way to do so). You are probably misunderstanding its purpose.\nSee \"<<appendix-faq-what-is-userdetailservice,What is a UserDetailsService?>>\", earlier in the FAQ.\n\n[[appendix-faq-dynamic-url-metadata]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "How do I access the user's password in a UserDetailsService?", "heading_level": 3, "file_order": 72, "section_index": 38, "content_hash": "303dde74021ae647f82f07216ddd39a3bc247ef9433c1dc5a460a9470f80b926", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:a4fb63b39603593d054160cbf58dbeff81b830ec317b59cd5781e59e3607a6da", "content": "People often ask about how to store the mapping between secured URLs and security metadata attributes in a database rather than in the application context.\n\nThe first thing you should ask yourself is if you really need to do this.\nIf an application needs to be secure, it also requires that the security be tested thoroughly based on a defined policy.\nIt may require auditing and acceptance testing before being rolled out into a production environment.\nA security-conscious organization should be aware that the benefits of their diligent testing process could be wiped out instantly by letting the security settings be modified at runtime by changing a row or two in a configuration database.\nIf you have taken this into account (perhaps by using multiple layers of security within your application), Spring Security lets you fully customize the source of security metadata.\nYou can make it fully dynamic if you choose.\n\nBoth method and web security are protected by implementations of `AuthorizationManager`.\nFor web security, you can supply your own implementation of `AuthorizationManager<RequestAuthorizationContext>` and supply it to the filter chain DSL like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class DynamicAuthorizationManager implements AuthorizationManager<RequestAuthorizationContext> {\n\tprivate final MyExternalAuthorizationService authz;\n\n\t// ...\n\n @Override\n public AuthorizationResult authorize(Supplier<Authentication> authentication, RequestAuthorizationContext context) {\n // query the external service\n }\n}\n\nhttp\n .authorizeHttpRequests((authorize) -> authorize.anyRequest().access(dynamicAuthorizationManager))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass DynamicAuthorizationManager : AuthorizationManager<RequestAuthorizationContext?> {\n private val rules: MyAuthorizationRulesRepository? = null\n\n // ...\n\n override fun authorize(authentication: Supplier<Authentication?>?, context: RequestAuthorizationContext?): AuthorizationResult {\n // look up rules from the database\n }\n}\n\nhttp {\n authorizeHttpRequests {\n authorize(anyRequest, dynamicAuthorizationManager)\n }\n}\n----\n======\n\nFor method security, you can supply your own implementation of `AuthorizationManager<MethodInvocation>` and supply it to Spring AOP like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class DynamicAuthorizationManager implements AuthorizationManager<MethodInvocation> {\n\tprivate final MyExternalAuthorizationService authz;\n\n\t// ...\n\n @Override\n public AuthorizationResult authorize(Supplier<Authentication> authentication, MethodInvocation invocation) {\n // query the external service\n }\n}\n\n@Bean\nstatic Advisor securedAuthorizationAdvisor(DynamicAuthorizationManager dynamicAuthorizationManager) {\n return AuthorizationManagerBeforeMethodInterceptor.secured(dynamicAuthorizationManager)\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass DynamicAuthorizationManager : AuthorizationManager<MethodInvocation?> {\n private val authz: MyExternalAuthorizationService? = null\n\n // ...\n override fun authorize(authentication: Supplier<Authentication?>?, invocation: MethodInvocation?): AuthorizationResult {\n // query the external service\n }\n}\n\ncompanion object {\n @Bean\n fun securedAuthorizationAdvisor(dynamicAuthorizationManager: DynamicAuthorizationManager): Advisor {\n return AuthorizationManagerBeforeMethodInterceptor.preAuthorize(dynamicAuthorizationManager)\n }\n}\n----\n======\n\n[[appendix-faq-ldap-authorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "How do I dynamically define the secured URLs within an application?", "heading_level": 3, "file_order": 72, "section_index": 39, "content_hash": "a4fb63b39603593d054160cbf58dbeff81b830ec317b59cd5781e59e3607a6da", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:ca9a8067b66e282ecb3883e0e2b3921bb426652e0457433f703042b7632cabe8", "content": "The `LdapAuthenticationProvider` bean (which handles normal LDAP authentication in Spring Security) is configured with two separate strategy interfaces, one that performs the authentication and one that loads the user authorities, called `LdapAuthenticator` and `LdapAuthoritiesPopulator`, respectively.\nThe `DefaultLdapAuthoritiesPopulator` loads the user authorities from the LDAP directory and has various configuration parameters to let you specify how these should be retrieved.\n\nTo use JDBC instead, you can implement the interface yourself, by using whatever SQL is appropriate for your schema:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n\npublic class MyAuthoritiesPopulator implements LdapAuthoritiesPopulator {\n @Autowired\n JdbcTemplate template;\n\n List<GrantedAuthority> getGrantedAuthorities(DirContextOperations userData, String username) {\n return template.query(\"select role from roles where username = ?\",\n new String[] {username},\n new RowMapper<GrantedAuthority>() {\n /**\n * We're assuming here that you're using the standard convention of using the role\n * prefix \"ROLE_\" to mark attributes which are supported by Spring Security's RoleVoter.\n */\n @Override\n public GrantedAuthority mapRow(ResultSet rs, int rowNum) throws SQLException {\n return new SimpleGrantedAuthority(\"ROLE_\" + rs.getString(1));\n }\n });\n }\n}\n\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass MyAuthoritiesPopulator : LdapAuthoritiesPopulator {\n @Autowired\n lateinit var template: JdbcTemplate\n\n override fun getGrantedAuthorities(userData: DirContextOperations, username: String): MutableList<GrantedAuthority?> {\n return template.query(\"select role from roles where username = ?\",\n arrayOf(username)\n ) { rs, _ ->\n /**\n * We're assuming here that you're using the standard convention of using the role\n * prefix \"ROLE_\" to mark attributes which are supported by Spring Security's RoleVoter.\n */\n SimpleGrantedAuthority(\"ROLE_\" + rs.getString(1))\n }\n }\n}\n----\n======\n\nYou would then add a bean of this type to your application context and inject it into the `LdapAuthenticationProvider`. This is covered in the section on configuring LDAP by using explicit Spring beans in the LDAP chapter of the reference manual.\nNote that you cannot use the namespace for configuration in this case.\nYou should also consult the {security-api-url}[Javadoc] for the relevant classes and interfaces.\n\n[[appendix-faq-namespace-post-processor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "How do I authenticate against LDAP but load user roles from a database?", "heading_level": 3, "file_order": 72, "section_index": 40, "content_hash": "ca9a8067b66e282ecb3883e0e2b3921bb426652e0457433f703042b7632cabe8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:ff924e451faee7587b859b5d649927395e0eb04db704c3844a59fc869fdb352c", "content": "The namespace functionality is intentionally limited, so it does not cover everything that you can do with plain beans.\nIf you want to do something simple, such as modifying a bean or injecting a different dependency, you can do so by adding a `BeanPostProcessor` to your configuration.\nYou can find more information in the https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/htmlsingle/spring-framework-reference.html#beans-factory-extension-bpp[Spring Reference Manual]. To do so, you need to know a bit about which beans are created, so you should also read the blog article mentioned in the earlier question on <<appendix-faq-namespace-to-bean-mapping,how the namespace maps to Spring beans>>.\n\nNormally, you would add the functionality you require to the `postProcessBeforeInitialization` method of `BeanPostProcessor`. Suppose that you want to customize the `AuthenticationDetailsSource` used by the `UsernamePasswordAuthenticationFilter` (created by the `form-login` element). You want to extract a particular header called `CUSTOM_HEADER` from the request and use it while authenticating the user.\nThe processor class would look like the following listing:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class CustomBeanPostProcessor implements BeanPostProcessor {\n\n public Object postProcessAfterInitialization(Object bean, String name) {\n if (bean instanceof UsernamePasswordAuthenticationFilter) {\n System.out.println(\"********* Post-processing \" + name);\n ((UsernamePasswordAuthenticationFilter)bean).setAuthenticationDetailsSource(\n new AuthenticationDetailsSource() {\n public Object buildDetails(Object context) {\n return ((HttpServletRequest)context).getHeader(\"CUSTOM_HEADER\");\n }\n });\n }\n return bean;\n }\n\n public Object postProcessBeforeInitialization(Object bean, String name) {\n return bean;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass CustomBeanPostProcessor : BeanPostProcessor {\n override fun postProcessAfterInitialization(bean: Any, name: String): Any {\n if (bean is UsernamePasswordAuthenticationFilter) {\n println(\"********* Post-processing $name\")\n bean.setAuthenticationDetailsSource(\n AuthenticationDetailsSource<HttpServletRequest, Any?> { context -> context.getHeader(\"CUSTOM_HEADER\") })\n }\n return bean\n }\n\n override fun postProcessBeforeInitialization(bean: Any, name: String?): Any {\n return bean\n }\n}\n----\n======\n\nYou would then register this bean in your application context.\nSpring automatically invoke it on the beans defined in the application context.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/faq.adoc", "title": "faq", "heading": "I want to modify the property of a bean that is created by the namespace, but there is nothing in the schema to support it. What can I do short of abandoning namespace use?", "heading_level": 3, "file_order": 72, "section_index": 41, "content_hash": "ff924e451faee7587b859b5d649927395e0eb04db704c3844a59fc869fdb352c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/faq.adoc"}}
{"id": "sha256:7939c34905eb4e6900e19ed175c279fd1d211871205daa6d06fb55db8491b35a", "content": "This is an appendix for Servlet based Spring Security.\nIt has the following sections:\n\n* xref:servlet/appendix/database-schema.adoc[Database Schemas]\n* xref:servlet/appendix/namespace/index.adoc[XML Namespace]\n* xref:servlet/appendix/faq.adoc[FAQ]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/index.adoc", "title": "Appendix", "heading": "Appendix", "heading_level": 1, "file_order": 73, "section_index": 0, "content_hash": "7939c34905eb4e6900e19ed175c279fd1d211871205daa6d06fb55db8491b35a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/index.adoc"}}
{"id": "sha256:3fe52ae9898662859107bb4713548231c6f67905b5ec5f9f043050e9610892dd", "content": "[[appendix-proxy-server]]\n\nWhen using a proxy server it is important to ensure that you have configured your application properly.\nFor example, many applications will have a load balancer that responds to request for https://example.com/ by forwarding the request to an application server at https://192.168.1:8080\nWithout proper configuration, the application server will not know that the load balancer exists and treat the request as though https://192.168.1:8080 was requested by the client.\n\nTo fix this you can use https://tools.ietf.org/html/rfc7239[RFC 7239] to specify that a load balancer is being used.\nTo make the application aware of this, you need to either configure your application server aware of the X-Forwarded headers.\nFor example Tomcat uses the https://tomcat.apache.org/tomcat-10.1-doc/api/org/apache/catalina/valves/RemoteIpValve.html[RemoteIpValve] and Jetty uses https://eclipse.dev/jetty/javadoc/jetty-11/org/eclipse/jetty/server/ForwardedRequestCustomizer.html[ForwardedRequestCustomizer].\nAlternatively, Spring 4.3+ users can leverage https://github.com/spring-projects/spring-framework/blob/v4.3.3.RELEASE/spring-web/src/main/java/org/springframework/web/filter/ForwardedHeaderFilter.java[ForwardedHeaderFilter].\n\nSpring Boot users may use the `server.use-forward-headers` property to configure the application.\nSee the https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto.webserver.use-behind-a-proxy-server[Spring Boot documentation] for further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/appendix/proxy-server.adoc", "title": "proxy-server", "heading": "proxy-server", "heading_level": 1, "file_order": 74, "section_index": 0, "content_hash": "3fe52ae9898662859107bb4713548231c6f67905b5ec5f9f043050e9610892dd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/appendix/proxy-server.adoc"}}
{"id": "sha256:3d9a8a0057aa807df345e8d4ac35a506955e36235f6cf2916e9cde2157e011a2", "content": "[[appendices]]\n\n[appendix]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc", "title": "appendix", "heading": "appendix", "heading_level": 1, "file_order": 75, "section_index": 0, "content_hash": "3d9a8a0057aa807df345e8d4ac35a506955e36235f6cf2916e9cde2157e011a2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc"}}
{"id": "sha256:e1e6d1f37ca1bec6ab49bbcf372075f3dcd45054181197485c490e6a132a017a", "content": "Dummy UserDetailsService used in samples because we don't have a real\nuser source.\n\n[source,java,indent=0]\n----\npublic class DummyUserDetailsService implements UserDetailsService {\n\n    @Override\n    public UserDetails loadUserByUsername(String username)\n            throws UsernameNotFoundException {\n        return new User(username, \"notUsed\", true, true, true, true,\n                AuthorityUtils.createAuthorityList(\"ROLE_USER\"));\n    }\n\n}\n----\n\n[appendix]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc", "title": "appendix", "heading": "Material Used in this Document", "heading_level": 2, "file_order": 75, "section_index": 1, "content_hash": "e1e6d1f37ca1bec6ab49bbcf372075f3dcd45054181197485c490e6a132a017a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc"}}
{"id": "sha256:bc540b43a91df4199c4c33d0f260fc5ce90a6be3a92cc72e6f58ef422726fc48", "content": "In any authentication process there are usually a three parties\ninvolved.\n\nimage::{figures}/drawio-kerb-cc1.png[]\n\nFirst is a `client` which sometimes is a client computer but in most\nof the scenarios it is the actual user sitting on a computer and\ntrying to access resources. Then there is the `resource` user is trying\nto access. In this example it is a web server.\n\nThen there is a `Key Distribution Center` or `KDC`. In a case of\nWindows environment this would be a `Domain Controller`. `KDC` is the\none which really brings everything together and thus is the most\ncritical component in your environment. Because of this it is also\nconsidered as a single point of failure.\n\nInitially when `Kerberos` environment is setup and domain user\nprincipals created into a database, encryption keys are also\ncreated. These encryption keys are based on shared secrets(i.e. user\npassword) and actual passwords are never kept in a clear text.\nEffectively `KDC` has its own key and other keys for domain users.\n\nInterestingly there is no communication between a `resource` and a\n`KDC` during the authentication process.\n\nimage::{figures}/drawio-kerb-cc2.png[]\n\nWhen client wants to authenticate itself with a `resource` it first\nneeds to communicate with a `KDC`. `Client` will craft a special package\nwhich contains encrypted and unencrypted parts. Unencrypted part\ncontains i.e. information about a user and encrypted part other\ninformation which is part of a protocol. `Client` will encrypt package\ndata with its own key.\n\nWhen `KDC` receives this authentication package from a client it\nchecks who this `client` claims to be from an unencrypted part and based\non that information it uses `client` decryption key it already have in\nits database. If this decryption is successful `KDC` knows that this\n`client` is the one it claims to be.\n\nWhat KDC returns to a client is a ticket called `Ticket Granting\nTicket` which is signed by a KDC's own private key. Later when\n`client` sends back this ticket it can try to decrypt it and if that\noperation is successful it knows that it was a ticket it itself\noriginally signed and gave to a `client`.\n\nimage::{figures}/drawio-kerb-cc3.png[]\n\nWhen client wants to get a ticket which it can use to authenticate\nwith a service, `TGT` is sent to `KDC` which then signs a service ticket\nwith service's own key. This a moment when a trust between\n`client` and `service` is created. This service ticket contains data\nwhich only `service` itself is able to decrypt.\n\nimage::{figures}/drawio-kerb-cc4.png[]\n\nWhen `client` is authenticating with a service it sends previously\nreceived service ticket to a service which then thinks that I don't\nknow anything about this guy but he gave me an authentication ticket.\nWhat `service` can do next is try to decrypt that ticket and if that\noperation is successful it knows that only other party who knows my\ncredentials is the `KDC` and because I trust him I can also trust that\nthis client is a one he claims to be.\n\n[appendix]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc", "title": "appendix", "heading": "Crash Course to Kerberos", "heading_level": 2, "file_order": 75, "section_index": 2, "content_hash": "bc540b43a91df4199c4c33d0f260fc5ce90a6be3a92cc72e6f58ef422726fc48", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc"}}
{"id": "sha256:15b33717a11c8e63c5e37bc03676a649eb6df2e66a7977344474b11a03484033", "content": "Doing a production setup of Kerberos environment is out of scope of\nthis document but this appendix provides some help to get you\nstarted for setting up needed components for development.\n\n[[setupmitkerberos]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc", "title": "appendix", "heading": "Setup Kerberos Environments", "heading_level": 2, "file_order": 75, "section_index": 3, "content_hash": "15b33717a11c8e63c5e37bc03676a649eb6df2e66a7977344474b11a03484033", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc"}}
{"id": "sha256:55b6e68a4d0a7f245d10e102ff9686369cf19b4feb78b2ecb0a1800e12c916d4", "content": "First action is to setup a new realm and a database.\n\n[source,text,indent=0]\n----\n# kdb5_util create -s -r EXAMPLE.ORG\nLoading random data\nInitializing database '/var/lib/krb5kdc/principal' for realm 'EXAMPLE.ORG',\nmaster key name 'K/M@EXAMPLE.ORG'\nYou will be prompted for the database Master Password.\nIt is important that you NOT FORGET this password.\nEnter KDC database master key:\nRe-enter KDC database master key to verify:\n----\n\n`kadmin` command can be used to administer Kerberos environment but\nyou can't yet use it because there are no admin users in a database.\n\n[source,text,indent=0]\n----\nroot@neo:/etc/krb5kdc# kadmin\nAuthenticating as principal root/admin@EXAMPLE.ORG with password.\nkadmin: Client not found in Kerberos database while initializing\nkadmin interface\n----\n\nLets use `kadmin.local` command to create one.\n\n[source,text,indent=0]\n----\nroot@neo:/etc/krb5kdc# kadmin.local\nAuthenticating as principal root/admin@EXAMPLE.ORG with password.\n\nkadmin.local: listprincs\nK/M@EXAMPLE.ORG\nkadmin/admin@EXAMPLE.ORG\nkadmin/changepw@EXAMPLE.ORG\nkadmin/cypher@EXAMPLE.ORG\nkrbtgt/EXAMPLE.ORG@EXAMPLE.ORG\n\nkadmin.local: addprinc root/admin@EXAMPLE.ORG\nWARNING: no policy specified for root/admin@EXAMPLE.ORG; defaulting to\nno policy\nEnter password for principal \"root/admin@EXAMPLE.ORG\":\nRe-enter password for principal \"root/admin@EXAMPLE.ORG\":\nPrincipal \"root/admin@EXAMPLE.ORG\" created.\n----\n\nThen enable admins by modifying `kadm5.acl` file and restart Kerberos\nservices.\n\n[source,text,indent=0]\n----\n# cat /etc/krb5kdc/kadm5.acl\n# This file Is the access control list for krb5 administration.\n*/admin *\n----\n\nNow you can use `kadmin` with previously created `root/admin`\nprincipal. Lets create our first user `user1`.\n\n[source,text,indent=0]\n----\nkadmin: addprinc user1\nWARNING: no policy specified for user1@EXAMPLE.ORG; defaulting to no\npolicy\nEnter password for principal \"user1@EXAMPLE.ORG\":\nRe-enter password for principal \"user1@EXAMPLE.ORG\":\nPrincipal \"user1@EXAMPLE.ORG\" created.\n----\n\nLets create our second user `user2` and export a keytab file.\n\n[source,text,indent=0]\n----\nkadmin: addprinc user2\nWARNING: no policy specified for user2@EXAMPLE.ORG; defaulting to no\npolicy\nEnter password for principal \"user2@EXAMPLE.ORG\":\nRe-enter password for principal \"user2@EXAMPLE.ORG\":\nPrincipal \"user2@EXAMPLE.ORG\" created.\n\nkadmin: ktadd -k /tmp/user2.keytab user2@EXAMPLE.ORG\nEntry for principal user2@EXAMPLE.ORG with kvno 2, encryption type aes256-cts-hmac-sha1-96 added to keytab WRFILE:/tmp/user2.keytab.\nEntry for principal user2@EXAMPLE.ORG with kvno 2, encryption type arcfour-hmac added to keytab WRFILE:/tmp/user2.keytab.\nEntry for principal user2@EXAMPLE.ORG with kvno 2, encryption type des3-cbc-sha1 added to keytab WRFILE:/tmp/user2.keytab.\nEntry for principal user2@EXAMPLE.ORG with kvno 2, encryption type des-cbc-crc added to keytab WRFILE:/tmp/user2.keytab.\n----\n\nLets create a service ticket for tomcat and export credentials to a\nkeytab file named `tomcat.keytab`.\n\n[source,text,indent=0]\n----\nkadmin: addprinc -randkey HTTP/neo.example.org@EXAMPLE.ORG\nWARNING: no policy specified for HTTP/neo.example.org@EXAMPLE.ORG;\ndefaulting to no policy\nPrincipal \"HTTP/neo.example.org@EXAMPLE.ORG\" created.\n\nkadmin: ktadd -k /tmp/tomcat.keytab HTTP/neo.example.org@EXAMPLE.ORG\nEntry for principal HTTP/neo.example.org@EXAMPLE.ORG with kvno 2, encryption type aes256-cts-hmac-sha1-96 added to keytab WRFILE:/tmp/tomcat2.keytab.\nEntry for principal HTTP/neo.example.org@EXAMPLE.ORG with kvno 2, encryption type arcfour-hmac added to keytab WRFILE:/tmp/tomcat2.keytab.\nEntry for principal HTTP/neo.example.org@EXAMPLE.ORG with kvno 2, encryption type des3-cbc-sha1 added to keytab WRFILE:/tmp/tomcat2.keytab.\nEntry for principal HTTP/neo.example.org@EXAMPLE.ORG with kvno 2, encryption type des-cbc-crc added to keytab WRFILE:/tmp/tomcat2.keytab.\n----\n\n[[setupwinkerberos]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc", "title": "appendix", "heading": "Setup MIT Kerberos", "heading_level": 3, "file_order": 75, "section_index": 4, "content_hash": "55b6e68a4d0a7f245d10e102ff9686369cf19b4feb78b2ecb0a1800e12c916d4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc"}}
{"id": "sha256:e3ba23350b2c2351162b073c829c5dad91f20da2d2c436eb59379b0d311b3779", "content": "This was tested using `Windows Server 2012 R2`\n\n[TIP]\n====\nInternet is full of good articles and videos how to setup Windows AD\nbut these two are quite usefull\nhttps://www.rackspace.com/knowledge_center/article/installing-active-directory-on-windows-server-2012[Rackspace] and\nhttps://social.technet.microsoft.com/wiki/contents/articles/12370.windows-server-2012-set-up-your-first-domain-controller-step-by-step.aspx[Microsoft\nTechnet].\n====\n\n- Normal domain controller and active directory setup was done.\n- Used dns domain `example.org` and windows domain `EXAMPLE`.\n- I created various domain users like `user1`, `user2`, `user3`,\n `tomcat` and set passwords to `Password#`.\n\nI eventually also added all ip's of my vm's to AD's dns server for\nthat not to cause any trouble.\n\n[source,text]\n----\nName: WIN-EKBO0EQ7TS7.example.org\nAddress: 172.16.101.135\n\nName: win8vm.example.org\nAddress: 172.16.101.136\n\nName: neo.example.org\nAddress: 172.16.101.1\n----\n\nService Principal Name(SPN) needs to be setup with `HTTP` and a\nserver name `neo.example.org` where tomcat servlet container is run. This\nis used with `tomcat` domain user and its `keytab` is then used as a\nservice credential.\n\n[source,text]\n----\nPS C:\\> setspn -A HTTP/neo.example.org tomcat\n----\n\nI exported keytab file which is copied to linux server running tomcat.\n\n[source,text]\n----\nPS C:\\> ktpass /out c:\\tomcat.keytab /mapuser tomcat@EXAMPLE.ORG /princ HTTP/neo.example.org@EXAMPLE.ORG /pass Password# /ptype KRB5_NT_PRINCIPAL /crypto All\n Targeting domain controller: WIN-EKBO0EQ7TS7.example.org\n Using legacy password setting method\n Successfully mapped HTTP/neo.example.org to tomcat.\n----\n\n[appendix]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc", "title": "appendix", "heading": "Setup Windows Domain Controller", "heading_level": 3, "file_order": 75, "section_index": 5, "content_hash": "e3ba23350b2c2351162b073c829c5dad91f20da2d2c436eb59379b0d311b3779", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc"}}
{"id": "sha256:6bc73d52ab88350bae762eb3b53e505984d2e0f32cc9beb53537680a1f816e97", "content": "This appendix provides generic information about troubleshooting\nerrors and problems.\n\n[IMPORTANT]\n====\nIf you think environment and configuration is correctly setup, do\ndouble check and ask other person to check possible obvious mistakes\nor typos. Kerberos setup is generally very brittle and it is not\nalways very easy to debug where the problem lies.\n====\n\n.Cannot find key of appropriate type to decrypt\n\n[source,text]\n----\nGSSException: Failure unspecified at GSS-API level (Mechanism level:\nInvalid argument (400) - Cannot find key of appropriate type to\ndecrypt AP REP - RC4 with HMAC)\n----\n\nIf you see abore error indicating missing key type, this will happen\nwith two different use cases. Firstly your JVM may not support\nappropriate encryption type or it is disabled in your `krb5.conf`\nfile.\n\n[source,text]\n----\ndefault_tkt_enctypes = rc4-hmac\ndefault_tgs_enctypes = rc4-hmac\n----\n\nSecond case is less obvious and hard to track because it will lead\ninto same error. This specific `GSSException` is throws also if you\nsimply don't have a required encryption key which then may be caused\nby a misconfiguration in your kerberos server or a simply typo in your\nprincipal.\n\n.Using wrong kerberos configuration\n\n{zwsp} +\n\nIn most system all commands and libraries will search kerberos\nconfiguration either from a default locations or special locations\nlike JDKs. It's easy to get mixed up especially if working from unix\nsystems, which already may have default settings to work with MIT\nkerberos, towards Windows domains.\n\nThis is a specific example what happens with `ldapsearch` trying to\nquery Windows AD using kerberos authentication.\n\n[source,text]\n----\n$ ldapsearch -H ldap://WIN-EKBO0EQ7TS7.example.org -b \"dc=example,dc=org\"\nSASL/GSSAPI authentication started\nldap_sasl_interactive_bind_s: Local error (-2)\n additional info: SASL(-1): generic failure: GSSAPI Error:\n Unspecified GSS failure. Minor code may provide more information\n (No Kerberos credentials available)\n----\n\nWell that doesn't look good and is a simple indication that I don't\nhave a valid kerberos tickets as shown below.\n\n[source,text]\n----\n$ klist\nklist: Credentials cache file '/tmp/krb5cc_1000' not found\n----\n\nWe already have a keytab file we exported from Windows AD to be used\nwith tomcat running on Linux. Lets try to use that to authenticate\nwith Windows AD.\n\nYou can have a dedicated config file which usually can be used with\nnative Linux commands and JVMs via system propertys.\n\n[source,text]\n----\n$ cat krb5.ini\n[libdefaults]\ndefault_realm = EXAMPLE.ORG\ndefault_keytab_name = /tmp/tomcat.keytab\nforwardable=true\n\n[realms]\nEXAMPLE.ORG = {\n kdc = WIN-EKBO0EQ7TS7.example.org:88\n}\n\n[domain_realm]\nexample.org=EXAMPLE.ORG\n.example.org=EXAMPLE.ORG\n----\n\nLets use that config and a keytab to get initial credentials.\n\n[source,text]\n----\n$ env KRB5_CONFIG=/path/to/krb5.ini kinit -kt tomcat.keytab HTTP/neo.example.org@EXAMPLE.ORG\n\n$ klist\nTicket cache: FILE:/tmp/krb5cc_1000\nDefault principal: HTTP/neo.example.org@EXAMPLE.ORG\n\nValid starting Expires Service principal\n26/03/15 09:04:37 26/03/15 19:04:37 krbtgt/EXAMPLE.ORG@EXAMPLE.ORG\n renew until 27/03/15 09:04:37\n----\n\nLets see what happens if we now try to do a simple query against\nWindows AD.\n\n[source,text]\n----\n$ ldapsearch -H ldap://WIN-EKBO0EQ7TS7.example.org -b \"dc=example,dc=org\"\nSASL/GSSAPI authentication started\nldap_sasl_interactive_bind_s: Local error (-2)\n additional info: SASL(-1): generic failure: GSSAPI Error:\n Unspecified GSS failure. Minor code may provide more information\n (KDC returned error string: PROCESS_TGS)\n----\n\nThis may be simply because `ldapsearch` is getting confused and simply\nusing wrong configuration. You can tell `ldapsearch` to use a\ndifferent configuration via `KRB5_CONFIG` env variable just like we\ndid with `kinit`. You can also use `KRB5_TRACE=/dev/stderr` to get\nmore verbose output of what native libraries are doing.\n\n[source,text]\n----\n$ env KRB5_CONFIG=/path/to/krb5.ini ldapsearch -H ldap://WIN-EKBO0EQ7TS7.example.org -b \"dc=example,dc=org\"\n\n$ klist\nTicket cache: FILE:/tmp/krb5cc_1000\nDefault principal: HTTP/neo.example.org@EXAMPLE.ORG\n\nValid starting Expires Service principal\n26/03/15 09:11:03 26/03/15 19:11:03 krbtgt/EXAMPLE.ORG@EXAMPLE.ORG\n renew until 27/03/15 09:11:03\n 26/03/15 09:11:44 26/03/15 19:11:03\n ldap/win-ekbo0eq7ts7.example.org@EXAMPLE.ORG\n renew until 27/03/15 09:11:03\n----\n\nAbove you can see what happened if query was successful by looking\nkerberos tickets. Now you can experiment with further query commands\ni.e. if you are working with `KerberosLdapContextSource`.\n\n[source,text]\n----\n$ ldapsearch -H ldap://WIN-EKBO0EQ7TS7.example.org \\\n-b \"dc=example,dc=org\" \\\n\"(| (userPrincipalName=user2@EXAMPLE.ORG)\n(sAMAccountName=user2@EXAMPLE.ORG))\" \\\ndn\n\n...\n# test user, example.org\ndn: CN=test user,DC=example,DC=org\n----\n\n[appendix]\n[[browserspnegoconfig]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc", "title": "appendix", "heading": "Troubleshooting", "heading_level": 2, "file_order": 75, "section_index": 6, "content_hash": "6bc73d52ab88350bae762eb3b53e505984d2e0f32cc9beb53537680a1f816e97", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc"}}
{"id": "sha256:dfe084da01ec88e16a6f3a75387517e886e709aab146c98f318a7572cfaf3635", "content": "Complete following steps to ensure that your Firefox browser is\nenabled to perform Spnego authentication.\n\n- Open Firefox.\n- At address field, type *about:config*.\n- In filter/search, type *negotiate*.\n- Parameter *network.negotiate-auth.trusted-uris* may be set to\n default *https://* which doesn't work for you. Generally speaking\n this parameter has to replaced with the server address if Kerberos\n delegation is required.\n- It is recommended to use `https` for all communication.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc", "title": "appendix", "heading": "Firefox", "heading_level": 3, "file_order": 75, "section_index": 7, "content_hash": "dfe084da01ec88e16a6f3a75387517e886e709aab146c98f318a7572cfaf3635", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc"}}
{"id": "sha256:8caa49249b4d30faf4b6a95c4fdc63476791a136f1b004ab0bfa4f8e690c2e9d", "content": "With Google Chrome you generally need to set command-line parameters\norder to white list servers with Chrome will negotiate.\n\n- on Windows machines (clients): Chrome shares the configuration with\n Internet Explorer so if all changes were applied to IE (as described\n in E.3), nothing has to be passed via command-line parameters.\n- on Linux/Mac OS machines (clients): the command-line parameter\n `--auth-negotiate-delegate-whitelist` should only be used if Kerberos\n delegation is required (otherwise do not set this parameter).\n- It is recommended to use `https` for all communication.\n\n[source,text]\n----\n--auth-server-whitelist=\"*.example.com\"\n--auth-negotiate-delegate-whitelist=\"*.example.com\"\n----\n\nYou can see which policies are enable by typing *chrome://policy/*\ninto Chrome's address bar.\n\nWith Linux Chrome will also read policy files from\n`/etc/opt/chrome/policies/managed` directory.\n\n.mypolicy.json\n[source,json]\n----\n{\n \"AuthServerWhitelist\" : \"*.example.org\",\n \"AuthNegotiateDelegateWhitelist\" : \"*.example.org\",\n \"DisableAuthNegotiateCnameLookup\" : true,\n \"EnableAuthNegotiatePort\" : true\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc", "title": "appendix", "heading": "Chrome", "heading_level": 3, "file_order": 75, "section_index": 8, "content_hash": "8caa49249b4d30faf4b6a95c4fdc63476791a136f1b004ab0bfa4f8e690c2e9d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc"}}
{"id": "sha256:8456640b8a6fb0bd518c627e215d73f382667c47a8c6ce2524a0f04e33dc250f", "content": "Complete following steps to ensure that your Internet Explorer browser\nis enabled to perform Spnego authentication.\n\n- Open Internet Explorer.\n- Click *Tools > Intenet Options > Security* tab.\n- In *Local intranet* section make sure your server is trusted by i.e.\n adding it into a list.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc", "title": "appendix", "heading": "Internet Explorer", "heading_level": 3, "file_order": 75, "section_index": 9, "content_hash": "8456640b8a6fb0bd518c627e215d73f382667c47a8c6ce2524a0f04e33dc250f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/appendix.adoc"}}
{"id": "sha256:162f1b38f091e91413817f12ed9fed805c8f9c08af25f4991c26c635f9e313bb", "content": "Spring Security Kerberos adds the ability to work with Kerberos and Spring applications.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/index.adoc", "title": "Spring Security Kerberos", "heading": "Spring Security Kerberos", "heading_level": 1, "file_order": 76, "section_index": 0, "content_hash": "162f1b38f091e91413817f12ed9fed805c8f9c08af25f4991c26c635f9e313bb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/index.adoc"}}
{"id": "sha256:88085bc79ad525ae556dfc0ca6f916979eae4c3606bdb204ef1534a7610857d1", "content": "[[introduction]]\n\nSpring Security Kerberos {spring-security-version} is built and tested with JDK 17,\nSpring Security {spring-security-version} and Spring Framework {spring-core-version}.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/introduction.adoc", "title": "introduction", "heading": "introduction", "heading_level": 1, "file_order": 77, "section_index": 0, "content_hash": "88085bc79ad525ae556dfc0ca6f916979eae4c3606bdb204ef1534a7610857d1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/introduction.adoc"}}
{"id": "sha256:60b1034e63b38a584b91df66053003b18c31a6435d35f6bd97797a1a9f331686", "content": "[[springsecuritykerberossamples]]\n\nThis part of the reference documentation is introducing samples\nprojects. Samples can be compiled manually by building main\ndistribution from\nhttps://github.com/spring-projects/spring-security-kerberos.\n\n[IMPORTANT]\n====\nIf you run sample as is it will not work until a correct configuration\nis applied. See notes below for specific samples.\n====\n\n<<samples-sec-server-win-auth>> sample for Windows environment\n\n<<samples-sec-server-client-auth>> sample using server side authenticator\n\n<<samples-sec-server-spnego-form-auth>> sample using ticket validation\nwith spnego and form\n\n<<samples-sec-client-rest-template>> sample for KerberosRestTemplate\n\n[[samples-sec-server-win-auth]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/samples.adoc", "title": "samples", "heading": "samples", "heading_level": 1, "file_order": 78, "section_index": 0, "content_hash": "60b1034e63b38a584b91df66053003b18c31a6435d35f6bd97797a1a9f331686", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/samples.adoc"}}
{"id": "sha256:984e33164d99d1d6af4d8ece1c17efb79e2f9fc6a23e49dd3e6862dfd248dcdd", "content": "Goals of this sample:\n\n- In windows environment, User will be able to logon to application\n with Windows Active directory Credential which has been entered\n during log on to windows. There should not be any ask for\n userid/password credentials.\n- In non-windows environment, User will be presented with a screen\n to provide Active directory credentials.\n\n[source,yaml,indent=0]\n----\nserver:\n port: 8080\n app:\n ad-domain: EXAMPLE.ORG\n ad-server: ldap://WIN-EKBO0EQ7TS7.example.org/\n service-principal: HTTP/neo.example.org@EXAMPLE.ORG\n keytab-location: /tmp/tomcat.keytab\n ldap-search-base: dc=example,dc=org\n ldap-search-filter: \"(| (userPrincipalName={0}) (sAMAccountName={0}))\"\n----\nIn above you can see the default configuration for this sample. You\ncan override these settings using a normal Spring Boot tricks like\nusing command-line options or custom `application.yml` file.\n\nRun a server.\n[source,text,subs=\"attributes\"]\n----\n$ java -jar sec-server-win-auth-{spring-security-version}.jar\n----\n\n[IMPORTANT]\n====\nYou may need to use custom kerberos config with Linux either by using\n`-Djava.security.krb5.conf=/path/to/krb5.ini` or\n`GlobalSunJaasKerberosConfig` bean.\n====\n\n[NOTE]\n====\nSee xref:servlet/authentication/kerberos/appendix.adoc#setupwinkerberos[Setup Windows Domain Controller]\nfor more instructions how to work with windows kerberos environment.\n====\n\nLogin to `Windows 8.1` using domain credentials and access sample\n\nimage::{figures}/ie1.png[]\nimage::{figures}/ie2.png[]\n\nAccess sample application from a non windows vm and use domain\ncredentials manually.\n\nimage::{figures}/ff1.png[]\nimage::{figures}/ff2.png[]\nimage::{figures}/ff3.png[]\n\n[[samples-sec-server-client-auth]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/samples.adoc", "title": "samples", "heading": "Security Server Windows Auth Sample", "heading_level": 2, "file_order": 78, "section_index": 1, "content_hash": "984e33164d99d1d6af4d8ece1c17efb79e2f9fc6a23e49dd3e6862dfd248dcdd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/samples.adoc"}}
{"id": "sha256:c5d6d46364172bcd83802100519a8b6a83b3bcc68be507e5e5d6886f3d5a7728", "content": "This sample demonstrates how server is able to authenticate user\nagainst kerberos environment using his credentials passed in via a\nform login.\n\nRun a server.\n[source,text,subs=\"attributes\"]\n----\n$ java -jar sec-server-client-auth-{spring-security-version}.jar\n----\n\n[source,yaml,indent=0]\n----\nserver:\n port: 8080\n----\n\n[[samples-sec-server-spnego-form-auth]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/samples.adoc", "title": "samples", "heading": "Security Server Side Auth Sample", "heading_level": 2, "file_order": 78, "section_index": 2, "content_hash": "c5d6d46364172bcd83802100519a8b6a83b3bcc68be507e5e5d6886f3d5a7728", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/samples.adoc"}}
{"id": "sha256:58a50e03da314b04c501415d1da8c0e3adec53976d1a6863a874f08fe297b77e", "content": "This sample demonstrates how a server can be configured to accept a\nSpnego based negotiation from a browser while still being able to fall\nback to a form based authentication.\n\nUsing a `user1` principal xref:servlet/authentication/kerberos/appendix.adoc#setupmitkerberos[Setup MIT Kerberos],\ndo a kerberos login manually using credentials.\n[source,text]\n----\n$ kinit user1\nPassword for user1@EXAMPLE.ORG:\n\n$ klist\nTicket cache: FILE:/tmp/krb5cc_1000\nDefault principal: user1@EXAMPLE.ORG\n\nValid starting Expires Service principal\n10/03/15 17:18:45 11/03/15 03:18:45 krbtgt/EXAMPLE.ORG@EXAMPLE.ORG\n renew until 11/03/15 17:18:40\n----\n\nor using a keytab file.\n\n[source,text]\n----\n$ kinit -kt user2.keytab user1\n\n$ klist\nTicket cache: FILE:/tmp/krb5cc_1000\nDefault principal: user2@EXAMPLE.ORG\n\nValid starting Expires Service principal\n10/03/15 17:25:03 11/03/15 03:25:03 krbtgt/EXAMPLE.ORG@EXAMPLE.ORG\n renew until 11/03/15 17:25:03\n----\n\nRun a server.\n[source,text,subs=\"attributes\"]\n----\n$ java -jar sec-server-spnego-form-auth-{spring-security-version}.jar\n----\n\nNow you should be able to open your browser and let it do Spnego\nauthentication with existing ticket.\n\n[NOTE]\n====\nSee xref:servlet/authentication/kerberos/appendix.adoc#browserspnegoconfig[Configure Browsers for Spnego Negotiation]\nfor more instructions for configuring browsers to use Spnego.\n====\n\n[source,yaml,indent=0]\n----\nserver:\n port: 8080\napp:\n service-principal: HTTP/neo.example.org@EXAMPLE.ORG\n keytab-location: /tmp/tomcat.keytab\n----\n\n[[samples-sec-client-rest-template]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/samples.adoc", "title": "samples", "heading": "Security Server Spnego and Form Auth Sample", "heading_level": 2, "file_order": 78, "section_index": 3, "content_hash": "58a50e03da314b04c501415d1da8c0e3adec53976d1a6863a874f08fe297b77e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/samples.adoc"}}
{"id": "sha256:f56ab5a341e016da4baccee8edf69329c995f786c21309316f069b997118557b", "content": "This is a sample using a Spring RestTemplate to access Kerberos\nprotected resource. You can use this together with\n<<samples-sec-server-spnego-form-auth>>.\n\nDefault application is configured as shown below.\n[source,yaml,indent=0]\n----\napp:\n user-principal: user2@EXAMPLE.ORG\n keytab-location: /tmp/user2.keytab\n access-url: https://neo.example.org:8080/hello\n----\n\nUsing a `user1` principal xref:servlet/authentication/kerberos/appendix.adoc#setupmitkerberos[Setup MIT Kerberos],\ndo a kerberos login manually using credentials.\n[source,text,subs=\"attributes\"]\n----\n$ java -jar sec-client-rest-template-{spring-security-version}.jar --app.user-principal --app.keytab-location\n----\n\n[NOTE]\n====\nIn above we simply set `app.user-principal` and `app.keytab-location`\nto empty values which disables a use of keytab file.\n====\n\nIf operation is successful you should see below output with `user1@EXAMPLE.ORG`.\n[source,text]\n----\n<html xmlns=\"https://www.w3.org/1999/xhtml\"\n xmlns:sec=\"https://www.thymeleaf.org/thymeleaf-extras-springsecurity3\">\n <head>\n <title>Spring Security Kerberos Example</title>\n </head>\n <body>\n <h1>Hello user1@EXAMPLE.ORG!</h1>\n </body>\n</html>\n----\n\nOr use a `user2` with a keytab file.\n[source,text,subs=\"attributes\"]\n----\n$ java -jar sec-client-rest-template-{spring-security-version}.jar\n----\n\nIf operation is succesful you should see below output with `user2@EXAMPLE.ORG`.\n[source,text]\n----\n<html xmlns=\"https://www.w3.org/1999/xhtml\"\n xmlns:sec=\"https://www.thymeleaf.org/thymeleaf-extras-springsecurity3\">\n <head>\n <title>Spring Security Kerberos Example</title>\n </head>\n <body>\n <h1>Hello user2@EXAMPLE.ORG!</h1>\n </body>\n</html>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/samples.adoc", "title": "samples", "heading": "Security Client KerberosRestTemplate Sample", "heading_level": 2, "file_order": 78, "section_index": 4, "content_hash": "f56ab5a341e016da4baccee8edf69329c995f786c21309316f069b997118557b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/samples.adoc"}}
{"id": "sha256:6299fa858d4355ad5688b201715bcb1858b69f375fdb66f971aec84ae6ceff4f", "content": "[[springsecuritykerberos]]\n\nThis part of the reference documentation explains the core functionality\nthat Spring Security Kerberos provides to any Spring based application.\n\n<<ssk-authprovider>> describes the authentication provider support.\n\n<<ssk-spnego>> describes the spnego negotiate support.\n\n<<ssk-resttemplate>> describes the RestTemplate support.\n\n[[ssk-authprovider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/ssk.adoc", "title": "ssk", "heading": "ssk", "heading_level": 1, "file_order": 79, "section_index": 0, "content_hash": "6299fa858d4355ad5688b201715bcb1858b69f375fdb66f971aec84ae6ceff4f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/ssk.adoc"}}
{"id": "sha256:6f812f5daf7fac02f9ba249abdb435df2559f764cff4c69374d004c13bbc5db1", "content": "Provider configuration using JavaConfig.\n\n[source,java,indent=0]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Value(\"${app.service-principal}\")\n\tprivate String servicePrincipal;\n\n\t@Value(\"${app.keytab-location}\")\n\tprivate String keytabLocation;\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n\t\tKerberosAuthenticationProvider kerberosAuthenticationProvider = kerberosAuthenticationProvider();\n\t\tKerberosServiceAuthenticationProvider kerberosServiceAuthenticationProvider = kerberosServiceAuthenticationProvider();\n\t\tProviderManager providerManager = new ProviderManager(kerberosAuthenticationProvider,\n\t\t\t\tkerberosServiceAuthenticationProvider);\n\n\t\thttp\n\t\t\t.authorizeHttpRequests((authz) -> authz\n\t\t\t\t.requestMatchers(\"/\", \"/home\").permitAll()\n\t\t\t\t.anyRequest().authenticated()\n\t\t\t)\n\t\t\t.exceptionHandling()\n\t\t\t\t.authenticationEntryPoint(spnegoEntryPoint())\n\t\t\t\t.and()\n\t\t\t.formLogin()\n\t\t\t\t.loginPage(\"/login\").permitAll()\n\t\t\t\t.and()\n\t\t\t.logout()\n\t\t\t\t.permitAll()\n\t\t\t\t.and()\n\t\t\t.authenticationProvider(kerberosAuthenticationProvider())\n\t\t\t.authenticationProvider(kerberosServiceAuthenticationProvider())\n\t\t\t.addFilterBefore(spnegoAuthenticationProcessingFilter(providerManager),\n\t\t\t\t\tBasicAuthenticationFilter.class);\n\t\t\treturn http.build();\n\t}\n\n\t@Bean\n\tpublic KerberosAuthenticationProvider kerberosAuthenticationProvider() {\n\t\tKerberosAuthenticationProvider provider = new KerberosAuthenticationProvider();\n\t\tSunJaasKerberosClient client = new SunJaasKerberosClient();\n\t\tclient.setDebug(true);\n\t\tprovider.setKerberosClient(client);\n\t\tprovider.setUserDetailsService(dummyUserDetailsService());\n\t\treturn provider;\n\t}\n\n\t@Bean\n\tpublic SpnegoEntryPoint spnegoEntryPoint() {\n\t\treturn new SpnegoEntryPoint(\"/login\");\n\t}\n\n\tpublic SpnegoAuthenticationProcessingFilter spnegoAuthenticationProcessingFilter(\n\t\t\tAuthenticationManager authenticationManager) {\n\t\tSpnegoAuthenticationProcessingFilter filter = new SpnegoAuthenticationProcessingFilter();\n\t\tfilter.setAuthenticationManager(authenticationManager);\n\t\treturn filter;\n\t}\n\n\t@Bean\n\tpublic KerberosServiceAuthenticationProvider kerberosServiceAuthenticationProvider() {\n\t\tKerberosServiceAuthenticationProvider provider = new KerberosServiceAuthenticationProvider();\n\t\tprovider.setTicketValidator(sunJaasKerberosTicketValidator());\n\t\tprovider.setUserDetailsService(dummyUserDetailsService());\n\t\treturn provider;\n\t}\n\n\t@Bean\n\tpublic SunJaasKerberosTicketValidator sunJaasKerberosTicketValidator() {\n\t\tSunJaasKerberosTicketValidator ticketValidator = new SunJaasKerberosTicketValidator();\n\t\tticketValidator.setServicePrincipal(servicePrincipal);\n\t\tticketValidator.setKeyTabLocation(new FileSystemResource(keytabLocation));\n\t\tticketValidator.setDebug(true);\n\t\treturn ticketValidator;\n\t}\n\n\t@Bean\n\tpublic DummyUserDetailsService dummyUserDetailsService() {\n\t\treturn new DummyUserDetailsService();\n\t}\n}\n----\n\n[[ssk-spnego]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/ssk.adoc", "title": "ssk", "heading": "Authentication Provider", "heading_level": 2, "file_order": 79, "section_index": 1, "content_hash": "6f812f5daf7fac02f9ba249abdb435df2559f764cff4c69374d004c13bbc5db1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/ssk.adoc"}}
{"id": "sha256:8ae5582272278f9a3000f40787100fca4990a0234587fd46d84560dd367113ea", "content": "Spnego configuration using JavaConfig.\n\n[source,java,indent=0]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Value(\"${app.ad-domain}\")\n\tprivate String adDomain;\n\n\t@Value(\"${app.ad-server}\")\n\tprivate String adServer;\n\n\t@Value(\"${app.service-principal}\")\n\tprivate String servicePrincipal;\n\n\t@Value(\"${app.keytab-location}\")\n\tprivate String keytabLocation;\n\n\t@Value(\"${app.ldap-search-base}\")\n\tprivate String ldapSearchBase;\n\n\t@Value(\"${app.ldap-search-filter}\")\n\tprivate String ldapSearchFilter;\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n\t\tKerberosServiceAuthenticationProvider kerberosServiceAuthenticationProvider = kerberosServiceAuthenticationProvider();\n\t\tActiveDirectoryLdapAuthenticationProvider activeDirectoryLdapAuthenticationProvider = activeDirectoryLdapAuthenticationProvider();\n\t\tProviderManager providerManager = new ProviderManager(kerberosServiceAuthenticationProvider,\n\t\t\t\tactiveDirectoryLdapAuthenticationProvider);\n\n\t\thttp\n\t\t\t.authorizeHttpRequests((authz) -> authz\n\t\t\t\t.requestMatchers(\"/\", \"/home\").permitAll()\n\t\t\t\t.anyRequest().authenticated()\n\t\t\t)\n\t\t\t.exceptionHandling()\n\t\t\t\t.authenticationEntryPoint(spnegoEntryPoint())\n\t\t\t\t.and()\n\t\t\t.formLogin()\n\t\t\t\t.loginPage(\"/login\").permitAll()\n\t\t\t\t.and()\n\t\t\t.logout()\n\t\t\t\t.permitAll()\n\t\t\t\t.and()\n\t\t\t.authenticationProvider(activeDirectoryLdapAuthenticationProvider())\n\t\t\t.authenticationProvider(kerberosServiceAuthenticationProvider())\n\t\t\t.addFilterBefore(spnegoAuthenticationProcessingFilter(providerManager),\n\t\t\t\tBasicAuthenticationFilter.class);\n\n\t\treturn http.build();\n\t}\n\n\t@Bean\n\tpublic ActiveDirectoryLdapAuthenticationProvider activeDirectoryLdapAuthenticationProvider() {\n\t\treturn new ActiveDirectoryLdapAuthenticationProvider(adDomain, adServer);\n\t}\n\n\t@Bean\n\tpublic SpnegoEntryPoint spnegoEntryPoint() {\n\t\treturn new SpnegoEntryPoint(\"/login\");\n\t}\n\n\tpublic SpnegoAuthenticationProcessingFilter spnegoAuthenticationProcessingFilter(\n\t\t\tAuthenticationManager authenticationManager) {\n\t\tSpnegoAuthenticationProcessingFilter filter = new SpnegoAuthenticationProcessingFilter();\n\t\tfilter.setAuthenticationManager(authenticationManager);\n\t\treturn filter;\n\t}\n\n\tpublic KerberosServiceAuthenticationProvider kerberosServiceAuthenticationProvider() throws Exception {\n\t\tKerberosServiceAuthenticationProvider provider = new KerberosServiceAuthenticationProvider();\n\t\tprovider.setTicketValidator(sunJaasKerberosTicketValidator());\n\t\tprovider.setUserDetailsService(ldapUserDetailsService());\n\t\treturn provider;\n\t}\n\n\t@Bean\n\tpublic SunJaasKerberosTicketValidator sunJaasKerberosTicketValidator() {\n\t\tSunJaasKerberosTicketValidator ticketValidator = new SunJaasKerberosTicketValidator();\n\t\tticketValidator.setServicePrincipal(servicePrincipal);\n\t\tticketValidator.setKeyTabLocation(new FileSystemResource(keytabLocation));\n\t\tticketValidator.setDebug(true);\n\t\treturn ticketValidator;\n\t}\n\n\t@Bean\n\tpublic KerberosLdapContextSource kerberosLdapContextSource() throws Exception {\n\t\tKerberosLdapContextSource contextSource = new KerberosLdapContextSource(adServer);\n\t\tcontextSource.setLoginConfig(loginConfig());\n\t\treturn contextSource;\n\t}\n\n\tpublic SunJaasKrb5LoginConfig loginConfig() throws Exception {\n\t\tSunJaasKrb5LoginConfig loginConfig = new SunJaasKrb5LoginConfig();\n\t\tloginConfig.setKeyTabLocation(new FileSystemResource(keytabLocation));\n\t\tloginConfig.setServicePrincipal(servicePrincipal);\n\t\tloginConfig.setDebug(true);\n\t\tloginConfig.setIsInitiator(true);\n\t\tloginConfig.afterPropertiesSet();\n\t\treturn loginConfig;\n\t}\n\n\t@Bean\n\tpublic LdapUserDetailsService ldapUserDetailsService() throws Exception {\n\t\tFilterBasedLdapUserSearch userSearch =\n\t\t\t\tnew FilterBasedLdapUserSearch(ldapSearchBase, ldapSearchFilter, kerberosLdapContextSource());\n\t\tLdapUserDetailsService service =\n\t\t\t\tnew LdapUserDetailsService(userSearch, new ActiveDirectoryLdapAuthoritiesPopulator());\n\t\tservice.setUserDetailsMapper(new LdapUserDetailsMapper());\n\t\treturn service;\n\t}\n}\n----\n\n[[ssk-resttemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/ssk.adoc", "title": "ssk", "heading": "Spnego Negotiate", "heading_level": 2, "file_order": 79, "section_index": 2, "content_hash": "8ae5582272278f9a3000f40787100fca4990a0234587fd46d84560dd367113ea", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/ssk.adoc"}}
{"id": "sha256:34079513fe17fed7369c9b500f8b1f41ca0c93009d18303a9fa8eee4dcbe485b", "content": "If there is a need to access Kerberos protected web resources\nprogrammatically we have `KerberosRestTemplate` which extends\n`RestTemplate` and does necessary login actions prior to delegating to\nactual RestTemplate methods. You basically have few options to\nconfigure this template.\n\n- Leave keyTabLocation and userPrincipal empty if you want to\n use cached ticket.\n- Use keyTabLocation and userPrincipal if you want to use\n keytab file.\n- Use loginOptions if you want to customise Krb5LoginModule options.\n- Use a customised httpClient.\n\nWith ticket cache.\n[source,java,indent=0]\n----\n    public void doWithTicketCache() {\n        KerberosRestTemplate restTemplate =\n                new KerberosRestTemplate();\n        restTemplate.getForObject(\"http://neo.example.org:8080/hello\", String.class);\n    }\n----\n\nWith keytab file.\n[source,java,indent=0]\n----\n    public void doWithKeytabFile() {\n        KerberosRestTemplate restTemplate =\n                new KerberosRestTemplate(\"/tmp/user2.keytab\", \"user2@EXAMPLE.ORG\");\n        restTemplate.getForObject(\"http://neo.example.org:8080/hello\", String.class);\n    }\n----\n\n[[ssk-kerberosldap]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/ssk.adoc", "title": "ssk", "heading": "Using KerberosRestTemplate", "heading_level": 2, "file_order": 79, "section_index": 3, "content_hash": "34079513fe17fed7369c9b500f8b1f41ca0c93009d18303a9fa8eee4dcbe485b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/ssk.adoc"}}
{"id": "sha256:c0aa5530a4532bcaf3ea5987af3e2ace9ad1a49da1d24d85593609942e7fb3dc", "content": "With most of your samples we're using `DummyUserDetailsService`\nbecause there is not necessarily need to query a real user details\nonce kerberos authentication is successful and we can use kerberos\nprincipal info to create that dummy user. However there is a way to\naccess kerberized LDAP services in a say way and query user details\nfrom there.\n\n`KerberosLdapContextSource` can be used to bind into LDAP via kerberos\nwhich is at least proven to work well with Windows AD services.\n\n[source,java,indent=0]\n----\n\t@Value(\"${app.ad-server}\")\n\tprivate String adServer;\n\n\t@Value(\"${app.service-principal}\")\n\tprivate String servicePrincipal;\n\n\t@Value(\"${app.keytab-location}\")\n\tprivate String keytabLocation;\n\n\t@Value(\"${app.ldap-search-base}\")\n\tprivate String ldapSearchBase;\n\n\t@Value(\"${app.ldap-search-filter}\")\n\tprivate String ldapSearchFilter;\n\n\t@Bean\n\tpublic KerberosLdapContextSource kerberosLdapContextSource() {\n\t\tKerberosLdapContextSource contextSource = new KerberosLdapContextSource(adServer);\n\t\tSunJaasKrb5LoginConfig loginConfig = new SunJaasKrb5LoginConfig();\n\t\tloginConfig.setKeyTabLocation(new FileSystemResource(keytabLocation));\n\t\tloginConfig.setServicePrincipal(servicePrincipal);\n\t\tloginConfig.setDebug(true);\n\t\tloginConfig.setIsInitiator(true);\n\t\tcontextSource.setLoginConfig(loginConfig);\n\t\treturn contextSource;\n\t}\n\n\t@Bean\n\tpublic LdapUserDetailsService ldapUserDetailsService() {\n\t\tFilterBasedLdapUserSearch userSearch =\n\t\t\t\tnew FilterBasedLdapUserSearch(ldapSearchBase, ldapSearchFilter, kerberosLdapContextSource());\n\t\tLdapUserDetailsService service = new LdapUserDetailsService(userSearch);\n\t\tservice.setUserDetailsMapper(new LdapUserDetailsMapper());\n\t\treturn service;\n\t}\n----\n\n[TIP]\n====\nSample xref:servlet/authentication/kerberos/samples.adoc#samples-sec-server-win-auth[Security Server Windows Auth Sample]\nis currently configured to query user details from AD if authentication happen via kerberos.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/kerberos/ssk.adoc", "title": "ssk", "heading": "Authentication with LDAP Services", "heading_level": 2, "file_order": 79, "section_index": 4, "content_hash": "c0aa5530a4532bcaf3ea5987af3e2ace9ad1a49da1d24d85593609942e7fb3dc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/kerberos/ssk.adoc"}}
{"id": "sha256:98a4257533dba44fd56eb3f4e027618a6bb1aa1767e7c3af7e50e481da05ddf7", "content": "[[servlet-authentication-basic]]\n\nThis section provides details on how Spring Security provides support for https://tools.ietf.org/html/rfc7617[Basic HTTP Authentication] for servlet-based applications.\n\nThis section describes how HTTP Basic Authentication works within Spring Security.\nFirst, we see the https://tools.ietf.org/html/rfc7235#section-4.1[WWW-Authenticate] header is sent back to an unauthenticated client:\n\n.Sending WWW-Authenticate Header\n[.invert-dark]\nimage::{figures}/basicauthenticationentrypoint.png[]\n\nThe preceding figure builds off our xref:servlet/architecture.adoc#servlet-securityfilterchain[`SecurityFilterChain`] diagram.\n\nimage:{icondir}/number_1.png[] First, a user makes an unauthenticated request to the resource `/private` for which it is not authorized.\n\nimage:{icondir}/number_2.png[] Spring Security's xref:servlet/authorization/authorize-http-requests.adoc[`AuthorizationFilter`] indicates that the unauthenticated request is __Denied__ by throwing an `AccessDeniedException`.\n\nimage:{icondir}/number_3.png[] Since the user is not authenticated, xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[`ExceptionTranslationFilter`] initiates __Start Authentication__.\nThe configured xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationentrypoint[`AuthenticationEntryPoint`] is an instance of javadoc:org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint[], which sends a WWW-Authenticate header.\nThe `RequestCache` is typically a `NullRequestCache` that does not save the request since the client is capable of replaying the requests it originally requested.\n\n[NOTE]\n====\nThe default HTTP Basic Auth Provider will suppress both Response body and `WWW-Authenticate` header in the 401 response when the request was made with a `X-Requested-With: XMLHttpRequest` header.\nThis allows frontends to implement their own authentication code, instead of triggering the browser login dialog.\nTo override, implement your own javadoc:org.springframework.security.web.authentication.www.BasicAuthenticationEntryPoint[].\n====\n\nWhen a client receives the `WWW-Authenticate` header, it knows it should retry with a username and password.\nThe following image shows the flow for the username and password being processed:\n\n[[servlet-authentication-basicauthenticationfilter]]\n.Authenticating Username and Password\n[.invert-dark]\nimage::{figures}/basicauthenticationfilter.png[]\n\nThe preceding figure builds off our xref:servlet/architecture.adoc#servlet-securityfilterchain[`SecurityFilterChain`] diagram.\n\nimage:{icondir}/number_1.png[] When the user submits their username and password, the `BasicAuthenticationFilter` creates a `UsernamePasswordAuthenticationToken`, which is a type of xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`] by extracting the username and password from the `HttpServletRequest`.\n\nimage:{icondir}/number_2.png[] Next, the `UsernamePasswordAuthenticationToken` is passed into the `AuthenticationManager` to be authenticated.\nThe details of what `AuthenticationManager` looks like depend on how the xref:servlet/authentication/passwords/index.adoc#servlet-authentication-unpwd[user information is stored].\n\nimage:{icondir}/number_3.png[] If authentication fails, then __Failure__.\n\n. The xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[SecurityContextHolder] is cleared out.\n. `RememberMeServices.loginFail` is invoked.\nIf remember me is not configured, this is a no-op.\nSee the javadoc:org.springframework.security.web.authentication.RememberMeServices[] interface in the Javadoc.\n. `AuthenticationEntryPoint` is invoked to trigger the WWW-Authenticate to be sent again.\nSee the javadoc:org.springframework.security.web.AuthenticationEntryPoint[] interface in the Javadoc.\n\nimage:{icondir}/number_4.png[] If authentication is successful, then __Success__.\n\n* Any already-authenticated `Authentication` in the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[`SecurityContextHolder`] is loaded and its\nauthorities are added to the returned xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`].\n. The xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[Authentication] is set on the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[SecurityContextHolder].\n. `RememberMeServices.loginSuccess` is invoked.\nIf remember me is not configured, this is a no-op.\nSee the javadoc:org.springframework.security.web.authentication.RememberMeServices[] interface in the Javadoc.\n. The `BasicAuthenticationFilter` invokes `FilterChain.doFilter(request,response)` to continue with the rest of the application logic.\nSee the javadoc:org.springframework.security.web.authentication.www.BasicAuthenticationFilter[] Class in the Javadoc\n\nBy default, Spring Security's HTTP Basic Authentication support is enabled.\nHowever, as soon as any servlet based configuration is provided, HTTP Basic must be explicitly provided.\n\nThe following example shows a minimal, explicit configuration:\n\n.Explicit HTTP Basic Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n\thttp\n // ...\n .httpBasic(withDefaults());\n\treturn http.build();\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<http-basic />\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n\thttp {\n // ...\n httpBasic { }\n\t}\n\treturn http.build()\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/basic.adoc", "title": "basic", "heading": "basic", "heading_level": 1, "file_order": 80, "section_index": 0, "content_hash": "98a4257533dba44fd56eb3f4e027618a6bb1aa1767e7c3af7e50e481da05ddf7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/basic.adoc"}}
{"id": "sha256:45b3aa8142aef01b69029bc776b86bf71e643293e3d8b0f3a83d0d008a806a0d", "content": "[[servlet-authentication-caching-user-details]]\n\nSpring Security provides support for caching `UserDetails` with <<servlet-authentication-caching-user-details-service,`CachingUserDetailsService`>>.\nAlternatively, you can use Spring Framework's <<servlet-authentication-caching-user-details-cacheable,`@Cacheable`>> annotation.\nIn either case, you will need to <<servlet-authentication-caching-user-details-credential-erasure,disable credential erasure>> in order to validate passwords retrieved from the cache.\n\n[[servlet-authentication-caching-user-details-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/caching.adoc", "title": "caching", "heading": "caching", "heading_level": 1, "file_order": 81, "section_index": 0, "content_hash": "45b3aa8142aef01b69029bc776b86bf71e643293e3d8b0f3a83d0d008a806a0d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/caching.adoc"}}
{"id": "sha256:2a584cba27600e12e7b7890e98597a7150eec056a7dac1da557f98706736d08e", "content": "Spring Security's `CachingUserDetailsService` implements xref:servlet/authentication/passwords/user-details-service.adoc#servlet-authentication-userdetailsservice[UserDetailsService] to provide support for caching `UserDetails`.\n`CachingUserDetailsService` provides caching support for `UserDetails` by delegating to the provided `UserDetailsService`.\nThe result is then stored in a `UserCache` to reduce computation in subsequent calls.\n\nThe following example simply defines a `@Bean` that encapsulates a concrete implementation of `UserDetailsService` and a `UserCache` for caching the `UserDetails`:\n\n.Provide a `CachingUserDetailsService` `@Bean`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic CachingUserDetailsService cachingUserDetailsService(UserCache userCache) {\n\tUserDetailsService delegate = ...;\n CachingUserDetailsService service = new CachingUserDetailsService(delegate);\n service.setUserCache(userCache);\n return service;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun cachingUserDetailsService(userCache: UserCache): CachingUserDetailsService {\n val delegate: UserDetailsService = ...\n val service = CachingUserDetailsService(delegate)\n service.userCache = userCache\n return service\n}\n----\n======\n\n[[servlet-authentication-caching-user-details-cacheable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/caching.adoc", "title": "caching", "heading": "`CachingUserDetailsService`", "heading_level": 2, "file_order": 81, "section_index": 1, "content_hash": "2a584cba27600e12e7b7890e98597a7150eec056a7dac1da557f98706736d08e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/caching.adoc"}}
{"id": "sha256:37a1907f770a50f802751c80075680f1fcd73ef745811383b038c1d5ffd4bc91", "content": "An alternative approach would be to use Spring Framework's {spring-framework-reference-url}integration.html#cache-annotations-cacheable[`@Cacheable`] in your `UserDetailsService` implementation to cache `UserDetails` by `username`.\nThe benefit to this approach is simpler configuration, especially if you are already using caching elsewhere in your application.\n\nThe following example assumes caching is already configured, and annotates the `loadUserByUsername` with `@Cacheable`:\n\n.`UserDetailsService` annotated with `@Cacheable`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Service\npublic class MyCustomUserDetailsImplementation implements UserDetailsService {\n\n @Override\n @Cacheable\n public UserDetails loadUserByUsername(String username) {\n // some logic here to get the actual user details\n return userDetails;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Service\nclass MyCustomUserDetailsImplementation : UserDetailsService {\n\n @Cacheable\n override fun loadUserByUsername(username: String): UserDetails {\n // some logic here to get the actual user details\n return userDetails\n }\n}\n----\n======\n\n[[servlet-authentication-caching-user-details-credential-erasure]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/caching.adoc", "title": "caching", "heading": "`@Cacheable`", "heading_level": 2, "file_order": 81, "section_index": 2, "content_hash": "37a1907f770a50f802751c80075680f1fcd73ef745811383b038c1d5ffd4bc91", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/caching.adoc"}}
{"id": "sha256:bc175012ca921b60fef6bf47dc9046024f8e2512d79c3fdc737147604ed12819", "content": "Whether you use <<servlet-authentication-caching-user-details-service,`CachingUserDetailsService`>> or <<servlet-authentication-caching-user-details-cacheable,`@Cacheable`>>, you will need to disable xref:servlet/authentication/architecture.adoc#servlet-authentication-providermanager-erasing-credentials[credential erasure] so that the `UserDetails` will contain a `password` to be validated when retrieved from the cache.\nThe following example disables credential erasure for the global `AuthenticationManager` by configuring the `AuthenticationManagerBuilder` provided by Spring Security:\n\n.Disable credential erasure for the global `AuthenticationManager`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n // ...\n return http.build();\n\t}\n\n\t@Bean\n\tpublic UserDetailsService userDetailsService() {\n // Return a UserDetailsService that caches users\n // ...\n\t}\n\n\t@Autowired\n\tpublic void configure(AuthenticationManagerBuilder builder) {\n builder.eraseCredentials(false);\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n // ...\n return http.build()\n\t}\n\n\t@Bean\n\tfun userDetailsService(): UserDetailsService {\n // Return a UserDetailsService that caches users\n // ...\n\t}\n\n\t@Autowired\n\tfun configure(builder: AuthenticationManagerBuilder) {\n builder.eraseCredentials(false)\n\t}\n\n}\n----\n=====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/caching.adoc", "title": "caching", "heading": "Disable Credential Erasure", "heading_level": 2, "file_order": 81, "section_index": 3, "content_hash": "bc175012ca921b60fef6bf47dc9046024f8e2512d79c3fdc737147604ed12819", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/caching.adoc"}}
{"id": "sha256:758e816b85da9cfa959b232a1562c642f90c2b28e8fe2b1bf33094681dd7a9a0", "content": "[[servlet-authentication-credentialscontainer]]\n\nThe javadoc:org.springframework.security.core.CredentialsContainer[] interface indicates that the implementing object contains sensitive data, and is used internally by Spring Security to erase the authentication credentials after a successful authentication.\nThis interface is implemented by most of Spring Security internal domain classes, like javadoc:org.springframework.security.core.userdetails.User[] and javadoc:org.springframework.security.authentication.UsernamePasswordAuthenticationToken[].\n\nThe `ProviderManager` manager checks whether the returned `Authentication` implements this interface.\nIf so, xref:servlet/authentication/architecture.adoc#servlet-authentication-providermanager-erasing-credentials[it calls the `eraseCredentials` method] to remove the credentials from the object.\n\nIf you want your custom authentication objects to have their credentials erased after authentication, you should ensure that the classes implement the `CredentialsContainer` interface.\n\nUsers who are writing their own `AuthenticationProvider` implementations should create and return an appropriate `Authentication` object there, minus any sensitive data, rather than using this interface.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/credentials-container.adoc", "title": "credentials-container", "heading": "credentials-container", "heading_level": 1, "file_order": 82, "section_index": 0, "content_hash": "758e816b85da9cfa959b232a1562c642f90c2b28e8fe2b1bf33094681dd7a9a0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/credentials-container.adoc"}}
{"id": "sha256:4c86bc818aa73de53e572394af1ec45fb490fb10f010b5432cb1423abfbff172", "content": "[[servlet-authentication-daoauthenticationprovider]]\n\njavadoc:org.springframework.security.authentication.dao.DaoAuthenticationProvider[] is an xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationprovider[`AuthenticationProvider`] implementation that uses a xref:servlet/authentication/passwords/user-details-service.adoc#servlet-authentication-userdetailsservice[`UserDetailsService`] and xref:servlet/authentication/passwords/password-encoder.adoc#servlet-authentication-password-storage[`PasswordEncoder`] to authenticate a username and password.\n\nThis section examines how `DaoAuthenticationProvider` works within Spring Security.\nThe following figure explains the workings of the xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationmanager[`AuthenticationManager`] in figures from the xref:servlet/authentication/passwords/index.adoc#servlet-authentication-unpwd-input[Reading the Username & Password] section.\n\n.`DaoAuthenticationProvider` Usage\n[.invert-dark]\nimage::{figures}/daoauthenticationprovider.png[]\n\nimage:{icondir}/number_1.png[] The authentication `Filter` from the xref:servlet/authentication/passwords/index.adoc#servlet-authentication-unpwd-input[Reading the Username & Password] section passes a `UsernamePasswordAuthenticationToken` to the `AuthenticationManager`, which is implemented by xref:servlet/authentication/architecture.adoc#servlet-authentication-providermanager[`ProviderManager`].\n\nimage:{icondir}/number_2.png[] The `ProviderManager` is configured to use an xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationprovider[AuthenticationProvider] of type `DaoAuthenticationProvider`.\n\nimage:{icondir}/number_3.png[] `DaoAuthenticationProvider` looks up the `UserDetails` from the `UserDetailsService`.\n\nimage:{icondir}/number_4.png[] `DaoAuthenticationProvider` uses the xref:servlet/authentication/passwords/password-encoder.adoc#servlet-authentication-password-storage[`PasswordEncoder`] to validate the password on the `UserDetails` returned in the previous step.\n\nimage:{icondir}/number_5.png[] When authentication is successful, the xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`] that is returned is of type `UsernamePasswordAuthenticationToken` and has a principal that is the `UserDetails` returned by the configured `UserDetailsService` and a set of authorities containing at least `FACTOR_PASSWORD`.\nUltimately, the returned `UsernamePasswordAuthenticationToken` is set on the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[`SecurityContextHolder`] by the authentication `Filter`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/dao-authentication-provider.adoc", "title": "dao-authentication-provider", "heading": "dao-authentication-provider", "heading_level": 1, "file_order": 83, "section_index": 0, "content_hash": "4c86bc818aa73de53e572394af1ec45fb490fb10f010b5432cb1423abfbff172", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/dao-authentication-provider.adoc"}}
{"id": "sha256:b2ca23a5b7c6eb8b8de506a5960096c55f43e4b6c25e8c1a03d0543885510ae0", "content": "[[servlet-authentication-digest]]\n\nThis section provides details on how Spring Security provides support for https://tools.ietf.org/html/rfc2617[Digest Authentication], which is provided `DigestAuthenticationFilter`.\n\n[WARNING]\n====\nYou should not use Digest Authentication in modern applications, because it is not considered to be secure.\nThe most obvious problem is that you must store your passwords in plaintext or an encrypted or MD5 format.\nAll of these storage formats are considered insecure.\nInstead, you should store credentials by using a one way adaptive password hash (bCrypt, PBKDF2, SCrypt, and others), which is not supported by Digest Authentication.\n====\n\nDigest Authentication tries to solve many of the weaknesses of xref:servlet/authentication/passwords/basic.adoc#servlet-authentication-basic[Basic authentication], specifically by ensuring credentials are never sent in clear text across the wire.\nMany https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Digest#Browser_compatibility[browsers support Digest Authentication].\n\nThe standard governing HTTP Digest Authentication is defined by https://tools.ietf.org/html/rfc2617[RFC 2617], which updates an earlier version of the Digest Authentication standard prescribed by https://tools.ietf.org/html/rfc2069[RFC 2069].\nMost user agents implement RFC 2617.\nSpring Security's Digest Authentication support is compatible with the \"`auth`\" quality of protection (`qop`) prescribed by RFC 2617, which also provides backward compatibility with RFC 2069.\nDigest Authentication was seen as a more attractive option if you need to use unencrypted HTTP (no TLS or HTTPS) and wish to maximize security of the authentication process.\nHowever, everyone should use xref:features/exploits/http.adoc#http[HTTPS].\n\nCentral to Digest Authentication is a \"`nonce`\".\nThis is a value the server generates.\nSpring Security's nonce adopts the following format:\n\n.Digest Syntax\n[source,txt]\n----\nbase64(expirationTime + \":\" + md5Hex(expirationTime + \":\" + key))\nexpirationTime: The date and time when the nonce expires, expressed in milliseconds\nkey: A private key to prevent modification of the nonce token\n----\n\nYou need to ensure that you xref:features/authentication/password-storage.adoc#authentication-password-storage-configuration[configure] insecure plain text xref:features/authentication/password-storage.adoc#authentication-password-storage[Password Storage] using `NoOpPasswordEncoder`.\n(See the javadoc:org.springframework.security.crypto.password.NoOpPasswordEncoder[] class in the Javadoc.)\nThe following provides an example of configuring Digest Authentication with Java Configuration:\n\n.Digest Authentication\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nUserDetailsService userDetailsService;\n\nDigestAuthenticationEntryPoint authenticationEntryPoint() {\n\tDigestAuthenticationEntryPoint result = new DigestAuthenticationEntryPoint();\n\tresult.setRealmName(\"My App Realm\");\n\tresult.setKey(\"3028472b-da34-4501-bfd8-a355c42bdf92\");\n\treturn result;\n}\n\nDigestAuthenticationFilter digestAuthenticationFilter() {\n\tDigestAuthenticationFilter result = new DigestAuthenticationFilter();\n\tresult.setUserDetailsService(userDetailsService);\n\tresult.setAuthenticationEntryPoint(authenticationEntryPoint());\n\treturn result;\n}\n\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n\thttp\n // ...\n .exceptionHandling((e) -> e.authenticationEntryPoint(authenticationEntryPoint()))\n .addFilter(digestAuthenticationFilter());\n\treturn http.build();\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<b:bean id=\"digestFilter\"\n class=\"org.springframework.security.web.authentication.www.DigestAuthenticationFilter\"\n p:userDetailsService-ref=\"jdbcDaoImpl\"\n p:authenticationEntryPoint-ref=\"digestEntryPoint\"\n/>\n\n<b:bean id=\"digestEntryPoint\"\n class=\"org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint\"\n p:realmName=\"My App Realm\"\n\tp:key=\"3028472b-da34-4501-bfd8-a355c42bdf92\"\n/>\n\n<http>\n\t<!-- ... -->\n\t<custom-filter ref=\"userFilter\" position=\"DIGEST_AUTH_FILTER\"/>\n</http>\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/digest.adoc", "title": "digest", "heading": "digest", "heading_level": 1, "file_order": 84, "section_index": 0, "content_hash": "b2ca23a5b7c6eb8b8de506a5960096c55f43e4b6c25e8c1a03d0543885510ae0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/digest.adoc"}}
{"id": "sha256:b0095fea372607471482e93bbec55fd4fdb037c60f9d1c12c735d7242fd7a83f", "content": "After successful authentication, it is a security best practice to erase credentials from memory to prevent them from being exposed to potential memory dump attacks.\n`ProviderManager` in Spring Security supports this practice through the `eraseCredentials` method, which should be invoked after the authentication process is complete.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/erasure.adoc", "title": "erasure", "heading": "Password Erasure", "heading_level": 2, "file_order": 85, "section_index": 0, "content_hash": "b0095fea372607471482e93bbec55fd4fdb037c60f9d1c12c735d7242fd7a83f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/erasure.adoc"}}
{"id": "sha256:ea7b5d44bd1eaf7d0057ecea1a385886383d1ac169ea31954359ec33bd6874ea", "content": "* *Immediate Erasure*: Credentials should be erased immediately after they are no longer needed, which minimizes the window during which the credentials are exposed in memory.\n* *Automatic Erasure*: Configure `ProviderManager` to automatically erase credentials post-authentication by setting `eraseCredentialsAfterAuthentication` to `true` (the default).\n* *Custom Erasure Strategies*: Implement custom erasure strategies in custom `AuthenticationManager` implementations if the default erasure behavior does not meet specific security requirements.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/erasure.adoc", "title": "erasure", "heading": "Best Practices", "heading_level": 3, "file_order": 85, "section_index": 1, "content_hash": "ea7b5d44bd1eaf7d0057ecea1a385886383d1ac169ea31954359ec33bd6874ea", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/erasure.adoc"}}
{"id": "sha256:b7c69fd965888ad2e8875b1646ebab72a16189b138844769dfc10db3500fba86", "content": "Failure to properly erase credentials can lead to several risks:\n\n* *Memory Access Attacks*: Attackers can access raw credentials from memory through exploits like buffer overflow attacks or memory dumps.\n* *Insider Threats*: Malicious insiders with access to systems could potentially extract credentials from application memory.\n* *Accidental Exposure*: In multi-tenant environments, lingering credentials in memory could accidentally be exposed to other tenants.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/erasure.adoc", "title": "erasure", "heading": "Risk Assessment", "heading_level": 3, "file_order": 85, "section_index": 2, "content_hash": "b7c69fd965888ad2e8875b1646ebab72a16189b138844769dfc10db3500fba86", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/erasure.adoc"}}
{"id": "sha256:9fc0639c9ad54b9a8f9b8c093da6b74a88f4444e41136db8da846e2e80e9b94c", "content": "[source,java]\n----\npublic class CustomAuthenticationManager implements AuthenticationManager {\n\n\t@Override\n\tpublic Authentication authenticate(Authentication authenticationRequest)\n throws AuthenticationException {\n\n Authentication authenticationResult;\n // TODO: Perform authentication checks...\n\n // Erase credentials post-check\n if (authenticationResult instanceof CredentialsContainer container) {\n container.eraseCredentials();\n }\n\t}\n\n}\n----\n\nBy implementing these practices, organizations can significantly enhance the security of their authentication systems by ensuring that credentials are not left exposed in system memory.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/erasure.adoc", "title": "erasure", "heading": "Implementation", "heading_level": 3, "file_order": 85, "section_index": 3, "content_hash": "9fc0639c9ad54b9a8f9b8c093da6b74a88f4444e41136db8da846e2e80e9b94c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/erasure.adoc"}}
{"id": "sha256:d8fe92b1ea18df7cd29c246785df987b8eea3be9407f445df88377c5b15bc943", "content": "[[servlet-authentication-form]]\n\nSpring Security provides support for username and password being provided through an HTML form.\nThis section provides details on how form based authentication works within Spring Security.\n\nThis section examines how form-based login works within Spring Security.\nFirst, we see how the user is redirected to the login form:\n\n.Redirecting to the Login Page\n[.invert-dark]\nimage::{figures}/loginurlauthenticationentrypoint.png[]\n\nThe preceding figure builds off our xref:servlet/architecture.adoc#servlet-securityfilterchain[`SecurityFilterChain`] diagram.\n\nimage:{icondir}/number_1.png[] First, a user makes an unauthenticated request to the resource (`/private`) for which it is not authorized.\n\nimage:{icondir}/number_2.png[] Spring Security's xref:servlet/authorization/authorize-http-requests.adoc[`AuthorizationFilter`] indicates that the unauthenticated request is __Denied__ by throwing an `AccessDeniedException`.\n\nimage:{icondir}/number_3.png[] Since the user is not authenticated, xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[`ExceptionTranslationFilter`] initiates __Start Authentication__ and sends a redirect to the login page with the configured xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationentrypoint[`AuthenticationEntryPoint`].\nIn most cases, the `AuthenticationEntryPoint` is an instance of javadoc:org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint[].\n\nimage:{icondir}/number_4.png[] The browser requests the login page to which it was redirected.\n\nimage:{icondir}/number_5.png[] Something within the application, must <<servlet-authentication-form-custom,render the login page>>.\n\n[[servlet-authentication-usernamepasswordauthenticationfilter]]\nWhen the username and password are submitted, the `UsernamePasswordAuthenticationFilter` creates a `UsernamePasswordAuthenticationToken` which is a type of https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html#servlet-authentication-authentication[Authentication], by extracting the username and password from the `HttpServletRequest` instance.\nThe `UsernamePasswordAuthenticationFilter` extends xref:servlet/authentication/architecture.adoc#servlet-authentication-abstractprocessingfilter[AbstractAuthenticationProcessingFilter], so the following diagram should look pretty similar:\n\n.Authenticating Username and Password\n[.invert-dark]\nimage::{figures}/usernamepasswordauthenticationfilter.png[]\n\nThe figure builds off our xref:servlet/architecture.adoc#servlet-securityfilterchain[`SecurityFilterChain`] diagram.\n\nimage:{icondir}/number_1.png[] When the user submits their username and password, the `UsernamePasswordAuthenticationFilter` creates a `UsernamePasswordAuthenticationToken`, which is a type of xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`], by extracting the username and password from the `HttpServletRequest` instance.\n\nimage:{icondir}/number_2.png[] Next, the `UsernamePasswordAuthenticationToken` is passed into the `AuthenticationManager` instance to be authenticated.\nThe details of what `AuthenticationManager` looks like depend on how the xref:servlet/authentication/passwords/index.adoc#servlet-authentication-unpwd-storage[user information is stored].\n\nimage:{icondir}/number_3.png[] If authentication fails, then __Failure__.\n\n. The xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[SecurityContextHolder] is cleared out.\n. `RememberMeServices.loginFail` is invoked.\nIf remember me is not configured, this is a no-op.\nSee the javadoc:org.springframework.security.web.authentication.RememberMeServices[] interface in the Javadoc.\n. `AuthenticationFailureHandler` is invoked.\nSee the javadoc:org.springframework.security.web.authentication.AuthenticationFailureHandler[] class in the Javadoc\n\nimage:{icondir}/number_4.png[] If authentication is successful, then __Success__.\n\n. `SessionAuthenticationStrategy` is notified of a new login.\nSee the javadoc:org.springframework.security.web.authentication.session.SessionAuthenticationStrategy[] interface in the Javadoc.\n. The xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[Authentication] is set on the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[SecurityContextHolder].\nSee the javadoc:org.springframework.security.web.context.SecurityContextPersistenceFilter[] class in the Javadoc.\n. `RememberMeServices.loginSuccess` is invoked.\nIf remember me is not configured, this is a no-op.\nSee the javadoc:org.springframework.security.web.authentication.RememberMeServices[] interface in the Javadoc.\n. `ApplicationEventPublisher` publishes an `InteractiveAuthenticationSuccessEvent`.\n. The `AuthenticationSuccessHandler` is invoked. Typically, this is a `SimpleUrlAuthenticationSuccessHandler`, which redirects to a request saved by xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[`ExceptionTranslationFilter`] when we redirect to the login page.\n\n[[servlet-authentication-form-min]]\nBy default, Spring Security form login is enabled.\nHowever, as soon as any servlet-based configuration is provided, form based login must be explicitly provided.\nThe following example shows a minimal, explicit Java configuration:\n\n.Form Login\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n\thttp\n .formLogin(withDefaults());\n\t// ...\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<form-login />\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n\thttp {\n formLogin { }\n\t}\n\t// ...\n}\n----\n======\n\nIn the preceding configuration, Spring Security renders a default login page.\nMost production applications require a custom login form.\n\n[[servlet-authentication-form-custom]]\nThe following configuration demonstrates how to provide a custom login form.\n\n.Custom Login Form Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n\thttp\n .formLogin((form) -> form\n .loginPage(\"/login\")\n .permitAll()\n );\n\t// ...\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<intercept-url pattern=\"/login\" access=\"permitAll\" />\n\t<form-login login-page=\"/login\" />\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n\thttp {\n formLogin {\n loginPage = \"/login\"\n permitAll()\n }\n\t}\n\t// ...\n}\n----\n======\n\n[[servlet-authentication-form-custom-html]]\nWhen the login page is specified in the Spring Security configuration, you are responsible for rendering the page.\nThe following https://www.thymeleaf.org/[Thymeleaf] template produces an HTML login form that complies with a login page of `/login`.:\n\n.Login Form - src/main/resources/templates/login.html\n[source,xml]\n----\n<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"https://www.thymeleaf.org\">\n\t<head>\n <title>Please Log In</title>\n\t</head>\n\t<body>\n <h1>Please Log In</h1>\n <div th:if=\"${param.error}\">\n Invalid username and password.</div>\n <div th:if=\"${param.logout}\">\n You have been logged out.</div>\n <form th:action=\"@{/login}\" method=\"post\">\n <div>\n <input type=\"text\" name=\"username\" placeholder=\"Username\"/>\n </div>\n <div>\n <input type=\"password\" name=\"password\" placeholder=\"Password\"/>\n </div>\n <input type=\"submit\" value=\"Log in\" />\n </form>\n\t</body>\n</html>\n----\n\nThere are a few key points about the default HTML form:\n\n* The form should perform a `post` to `/login`.\n* The form needs to include a xref:servlet/exploits/csrf.adoc#servlet-csrf[CSRF Token], which is xref:servlet/exploits/csrf.adoc#csrf-integration-form[automatically included] by Thymeleaf.\n* The form should specify the username in a parameter named `username`.\n* The form should specify the password in a parameter named `password`.\n* If the HTTP parameter named `error` is found, it indicates the user failed to provide a valid username or password.\n* If the HTTP parameter named `logout` is found, it indicates the user has logged out successfully.\n\nMany users do not need much more than to customize the login page.\nHowever, if needed, you can customize everything shown earlier with additional configuration.\n\n[[servlet-authentication-form-custom-controller]]\nIf you use Spring MVC, you need a controller that maps `GET /login` to the login template we created.\nThe following example shows a minimal `LoginController`:\n\n.LoginController\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\nclass LoginController {\n\t@GetMapping(\"/login\")\n\tString login() {\n return \"login\";\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nclass LoginController {\n @GetMapping(\"/login\")\n fun login(): String {\n return \"login\"\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/form.adoc", "title": "form", "heading": "form", "heading_level": 1, "file_order": 86, "section_index": 0, "content_hash": "d8fe92b1ea18df7cd29c246785df987b8eea3be9407f445df88377c5b15bc943", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/form.adoc"}}
{"id": "sha256:efbdbf486c0ceaab24781562539a33518eff53ff1afc3d4a8dac9f4d35be0b39", "content": "[[servlet-authentication-inmemory]]\n\nSpring Security's `InMemoryUserDetailsManager` implements xref:servlet/authentication/passwords/user-details-service.adoc#servlet-authentication-userdetailsservice[UserDetailsService] to provide support for username/password based authentication that is stored in memory.\n`InMemoryUserDetailsManager` provides management of `UserDetails` by implementing the `UserDetailsManager` interface.\n`UserDetails`-based authentication is used by Spring Security when it is configured to xref:servlet/authentication/passwords/index.adoc#servlet-authentication-unpwd-input[accept a username and password] for authentication.\n\nIn the following sample, we use xref:features/authentication/password-storage.adoc#authentication-password-storage-boot-cli[Spring Boot CLI] to encode a password value of `password` and get the encoded password of `+{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW+`:\n\n.InMemoryUserDetailsManager Java Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",attrs=\"-attributes\"]\n----\n@Bean\npublic UserDetailsService users() {\n\tUserDetails user = User.builder()\n .username(\"user\")\n .password(\"{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\")\n .roles(\"USER\")\n .build();\n\tUserDetails admin = User.builder()\n .username(\"admin\")\n .password(\"{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\")\n .roles(\"USER\", \"ADMIN\")\n .build();\n\treturn new InMemoryUserDetailsManager(user, admin);\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\",attrs=\"-attributes\"]\n----\n<user-service>\n\t<user name=\"user\"\n password=\"{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\"\n authorities=\"ROLE_USER\" />\n\t<user name=\"admin\"\n password=\"{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\"\n authorities=\"ROLE_USER,ROLE_ADMIN\" />\n</user-service>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",attrs=\"-attributes\"]\n----\n@Bean\nfun users(): UserDetailsService {\n val user = User.builder()\n .username(\"user\")\n .password(\"{bcrypt}$2a$10\\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\")\n .roles(\"USER\")\n .build()\n val admin = User.builder()\n .username(\"admin\")\n .password(\"{bcrypt}$2a$10\\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\")\n .roles(\"USER\", \"ADMIN\")\n .build()\n return InMemoryUserDetailsManager(user, admin)\n}\n----\n======\n\nThe preceding samples store the passwords in a secure format but leave a lot to be desired in terms of a getting started experience.\n\nIn the following sample, we use xref:features/authentication/password-storage.adoc#authentication-password-storage-dep-getting-started[User.withDefaultPasswordEncoder] to ensure that the password stored in memory is protected.\nHowever, it does not protect against obtaining the password by decompiling the source code.\nFor this reason, `User.withDefaultPasswordEncoder` should only be used for \"`getting started`\" and is not intended for production.\n\n.InMemoryUserDetailsManager with User.withDefaultPasswordEncoder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic UserDetailsService users() {\n\t// The builder will ensure the passwords are encoded before saving in memory\n\tUserBuilder users = User.withDefaultPasswordEncoder();\n\tUserDetails user = users\n .username(\"user\")\n .password(\"password\")\n .roles(\"USER\")\n .build();\n\tUserDetails admin = users\n .username(\"admin\")\n .password(\"password\")\n .roles(\"USER\", \"ADMIN\")\n .build();\n\treturn new InMemoryUserDetailsManager(user, admin);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun users(): UserDetailsService {\n // The builder will ensure the passwords are encoded before saving in memory\n val users = User.withDefaultPasswordEncoder()\n val user = users\n .username(\"user\")\n .password(\"password\")\n .roles(\"USER\")\n .build()\n val admin = users\n .username(\"admin\")\n .password(\"password\")\n .roles(\"USER\", \"ADMIN\")\n .build()\n return InMemoryUserDetailsManager(user, admin)\n}\n----\n======\n\nThere is no simple way to use `User.withDefaultPasswordEncoder` with XML-based configuration.\nFor demos or just getting started, you can choose to prefix the password with `+{noop}+` to indicate xref:features/authentication/password-storage.adoc#authentication-password-storage-dpe-format[no encoding should be used]:\n\n.<user-service> `+{noop}+` XML Configuration\n[source,xml,attrs=\"-attributes\"]\n----\n<user-service>\n\t<user name=\"user\"\n password=\"{noop}password\"\n authorities=\"ROLE_USER\" />\n\t<user name=\"admin\"\n password=\"{noop}password\"\n authorities=\"ROLE_USER,ROLE_ADMIN\" />\n</user-service>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/in-memory.adoc", "title": "in-memory", "heading": "in-memory", "heading_level": 1, "file_order": 87, "section_index": 0, "content_hash": "efbdbf486c0ceaab24781562539a33518eff53ff1afc3d4a8dac9f4d35be0b39", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/in-memory.adoc"}}
{"id": "sha256:7ccb116c6d116f05ae796ed6771b7134df329b8c639bff3a4f554e39a53b9389", "content": "[[servlet-authentication-unpwd]]\n\nOne of the most common ways to authenticate a user is by validating a username and password.\nSpring Security provides comprehensive support for authenticating with a username and password.\n\nYou can configure username and password authentication using the following:\n\n.Simple Username/Password Example\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .httpBasic(Customizer.withDefaults())\n .formLogin(Customizer.withDefaults());\n\n return http.build();\n\t}\n\n\t@Bean\n\tpublic UserDetailsService userDetailsService() {\n UserDetails userDetails = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .roles(\"USER\")\n .build();\n\n return new InMemoryUserDetailsManager(userDetails);\n\t}\n\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<intercept-url pattern=\"/**\" access=\"authenticated\"/>\n\t<form-login />\n\t<http-basic />\n\n\t<user-service>\n <user name=\"user\"\n password=\"{noop}password\"\n authorities=\"ROLE_USER\" />\n\t</user-service>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n formLogin { }\n httpBasic { }\n }\n\n return http.build()\n\t}\n\n\t@Bean\n\tfun userDetailsService(): UserDetailsService {\n val user = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .roles(\"USER\")\n .build()\n\n return InMemoryUserDetailsManager(user)\n\t}\n\n}\n----\n=====\n\n[WARNING]\n`User#withDefaultPasswordEncoder` is considered unsafe for production and is only intended for sample applications. See javadoc:org.springframework.security.core.userdetails.User#withDefaultPasswordEncoder()[User#withDefaultPasswordEncoder] for more details.\n\nThe preceding configuration automatically registers an xref:servlet/authentication/passwords/in-memory.adoc[in-memory `UserDetailsService`] with the `SecurityFilterChain`, registers the xref:servlet/authentication/passwords/dao-authentication-provider.adoc[`DaoAuthenticationProvider`] with the default xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationmanager[`AuthenticationManager`], and enables xref:servlet/authentication/passwords/form.adoc[Form Login] and xref:servlet/authentication/passwords/basic.adoc[HTTP Basic] authentication.\n\nTo learn more about username/password authentication, consider the following use cases:\n\n* I want to xref:servlet/authentication/passwords/form.adoc[learn how Form Login works]\n* I want to xref:servlet/authentication/passwords/basic.adoc[learn how HTTP Basic authentication works]\n* I want to xref:servlet/authentication/passwords/dao-authentication-provider.adoc[learn how `DaoAuthenticationProvider` works]\n* I want to xref:servlet/authentication/passwords/in-memory.adoc[manage users in memory]\n* I want to xref:servlet/authentication/passwords/jdbc.adoc[manage users in a database]\n* I want to xref:servlet/authentication/passwords/ldap.adoc#servlet-authentication-ldap-authentication[manage users in LDAP]\n* I want to <<publish-authentication-manager-bean,publish an `AuthenticationManager` bean>> for custom authentication\n* I want to <<customize-global-authentication-manager,customize the global `AuthenticationManager`>>\n\n[[publish-authentication-manager-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 88, "section_index": 0, "content_hash": "7ccb116c6d116f05ae796ed6771b7134df329b8c639bff3a4f554e39a53b9389", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/index.adoc"}}
{"id": "sha256:8975f03f260412afc953f70f5c99e7e0ef0b1e5db2c127c3d9568493b3e4ed11", "content": "A fairly common requirement is publishing an `AuthenticationManager` bean to allow for custom authentication, such as in a `@Service` or Spring MVC `@Controller`.\nFor example, you may want to authenticate users via a REST API instead of using xref:servlet/authentication/passwords/form.adoc[Form Login].\n\nYou can publish such an `AuthenticationManager` for custom authentication scenarios using the following configuration:\n\n.Publish `AuthenticationManager` bean for Custom Authentication\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/login\").permitAll()\n .anyRequest().authenticated()\n );\n\n return http.build();\n\t}\n\n\t@Bean\n\tpublic AuthenticationManager authenticationManager(\n UserDetailsService userDetailsService,\n PasswordEncoder passwordEncoder) {\n DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider(userDetailsService);\n authenticationProvider.setPasswordEncoder(passwordEncoder);\n\n return new ProviderManager(authenticationProvider);\n\t}\n\n\t@Bean\n\tpublic UserDetailsService userDetailsService() {\n UserDetails userDetails = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .roles(\"USER\")\n .build();\n\n return new InMemoryUserDetailsManager(userDetails);\n\t}\n\n\t@Bean\n\tpublic PasswordEncoder passwordEncoder() {\n return PasswordEncoderFactories.createDelegatingPasswordEncoder();\n\t}\n\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<intercept-url pattern=\"/login\" access=\"permitAll\"/>\n\t<intercept-url pattern=\"/**\" access=\"authenticated\"/>\n\n\t<bean id=\"authenticationManager\"\n class=\"org.springframework.security.authentication.ProviderManager\">\n <constructor-arg>\n <bean class=\"org.springframework.security.authentication.dao.DaoAuthenticationProvider\">\n <constructor-arg name=\"userDetailsService\" ref=\"userDetailsService\" />\n <property name=\"passwordEncoder\" ref=\"passwordEncoder\" />\n </bean>\n </constructor-arg>\n\t</bean>\n\n\t<user-service id=\"userDetailsService\">\n <user name=\"user\"\n password=\"{noop}password\"\n authorities=\"ROLE_USER\" />\n\t</user-service>\n\n\t<bean id=\"passwordEncoder\"\n class=\"org.springframework.security.crypto.factory.PasswordEncoderFactories\" factory-method=\"createDelegatingPasswordEncoder\"/>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(\"/login\", permitAll)\n authorize(anyRequest, authenticated)\n }\n }\n\n return http.build()\n\t}\n\n\t@Bean\n\tfun authenticationManager(\n userDetailsService: UserDetailsService,\n passwordEncoder: PasswordEncoder): AuthenticationManager {\n val authenticationProvider = DaoAuthenticationProvider(userDetailsService)\n authenticationProvider.setPasswordEncoder(passwordEncoder)\n\n return ProviderManager(authenticationProvider)\n\t}\n\n\t@Bean\n\tfun userDetailsService(): UserDetailsService {\n val user = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .roles(\"USER\")\n .build()\n\n return InMemoryUserDetailsManager(user)\n\t}\n\n\t@Bean\n\tfun passwordEncoder(): PasswordEncoder {\n return PasswordEncoderFactories.createDelegatingPasswordEncoder()\n\t}\n\n}\n----\n=====\n\nWith the preceding configuration in place, you can create a `@RestController` that uses the `AuthenticationManager` as follows:\n\n.Create a `@RestController` for Authentication\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic class LoginController {\n\n\tprivate final AuthenticationManager authenticationManager;\n\n\tpublic LoginController(AuthenticationManager authenticationManager) {\n this.authenticationManager = authenticationManager;\n\t}\n\n\t@PostMapping(\"/login\")\n\tpublic ResponseEntity<Void> login(@RequestBody LoginRequest loginRequest) {\n Authentication authenticationRequest =\n UsernamePasswordAuthenticationToken.unauthenticated(loginRequest.username(), loginRequest.password());\n Authentication authenticationResponse =\n this.authenticationManager.authenticate(authenticationRequest);\n // ...\n\t}\n\n\tpublic record LoginRequest(String username, String password) {\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RestController\nclass LoginController(val authenticationManager: AuthenticationManager) {\n\n\t@PostMapping(\"/login\")\n\tfun login(@RequestBody loginRequest: LoginRequest): ResponseEntity<Void> {\n val authenticationRequest =\n UsernamePasswordAuthenticationToken.unauthenticated(\n loginRequest.username, loginRequest.password)\n val authenticationResponse =\n authenticationManager.authenticate(authenticationRequest)\n // ...\n\t}\n\n\tdata class LoginRequest(val username: String, val password: String)\n\n}\n----\n=====\n\n[NOTE]\n====\nIn this example, it is your responsibility to save the authenticated user in the `SecurityContextRepository` if needed.\nFor example, if using the `HttpSession` to persist the `SecurityContext` between requests, you can use xref:servlet/authentication/persistence.adoc#httpsecuritycontextrepository[`HttpSessionSecurityContextRepository`].\n====\n\n[[customize-global-authentication-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/index.adoc", "title": "index", "heading": "Publish an `AuthenticationManager` bean", "heading_level": 2, "file_order": 88, "section_index": 1, "content_hash": "8975f03f260412afc953f70f5c99e7e0ef0b1e5db2c127c3d9568493b3e4ed11", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/index.adoc"}}
{"id": "sha256:bbe0d60df7ea243a8e58409e4d67c32599814d0cfea6d44d00e921f17af9d629", "content": "Normally, Spring Security builds an `AuthenticationManager` internally composed of a `DaoAuthenticationProvider` for username/password authentication.\nIn certain cases, it may still be desired to customize the instance of `AuthenticationManager` used by Spring Security.\nFor example, you may need to simply disable xref:servlet/authentication/architecture.adoc#servlet-authentication-providermanager-erasing-credentials[credential erasure] for cached users.\n\nTo do this, you can take advantage of the fact that the `AuthenticationManagerBuilder` used to build Spring Security's global `AuthenticationManager` is published as a bean.\nYou can configure the builder as follows:\n\n.Configure global `AuthenticationManagerBuilder`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n // ...\n return http.build();\n\t}\n\n\t@Bean\n\tpublic UserDetailsService userDetailsService() {\n // Return a UserDetailsService that caches users\n // ...\n\t}\n\n\t@Autowired\n\tpublic void configure(AuthenticationManagerBuilder builder) {\n builder.eraseCredentials(false);\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n // ...\n return http.build()\n\t}\n\n\t@Bean\n\tfun userDetailsService(): UserDetailsService {\n // Return a UserDetailsService that caches users\n // ...\n\t}\n\n\t@Autowired\n\tfun configure(builder: AuthenticationManagerBuilder) {\n builder.eraseCredentials(false)\n\t}\n\n}\n----\n=====\n\nAlternatively, you may configure a local `AuthenticationManager` to override the global one.\n\n.Configure local `AuthenticationManager` for Spring Security\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .httpBasic(Customizer.withDefaults())\n .formLogin(Customizer.withDefaults())\n .authenticationManager(authenticationManager());\n\n return http.build();\n\t}\n\n\tprivate AuthenticationManager authenticationManager() {\n DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider(userDetailsService());\n authenticationProvider.setPasswordEncoder(passwordEncoder());\n\n ProviderManager providerManager = new ProviderManager(authenticationProvider);\n providerManager.setEraseCredentialsAfterAuthentication(false);\n\n return providerManager;\n\t}\n\n\tprivate UserDetailsService userDetailsService() {\n UserDetails userDetails = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .roles(\"USER\")\n .build();\n\n return new InMemoryUserDetailsManager(userDetails);\n\t}\n\n\tprivate PasswordEncoder passwordEncoder() {\n return PasswordEncoderFactories.createDelegatingPasswordEncoder();\n\t}\n\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http authentication-manager-ref=\"authenticationManager\">\n\t<intercept-url pattern=\"/**\" access=\"authenticated\"/>\n\t<form-login />\n\t<http-basic />\n\n\t<bean id=\"authenticationManager\"\n class=\"org.springframework.security.authentication.ProviderManager\">\n <constructor-arg>\n <bean class=\"org.springframework.security.authentication.dao.DaoAuthenticationProvider\">\n <constructor-arg name=\"userDetailsService\" ref=\"userDetailsService\" />\n <property name=\"passwordEncoder\" ref=\"passwordEncoder\" />\n </bean>\n </constructor-arg>\n\t</bean>\n\n\t<user-service id=\"userDetailsService\">\n <user name=\"user\"\n password=\"{noop}password\"\n authorities=\"ROLE_USER\" />\n\t</user-service>\n\n\t<bean id=\"passwordEncoder\"\n class=\"org.springframework.security.crypto.factory.PasswordEncoderFactories\" factory-method=\"createDelegatingPasswordEncoder\"/>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n formLogin { }\n httpBasic { }\n authenticationManager = authenticationManager()\n }\n\n return http.build()\n\t}\n\n\t@Bean\n\tfun authenticationManager(): AuthenticationManager {\n val authenticationProvider = DaoAuthenticationProvider(userDetailsService())\n authenticationProvider.setPasswordEncoder(passwordEncoder())\n\n val providerManager = ProviderManager(authenticationProvider)\n providerManager.eraseCredentialsAfterAuthentication = false\n\n return providerManager\n\t}\n\n\tprivate fun userDetailsService(): UserDetailsService {\n val user = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .roles(\"USER\")\n .build()\n\n return InMemoryUserDetailsManager(user)\n\t}\n\n\tprivate fun passwordEncoder(): PasswordEncoder {\n return PasswordEncoderFactories.createDelegatingPasswordEncoder()\n\t}\n\n}\n----\n=====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/index.adoc", "title": "index", "heading": "Customize the `AuthenticationManager`", "heading_level": 2, "file_order": 88, "section_index": 2, "content_hash": "bbe0d60df7ea243a8e58409e4d67c32599814d0cfea6d44d00e921f17af9d629", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/index.adoc"}}
{"id": "sha256:cac153312f286136d066ddd34a1e056e056e142ad0ddc9e491026f2aecd418aa", "content": "[[servlet-authentication-unpwd-input]]\n\nSpring Security provides the following built-in mechanisms for reading a username and password from `HttpServletRequest`:", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/input.adoc", "title": "input", "heading": "input", "heading_level": 1, "file_order": 89, "section_index": 0, "content_hash": "cac153312f286136d066ddd34a1e056e056e142ad0ddc9e491026f2aecd418aa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/input.adoc"}}
{"id": "sha256:6b331b95fde67c97db6a7fc8bd79236fb277c8770f3a9737c6898b4c17db4895", "content": "[[servlet-authentication-jdbc]]\n\nSpring Security's `JdbcDaoImpl` implements xref:servlet/authentication/passwords/user-details-service.adoc#servlet-authentication-userdetailsservice[`UserDetailsService`] to provide support for username-and-password-based authentication that is retrieved by using JDBC.\n`JdbcUserDetailsManager` extends `JdbcDaoImpl` to provide management of `UserDetails` through the `UserDetailsManager` interface.\n`UserDetails`-based authentication is used by Spring Security when it is configured to xref:servlet/authentication/passwords/index.adoc#servlet-authentication-unpwd-input[accept a username/password] for authentication.\n\nIn the following sections, we discuss:\n\n* The <<servlet-authentication-jdbc-schema>> used by Spring Security JDBC Authentication\n* <<servlet-authentication-jdbc-datasource>>\n* <<servlet-authentication-jdbc-bean>>\n\n[[servlet-authentication-jdbc-schema]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc", "title": "jdbc", "heading": "jdbc", "heading_level": 1, "file_order": 90, "section_index": 0, "content_hash": "6b331b95fde67c97db6a7fc8bd79236fb277c8770f3a9737c6898b4c17db4895", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc"}}
{"id": "sha256:f1d5ace307b8bd9c0e3a1fed1bb7c60615626a6b7c4180095e69dc7538fb60b3", "content": "Spring Security provides default queries for JDBC-based authentication.\nThis section provides the corresponding default schemas used with the default queries.\nYou need to adjust the schema to match any customizations to the queries and the database dialect you use.\n\n[[servlet-authentication-jdbc-schema-user]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc", "title": "jdbc", "heading": "Default Schema", "heading_level": 2, "file_order": 90, "section_index": 1, "content_hash": "f1d5ace307b8bd9c0e3a1fed1bb7c60615626a6b7c4180095e69dc7538fb60b3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc"}}
{"id": "sha256:b65384dad22ecdd7e52cf02627683a526411bd42fb15cc90734f94241f7b40a9", "content": "`JdbcDaoImpl` requires tables to load the password, account status (enabled or disabled) and a list of authorities (roles) for the user.\n\n[NOTE]\n====\nThe default schema is also exposed as a classpath resource named `org/springframework/security/core/userdetails/jdbc/users.ddl`.\n====\n\n.Default User Schema\n[source,sql]\n----\ncreate table users(\n\tusername varchar_ignorecase(50) not null primary key,\n\tpassword varchar_ignorecase(500) not null,\n\tenabled boolean not null\n);\n\ncreate table authorities (\n\tusername varchar_ignorecase(50) not null,\n\tauthority varchar_ignorecase(50) not null,\n\tconstraint fk_authorities_users foreign key(username) references users(username)\n);\ncreate unique index ix_auth_username on authorities (username,authority);\n----\n\nOracle is a popular database choice but requires a slightly different schema:\n\n.Default User Schema for Oracle Databases\n[source,sql]\n----\nCREATE TABLE USERS (\n USERNAME NVARCHAR2(128) PRIMARY KEY,\n PASSWORD NVARCHAR2(128) NOT NULL,\n ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL\n);\n\nCREATE TABLE AUTHORITIES (\n USERNAME NVARCHAR2(128) NOT NULL,\n AUTHORITY NVARCHAR2(128) NOT NULL\n);\nALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY);\nALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE;\n----\n\n[[servlet-authentication-jdbc-schema-group]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc", "title": "jdbc", "heading": "User Schema", "heading_level": 3, "file_order": 90, "section_index": 2, "content_hash": "b65384dad22ecdd7e52cf02627683a526411bd42fb15cc90734f94241f7b40a9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc"}}
{"id": "sha256:ca19b719942d86996c7af63d26bce3c7ab59b61bec339ed616078f0189a78bad", "content": "If your application uses groups, you need to provide the groups schema:\n\n.Default Group Schema\n[source,sql]\n----\ncreate table groups (\n\tid bigint generated by default as identity(start with 0) primary key,\n\tgroup_name varchar_ignorecase(50) not null\n);\n\ncreate table group_authorities (\n\tgroup_id bigint not null,\n\tauthority varchar(50) not null,\n\tconstraint fk_group_authorities_group foreign key(group_id) references groups(id)\n);\n\ncreate table group_members (\n\tid bigint generated by default as identity(start with 0) primary key,\n\tusername varchar(50) not null,\n\tgroup_id bigint not null,\n\tconstraint fk_group_members_group foreign key(group_id) references groups(id)\n);\n----\n\n[[servlet-authentication-jdbc-datasource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc", "title": "jdbc", "heading": "Group Schema", "heading_level": 3, "file_order": 90, "section_index": 3, "content_hash": "ca19b719942d86996c7af63d26bce3c7ab59b61bec339ed616078f0189a78bad", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc"}}
{"id": "sha256:f12a83a5eaccce0aee60d45a07479f9114b51b16267e1dff6e6c4e322d3d8ed9", "content": "Before we configure `JdbcUserDetailsManager`, we must create a `DataSource`.\nIn our example, we set up an https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#jdbc-embedded-database-support[embedded DataSource] that is initialized with the <<servlet-authentication-jdbc-schema,default user schema>>.\n\n.Embedded Data Source\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nDataSource dataSource() {\n\treturn new EmbeddedDatabaseBuilder()\n .setType(H2)\n .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)\n .build();\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<jdbc:embedded-database>\n\t<jdbc:script location=\"classpath:org/springframework/security/core/userdetails/jdbc/users.ddl\"/>\n</jdbc:embedded-database>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun dataSource(): DataSource {\n return EmbeddedDatabaseBuilder()\n .setType(H2)\n .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)\n .build()\n}\n----\n======\n\nIn a production environment, you want to ensure that you set up a connection to an external database.\n\n[[servlet-authentication-jdbc-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc", "title": "jdbc", "heading": "Setting up a DataSource", "heading_level": 2, "file_order": 90, "section_index": 4, "content_hash": "f12a83a5eaccce0aee60d45a07479f9114b51b16267e1dff6e6c4e322d3d8ed9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc"}}
{"id": "sha256:b0a32d435627dc4d97d69a478747d0669fbf4d9197a240a3f9103e694ad90ccd", "content": "In this sample, we use xref:features/authentication/password-storage.adoc#authentication-password-storage-boot-cli[Spring Boot CLI] to encode a password value of `password` and get the encoded password of `+{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW+`.\nSee the xref:features/authentication/password-storage.adoc#authentication-password-storage[PasswordEncoder] section for more details about how to store passwords.\n\n.JdbcUserDetailsManager\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",attrs=\"-attributes\"]\n----\n@Bean\nUserDetailsManager users(DataSource dataSource) {\n\tUserDetails user = User.builder()\n .username(\"user\")\n .password(\"{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\")\n .roles(\"USER\")\n .build();\n\tUserDetails admin = User.builder()\n .username(\"admin\")\n .password(\"{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\")\n .roles(\"USER\", \"ADMIN\")\n .build();\n\tJdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);\n\tusers.createUser(user);\n\tusers.createUser(admin);\n\treturn users;\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\",attrs=\"-attributes\"]\n----\n<jdbc-user-service>\n\t<user name=\"user\"\n password=\"{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\"\n authorities=\"ROLE_USER\" />\n\t<user name=\"admin\"\n password=\"{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\"\n authorities=\"ROLE_USER,ROLE_ADMIN\" />\n</jdbc-user-service>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",attrs=\"-attributes\"]\n----\n@Bean\nfun users(dataSource: DataSource): UserDetailsManager {\n val user = User.builder()\n .username(\"user\")\n .password(\"{bcrypt}$2a$10\\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\")\n .roles(\"USER\")\n .build();\n val admin = User.builder()\n .username(\"admin\")\n .password(\"{bcrypt}$2a$10\\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW\")\n .roles(\"USER\", \"ADMIN\")\n .build();\n val users = JdbcUserDetailsManager(dataSource)\n users.createUser(user)\n users.createUser(admin)\n return users\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc", "title": "jdbc", "heading": "JdbcUserDetailsManager Bean", "heading_level": 2, "file_order": 90, "section_index": 5, "content_hash": "b0a32d435627dc4d97d69a478747d0669fbf4d9197a240a3f9103e694ad90ccd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/jdbc.adoc"}}
{"id": "sha256:c4ea576459dff641cfb1a7b9b2fc86c094c2d0cf747dd6a675b0f1ee9718f489", "content": "[[servlet-authentication-ldap]]\n\nLDAP (Lightweight Directory Access Protocol) is often used by organizations as a central repository for user information and as an authentication service.\nIt can also be used to store the role information for application users.\n\nSpring Security's LDAP-based authentication is used by Spring Security when it is configured to xref:servlet/authentication/passwords/index.adoc#servlet-authentication-unpwd-input[accept a username/password] for authentication.\nHowever, despite using a username and password for authentication, it does not use `UserDetailsService`, because, in <<servlet-authentication-ldap-bind,bind authentication>>, the LDAP server does not return the password, so the application cannot perform validation of the password.\n\nThere are many different scenarios for how an LDAP server can be configured, so Spring Security's LDAP provider is fully configurable.\nIt uses separate strategy interfaces for authentication and role retrieval and provides default implementations, which can be configured to handle a wide range of situations.\n\n[[servlet-authentication-ldap-required-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "ldap", "heading_level": 1, "file_order": 91, "section_index": 0, "content_hash": "c4ea576459dff641cfb1a7b9b2fc86c094c2d0cf747dd6a675b0f1ee9718f489", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:fbc871d7f5c26d062d161ebd0f493e3356699425b68a8c221f94d36146aa2baa", "content": "To get started, add the `spring-security-ldap` dependency to your project.\nWhen using Spring Boot, add the following dependencies:\n\n.Spring Security LDAP Dependencies\n[tabs]\n======\nMaven::\n+\n[source,xml,role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-data-ldap</artifactId>\n</dependency>\n\n<dependency>\n <groupId>org.springframework.security</groupId>\n <artifactId>spring-security-ldap</artifactId>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,role=\"secondary\"]\n----\ndependencies {\n implementation \"org.springframework.boot:spring-boot-starter-data-ldap\"\n implementation \"org.springframework.security:spring-security-ldap\"\n}\n----\n======\n\n[[servlet-authentication-ldap-prerequisites]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "Required Dependencies", "heading_level": 2, "file_order": 91, "section_index": 1, "content_hash": "fbc871d7f5c26d062d161ebd0f493e3356699425b68a8c221f94d36146aa2baa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:94435147812324e35306706eb20b414a72efacc11fe8ce9795062373f7e0e8d7", "content": "You should be familiar with LDAP before trying to use it with Spring Security.\nThe following link provides a good introduction to the concepts involved and a guide to setting up a directory using the free LDAP server, OpenLDAP: https://www.zytrax.com/books/ldap/.\nSome familiarity with the JNDI APIs used to access LDAP from Java can also be useful.\nWe do not use any third-party LDAP libraries (Mozilla, JLDAP, or others) in the LDAP provider, but extensive use is made of Spring LDAP, so some familiarity with that project may be useful if you plan on adding your own customizations.\n\nWhen using LDAP authentication, you should ensure that you properly configure LDAP connection pooling.\nIf you are unfamiliar with how to do so, see the https://docs.oracle.com/javase/jndi/tutorial/ldap/connect/config.html[Java LDAP documentation].\n\n[[servlet-authentication-ldap-embedded]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "Prerequisites", "heading_level": 2, "file_order": 91, "section_index": 2, "content_hash": "94435147812324e35306706eb20b414a72efacc11fe8ce9795062373f7e0e8d7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:340341ef5c6f6edd242e5e132261a7d60a1b5dc4220c3de4b8cec542fc565e1c", "content": "The first thing you need to do is to ensure that you have an LDAP Server to which to point your configuration.\nFor simplicity, it is often best to start with an embedded LDAP Server.\nSpring Security supports using either:\n\n* <<servlet-authentication-ldap-unboundid>>\n* <<servlet-authentication-ldap-apacheds>>\n\nIn the following samples, we expose `users.ldif` as a classpath resource to initialize the embedded LDAP server with two users, `user` and `admin`, both of which have a password of `password`:\n\n.users.ldif\n[source,ldif]\n----\ndn: ou=groups,dc=springframework,dc=org\nobjectclass: top\nobjectclass: organizationalUnit\nou: groups\n\ndn: ou=people,dc=springframework,dc=org\nobjectclass: top\nobjectclass: organizationalUnit\nou: people\n\ndn: uid=admin,ou=people,dc=springframework,dc=org\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\ncn: Rod Johnson\nsn: Johnson\nuid: admin\nuserPassword: password\n\ndn: uid=user,ou=people,dc=springframework,dc=org\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\ncn: Dianne Emu\nsn: Emu\nuid: user\nuserPassword: password\n\ndn: cn=user,ou=groups,dc=springframework,dc=org\nobjectclass: top\nobjectclass: groupOfNames\ncn: user\nmember: uid=admin,ou=people,dc=springframework,dc=org\nmember: uid=user,ou=people,dc=springframework,dc=org\n\ndn: cn=admin,ou=groups,dc=springframework,dc=org\nobjectclass: top\nobjectclass: groupOfNames\ncn: admin\nmember: uid=admin,ou=people,dc=springframework,dc=org\n----\n\n[[servlet-authentication-ldap-unboundid]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "Setting up an Embedded LDAP Server", "heading_level": 2, "file_order": 91, "section_index": 3, "content_hash": "340341ef5c6f6edd242e5e132261a7d60a1b5dc4220c3de4b8cec542fc565e1c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:e5a740c8b633ffc053f62c3a5e0d8cfdec61dcf828b437fab71512a8a40ff422", "content": "If you wish to use https://ldap.com/unboundid-ldap-sdk-for-java/[UnboundID], specify the following dependencies:\n\n.UnboundID Dependencies\n[tabs]\n======\nMaven::\n+\n[source,xml,role=\"primary\",subs=\"verbatim,attributes\"]\n----\n<dependency>\n\t<groupId>com.unboundid</groupId>\n\t<artifactId>unboundid-ldapsdk</artifactId>\n\t<version>{unboundid-ldapsdk-version}</version>\n\t<scope>runtime</scope>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,role=\"secondary\",subs=\"verbatim,attributes\"]\n----\ndependencies {\n\truntimeOnly \"com.unboundid:unboundid-ldapsdk:{unboundid-ldapsdk-version}\"\n}\n----\n======\n\nYou can then configure the Embedded LDAP Server using an `EmbeddedLdapServerContextSourceFactoryBean`.\nThis will instruct Spring Security to start an in-memory LDAP server:\n\n.Embedded LDAP Server Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean() {\n\treturn EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun contextSourceFactoryBean(): EmbeddedLdapServerContextSourceFactoryBean {\n return EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer()\n}\n----\n======\n\nAlternatively, you can manually configure the Embedded LDAP Server.\nIf you choose this approach, you will be responsible for managing the lifecycle of the Embedded LDAP Server.\n\n.Explicit Embedded LDAP Server Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nUnboundIdContainer ldapContainer() {\n\treturn new UnboundIdContainer(\"dc=springframework,dc=org\",\n \"classpath:users.ldif\");\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<b:bean class=\"org.springframework.security.ldap.server.UnboundIdContainer\"\n\tc:defaultPartitionSuffix=\"dc=springframework,dc=org\"\n\tc:ldif=\"classpath:users.ldif\"/>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun ldapContainer(): UnboundIdContainer {\n return UnboundIdContainer(\"dc=springframework,dc=org\",\"classpath:users.ldif\")\n}\n----\n======\n\n[[servlet-authentication-ldap-apacheds]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "Embedded UnboundID Server", "heading_level": 3, "file_order": 91, "section_index": 4, "content_hash": "e5a740c8b633ffc053f62c3a5e0d8cfdec61dcf828b437fab71512a8a40ff422", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:daea4d078e6ddba095cf6ce903277a8a22864741a66856027edf35907f738aab", "content": "Spring Security 7 removes support for Apache DS.\nPlease use <<servlet-authentication-ldap-unboundid,UnboundID>> instead.\n\n[[servlet-authentication-ldap-contextsource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "Embedded ApacheDS Server", "heading_level": 3, "file_order": 91, "section_index": 5, "content_hash": "daea4d078e6ddba095cf6ce903277a8a22864741a66856027edf35907f738aab", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:1b8c931bbe0dcdcbb9c42bb0978a262adfd34dfaea4c412650124f8964990bac", "content": "Once you have an LDAP Server to which to point your configuration, you need to configure Spring Security to point to an LDAP server that should be used to authenticate users.\nTo do so, create an LDAP `ContextSource` (which is the equivalent of a JDBC `DataSource`).\nIf you have already configured an `EmbeddedLdapServerContextSourceFactoryBean`, Spring Security will create an LDAP `ContextSource` that points to the embedded LDAP server.\n\n.LDAP Context Source with Embedded LDAP Server\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean() {\n\tEmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean =\n EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer();\n\tcontextSourceFactoryBean.setPort(0);\n\treturn contextSourceFactoryBean;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun contextSourceFactoryBean(): EmbeddedLdapServerContextSourceFactoryBean {\n val contextSourceFactoryBean = EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer()\n contextSourceFactoryBean.setPort(0)\n return contextSourceFactoryBean\n}\n----\n======\n\nAlternatively, you can explicitly configure the LDAP `ContextSource` to connect to the supplied LDAP server:\n\n.LDAP Context Source\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nContextSource contextSource(UnboundIdContainer container) {\n\treturn new DefaultSpringSecurityContextSource(\"ldap://localhost:53389/dc=springframework,dc=org\");\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<ldap-server\n\turl=\"ldap://localhost:53389/dc=springframework,dc=org\" />\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nfun contextSource(container: UnboundIdContainer): ContextSource {\n return DefaultSpringSecurityContextSource(\"ldap://localhost:53389/dc=springframework,dc=org\")\n}\n----\n======\n\n[[servlet-authentication-ldap-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "LDAP ContextSource", "heading_level": 2, "file_order": 91, "section_index": 6, "content_hash": "1b8c931bbe0dcdcbb9c42bb0978a262adfd34dfaea4c412650124f8964990bac", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:21e849976925e1c0300323c32ff61762310fbb149b593bf0ab47a97f90215563", "content": "Spring Security's LDAP support does not use the xref:servlet/authentication/passwords/user-details-service.adoc#servlet-authentication-userdetailsservice[UserDetailsService] because LDAP bind authentication does not let clients read the password or even a hashed version of the password.\nThis means there is no way for a password to be read and then authenticated by Spring Security.\n\nFor this reason, LDAP support is implemented through the `LdapAuthenticator` interface.\nThe `LdapAuthenticator` interface is also responsible for retrieving any required user attributes.\nThis is because the permissions on the attributes may depend on the type of authentication being used.\nFor example, if binding as the user, it may be necessary to read the attributes with the user's own permissions.\n\nSpring Security supplies two `LdapAuthenticator` implementations:\n\n* <<servlet-authentication-ldap-bind>>\n* <<servlet-authentication-ldap-pwd>>\n\n[[servlet-authentication-ldap-bind]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "Authentication", "heading_level": 2, "file_order": 91, "section_index": 7, "content_hash": "21e849976925e1c0300323c32ff61762310fbb149b593bf0ab47a97f90215563", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:91a5a19759cedbf710b2a7d68acd0d472ef30ca5099ea43b19df40eebc8e8cab", "content": "https://ldap.com/the-ldap-bind-operation/[Bind Authentication] is the most common mechanism for authenticating users with LDAP.\nIn bind authentication, the user's credentials (username and password) are submitted to the LDAP server, which authenticates them.\nThe advantage to using bind authentication is that the user's secrets (the password) do not need to be exposed to clients, which helps to protect them from leaking.\n\nThe following example shows bind authentication configuration:\n\n.Bind Authentication\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",attrs=\"-attributes\"]\n----\n@Bean\nAuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) {\n\tLdapBindAuthenticationManagerFactory factory = new LdapBindAuthenticationManagerFactory(contextSource);\n\tfactory.setUserDnPatterns(\"uid={0},ou=people\");\n\treturn factory.createAuthenticationManager();\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\",attrs=\"-attributes\"]\n----\n<ldap-authentication-provider\n\tuser-dn-pattern=\"uid={0},ou=people\"/>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",attrs=\"-attributes\"]\n----\n@Bean\nfun authenticationManager(contextSource: BaseLdapPathContextSource): AuthenticationManager {\n val factory = LdapBindAuthenticationManagerFactory(contextSource)\n factory.setUserDnPatterns(\"uid={0},ou=people\")\n return factory.createAuthenticationManager()\n}\n----\n======\n\nThe preceding simple example would obtain the DN for the user by substituting the user login name in the supplied pattern and attempting to bind as that user with the login password.\nThis is OK if all your users are stored under a single node in the directory.\nIf, instead, you wish to configure an LDAP search filter to locate the user, you could use the following:\n\n.Bind Authentication with Search Filter\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",attrs=\"-attributes\"]\n----\n@Bean\nAuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) {\n\tLdapBindAuthenticationManagerFactory factory = new LdapBindAuthenticationManagerFactory(contextSource);\n\tfactory.setUserSearchFilter(\"(uid={0})\");\n\tfactory.setUserSearchBase(\"ou=people\");\n\treturn factory.createAuthenticationManager();\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\",attrs=\"-attributes\"]\n----\n<ldap-authentication-provider\n user-search-filter=\"(uid={0})\"\n\tuser-search-base=\"ou=people\"/>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",attrs=\"-attributes\"]\n----\n@Bean\nfun authenticationManager(contextSource: BaseLdapPathContextSource): AuthenticationManager {\n val factory = LdapBindAuthenticationManagerFactory(contextSource)\n factory.setUserSearchFilter(\"(uid={0})\")\n factory.setUserSearchBase(\"ou=people\")\n return factory.createAuthenticationManager()\n}\n----\n======\n\nIf used with the `ContextSource` <<servlet-authentication-ldap-contextsource,definition shown earlier>>, this would perform a search under the DN `ou=people,dc=springframework,dc=org` by using `+(uid={0})+` as a filter.\nAgain, the user login name is substituted for the parameter in the filter name, so it searches for an entry with the `uid` attribute equal to the user name.\nIf a user search base is not supplied, the search is performed from the root.\n\n[[servlet-authentication-ldap-pwd]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "Using Bind Authentication", "heading_level": 2, "file_order": 91, "section_index": 8, "content_hash": "91a5a19759cedbf710b2a7d68acd0d472ef30ca5099ea43b19df40eebc8e8cab", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:9314975001a534f426e543777d829e1dfa7f785984d5a59e46b4687fbf42bbbc", "content": "Password comparison is when the password supplied by the user is compared with the one stored in the repository.\nThis can either be done by retrieving the value of the password attribute and checking it locally or by performing an LDAP \"`compare`\" operation, where the supplied password is passed to the server for comparison and the real password value is never retrieved.\nAn LDAP compare cannot be done when the password is properly hashed with a random salt.\n\n.Minimal Password Compare Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nAuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) {\n\tLdapPasswordComparisonAuthenticationManagerFactory factory = new LdapPasswordComparisonAuthenticationManagerFactory(\n contextSource, NoOpPasswordEncoder.getInstance());\n\tfactory.setUserDnPatterns(\"uid={0},ou=people\");\n\treturn factory.createAuthenticationManager();\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\",attrs=\"-attributes\"]\n----\n<ldap-authentication-provider\n user-dn-pattern=\"uid={0},ou=people\">\n\t<password-compare />\n</ldap-authentication-provider>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationManager(contextSource: BaseLdapPathContextSource?): AuthenticationManager? {\n val factory = LdapPasswordComparisonAuthenticationManagerFactory(\n contextSource, NoOpPasswordEncoder.getInstance()\n )\n factory.setUserDnPatterns(\"uid={0},ou=people\")\n return factory.createAuthenticationManager()\n}\n----\n======\n\nThe following example shows a more advanced configuration with some customizations:\n\n.Password Compare Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nAuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) {\n\tLdapPasswordComparisonAuthenticationManagerFactory factory = new LdapPasswordComparisonAuthenticationManagerFactory(\n contextSource, new BCryptPasswordEncoder());\n\tfactory.setUserDnPatterns(\"uid={0},ou=people\");\n\tfactory.setPasswordAttribute(\"pwd\"); // <1>\n\treturn factory.createAuthenticationManager();\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\",attrs=\"-attributes\"]\n----\n<ldap-authentication-provider\n user-dn-pattern=\"uid={0},ou=people\">\n\t<password-compare password-attribute=\"pwd\"> <!--1-->\n <password-encoder ref=\"passwordEncoder\" /> <!--2-->\n\t</password-compare>\n</ldap-authentication-provider>\n<b:bean id=\"passwordEncoder\"\n\tclass=\"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\" />\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationManager(contextSource: BaseLdapPathContextSource): AuthenticationManager {\n val factory = LdapPasswordComparisonAuthenticationManagerFactory(\n contextSource, BCryptPasswordEncoder()\n )\n factory.setUserDnPatterns(\"uid={0},ou=people\")\n factory.setPasswordAttribute(\"pwd\") // <1>\n return factory.createAuthenticationManager()\n}\n----\n======\n\n<1> Specify the password attribute as `pwd`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "Using Password Authentication", "heading_level": 2, "file_order": 91, "section_index": 9, "content_hash": "9314975001a534f426e543777d829e1dfa7f785984d5a59e46b4687fbf42bbbc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:4e915b9bad5b1b9848d3dfe7fae48d17549f814c27a1cf1f55962c7e079d2161", "content": "Spring Security's `LdapAuthoritiesPopulator` is used to determine what authorities are returned for the user.\nThe following example shows how configure `LdapAuthoritiesPopulator`:\n\n.LdapAuthoritiesPopulator Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",attrs=\"-attributes\"]\n----\n@Bean\nLdapAuthoritiesPopulator authorities(BaseLdapPathContextSource contextSource) {\n\tString groupSearchBase = \"\";\n\tDefaultLdapAuthoritiesPopulator authorities =\n new DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase);\n\tauthorities.setGroupSearchFilter(\"member={0}\");\n\treturn authorities;\n}\n\n@Bean\nAuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource, LdapAuthoritiesPopulator authorities) {\n\tLdapBindAuthenticationManagerFactory factory = new LdapBindAuthenticationManagerFactory(contextSource);\n\tfactory.setUserDnPatterns(\"uid={0},ou=people\");\n\tfactory.setLdapAuthoritiesPopulator(authorities);\n\treturn factory.createAuthenticationManager();\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\",attrs=\"-attributes\"]\n----\n<ldap-authentication-provider\n\tuser-dn-pattern=\"uid={0},ou=people\"\n\tgroup-search-filter=\"member={0}\"/>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",attrs=\"-attributes\"]\n----\n@Bean\nfun authorities(contextSource: BaseLdapPathContextSource): LdapAuthoritiesPopulator {\n val groupSearchBase = \"\"\n val authorities = DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase)\n authorities.setGroupSearchFilter(\"member={0}\")\n return authorities\n}\n\n@Bean\nfun authenticationManager(\n contextSource: BaseLdapPathContextSource,\n authorities: LdapAuthoritiesPopulator): AuthenticationManager {\n val factory = LdapBindAuthenticationManagerFactory(contextSource)\n factory.setUserDnPatterns(\"uid={0},ou=people\")\n factory.setLdapAuthoritiesPopulator(authorities)\n return factory.createAuthenticationManager()\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "LdapAuthoritiesPopulator", "heading_level": 2, "file_order": 91, "section_index": 10, "content_hash": "4e915b9bad5b1b9848d3dfe7fae48d17549f814c27a1cf1f55962c7e079d2161", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:ead45548145c7119e67b9a444535a5c196970fccd441bc67f0498803b690585b", "content": "Active Directory supports its own non-standard authentication options, and the normal usage pattern does not fit too cleanly with the standard `LdapAuthenticationProvider`.\nTypically, authentication is performed by using the domain username (in the form of `user@domain`), rather than using an LDAP distinguished name.\nTo make this easier, Spring Security has an authentication provider, which is customized for a typical Active Directory setup.\n\nConfiguring `ActiveDirectoryLdapAuthenticationProvider` is quite straightforward.\nYou need only supply the domain name and an LDAP URL that supplies the address of the server.\n\n[NOTE]\n====\nIt is also possible to obtain the server's IP address by using a DNS lookup.\nThis is not currently supported, but hopefully will be in a future version.\n====\n\nThe following example configures Active Directory:\n\n.Example Active Directory Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nActiveDirectoryLdapAuthenticationProvider authenticationProvider() {\n\treturn new ActiveDirectoryLdapAuthenticationProvider(\"example.com\", \"ldap://company.example.com/\");\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<bean id=\"authenticationProvider\"\n class=\"org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider\">\n\t<constructor-arg value=\"example.com\" />\n\t<constructor-arg value=\"ldap://company.example.com/\" />\n</bean>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationProvider(): ActiveDirectoryLdapAuthenticationProvider {\n return ActiveDirectoryLdapAuthenticationProvider(\"example.com\", \"ldap://company.example.com/\")\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc", "title": "ldap", "heading": "Active Directory", "heading_level": 2, "file_order": 91, "section_index": 11, "content_hash": "ead45548145c7119e67b9a444535a5c196970fccd441bc67f0498803b690585b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/ldap.adoc"}}
{"id": "sha256:fa3991063afb54458722b67eb4a6dde1c441f3ae499f117e9fea025d90715f0a", "content": "[[servlet-authentication-password-storage]]\n\nSpring Security's servlet support includes storing passwords securely by integrating with xref:features/authentication/password-storage.adoc#authentication-password-storage[`PasswordEncoder`].\nYou can customize the `PasswordEncoder` implementation used by Spring Security by xref:features/authentication/password-storage.adoc#authentication-password-storage-configuration[exposing a `PasswordEncoder` Bean].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/password-encoder.adoc", "title": "password-encoder", "heading": "password-encoder", "heading_level": 1, "file_order": 92, "section_index": 0, "content_hash": "fa3991063afb54458722b67eb4a6dde1c441f3ae499f117e9fea025d90715f0a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/password-encoder.adoc"}}
{"id": "sha256:fde63db6814efedcbddc030dea94c96df6c8e4b6426a3c9fd1e864bca7844cfc", "content": "[[servlet-authentication-unpwd-storage]]\n\nEach of the supported mechanisms for reading a username and password can use any of the supported storage mechanisms:\n\n* Simple Storage with xref:servlet/authentication/passwords/in-memory.adoc#servlet-authentication-inmemory[In-Memory Authentication]\n* Relational Databases with xref:servlet/authentication/passwords/jdbc.adoc#servlet-authentication-jdbc[JDBC Authentication]\n* Custom data stores with xref:servlet/authentication/passwords/user-details-service.adoc#servlet-authentication-userdetailsservice[UserDetailsService]\n* LDAP storage with xref:servlet/authentication/passwords/ldap.adoc#servlet-authentication-ldap[LDAP Authentication]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/storage.adoc", "title": "storage", "heading": "storage", "heading_level": 1, "file_order": 93, "section_index": 0, "content_hash": "fde63db6814efedcbddc030dea94c96df6c8e4b6426a3c9fd1e864bca7844cfc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/storage.adoc"}}
{"id": "sha256:3d9ac2caf9521d791c92c5403b13bdd96ce558b6f4ae2cffa4e74ce4c4127648", "content": "[[servlet-authentication-userdetailsservice]]\n\njavadoc:org.springframework.security.core.userdetails.UserDetailsService[] is used by xref:servlet/authentication/passwords/dao-authentication-provider.adoc#servlet-authentication-daoauthenticationprovider[`DaoAuthenticationProvider`] for retrieving a username, a password, and other attributes for authenticating with a username and password.\nSpring Security provides xref:servlet/authentication/passwords/in-memory.adoc#servlet-authentication-inmemory[in-memory], xref:servlet/authentication/passwords/jdbc.adoc#servlet-authentication-jdbc[JDBC], and xref:servlet/authentication/passwords/caching.adoc#servlet-authentication-caching-user-details[caching] implementations of `UserDetailsService`.\n\nYou can define custom authentication by exposing a custom `UserDetailsService` as a bean.\nFor example, the following listing customizes authentication, assuming that `CustomUserDetailsService` implements `UserDetailsService`:\n\n[NOTE]\n====\nThis is only used if the `AuthenticationManagerBuilder` has not been populated and no `AuthenticationProviderBean` is defined.\n====\n\n.Custom UserDetailsService Bean\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nCustomUserDetailsService customUserDetailsService() {\n\treturn new CustomUserDetailsService();\n}\n----\n\nXML::\n+\n[source,java,role=\"secondary\"]\n----\n<b:bean class=\"example.CustomUserDetailsService\"/>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun customUserDetailsService() = CustomUserDetailsService()\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/user-details-service.adoc", "title": "user-details-service", "heading": "user-details-service", "heading_level": 1, "file_order": 94, "section_index": 0, "content_hash": "3d9ac2caf9521d791c92c5403b13bdd96ce558b6f4ae2cffa4e74ce4c4127648", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/user-details-service.adoc"}}
{"id": "sha256:c985ecc287a51641d7380f8e490db8aaeb8857338152b030fa09128a1078f905", "content": "[[servlet-authentication-userdetails]]\n\njavadoc:org.springframework.security.core.userdetails.UserDetails[] is returned by the xref:servlet/authentication/passwords/user-details-service.adoc#servlet-authentication-userdetailsservice[`UserDetailsService`].\nThe xref:servlet/authentication/passwords/dao-authentication-provider.adoc#servlet-authentication-daoauthenticationprovider[`DaoAuthenticationProvider`] validates the `UserDetails` and then returns an xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`] that has a principal that is the `UserDetails` returned by the configured `UserDetailsService`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/user-details.adoc", "title": "user-details", "heading": "user-details", "heading_level": 1, "file_order": 95, "section_index": 0, "content_hash": "c985ecc287a51641d7380f8e490db8aaeb8857338152b030fa09128a1078f905", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/user-details.adoc"}}
{"id": "sha256:a1267c9164477e1d5f9bb945b625e6009861293bfca3cda7a0d7123c23f483af", "content": "Implementing the `CredentialsContainer` interface in classes that store user credentials, such as those extending or implementing `UserDetails`, is strongly recommended, especially in applications where user details are not cached.\nThis practice enhances security by ensuring that sensitive data, such as passwords, are not retained in memory longer than necessary.\n\n[TIP]\n====\nIn cases where user details are cached, consider creating a copy of the `UserDetails` that does not include credentials and returning the copy in the response from a custom `AuthenticationProvider` instead of the original object.\nThis can help prevent the cached instance containing credentials from being referenced by the rest of the application once the authentication process is complete.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/user-details.adoc", "title": "user-details", "heading": "Credentials Management", "heading_level": 2, "file_order": 95, "section_index": 1, "content_hash": "a1267c9164477e1d5f9bb945b625e6009861293bfca3cda7a0d7123c23f483af", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/user-details.adoc"}}
{"id": "sha256:6b5906a520a60e294b604b90e4a294b7d30d4bfb1fa7ef5f2c513e22d98ba871", "content": "Applications that do not employ caching mechanisms for `UserDetails` should particularly consider implementing `CredentialsContainer`.\nThis approach helps in mitigating the risk associated with retaining sensitive information in memory, which can be vulnerable to attack vectors such as memory dumps.\n\n[source,java]\n----\npublic class MyUserDetails implements UserDetails, CredentialsContainer {\n\n private String username;\n\n private String password;\n\n // UserDetails implementation...\n\n @Override\n public void eraseCredentials() {\n this.password = null; // Securely dereference the password field\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/user-details.adoc", "title": "user-details", "heading": "When to Implement `CredentialsContainer`", "heading_level": 3, "file_order": 95, "section_index": 2, "content_hash": "6b5906a520a60e294b604b90e4a294b7d30d4bfb1fa7ef5f2c513e22d98ba871", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/user-details.adoc"}}
{"id": "sha256:9d79185e98b3c9b595ac2e75dbdc692e6c4cee23bbd3918cf25dc9b902823f05", "content": "* *Immediate Erasure*: Credentials should be erased immediately after they are no longer needed, typically post-authentication.\n* *Automatic Invocation*: Ensure that `eraseCredentials()` is automatically called by your authentication framework, such as `AuthenticationManager`, once the authentication process is complete.\n* *Consistency*: Apply this practice uniformly across all applications to prevent security lapses that could lead to data breaches.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/user-details.adoc", "title": "user-details", "heading": "Implementation Guidelines", "heading_level": 3, "file_order": 95, "section_index": 3, "content_hash": "9d79185e98b3c9b595ac2e75dbdc692e6c4cee23bbd3918cf25dc9b902823f05", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/user-details.adoc"}}
{"id": "sha256:536e24e5fe4dc722a8ecade744b6b70b1346ceb0d4b3d30caf1eecc1bd472873", "content": "While interfaces like `CredentialsContainer` provide a framework for credential management, the practical implementation often depends on specific classes and their interactions.\n\nFor example, the `DaoAuthenticationProvider` class, adhering to the contract of `AuthenticationProvider`, does not perform credential erasure within its own `authenticate` method.\nInstead, it relies on `ProviderManager`Spring Security's default implementation of `AuthenticationManager`to handle the erasure of credentials and other sensitive data post-authentication.\nThis separation emphasizes the principle that the `AuthenticationProvider` should not assume the responsibility for credentials management.\n\nIncorporating `CredentialsContainer` into your `UserDetails` implementation aligns with security best practices, reducing potential exposure to data breaches by minimizing the lifespan of sensitive data in memory.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passwords/user-details.adoc", "title": "user-details", "heading": "Beyond Basic Interface Implementation", "heading_level": 3, "file_order": 95, "section_index": 4, "content_hash": "536e24e5fe4dc722a8ecade744b6b70b1346ceb0d4b3d30caf1eecc1bd472873", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passwords/user-details.adoc"}}
{"id": "sha256:f8b138a082e30551d8679f82d223ab594905cd70120abebd4b4f84ccee514e10", "content": "[[anonymous]]\n\n[[anonymous-overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/anonymous.adoc", "title": "anonymous", "heading": "anonymous", "heading_level": 1, "file_order": 96, "section_index": 0, "content_hash": "f8b138a082e30551d8679f82d223ab594905cd70120abebd4b4f84ccee514e10", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/anonymous.adoc"}}
{"id": "sha256:9f61770d69b9aa8ee614748d70020e2de0da31683081b320ba4393ad6f9d0bce", "content": "It is generally considered good security practice to adopt a \"`deny-by-default`\" stance, where you explicitly specify what is allowed and disallow everything else.\nDefining what is accessible to unauthenticated users is a similar situation, particularly for web applications.\nMany sites require that users must be authenticated for anything other than a few URLs (for example the home and login pages).\nIn that case, it is easiest to define access configuration attributes for these specific URLs rather than for every secured resource.\nPut differently, sometimes it is nice to say `ROLE_SOMETHING` is required by default and allow only certain exceptions to this rule, such as for login, logout, and home pages of an application.\nYou could also omit these pages from the filter chain entirely, thus bypassing the access control checks, but this may be undesirable for other reasons, particularly if the pages behave differently for authenticated users.\n\nThis is what we mean by anonymous authentication.\nNote that there is no real conceptual difference between a user who is \"`anonymously authenticated`\" and an unauthenticated user.\nSpring Security's anonymous authentication just gives you a more convenient way to configure your access-control attributes.\nCalls to servlet API calls, such as `getCallerPrincipal`, still return null, even though there is actually an anonymous authentication object in the `SecurityContextHolder`.\n\nThere are other situations where anonymous authentication is useful, such as when an auditing interceptor queries the `SecurityContextHolder` to identify which principal was responsible for a given operation.\nClasses can be authored more robustly if they know the `SecurityContextHolder` always contains an `Authentication` object and never contains `null`.\n\n[[anonymous-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/anonymous.adoc", "title": "anonymous", "heading": "Overview", "heading_level": 2, "file_order": 96, "section_index": 1, "content_hash": "9f61770d69b9aa8ee614748d70020e2de0da31683081b320ba4393ad6f9d0bce", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/anonymous.adoc"}}
{"id": "sha256:7bddde725e1a3281038f2f39b9136e45910ae3e1ec2c84f33b692531f4620b8e", "content": "Anonymous authentication support is provided automatically when you use the HTTP configuration (introduced in Spring Security 3.0).\nYou can customize (or disable) it by using the `<anonymous>` element.\nYou need not configure the beans described here unless you are using traditional bean configuration.\n\nThree classes work together to provide the anonymous authentication feature.\n`AnonymousAuthenticationToken` is an implementation of `Authentication` and stores the `GrantedAuthority` instances that apply to the anonymous principal.\nThere is a corresponding `AnonymousAuthenticationProvider`, which is chained into the `ProviderManager` so that `AnonymousAuthenticationToken` instances are accepted.\nFinally, an `AnonymousAuthenticationFilter` is chained after the normal authentication mechanisms and automatically adds an `AnonymousAuthenticationToken` to the `SecurityContextHolder` if there is no existing `Authentication` held there.\nThe filter and authentication provider is defined as follows:\n\n[source,xml]\n----\n<bean id=\"anonymousAuthFilter\"\n\tclass=\"org.springframework.security.web.authentication.AnonymousAuthenticationFilter\">\n<property name=\"key\" value=\"foobar\"/>\n<property name=\"userAttribute\" value=\"anonymousUser,ROLE_ANONYMOUS\"/>\n</bean>\n\n<bean id=\"anonymousAuthenticationProvider\"\n\tclass=\"org.springframework.security.authentication.AnonymousAuthenticationProvider\">\n<property name=\"key\" value=\"foobar\"/>\n</bean>\n----\n\nThe `key` is shared between the filter and authentication provider, so that tokens created by the former are accepted by the latter\n\n[NOTE]\n====\nThe use of the `key` property should not be regarded as providing any real security here.\nIt is merely a book-keeping exercise.\nIf you share a `ProviderManager` that contains an `AnonymousAuthenticationProvider` in a scenario where it is possible for an authenticating client to construct the `Authentication` object (such as with RMI invocations), then a malicious client could submit an `AnonymousAuthenticationToken` that it had created itself (with the chosen username and authority list).\nIf the `key` is guessable or can be found out, the token would be accepted by the anonymous provider.\nThis is not a problem with normal usage. However, if you use RMI, you should use a customized `ProviderManager` that omits the anonymous provider rather than sharing the one you use for your HTTP authentication mechanisms.\n====\n\nThe `userAttribute` is expressed in the form of `usernameInTheAuthenticationToken,grantedAuthority[,grantedAuthority]`.\nThe same syntax is used after the equals sign for the `userMap` property of `InMemoryDaoImpl`.\n\nAs explained earlier, the benefit of anonymous authentication is that all URI patterns can have security applied to them, as the following example shows:\n\n[source,xml]\n----\n<bean id=\"filterSecurityInterceptor\"\n\tclass=\"org.springframework.security.web.access.intercept.FilterSecurityInterceptor\">\n<property name=\"authenticationManager\" ref=\"authenticationManager\"/>\n<property name=\"accessDecisionManager\" ref=\"httpRequestAccessDecisionManager\"/>\n<property name=\"securityMetadata\">\n\t<security:filter-security-metadata-source>\n\t<security:intercept-url pattern='/index.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/>\n\t<security:intercept-url pattern='/hello.htm' access='ROLE_ANONYMOUS,ROLE_USER'/>\n\t<security:intercept-url pattern='/logoff.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/>\n\t<security:intercept-url pattern='/login.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/>\n\t<security:intercept-url pattern='/**' access='ROLE_USER'/>\n\t</security:filter-security-metadata-source>\" +\n</property>\n</bean>\n----\n\n[[anonymous-auth-trust-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/anonymous.adoc", "title": "anonymous", "heading": "Configuration", "heading_level": 2, "file_order": 96, "section_index": 2, "content_hash": "7bddde725e1a3281038f2f39b9136e45910ae3e1ec2c84f33b692531f4620b8e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/anonymous.adoc"}}
{"id": "sha256:df863ed3dadb968ca28d4b3e0f5b0bd492d0ac6d03c327bfdd62d4f5b133ab44", "content": "Rounding out the anonymous authentication discussion is the `AuthenticationTrustResolver` interface, with its corresponding `AuthenticationTrustResolverImpl` implementation.\nThis interface provides an `isAnonymous(Authentication)` method, which allows interested classes to take into account this special type of authentication status.\nThe `ExceptionTranslationFilter` uses this interface in processing `AccessDeniedException` instances.\nIf an `AccessDeniedException` is thrown and the authentication is of an anonymous type, instead of throwing a 403 (forbidden) response, the filter, instead, commences the `AuthenticationEntryPoint` so that the principal can authenticate properly.\nThis is a necessary distinction. Otherwise, principals would always be deemed \"`authenticated`\" and never be given an opportunity to login through form, basic, digest, or some other normal authentication mechanism.\n\nWe often see the `ROLE_ANONYMOUS` attribute in the earlier interceptor configuration replaced with `IS_AUTHENTICATED_ANONYMOUSLY`, which is effectively the same thing when defining access controls.\nThis is an example of the use of the `AuthenticatedVoter`, which we cover in the xref:servlet/authorization/architecture.adoc#authz-authenticated-voter[authorization chapter].\nIt uses an `AuthenticationTrustResolver` to process this particular configuration attribute and grant access to anonymous users.\nThe `AuthenticatedVoter` approach is more powerful, since it lets you differentiate between anonymous, remember-me, and fully authenticated users.\nIf you do not need this functionality, though, you can stick with `ROLE_ANONYMOUS`, which is processed by Spring Security's standard `RoleVoter`.\n\n[[anonymous-auth-mvc-controller]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/anonymous.adoc", "title": "anonymous", "heading": "AuthenticationTrustResolver", "heading_level": 2, "file_order": 96, "section_index": 3, "content_hash": "df863ed3dadb968ca28d4b3e0f5b0bd492d0ac6d03c327bfdd62d4f5b133ab44", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/anonymous.adoc"}}
{"id": "sha256:7ee1ae2d9c5c73d0566cb2fa351c7cbb7fefb2dca29d57c45f4051e9b680b009", "content": "https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments[Spring MVC resolves parameters of type `Principal`] using its own argument resolver.\n\nThis means that a construct like this one:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/\")\npublic String method(Authentication authentication) {\n\tif (authentication instanceof AnonymousAuthenticationToken) {\n return \"anonymous\";\n\t} else {\n return \"not anonymous\";\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/\")\nfun method(authentication: Authentication?): String {\n return if (authentication is AnonymousAuthenticationToken) {\n \"anonymous\"\n } else {\n \"not anonymous\"\n }\n}\n----\n======\n\nwill always return \"not anonymous\", even for anonymous requests.\nThe reason is that Spring MVC resolves the parameter using `HttpServletRequest#getPrincipal`, which is `null` when the request is anonymous.\n\nIf you'd like to obtain the `Authentication` in anonymous requests, use\nxref:servlet/integrations/mvc.adoc#mvc-current-security-context[`@CurrentSecurityContext`] instead:\n\n.Use CurrentSecurityContext for Anonymous requests\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/\")\npublic String method(@CurrentSecurityContext SecurityContext context) {\n\tif (context.getAuthentication() instanceOf AnonymousAuthenticationToken) {\n return \"anonymous\"\n\t} else {\n return \"not anonymous\"\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/\")\nfun method(@CurrentSecurityContext context : SecurityContext) : String {\n return if (context!!.authentication is AnonymousAuthenticationToken) {\n\t\"anonymous\"\n } else {\n\t\"not anonymous\"\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/anonymous.adoc", "title": "anonymous", "heading": "Getting Anonymous Authentications with Spring MVC", "heading_level": 2, "file_order": 96, "section_index": 4, "content_hash": "7ee1ae2d9c5c73d0566cb2fa351c7cbb7fefb2dca29d57c45f4051e9b680b009", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/anonymous.adoc"}}
{"id": "sha256:73ac07df0c53f297483b981771261ab8cf035cc8d00b33fe2e6ab6235504cadf", "content": "[[servlet-authentication-architecture]]\n\nThis discussion expands on xref:servlet/architecture.adoc#servlet-architecture[Servlet Security: The Big Picture] to describe the main architectural components that Spring Security uses in Servlet authentication.\nIf you need concrete flows that explain how these pieces fit together, look at the xref:servlet/authentication/index.adoc#servlet-authentication-mechanisms[Authentication Mechanism] specific sections.\n\n* <<servlet-authentication-securitycontextholder>> - The `SecurityContextHolder` is where Spring Security stores the details of who is xref:features/authentication/index.adoc#authentication[authenticated].\n* <<servlet-authentication-securitycontext>> - is obtained from the `SecurityContextHolder` and contains the `Authentication` of the currently authenticated user.\n* <<servlet-authentication-authentication>> - Can be the input to `AuthenticationManager` to provide the credentials a user has provided to authenticate or the current user from the `SecurityContext`.\n* <<servlet-authentication-granted-authority>> - An authority that is granted to the principal on the `Authentication` (i.e. roles, scopes, etc.)\n* <<servlet-authentication-authenticationmanager>> - the API that defines how Spring Security's Filters perform xref:features/authentication/index.adoc#authentication[authentication].\n* <<servlet-authentication-providermanager>> - the most common implementation of `AuthenticationManager`.\n* <<servlet-authentication-authenticationprovider>> - used by `ProviderManager` to perform a specific type of authentication.\n* <<servlet-authentication-authenticationentrypoint>> - used for requesting credentials from a client (i.e. redirecting to a log in page, sending a `WWW-Authenticate` response, etc.)\n* <<servlet-authentication-abstractprocessingfilter>> - a base `Filter` used for authentication.\nThis also gives a good idea of the high level flow of authentication and how pieces work together.\n\n[[servlet-authentication-securitycontextholder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/architecture.adoc", "title": "architecture", "heading": "architecture", "heading_level": 1, "file_order": 97, "section_index": 0, "content_hash": "73ac07df0c53f297483b981771261ab8cf035cc8d00b33fe2e6ab6235504cadf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/architecture.adoc"}}
{"id": "sha256:7106c622f355b09e2b40ff37ca95d6ecef42b2b399500aa005b4d4e8fde85b8e", "content": "At the heart of Spring Security's authentication model is the `SecurityContextHolder`.\nIt contains the <<servlet-authentication-securitycontext>>.\n\n[.invert-dark]\nimage::{figures}/securitycontextholder.png[]\n\nThe `SecurityContextHolder` is where Spring Security stores the details of who is xref:features/authentication/index.adoc#authentication[authenticated].\nSpring Security does not care how the `SecurityContextHolder` is populated.\nIf it contains a value, it is used as the currently authenticated user.\n\nThe simplest way to indicate a user is authenticated is to set the `SecurityContextHolder` directly:\n\n.Setting `SecurityContextHolder`\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nSecurityContext context = SecurityContextHolder.createEmptyContext(); // <1>\nAuthentication authentication =\n new TestingAuthenticationToken(\"username\", \"password\", \"ROLE_USER\"); // <2>\ncontext.setAuthentication(authentication);\n\nSecurityContextHolder.setContext(context); // <3>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval context: SecurityContext = SecurityContextHolder.createEmptyContext() // <1>\nval authentication: Authentication = TestingAuthenticationToken(\"username\", \"password\", \"ROLE_USER\") // <2>\ncontext.authentication = authentication\n\nSecurityContextHolder.setContext(context) // <3>\n----\n======\n\n<1> We start by creating an empty `SecurityContext`.\nYou should create a new `SecurityContext` instance instead of using `SecurityContextHolder.getContext().setAuthentication(authentication)` to avoid race conditions across multiple threads.\n<2> Next, we create a new <<servlet-authentication-authentication,`Authentication`>> object.\nSpring Security does not care what type of `Authentication` implementation is set on the `SecurityContext`.\nHere, we use `TestingAuthenticationToken`, because it is very simple.\nA more common production scenario is `UsernamePasswordAuthenticationToken(userDetails, password, authorities)`.\n<3> Finally, we set the `SecurityContext` on the `SecurityContextHolder`.\nSpring Security uses this information for xref:servlet/authorization/index.adoc#servlet-authorization[authorization].\n\nTo obtain information about the authenticated principal, access the `SecurityContextHolder`.\n\n.Access Currently Authenticated User\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nSecurityContext context = SecurityContextHolder.getContext();\nAuthentication authentication = context.getAuthentication();\nString username = authentication.getName();\nObject principal = authentication.getPrincipal();\nCollection<? extends GrantedAuthority> authorities = authentication.getAuthorities();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval context = SecurityContextHolder.getContext()\nval authentication = context.authentication\nval username = authentication.name\nval principal = authentication.principal\nval authorities = authentication.authorities\n----\n======\n\nIn Spring MVC, you can resolve the current principal with\nxref:servlet/integrations/mvc.adoc#mvc-authentication-principal[`@AuthenticationPrincipal`]\nand the full `SecurityContext` with\nxref:servlet/integrations/mvc.adoc#mvc-current-security-context[`@CurrentSecurityContext`].\nFor Servlet API access, use `HttpServletRequest#getRemoteUser`.\n\nBy default, `SecurityContextHolder` uses a `ThreadLocal` to store these details, which means that the `SecurityContext` is always available to methods in the same thread, even if the `SecurityContext` is not explicitly passed around as an argument to those methods.\nUsing a `ThreadLocal` in this way is quite safe if you take care to clear the thread after the present principal's request is processed.\nSpring Security's xref:servlet/architecture.adoc#servlet-filterchainproxy[FilterChainProxy] ensures that the `SecurityContext` is always cleared.\n\nSome applications are not entirely suitable for using a `ThreadLocal`, because of the specific way they work with threads.\nFor example, a Swing client might want all threads in a Java Virtual Machine to use the same security context.\nYou can configure `SecurityContextHolder` with a strategy on startup to specify how you would like the context to be stored.\nFor a standalone application, you would use the `SecurityContextHolder.MODE_GLOBAL` strategy.\nOther applications might want to have threads spawned by the secure thread also assume the same security identity.\nYou can achieve this by using `SecurityContextHolder.MODE_INHERITABLETHREADLOCAL`.\nYou can change the mode from the default `SecurityContextHolder.MODE_THREADLOCAL` in two ways.\nThe first is to set a system property.\nThe second is to call a static method on `SecurityContextHolder`.\nMost applications need not change from the default.\nHowever, if you do, take a look at the JavaDoc for `SecurityContextHolder` to learn more.\n\n[[servlet-authentication-securitycontext]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/architecture.adoc", "title": "architecture", "heading": "SecurityContextHolder", "heading_level": 2, "file_order": 97, "section_index": 1, "content_hash": "7106c622f355b09e2b40ff37ca95d6ecef42b2b399500aa005b4d4e8fde85b8e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/architecture.adoc"}}
{"id": "sha256:2338bc211aa80c5a0be49c0cc5d2ae9ea4b5575b36e01958d0b8da54b99a234f", "content": "The javadoc:org.springframework.security.core.context.SecurityContext[] is obtained from the <<servlet-authentication-securitycontextholder>>.\nThe `SecurityContext` contains an <<servlet-authentication-authentication>> object.\n\n[[servlet-authentication-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/architecture.adoc", "title": "architecture", "heading": "SecurityContext", "heading_level": 2, "file_order": 97, "section_index": 2, "content_hash": "2338bc211aa80c5a0be49c0cc5d2ae9ea4b5575b36e01958d0b8da54b99a234f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/architecture.adoc"}}
{"id": "sha256:eafcfcc0a08ac6cb65714d794b6cb38cc32bb6aa3ab6047b4021d940f49f16ff", "content": "The javadoc:org.springframework.security.core.Authentication[] interface serves two main purposes within Spring Security:\n\n* An input to <<servlet-authentication-authenticationmanager,`AuthenticationManager`>> to provide the credentials a user has provided to authenticate.\nWhen used in this scenario, `isAuthenticated()` returns `false`.\n* Represent the currently authenticated user.\nYou can obtain the current `Authentication` from the <<servlet-authentication-securitycontext>>.\n\nThe `Authentication` contains:\n\n* `principal`: Identifies the user.\nWhen authenticating with a username/password this is often an instance of xref:servlet/authentication/passwords/user-details.adoc#servlet-authentication-userdetails[`UserDetails`].\n* `credentials`: Often a password.\nIn many cases, this is cleared after the user is authenticated, to ensure that it is not leaked.\n* `authorities`: The <<servlet-authentication-granted-authority,`GrantedAuthority`>> instances are high-level permissions the user is granted.\nTwo examples are roles and scopes.\n\nIt is also equipped with a `AdditionalRequiredFactorsBuilder` that allows you to mutate an existing `Authentication` instance and potentially merge it with another.\nThis is useful in scenarios like taking the authorities from one authentication step, like form login, and applying them to another, like one-time-token login, like so:\n\ninclude-code::./CopyAuthoritiesTests[tag=springSecurity,indent=0]\n\n[[servlet-authentication-granted-authority]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/architecture.adoc", "title": "architecture", "heading": "Authentication", "heading_level": 2, "file_order": 97, "section_index": 3, "content_hash": "eafcfcc0a08ac6cb65714d794b6cb38cc32bb6aa3ab6047b4021d940f49f16ff", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/architecture.adoc"}}
{"id": "sha256:f6a3bc01bc41bcdb513dee963109fd3ad92da8e1f840320002bf8af326f796f1", "content": "javadoc:org.springframework.security.core.GrantedAuthority[] instances are high-level permissions that the user is granted.\nTwo examples are roles and scopes.\n\nYou can obtain `GrantedAuthority` instances from the <<servlet-authentication-authentication,`Authentication.getAuthorities()`>> method.\nThis method provides a `Collection` of `GrantedAuthority` objects.\nA `GrantedAuthority` is, not surprisingly, an authority that is granted to the principal.\nSuch authorities are usually \"`roles`\", such as `ROLE_ADMINISTRATOR` or `ROLE_HR_SUPERVISOR`.\nThese roles are later configured for web authorization, method authorization, and domain object authorization.\nOther parts of Spring Security interpret these authorities and expect them to be present.\nWhen using username/password based authentication `GrantedAuthority` instances are usually loaded by the xref:servlet/authentication/passwords/user-details-service.adoc#servlet-authentication-userdetailsservice[`UserDetailsService`].\n\nUsually, the `GrantedAuthority` objects are application-wide permissions.\nThey are not specific to a given domain object.\nThus, you would not likely have a `GrantedAuthority` to represent a permission to `Employee` object number 54, because if there are thousands of such authorities you would quickly run out of memory (or, at the very least, cause the application to take a long time to authenticate a user).\nOf course, Spring Security is expressly designed to handle this common requirement, but you should instead use the project's domain object security capabilities for this purpose.\n\n[[servlet-authentication-authenticationmanager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/architecture.adoc", "title": "architecture", "heading": "GrantedAuthority", "heading_level": 2, "file_order": 97, "section_index": 4, "content_hash": "f6a3bc01bc41bcdb513dee963109fd3ad92da8e1f840320002bf8af326f796f1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/architecture.adoc"}}
{"id": "sha256:9fb37a9de0e021419f30db0da3f7015e8acaeb6ec301f444f12673875b75ffe0", "content": "javadoc:org.springframework.security.authentication.AuthenticationManager[] is the API that defines how Spring Security's Filters perform xref:features/authentication/index.adoc#authentication[authentication].\nThe <<servlet-authentication-authentication,`Authentication`>> that is returned is then set on the <<servlet-authentication-securitycontextholder>> by the controller (that is, by xref:servlet/architecture.adoc#servlet-security-filters[Spring Security's `Filters` instances]) that invoked the `AuthenticationManager`.\nIf you are not integrating with Spring Security's `Filters` instances, you can set the `SecurityContextHolder` directly and are not required to use an `AuthenticationManager`.\n\nWhile the implementation of `AuthenticationManager` could be anything, the most common implementation is <<servlet-authentication-providermanager,`ProviderManager`>>.\n\n[[servlet-authentication-providermanager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/architecture.adoc", "title": "architecture", "heading": "AuthenticationManager", "heading_level": 2, "file_order": 97, "section_index": 5, "content_hash": "9fb37a9de0e021419f30db0da3f7015e8acaeb6ec301f444f12673875b75ffe0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/architecture.adoc"}}
{"id": "sha256:290d47394b461f5a09e80168aacc3cc1ff96190328fbe4aef3ec18eca027f091", "content": "javadoc:org.springframework.security.authentication.ProviderManager[] is the most commonly used implementation of <<servlet-authentication-authenticationmanager,`AuthenticationManager`>>.\n`ProviderManager` delegates to a `List` of <<servlet-authentication-authenticationprovider,`AuthenticationProvider`>> instances.\nEach `AuthenticationProvider` has an opportunity to indicate that authentication should be successful, fail, or indicate it cannot make a decision and allow a downstream `AuthenticationProvider` to decide.\nIf none of the configured `AuthenticationProvider` instances can authenticate, authentication fails with a `ProviderNotFoundException`, which is a special `AuthenticationException` that indicates that the `ProviderManager` was not configured to support the type of `Authentication` that was passed into it.\n\n[.invert-dark]\nimage::{figures}/providermanager.png[]\n\nIn practice each `AuthenticationProvider` knows how to perform a specific type of authentication.\nFor example, one `AuthenticationProvider` might be able to validate a username/password, while another might be able to authenticate a SAML assertion.\nThis lets each `AuthenticationProvider` do a very specific type of authentication while supporting multiple types of authentication and expose only a single `AuthenticationManager` bean.\n\n`ProviderManager` also allows configuring an optional parent `AuthenticationManager`, which is consulted in the event that no `AuthenticationProvider` can perform authentication.\nThe parent can be any type of `AuthenticationManager`, but it is often an instance of `ProviderManager`.\n\n[.invert-dark]\nimage::{figures}/providermanager-parent.png[]\n\nIn fact, multiple `ProviderManager` instances might share the same parent `AuthenticationManager`.\nThis is somewhat common in scenarios where there are multiple xref:servlet/architecture.adoc#servlet-securityfilterchain[`SecurityFilterChain`] instances that have some authentication in common (the shared parent `AuthenticationManager`), but also different authentication mechanisms (the different `ProviderManager` instances).\n\n[.invert-dark]\nimage::{figures}/providermanagers-parent.png[]\n\n[[servlet-authentication-providermanager-erasing-credentials]]\nBy default, `ProviderManager` tries to clear any sensitive credentials information from the `Authentication` object that is returned by a successful authentication request.\nThis prevents information, such as passwords, being retained longer than necessary in the `HttpSession`.\n\n[NOTE]\n====\nThe `CredentialsContainer` interface plays a critical role in the authentication process.\nIt allows for the erasure of credential information once it is no longer needed, thereby enhancing security by ensuring sensitive data is not retained longer than necessary.\n====\n\nThis may cause issues when you use a cache of user objects, for example, to improve performance in a stateless application.\nIf the `Authentication` contains a reference to an object in the cache (such as a `UserDetails` instance) and this has its credentials removed, it is no longer possible to authenticate against the cached value.\nYou need to take this into account if you use a cache.\nAn obvious solution is to first make a copy of the object, either in the cache implementation or in the `AuthenticationProvider` that creates the returned `Authentication` object.\nAlternatively, you can disable the `eraseCredentialsAfterAuthentication` property on `ProviderManager`.\nSee the Javadoc for the javadoc:org.springframework.security.authentication.ProviderManager[] class.\n\n[[servlet-authentication-authenticationprovider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/architecture.adoc", "title": "architecture", "heading": "ProviderManager", "heading_level": 2, "file_order": 97, "section_index": 6, "content_hash": "290d47394b461f5a09e80168aacc3cc1ff96190328fbe4aef3ec18eca027f091", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/architecture.adoc"}}
{"id": "sha256:5151353efc11af95281157b4aec64debafb152bf180272557f87418fea0ac884", "content": "You can inject multiple javadoc:org.springframework.security.authentication.AuthenticationProvider[] instances into <<servlet-authentication-providermanager,`ProviderManager`>>.\nEach `AuthenticationProvider` performs a specific type of authentication.\nFor example, xref:servlet/authentication/passwords/dao-authentication-provider.adoc#servlet-authentication-daoauthenticationprovider[`DaoAuthenticationProvider`] supports username/password-based authentication, while `JwtAuthenticationProvider` supports authenticating a JWT token.\n\n[[servlet-authentication-authenticationentrypoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/architecture.adoc", "title": "architecture", "heading": "AuthenticationProvider", "heading_level": 2, "file_order": 97, "section_index": 7, "content_hash": "5151353efc11af95281157b4aec64debafb152bf180272557f87418fea0ac884", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/architecture.adoc"}}
{"id": "sha256:188b45d302a4db8e141a2c59c60a16ed807c164be0026206a6a01a5c2f941736", "content": "javadoc:org.springframework.security.web.AuthenticationEntryPoint[] is used to send an HTTP response that requests credentials from a client.\n\nSometimes, a client proactively includes credentials (such as a username and password) to request a resource.\nIn these cases, Spring Security does not need to provide an HTTP response that requests credentials from the client, since they are already included.\n\nIn other cases, a client makes an unauthenticated request to a resource that they are not authorized to access.\nIn this case, an implementation of `AuthenticationEntryPoint` is used to request credentials from the client.\nThe `AuthenticationEntryPoint` implementation might perform a xref:servlet/authentication/passwords/form.adoc#servlet-authentication-form[redirect to a log in page], respond with an xref:servlet/authentication/passwords/basic.adoc#servlet-authentication-basic[WWW-Authenticate] header, or take other action.\n\n[[servlet-authentication-abstractprocessingfilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/architecture.adoc", "title": "architecture", "heading": "Request Credentials with `AuthenticationEntryPoint`", "heading_level": 2, "file_order": 97, "section_index": 8, "content_hash": "188b45d302a4db8e141a2c59c60a16ed807c164be0026206a6a01a5c2f941736", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/architecture.adoc"}}
{"id": "sha256:81742fba9757bfe1aff28ac2265c372436f6251b9bf9bd3ef9f5fdbc8e2c1b2c", "content": "javadoc:org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter[] is used as a base `Filter` for authenticating a user's credentials.\nBefore the credentials can be authenticated, Spring Security typically requests the credentials by using <<servlet-authentication-authenticationentrypoint,`AuthenticationEntryPoint`>>.\n\nNext, the `AbstractAuthenticationProcessingFilter` can authenticate any authentication requests that are submitted to it.\n\n[.invert-dark]\nimage::{figures}/abstractauthenticationprocessingfilter.png[]\n\nimage:{icondir}/number_1.png[] When the user submits their credentials, the `AbstractAuthenticationProcessingFilter` creates an <<servlet-authentication-authentication,`Authentication`>> from the `HttpServletRequest` to be authenticated.\nThe type of `Authentication` created depends on the subclass of `AbstractAuthenticationProcessingFilter`.\nFor example, xref:servlet/authentication/passwords/form.adoc#servlet-authentication-usernamepasswordauthenticationfilter[`UsernamePasswordAuthenticationFilter`] creates a `UsernamePasswordAuthenticationToken` from a __username__ and __password__ that are submitted in the `HttpServletRequest`.\n\nimage:{icondir}/number_2.png[] Next, the <<servlet-authentication-authentication,`Authentication`>> is passed into the <<servlet-authentication-authenticationmanager,`AuthenticationManager`>> to be authenticated.\n\nimage:{icondir}/number_3.png[] If authentication fails, then __Failure__.\n\n* The <<servlet-authentication-securitycontextholder>> is cleared out.\n* `RememberMeServices.loginFail` is invoked.\nIf remember me is not configured, this is a no-op.\nSee the javadoc:org.springframework.security.web.authentication.rememberme.package-summary[rememberme] package.\n* `AuthenticationFailureHandler` is invoked.\nSee the javadoc:org.springframework.security.web.authentication.AuthenticationFailureHandler[] interface.\n\nimage:{icondir}/number_4.png[] If authentication is successful, then __Success__.\n\n* `SessionAuthenticationStrategy` is notified of a new login.\nSee the javadoc:org.springframework.security.web.authentication.session.SessionAuthenticationStrategy[] interface.\n* Any already-authenticated `Authentication` in the <<servlet-authentication-securitycontextholder>> is loaded and its\nauthorities are added to the returned <<servlet-authentication-authentication>>.\n* The <<servlet-authentication-authentication>> is set on the <<servlet-authentication-securitycontextholder>>.\nLater, if you need to save the `SecurityContext` so that it can be automatically set on future requests, `SecurityContextRepository#saveContext` must be explicitly invoked.\nSee the javadoc:org.springframework.security.web.context.SecurityContextHolderFilter[] class.\n\n* `RememberMeServices.loginSuccess` is invoked.\nIf remember me is not configured, this is a no-op.\nSee the javadoc:org.springframework.security.web.authentication.rememberme.package-summary[rememberme] package.\n* `ApplicationEventPublisher` publishes an `InteractiveAuthenticationSuccessEvent`.\n* `AuthenticationSuccessHandler` is invoked.\nSee the javadoc:org.springframework.security.web.authentication.AuthenticationSuccessHandler[] interface.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/architecture.adoc", "title": "architecture", "heading": "AbstractAuthenticationProcessingFilter", "heading_level": 2, "file_order": 97, "section_index": 9, "content_hash": "81742fba9757bfe1aff28ac2265c372436f6251b9bf9bd3ef9f5fdbc8e2c1b2c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/architecture.adoc"}}
{"id": "sha256:757156f19a49073b057cfdde220b2344b2b07ff24cd6982c1680fcbe2a41d700", "content": "[[servlet-cas]]\n\n[[cas-overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/cas.adoc", "title": "cas", "heading": "cas", "heading_level": 1, "file_order": 98, "section_index": 0, "content_hash": "757156f19a49073b057cfdde220b2344b2b07ff24cd6982c1680fcbe2a41d700", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/cas.adoc"}}
{"id": "sha256:d4db77228b2c6ae5c5f2a308d5da0387b5981f026ce981c21d45af923a0873f2", "content": "JA-SIG produces an enterprise-wide single sign on system known as CAS.\nUnlike other initiatives, JA-SIG's Central Authentication Service is open source, widely used, simple to understand, platform independent, and supports proxy capabilities.\nSpring Security fully supports CAS, and provides an easy migration path from single-application deployments of Spring Security through to multiple-application deployments secured by an enterprise-wide CAS server.\n\nYou can learn more about CAS at https://www.apereo.org.\nYou will also need to visit this site to download the CAS Server files.\n\n[[cas-how-it-works]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/cas.adoc", "title": "cas", "heading": "Overview", "heading_level": 2, "file_order": 98, "section_index": 1, "content_hash": "d4db77228b2c6ae5c5f2a308d5da0387b5981f026ce981c21d45af923a0873f2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/cas.adoc"}}
{"id": "sha256:9f09a10aaeb9119b4700be85709c8755c17a7daae7875694e3d64e153d33633d", "content": "Whilst the CAS web site contains documents that detail the architecture of CAS, we present the general overview again here within the context of Spring Security.\nSpring Security 3.x supports CAS 3.\nAt the time of writing, the CAS server was at version 3.4.\n\nSomewhere in your enterprise you will need to setup a CAS server.\nThe CAS server is simply a standard WAR file, so there isn't anything difficult about setting up your server.\nInside the WAR file you will customise the login and other single sign on pages displayed to users.\n\nWhen deploying a CAS 3.4 server, you will also need to specify an `AuthenticationHandler` in the `deployerConfigContext.xml` included with CAS.\nThe `AuthenticationHandler` has a simple method that returns a boolean as to whether a given set of Credentials is valid.\nYour `AuthenticationHandler` implementation will need to link into some type of backend authentication repository, such as an LDAP server or database.\nCAS itself includes numerous ``AuthenticationHandler``s out of the box to assist with this.\nWhen you download and deploy the server war file, it is set up to successfully authenticate users who enter a password matching their username, which is useful for testing.\n\nApart from the CAS server itself, the other key players are of course the secure web applications deployed throughout your enterprise.\nThese web applications are known as \"services\".\nThere are three types of services.\nThose that authenticate service tickets, those that can obtain proxy tickets, and those that authenticate proxy tickets.\nAuthenticating a proxy ticket differs because the list of proxies must be validated and often times a proxy ticket can be reused.\n\n[[cas-sequence]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/cas.adoc", "title": "cas", "heading": "How CAS Works", "heading_level": 2, "file_order": 98, "section_index": 2, "content_hash": "9f09a10aaeb9119b4700be85709c8755c17a7daae7875694e3d64e153d33633d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/cas.adoc"}}
{"id": "sha256:e266cb9b2ce292bfa8398f6d78cd2be8ae8692f9f8e6f5ac68dc3574c6a7999f", "content": "The basic interaction between a web browser, CAS server and a Spring Security-secured service is as follows:\n\n* The web user is browsing the service's public pages.\nCAS or Spring Security is not involved.\n* The user eventually requests a page that is either secure or one of the beans it uses is secure.\nSpring Security's `ExceptionTranslationFilter` will detect the `AccessDeniedException` or `AuthenticationException`.\n* Because the user's `Authentication` object (or lack thereof) caused an `AuthenticationException`, the `ExceptionTranslationFilter` will call the configured `AuthenticationEntryPoint`.\nIf using CAS, this will be the `CasAuthenticationEntryPoint` class.\n* The `CasAuthenticationEntryPoint` will redirect the user's browser to the CAS server.\nIt will also indicate a `service` parameter, which is the callback URL for the Spring Security service (your application).\nFor example, the URL to which the browser is redirected might be https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas.\n* After the user's browser redirects to CAS, they will be prompted for their username and password.\nIf the user presents a session cookie which indicates they've previously logged on, they will not be prompted to login again (there is an exception to this procedure, which we'll cover later).\nCAS will use the `PasswordHandler` (or `AuthenticationHandler` if using CAS 3.0) discussed above to decide whether the username and password is valid.\n* Upon successful login, CAS will redirect the user's browser back to the original service.\nIt will also include a `ticket` parameter, which is an opaque string representing the \"service ticket\".\nContinuing our earlier example, the URL the browser is redirected to might be https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ.\n* Back in the service web application, the `CasAuthenticationFilter` is always listening for requests to `/login/cas` (this is configurable, but we'll use the defaults in this introduction).\nThe processing filter will construct a `UsernamePasswordAuthenticationToken` representing the service ticket.\nThe principal will be equal to `CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER`, whilst the credentials will be the service ticket opaque value.\nThis authentication request will then be handed to the configured `AuthenticationManager`.\n* The `AuthenticationManager` implementation will be the `ProviderManager`, which is in turn configured with the `CasAuthenticationProvider`.\nThe `CasAuthenticationProvider` only responds to ``UsernamePasswordAuthenticationToken``s containing the CAS-specific principal (such as `CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER`) and ``CasAuthenticationToken``s (discussed later).\n* `CasAuthenticationProvider` will validate the service ticket using a `TicketValidator` implementation.\nThis will typically be a `Cas20ServiceTicketValidator` which is one of the classes included in the CAS client library.\nIn the event the application needs to validate proxy tickets, the `Cas20ProxyTicketValidator` is used.\nThe `TicketValidator` makes an HTTPS request to the CAS server in order to validate the service ticket.\nIt may also include a proxy callback URL, which is included in this example: https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&ticket=ST-0-ER94xMJmn6pha35CQRoZ&pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor.\n* Back on the CAS server, the validation request will be received.\nIf the presented service ticket matches the service URL the ticket was issued to, CAS will provide an affirmative response in XML indicating the username.\nIf any proxy was involved in the authentication (discussed below), the list of proxies is also included in the XML response.\n* [OPTIONAL] If the request to the CAS validation service included the proxy callback URL (in the `pgtUrl` parameter), CAS will include a `pgtIou` string in the XML response.\nThis `pgtIou` represents a proxy-granting ticket IOU.\nThe CAS server will then create its own HTTPS connection back to the `pgtUrl`.\nThis is to mutually authenticate the CAS server and the claimed service URL.\nThe HTTPS connection will be used to send a proxy granting ticket to the original web application.\nFor example, https://server3.company.com/webapp/login/cas/proxyreceptor?pgtIou=PGTIOU-0-R0zlgrl4pdAQwBvJWO3vnNpevwqStbSGcq3vKB2SqSFFRnjPHt&pgtId=PGT-1-si9YkkHLrtACBo64rmsi3v2nf7cpCResXg5MpESZFArbaZiOKH.\n* The `Cas20TicketValidator` will parse the XML received from the CAS server.\nIt will return to the `CasAuthenticationProvider` a `TicketResponse`, which includes the username (mandatory), proxy list (if any were involved), and proxy-granting ticket IOU (if the proxy callback was requested).\n* Next `CasAuthenticationProvider` will call a configured `CasProxyDecider`.\nThe `CasProxyDecider` indicates whether the proxy list in the `TicketResponse` is acceptable to the service.\nSeveral implementations are provided with Spring Security: `RejectProxyTickets`, `AcceptAnyCasProxy` and `NamedCasProxyDecider`.\nThese names are largely self-explanatory, except `NamedCasProxyDecider` which allows a `List` of trusted proxies to be provided.\n* `CasAuthenticationProvider` will next request a `AuthenticationUserDetailsService` to load the `GrantedAuthority` objects that apply to the user contained in the `Assertion`.\n* If there were no problems, `CasAuthenticationProvider` constructs a `CasAuthenticationToken` including the details contained in the `TicketResponse` and a set of ``GrantedAuthority``s that contains at least `FACTOR_BEARER`.\n* Control then returns to `CasAuthenticationFilter`, which places the created `CasAuthenticationToken` in the security context.\n* The user's browser is redirected to the original page that caused the `AuthenticationException` (or a custom destination depending on the configuration).\n\nIt's good that you're still here!\nLet's now look at how this is configured\n\n[[cas-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/cas.adoc", "title": "cas", "heading": "Spring Security and CAS Interaction Sequence", "heading_level": 3, "file_order": 98, "section_index": 3, "content_hash": "e266cb9b2ce292bfa8398f6d78cd2be8ae8692f9f8e6f5ac68dc3574c6a7999f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/cas.adoc"}}
{"id": "sha256:089991f799aa7d3a6aeef410cb6a7b5c030a47ea1538a73471eedbd260cd8d63", "content": "The web application side of CAS is made easy due to Spring Security.\nIt is assumed you already know the basics of using Spring Security, so these are not covered again below.\nWe'll assume a namespace based configuration is being used and add in the CAS beans as required.\nEach section builds upon the previous section.\nA full CAS sample application can be found in the Spring Security xref:samples.adoc#samples[Samples].\n\n[[cas-st]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/cas.adoc", "title": "cas", "heading": "Configuration of CAS Client", "heading_level": 2, "file_order": 98, "section_index": 4, "content_hash": "089991f799aa7d3a6aeef410cb6a7b5c030a47ea1538a73471eedbd260cd8d63", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/cas.adoc"}}
{"id": "sha256:f2e616a457a424a9a5203d014dd0e14c55d4161988f9e2d48fc0ad755acb3a65", "content": "This section describes how to setup Spring Security to authenticate Service Tickets.\nOften times this is all a web application requires.\nYou will need to add a `ServiceProperties` bean to your application context.\nThis represents your CAS service:\n\n[source,xml]\n----\n<bean id=\"serviceProperties\"\n\tclass=\"org.springframework.security.cas.ServiceProperties\">\n<property name=\"service\"\n\tvalue=\"https://localhost:8443/cas-sample/login/cas\"/>\n<property name=\"sendRenew\" value=\"false\"/>\n</bean>\n----\n\nThe `service` must equal a URL that will be monitored by the `CasAuthenticationFilter`.\nThe `sendRenew` defaults to false, but should be set to true if your application is particularly sensitive.\nWhat this parameter does is tell the CAS login service that a single sign on login is unacceptable.\nInstead, the user will need to re-enter their username and password in order to gain access to the service.\n\nThe following beans should be configured to commence the CAS authentication process (assuming you're using a namespace configuration):\n\n[source,xml]\n----\n<security:http entry-point-ref=\"casEntryPoint\">\n...\n<security:custom-filter position=\"CAS_FILTER\" ref=\"casFilter\" />\n</security:http>\n\n<bean id=\"casFilter\"\n\tclass=\"org.springframework.security.cas.web.CasAuthenticationFilter\">\n<property name=\"authenticationManager\" ref=\"authenticationManager\"/>\n</bean>\n\n<bean id=\"casEntryPoint\"\n\tclass=\"org.springframework.security.cas.web.CasAuthenticationEntryPoint\">\n<property name=\"loginUrl\" value=\"https://localhost:9443/cas/login\"/>\n<property name=\"serviceProperties\" ref=\"serviceProperties\"/>\n</bean>\n----\n\nFor CAS to operate, the `ExceptionTranslationFilter` must have its `authenticationEntryPoint` property set to the `CasAuthenticationEntryPoint` bean.\nThis can easily be done using xref:servlet/appendix/namespace/http.adoc#nsa-http-entry-point-ref[entry-point-ref] as is done in the example above.\nThe `CasAuthenticationEntryPoint` must refer to the `ServiceProperties` bean (discussed above), which provides the URL to the enterprise's CAS login server.\nThis is where the user's browser will be redirected.\n\nThe `CasAuthenticationFilter` has very similar properties to the `UsernamePasswordAuthenticationFilter` (used for form-based logins).\nYou can use these properties to customize things like behavior for authentication success and failure.\n\nNext you need to add a `CasAuthenticationProvider` and its collaborators:\n\n[source,xml,attrs=\"-attributes\"]\n----\n<security:authentication-manager alias=\"authenticationManager\">\n<security:authentication-provider ref=\"casAuthenticationProvider\" />\n</security:authentication-manager>\n\n<bean id=\"casAuthenticationProvider\"\n\tclass=\"org.springframework.security.cas.authentication.CasAuthenticationProvider\">\n<property name=\"authenticationUserDetailsService\">\n\t<bean class=\"org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper\">\n\t<constructor-arg ref=\"userService\" />\n\t</bean>\n</property>\n<property name=\"serviceProperties\" ref=\"serviceProperties\" />\n<property name=\"ticketValidator\">\n\t<bean class=\"org.apereo.cas.client.validation.Cas20ServiceTicketValidator\">\n\t<constructor-arg index=\"0\" value=\"https://localhost:9443/cas\" />\n\t</bean>\n</property>\n<property name=\"key\" value=\"an_id_for_this_auth_provider_only\"/>\n</bean>\n\n<security:user-service id=\"userService\">\n<!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that\nNoOpPasswordEncoder should be used.\nThis is not safe for production, but makes reading\nin samples easier.\nNormally passwords should be hashed using BCrypt -->\n<security:user name=\"joe\" password=\"{noop}joe\" authorities=\"ROLE_USER\" />\n...\n</security:user-service>\n----\n\nThe `CasAuthenticationProvider` uses a `UserDetailsService` instance to load the authorities for a user, once they have been authenticated by CAS.\nWe've shown a simple in-memory setup here.\nNote that the `CasAuthenticationProvider` does not actually use the password for authentication, but it does use the authorities.\n\nThe beans are all reasonably self-explanatory if you refer back to the <<cas-how-it-works,How CAS Works>> section.\n\nThis completes the most basic configuration for CAS.\nIf you haven't made any mistakes, your web application should happily work within the framework of CAS single sign on.\nNo other parts of Spring Security need to be concerned about the fact CAS handled authentication.\nIn the following sections we will discuss some (optional) more advanced configurations.\n\n[[cas-singlelogout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/cas.adoc", "title": "cas", "heading": "Service Ticket Authentication", "heading_level": 3, "file_order": 98, "section_index": 5, "content_hash": "f2e616a457a424a9a5203d014dd0e14c55d4161988f9e2d48fc0ad755acb3a65", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/cas.adoc"}}
{"id": "sha256:8ab3950855d81f874f811f1360c44eb81adc35bb296760099feb5fad11adf59f", "content": "The CAS protocol supports Single Logout and can be easily added to your Spring Security configuration.\nBelow are updates to the Spring Security configuration that handle Single Logout\n\n[source,xml]\n----\n<security:http entry-point-ref=\"casEntryPoint\">\n...\n<security:logout logout-success-url=\"/cas-logout.jsp\"/>\n<security:custom-filter ref=\"requestSingleLogoutFilter\" before=\"LOGOUT_FILTER\"/>\n<security:custom-filter ref=\"singleLogoutFilter\" before=\"CAS_FILTER\"/>\n</security:http>\n\n<!-- This filter handles a Single Logout Request from the CAS Server -->\n<bean id=\"singleLogoutFilter\" class=\"org.apereo.cas.client.session.SingleSignOutFilter\"/>\n\n<!-- This filter redirects to the CAS Server to signal Single Logout should be performed -->\n<bean id=\"requestSingleLogoutFilter\"\n\tclass=\"org.springframework.security.web.authentication.logout.LogoutFilter\">\n<constructor-arg value=\"https://localhost:9443/cas/logout\"/>\n<constructor-arg>\n\t<bean class=\n \"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler\"/>\n</constructor-arg>\n<property name=\"filterProcessesUrl\" value=\"/logout/cas\"/>\n</bean>\n----\n\nThe `logout` element logs the user out of the local application, but does not end the session with the CAS server or any other applications that have been logged into.\nThe `requestSingleLogoutFilter` filter will allow the URL of `/spring_security_cas_logout` to be requested to redirect the application to the configured CAS Server logout URL.\nThen the CAS Server will send a Single Logout request to all the services that were signed into.\nThe `singleLogoutFilter` handles the Single Logout request by looking up the `HttpSession` in a static `Map` and then invalidating it.\n\nIt might be confusing why both the `logout` element and the `singleLogoutFilter` are needed.\nIt is considered best practice to logout locally first since the `SingleSignOutFilter` just stores the `HttpSession` in a static `Map` in order to call invalidate on it.\nWith the configuration above, the flow of logout would be:\n\n* The user requests `/logout` which would log the user out of the local application and send the user to the logout success page.\n* The logout success page, `/cas-logout.jsp`, should instruct the user to click a link pointing to `/logout/cas` in order to logout out of all applications.\n* When the user clicks the link, the user is redirected to the CAS single logout URL (https://localhost:9443/cas/logout).\n* On the CAS Server side, the CAS single logout URL then submits single logout requests to all the CAS Services.\nOn the CAS Service side, Apereo's `SingleSignOutFilter` processes the logout request by invalidating the original session.\n\nThe next step is to add the following to your web.xml\n\n[source,xml]\n----\n<filter>\n<filter-name>characterEncodingFilter</filter-name>\n<filter-class>\n\torg.springframework.web.filter.CharacterEncodingFilter\n</filter-class>\n<init-param>\n\t<param-name>encoding</param-name>\n\t<param-value>UTF-8</param-value>\n</init-param>\n</filter>\n<filter-mapping>\n<filter-name>characterEncodingFilter</filter-name>\n<url-pattern>/*</url-pattern>\n</filter-mapping>\n<listener>\n<listener-class>\n\torg.apereo.cas.client.session.SingleSignOutHttpSessionListener\n</listener-class>\n</listener>\n----\n\nWhen using the SingleSignOutFilter you might encounter some encoding issues.\nTherefore it is recommended to add the `CharacterEncodingFilter` to ensure that the character encoding is correct when using the `SingleSignOutFilter`.\nAgain, refer to Apereo CAS's documentation for details.\nThe `SingleSignOutHttpSessionListener` ensures that when an `HttpSession` expires, the mapping used for single logout is removed.\n\n[[cas-pt-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/cas.adoc", "title": "cas", "heading": "Single Logout", "heading_level": 3, "file_order": 98, "section_index": 6, "content_hash": "8ab3950855d81f874f811f1360c44eb81adc35bb296760099feb5fad11adf59f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/cas.adoc"}}
{"id": "sha256:d6fbab6a8e7dd181deca04eac2cbd757396bbf344778db60e7f95271725179eb", "content": "This section describes how to authenticate to a service using CAS.\nIn other words, this section discusses how to setup a client that uses a service that authenticates with CAS.\nThe next section describes how to setup a stateless service to Authenticate using CAS.\n\n[[cas-pt-client-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/cas.adoc", "title": "cas", "heading": "Authenticating to a Stateless Service with CAS", "heading_level": 3, "file_order": 98, "section_index": 7, "content_hash": "d6fbab6a8e7dd181deca04eac2cbd757396bbf344778db60e7f95271725179eb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/cas.adoc"}}
{"id": "sha256:41c1e021beaa0db82e18bd7a1383116ed0c1520ed1333876cbb2a7940caf190e", "content": "In order to authenticate to a stateless service, the application needs to obtain a proxy granting ticket (PGT).\nThis section describes how to configure Spring Security to obtain a PGT building upon thencas-st[Service Ticket Authentication] configuration.\n\nThe first step is to include a `ProxyGrantingTicketStorage` in your Spring Security configuration.\nThis is used to store PGT's that are obtained by the `CasAuthenticationFilter` so that they can be used to obtain proxy tickets.\nAn example configuration is shown below\n\n[source,xml]\n----\n<!--\nNOTE: In a real application you should not use an in memory implementation.\nYou will also want to ensure to clean up expired tickets by calling\nProxyGrantingTicketStorage.cleanup()\n-->\n<bean id=\"pgtStorage\" class=\"org.apereo.cas.client.proxy.ProxyGrantingTicketStorageImpl\"/>\n----\n\nThe next step is to update the `CasAuthenticationProvider` to be able to obtain proxy tickets.\nTo do this replace the `Cas20ServiceTicketValidator` with a `Cas20ProxyTicketValidator`.\nThe `proxyCallbackUrl` should be set to a URL that the application will receive PGT's at.\nLast, the configuration should also reference the `ProxyGrantingTicketStorage` so it can use a PGT to obtain proxy tickets.\nYou can find an example of the configuration changes that should be made below.\n\n[source,xml]\n----\n<bean id=\"casAuthenticationProvider\"\n\tclass=\"org.springframework.security.cas.authentication.CasAuthenticationProvider\">\n...\n<property name=\"ticketValidator\">\n\t<bean class=\"org.apereo.cas.client.validation.Cas20ProxyTicketValidator\">\n\t<constructor-arg value=\"https://localhost:9443/cas\"/>\n <property name=\"proxyCallbackUrl\"\n value=\"https://localhost:8443/cas-sample/login/cas/proxyreceptor\"/>\n\t<property name=\"proxyGrantingTicketStorage\" ref=\"pgtStorage\"/>\n\t</bean>\n</property>\n</bean>\n----\n\nThe last step is to update the `CasAuthenticationFilter` to accept PGT and to store them in the `ProxyGrantingTicketStorage`.\nIt is important the `proxyReceptorUrl` matches the `proxyCallbackUrl` of the `Cas20ProxyTicketValidator`.\nAn example configuration is shown below.\n\n[source,xml]\n----\n\n<bean id=\"casFilter\"\n class=\"org.springframework.security.cas.web.CasAuthenticationFilter\">\n\t...\n\t<property name=\"proxyGrantingTicketStorage\" ref=\"pgtStorage\"/>\n\t<property name=\"proxyReceptorUrl\" value=\"/login/cas/proxyreceptor\"/>\n</bean>\n\n----\n\n[[cas-pt-client-sample]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/cas.adoc", "title": "cas", "heading": "Configuring CAS to Obtain Proxy Granting Tickets", "heading_level": 4, "file_order": 98, "section_index": 8, "content_hash": "41c1e021beaa0db82e18bd7a1383116ed0c1520ed1333876cbb2a7940caf190e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/cas.adoc"}}
{"id": "sha256:7f9a184a137b20c664cb066e2b507c9df1f3feb6d30527949e6df1fe8dbde182", "content": "Now that Spring Security obtains PGTs, you can use them to create proxy tickets which can be used to authenticate to a stateless service.\nThe CAS xref:samples.adoc#samples[sample application] contains a working example in the `ProxyTicketSampleServlet`.\nExample code can be found below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\tthrows ServletException, IOException {\nfinal CasAuthenticationToken token = (CasAuthenticationToken) request.getUserPrincipal();\nfinal String proxyTicket = token.getAssertion().getPrincipal().getProxyTicketFor(targetUrl);\n\nfinal String serviceUrl = targetUrl+\"?ticket=\"+URLEncoder.encode(proxyTicket, \"UTF-8\");\nString proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, \"UTF-8\");\n...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nprotected fun doGet(request: HttpServletRequest, response: HttpServletResponse?) {\n // NOTE: The CasAuthenticationToken can also be obtained using\n // SecurityContextHolder.getContext().getAuthentication()\n val token = request.userPrincipal as CasAuthenticationToken\n // proxyTicket could be reused to make calls to the CAS service even if the\n // target url differs\n val proxyTicket = token.assertion.principal.getProxyTicketFor(targetUrl)\n\n // Make a remote call using the proxy ticket\n val serviceUrl: String = targetUrl + \"?ticket=\" + URLEncoder.encode(proxyTicket, \"UTF-8\")\n val proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, \"UTF-8\")\n}\n----\n======\n\n[[cas-pt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/cas.adoc", "title": "cas", "heading": "Calling a Stateless Service Using a Proxy Ticket", "heading_level": 4, "file_order": 98, "section_index": 9, "content_hash": "7f9a184a137b20c664cb066e2b507c9df1f3feb6d30527949e6df1fe8dbde182", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/cas.adoc"}}
{"id": "sha256:6c3bd54f0586cdf4190321a20113bd5949fdd63a10bd86ddbfda60bafb32039f", "content": "The `CasAuthenticationProvider` distinguishes between stateful and stateless clients.\nA stateful client is considered any that submits to the `filterProcessesUrl` of the `CasAuthenticationFilter`.\nA stateless client is any that presents an authentication request to `CasAuthenticationFilter` on a URL other than the `filterProcessesUrl`.\n\nBecause remoting protocols have no way of presenting themselves within the context of an `HttpSession`, it isn't possible to rely on the default practice of storing the security context in the session between requests.\nFurthermore, because the CAS server invalidates a ticket after it has been validated by the `TicketValidator`, presenting the same proxy ticket on subsequent requests will not work.\n\nOne obvious option is to not use CAS at all for remoting protocol clients.\nHowever, this would eliminate many of the desirable features of CAS.\nAs a middle-ground, the `CasAuthenticationProvider` uses a `StatelessTicketCache`.\nThis is used solely for stateless clients which use a principal equal to `CasAuthenticationFilter.CAS_STATELESS_IDENTIFIER`.\nWhat happens is the `CasAuthenticationProvider` will store the resulting `CasAuthenticationToken` in the `StatelessTicketCache`, keyed on the proxy ticket.\nAccordingly, remoting protocol clients can present the same proxy ticket and the `CasAuthenticationProvider` will not need to contact the CAS server for validation (aside from the first request).\nOnce authenticated, the proxy ticket could be used for URLs other than the original target service.\n\nThis section builds upon the previous sections to accommodate proxy ticket authentication.\nThe first step is to specify to authenticate all artifacts as shown below.\n\n[source,xml]\n----\n<bean id=\"serviceProperties\"\n\tclass=\"org.springframework.security.cas.ServiceProperties\">\n...\n<property name=\"authenticateAllArtifacts\" value=\"true\"/>\n</bean>\n----\n\nThe next step is to specify `serviceProperties` and the `authenticationDetailsSource` for the `CasAuthenticationFilter`.\nThe `serviceProperties` property instructs the `CasAuthenticationFilter` to attempt to authenticate all artifacts instead of only ones present on the `filterProcessesUrl`.\nThe `ServiceAuthenticationDetailsSource` creates a `ServiceAuthenticationDetails` that ensures the current URL, based upon the `HttpServletRequest`, is used as the service URL when validating the ticket.\nThe method for generating the service URL can be customized by injecting a custom `AuthenticationDetailsSource` that returns a custom `ServiceAuthenticationDetails`.\n\n[source,xml]\n----\n<bean id=\"casFilter\"\n\tclass=\"org.springframework.security.cas.web.CasAuthenticationFilter\">\n...\n<property name=\"serviceProperties\" ref=\"serviceProperties\"/>\n<property name=\"authenticationDetailsSource\">\n\t<bean class=\n\t\"org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource\">\n\t<constructor-arg ref=\"serviceProperties\"/>\n\t</bean>\n</property>\n</bean>\n----\n\nYou will also need to update the `CasAuthenticationProvider` to handle proxy tickets.\nTo do this replace the `Cas20ServiceTicketValidator` with a `Cas20ProxyTicketValidator`.\nYou will need to configure the `statelessTicketCache` and which proxies you want to accept.\nYou can find an example of the updates required to accept all proxies below.\n\n[source,xml]\n----\n\n<bean id=\"casAuthenticationProvider\"\n\tclass=\"org.springframework.security.cas.authentication.CasAuthenticationProvider\">\n...\n<property name=\"ticketValidator\">\n\t<bean class=\"org.apereo.cas.client.validation.Cas20ProxyTicketValidator\">\n\t<constructor-arg value=\"https://localhost:9443/cas\"/>\n\t<property name=\"acceptAnyProxy\" value=\"true\"/>\n\t</bean>\n</property>\n<property name=\"statelessTicketCache\">\n\t<bean class=\"org.springframework.security.cas.authentication.SpringCacheBasedTicketCache\">\n\t<property name=\"cache\">\n <bean class=\"net.sf.ehcache.Cache\"\n init-method=\"initialise\" destroy-method=\"dispose\">\n <constructor-arg value=\"casTickets\"/>\n <constructor-arg value=\"50\"/>\n <constructor-arg value=\"true\"/>\n <constructor-arg value=\"false\"/>\n <constructor-arg value=\"3600\"/>\n <constructor-arg value=\"900\"/>\n </bean>\n\t</property>\n\t</bean>\n</property>\n</bean>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/cas.adoc", "title": "cas", "heading": "Proxy Ticket Authentication", "heading_level": 3, "file_order": 98, "section_index": 10, "content_hash": "6c3bd54f0586cdf4190321a20113bd5949fdd63a10bd86ddbfda60bafb32039f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/cas.adoc"}}
{"id": "sha256:151333a5877fb128a5c60931eb3e61f9a085b6e98f606f99f49581cb5e426b19", "content": "[[servlet-events]]\n\nFor each authentication that succeeds or fails, a `AuthenticationSuccessEvent` or `AuthenticationFailureEvent`, respectively, is fired.\n\nTo listen for these events, you must first publish an `AuthenticationEventPublisher`.\nSpring Security's `DefaultAuthenticationEventPublisher` works fine for this purpose:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic AuthenticationEventPublisher authenticationEventPublisher\n (ApplicationEventPublisher applicationEventPublisher) {\n return new DefaultAuthenticationEventPublisher(applicationEventPublisher);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationEventPublisher\n (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {\n return DefaultAuthenticationEventPublisher(applicationEventPublisher)\n}\n----\n======\n\nThen you can use Spring's `@EventListener` support:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class AuthenticationEvents {\n\t@EventListener\n public void onSuccess(AuthenticationSuccessEvent success) {\n // ...\n }\n\n @EventListener\n public void onFailure(AbstractAuthenticationFailureEvent failures) {\n // ...\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass AuthenticationEvents {\n @EventListener\n fun onSuccess(success: AuthenticationSuccessEvent?) {\n // ...\n }\n\n @EventListener\n fun onFailure(failures: AbstractAuthenticationFailureEvent?) {\n // ...\n }\n}\n----\n======\n\nWhile similar to `AuthenticationSuccessHandler` and `AuthenticationFailureHandler`, these are nice in that they can be used independently from the servlet API.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/events.adoc", "title": "events", "heading": "events", "heading_level": 1, "file_order": 99, "section_index": 0, "content_hash": "151333a5877fb128a5c60931eb3e61f9a085b6e98f606f99f49581cb5e426b19", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/events.adoc"}}
{"id": "sha256:1425a2774f4feabfc0aa7e12d51a4d74bd5bb64ff25851486d665a1990b05f4c", "content": "By default, `DefaultAuthenticationEventPublisher` publishes an `AuthenticationFailureEvent` for the following events:\n\n|============\n| Exception | Event\n| `BadCredentialsException` | `AuthenticationFailureBadCredentialsEvent`\n| `UsernameNotFoundException` | `AuthenticationFailureBadCredentialsEvent`\n| `AccountExpiredException` | `AuthenticationFailureExpiredEvent`\n| `ProviderNotFoundException` | `AuthenticationFailureProviderNotFoundEvent`\n| `DisabledException` | `AuthenticationFailureDisabledEvent`\n| `LockedException` | `AuthenticationFailureLockedEvent`\n| `AuthenticationServiceException` | `AuthenticationFailureServiceExceptionEvent`\n| `CredentialsExpiredException` | `AuthenticationFailureCredentialsExpiredEvent`\n| `InvalidBearerTokenException` | `AuthenticationFailureBadCredentialsEvent`\n|============\n\nThe publisher does an exact `Exception` match, which means that sub-classes of these exceptions do not also produce events.\n\nTo that end, you may want to supply additional mappings to the publisher through the `setAdditionalExceptionMappings` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic AuthenticationEventPublisher authenticationEventPublisher\n (ApplicationEventPublisher applicationEventPublisher) {\n Map<Class<? extends AuthenticationException>,\n Class<? extends AbstractAuthenticationFailureEvent>> mapping =\n Collections.singletonMap(FooException.class, FooEvent.class);\n DefaultAuthenticationEventPublisher authenticationEventPublisher =\n new DefaultAuthenticationEventPublisher(applicationEventPublisher);\n authenticationEventPublisher.setAdditionalExceptionMappings(mapping);\n return authenticationEventPublisher;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationEventPublisher\n (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {\n val mapping: Map<Class<out AuthenticationException>, Class<out AbstractAuthenticationFailureEvent>> =\n mapOf(Pair(FooException::class.java, FooEvent::class.java))\n val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher)\n authenticationEventPublisher.setAdditionalExceptionMappings(mapping)\n return authenticationEventPublisher\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/events.adoc", "title": "events", "heading": "Adding Exception Mappings", "heading_level": 2, "file_order": 99, "section_index": 1, "content_hash": "1425a2774f4feabfc0aa7e12d51a4d74bd5bb64ff25851486d665a1990b05f4c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/events.adoc"}}
{"id": "sha256:fd9b6e831c586f4273f0df1aab34935fc68ca56102d0ec8d5ae4dccbbbdd0ed5", "content": "You can also supply a catch-all event to fire in the case of any `AuthenticationException`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic AuthenticationEventPublisher authenticationEventPublisher\n (ApplicationEventPublisher applicationEventPublisher) {\n DefaultAuthenticationEventPublisher authenticationEventPublisher =\n new DefaultAuthenticationEventPublisher(applicationEventPublisher);\n authenticationEventPublisher.setDefaultAuthenticationFailureEvent\n (AbstractAuthenticationFailureEvent.class);\n return authenticationEventPublisher;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationEventPublisher\n (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {\n val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher)\n authenticationEventPublisher.setDefaultAuthenticationFailureEvent(AbstractAuthenticationFailureEvent::class.java)\n return authenticationEventPublisher\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/events.adoc", "title": "events", "heading": "Default Event", "heading_level": 2, "file_order": 99, "section_index": 2, "content_hash": "fd9b6e831c586f4273f0df1aab34935fc68ca56102d0ec8d5ae4dccbbbdd0ed5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/events.adoc"}}
{"id": "sha256:37fc45f18ec2ff94f3949a9f44088edb192e9f29c661f8f500bddd6c20e2e226", "content": "[[servlet-authentication]]\n\nSpring Security provides comprehensive support for xref:features/authentication/index.adoc#authentication[Authentication].\nWe start by discussing the overall xref:servlet/authentication/architecture.adoc[Servlet Authentication Architecture].\nAs you might expect, this section is more abstract describing the architecture without much discussion on how it applies to concrete flows.\n\nIf you prefer, you can refer to <<servlet-authentication-mechanisms,Authentication Mechanisms>> for concrete ways in which users can authenticate.\nThese sections focus on specific ways you may want to authenticate and point back at the architecture sections to describe how the specific flows work.\n\n[[servlet-authentication-mechanisms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 100, "section_index": 0, "content_hash": "37fc45f18ec2ff94f3949a9f44088edb192e9f29c661f8f500bddd6c20e2e226", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/index.adoc"}}
{"id": "sha256:17b962619c07a7b0b0ecd2674cbb876cff2a3a6acf5bb5ba66c5965e03e14b10", "content": "* xref:servlet/authentication/passwords/index.adoc#servlet-authentication-unpwd[Username and Password] - how to authenticate with a username/password\n* xref:servlet/oauth2/login/index.adoc#oauth2login[OAuth 2.0 Login] - OAuth 2.0 Log In with OpenID Connect and non-standard OAuth 2.0 Login (i.e. GitHub)\n* xref:servlet/saml2/index.adoc#servlet-saml2[SAML 2.0 Login] - SAML 2.0 Log In\n* xref:servlet/authentication/cas.adoc#servlet-cas[Central Authentication Server (CAS)] - Central Authentication Server (CAS) Support\n* xref:servlet/authentication/rememberme.adoc#servlet-rememberme[Remember Me] - how to remember a user past session expiration\n* xref:servlet/authentication/jaas.adoc#servlet-jaas[JAAS Authentication] - authenticate with JAAS\n* xref:servlet/authentication/preauth.adoc#servlet-preauth[Pre-Authentication Scenarios] - authenticate with an external mechanism such as https://www.siteminder.com/[SiteMinder] or Java EE security but still use Spring Security for authorization and protection against common exploits.\n* xref:servlet/authentication/x509.adoc#servlet-x509[X509 Authentication] - X509 Authentication", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/index.adoc", "title": "index", "heading": "Authentication Mechanisms", "heading_level": 2, "file_order": 100, "section_index": 1, "content_hash": "17b962619c07a7b0b0ecd2674cbb876cff2a3a6acf5bb5ba66c5965e03e14b10", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/index.adoc"}}
{"id": "sha256:0241c0231c52caa264d1d7538c807224bdc9ce3e575525efc09fe42d6eaf183c", "content": "[[servlet-jaas]]\n\nSpring Security provides a package to delegate authentication requests to the Java Authentication and Authorization Service (JAAS).\nThis section discusses that package.\n\n[[jaas-abstractjaasauthenticationprovider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/jaas.adoc", "title": "jaas", "heading": "jaas", "heading_level": 1, "file_order": 101, "section_index": 0, "content_hash": "0241c0231c52caa264d1d7538c807224bdc9ce3e575525efc09fe42d6eaf183c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/jaas.adoc"}}
{"id": "sha256:f1125281ecece9ae8fb8be3332babf3cf60e3651b7f814a98a16c8670c1c55c2", "content": "The `AbstractJaasAuthenticationProvider` class is the basis for the provided JAAS `AuthenticationProvider` implementations.\nSubclasses must implement a method that creates the `LoginContext`.\nThe `AbstractJaasAuthenticationProvider` has a number of dependencies that can be injected into it, as discussed in the remainder of this section.\n\n[[jaas-callbackhandler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/jaas.adoc", "title": "jaas", "heading": "AbstractJaasAuthenticationProvider", "heading_level": 2, "file_order": 101, "section_index": 1, "content_hash": "f1125281ecece9ae8fb8be3332babf3cf60e3651b7f814a98a16c8670c1c55c2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/jaas.adoc"}}
{"id": "sha256:1985a675c498ab25d6103720babfc52c19ce308d51a276ce73ea7e569111a4bb", "content": "Most JAAS `LoginModule` instances require a callback of some sort.\nThese callbacks are usually used to obtain the username and password from the user.\n\nIn a Spring Security deployment, Spring Security is responsible for this user interaction (through the authentication mechanism).\nThus, by the time the authentication request is delegated through to JAAS, Spring Security's authentication mechanism has already fully populated an `Authentication` object that contains all the information required by the JAAS `LoginModule`.\n\nTherefore, the JAAS package for Spring Security provides two default callback handlers: `JaasNameCallbackHandler` and `JaasPasswordCallbackHandler`.\nEach of these callback handlers implements `JaasAuthenticationCallbackHandler`.\nIn most cases, these callback handlers can be used without understanding the internal mechanics.\n\nFor those needing full control over the callback behavior, `AbstractJaasAuthenticationProvider` internally wraps these `JaasAuthenticationCallbackHandler` instances with an `InternalCallbackHandler`.\nThe `InternalCallbackHandler` is the class that actually implements the JAAS normal `CallbackHandler` interface.\nAny time that the JAAS `LoginModule` is used, it is passed a list of application contexts configured `InternalCallbackHandler` instances.\nIf the `LoginModule` requests a callback against the `InternalCallbackHandler` instances, the callback is, in turn, passed to the `JaasAuthenticationCallbackHandler` instances being wrapped.\n\n[[jaas-authoritygranter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/jaas.adoc", "title": "jaas", "heading": "JAAS CallbackHandler", "heading_level": 3, "file_order": 101, "section_index": 2, "content_hash": "1985a675c498ab25d6103720babfc52c19ce308d51a276ce73ea7e569111a4bb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/jaas.adoc"}}
{"id": "sha256:e495bf54901a0f44e18ee030eda5058bfdd26f45431a056e3f08c1654bc2a06e", "content": "JAAS works with principals.\nEven \"`roles`\" are represented as principals in JAAS.\nSpring Security, on the other hand, works with `Authentication` objects.\nEach `Authentication` object contains a single principal and multiple `GrantedAuthority` instances.\nTo facilitate mapping between these different concepts, Spring Security's JAAS package includes an `AuthorityGranter` interface.\n\nAn `AuthorityGranter` is responsible for inspecting a JAAS principal and returning a set of `String` objects that represent the authorities assigned to the principal.\nFor each returned authority string, the `AbstractJaasAuthenticationProvider` creates a `JaasGrantedAuthority` (which implements Spring Security's `GrantedAuthority` interface) that contains the authority string and the JAAS principal that the `AuthorityGranter` was passed.\nThe `AbstractJaasAuthenticationProvider` obtains the JAAS principals by first successfully authenticating the user's credentials by using the JAAS `LoginModule` and then accessing the `LoginContext` it returns.\nA call to `LoginContext.getSubject().getPrincipals()` is made, with each resulting principal passed to each `AuthorityGranter` defined against the `AbstractJaasAuthenticationProvider.setAuthorityGranters(List)` property.\n\nSpring Security does not include any production `AuthorityGranter` instances, given that every JAAS principal has an implementation-specific meaning.\nHowever, Spring Security does issue the `FACTOR_PASSWORD` authority by default when authentication suceeds.\n\n[TIP]\n====\nThere is a `TestAuthorityGranter` in the unit tests that demonstrates a simple `AuthorityGranter` implementation.\n====\n\n[[jaas-defaultjaasauthenticationprovider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/jaas.adoc", "title": "jaas", "heading": "JAAS AuthorityGranter", "heading_level": 3, "file_order": 101, "section_index": 3, "content_hash": "e495bf54901a0f44e18ee030eda5058bfdd26f45431a056e3f08c1654bc2a06e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/jaas.adoc"}}
{"id": "sha256:c0327042a1dc240ae9998cdf14da9379c4cdee64f01e96337b566ea14f0854e1", "content": "The `DefaultJaasAuthenticationProvider` lets a JAAS `Configuration` object be injected into it as a dependency.\nIt then creates a `LoginContext` by using the injected JAAS `Configuration`.\nThis means that `DefaultJaasAuthenticationProvider` is not bound to any particular implementation of `Configuration`, as `JaasAuthenticationProvider` is.\n\n[[jaas-inmemoryconfiguration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/jaas.adoc", "title": "jaas", "heading": "DefaultJaasAuthenticationProvider", "heading_level": 2, "file_order": 101, "section_index": 4, "content_hash": "c0327042a1dc240ae9998cdf14da9379c4cdee64f01e96337b566ea14f0854e1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/jaas.adoc"}}
{"id": "sha256:6c4b25ef9faccb7210b34b23ff94413377cf8c8e07773cd1d7b831d5705c3398", "content": "To make it easy to inject a `Configuration` into `DefaultJaasAuthenticationProvider`, a default in-memory implementation named `InMemoryConfiguration` is provided.\nThe implementation constructor accepts a `Map` where each key represents a login configuration name, and the value represents an `Array` of `AppConfigurationEntry` instances.\n`InMemoryConfiguration` also supports a default `Array` of `AppConfigurationEntry` objects that is used if no mapping is found within the provided `Map`.\nFor details, see the Javadoc of javadoc:org.springframework.security.authentication.jaas.memory.InMemoryConfiguration[].\n\n[[jaas-djap-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/jaas.adoc", "title": "jaas", "heading": "InMemoryConfiguration", "heading_level": 3, "file_order": 101, "section_index": 5, "content_hash": "6c4b25ef9faccb7210b34b23ff94413377cf8c8e07773cd1d7b831d5705c3398", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/jaas.adoc"}}
{"id": "sha256:1396f42ff74f09120f1e5224db2311e48247fa753c700a0badbecc25b5fb7f3d", "content": "While the Spring configuration for `InMemoryConfiguration` can be more verbose than the standard JAAS configuration files, using it in conjunction with `DefaultJaasAuthenticationProvider` is more flexible than `JaasAuthenticationProvider`, since it not dependent on the default `Configuration` implementation.\n\nThe next example provides a configuration of `DefaultJaasAuthenticationProvider` that uses `InMemoryConfiguration`.\nNote that custom implementations of `Configuration` can easily be injected into `DefaultJaasAuthenticationProvider` as well.\n\n[source,xml]\n----\n<bean id=\"jaasAuthProvider\"\nclass=\"org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider\">\n<property name=\"configuration\">\n<bean class=\"org.springframework.security.authentication.jaas.memory.InMemoryConfiguration\">\n<constructor-arg>\n\t<map>\n\t<!--\n\tSPRINGSECURITY is the default loginContextName\n\tfor AbstractJaasAuthenticationProvider\n\t-->\n\t<entry key=\"SPRINGSECURITY\">\n\t<array>\n\t<bean class=\"javax.security.auth.login.AppConfigurationEntry\">\n <constructor-arg value=\"sample.SampleLoginModule\" />\n <constructor-arg>\n <util:constant static-field=\n \"javax.security.auth.login.AppConfigurationEntry$LoginModuleControlFlag.REQUIRED\"/>\n </constructor-arg>\n <constructor-arg>\n <map></map>\n </constructor-arg>\n </bean>\n\t</array>\n\t</entry>\n\t</map>\n\t</constructor-arg>\n</bean>\n</property>\n<property name=\"authorityGranters\">\n<list>\n\t<!-- You will need to write your own implementation of AuthorityGranter -->\n\t<bean class=\"org.springframework.security.authentication.jaas.TestAuthorityGranter\"/>\n</list>\n</property>\n</bean>\n----\n\n[[jaas-jaasauthenticationprovider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/jaas.adoc", "title": "jaas", "heading": "DefaultJaasAuthenticationProvider Example Configuration", "heading_level": 3, "file_order": 101, "section_index": 6, "content_hash": "1396f42ff74f09120f1e5224db2311e48247fa753c700a0badbecc25b5fb7f3d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/jaas.adoc"}}
{"id": "sha256:e9dd78384a62b69a6a1e9cebbd77929447cb0be1597ebd553683e1e72132e5ea", "content": "The `JaasAuthenticationProvider` assumes that the default `Configuration` is an instance of https://docs.oracle.com/javase/8/docs/jre/api/security/jaas/spec/com/sun/security/auth/login/ConfigFile.html[`ConfigFile`].\nThis assumption is made in order to try to update the `Configuration`.\nThe `JaasAuthenticationProvider` then uses the default `Configuration` to create the `LoginContext`.\n\nAssume that we have a JAAS login configuration file, `/WEB-INF/login.conf`, with the following contents:\n\n[source,txt]\n----\nJAASTest {\n\tsample.SampleLoginModule required;\n};\n----\n\nLike all Spring Security beans, the `JaasAuthenticationProvider` is configured through the application context.\nThe following definitions would correspond to the above JAAS login configuration file:\n\n[source,xml]\n----\n\n<bean id=\"jaasAuthenticationProvider\"\nclass=\"org.springframework.security.authentication.jaas.JaasAuthenticationProvider\">\n<property name=\"loginConfig\" value=\"/WEB-INF/login.conf\"/>\n<property name=\"loginContextName\" value=\"JAASTest\"/>\n<property name=\"callbackHandlers\">\n<list>\n<bean\n\tclass=\"org.springframework.security.authentication.jaas.JaasNameCallbackHandler\"/>\n<bean\n\tclass=\"org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler\"/>\n</list>\n</property>\n<property name=\"authorityGranters\">\n\t<list>\n\t<bean class=\"org.springframework.security.authentication.jaas.TestAuthorityGranter\"/>\n\t</list>\n</property>\n</bean>\n----\n\n[[jaas-apiprovision]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/jaas.adoc", "title": "jaas", "heading": "JaasAuthenticationProvider", "heading_level": 2, "file_order": 101, "section_index": 7, "content_hash": "e9dd78384a62b69a6a1e9cebbd77929447cb0be1597ebd553683e1e72132e5ea", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/jaas.adoc"}}
{"id": "sha256:1ff4d6c0dbf379cbf1552648ae9e098877528000486a549a8116ef03f2cc2c6c", "content": "If configured, the `JaasApiIntegrationFilter` tries to run as the `Subject` on the `JaasAuthenticationToken`.\nThis means that the `Subject` can be accessed using:\n\n[source,java]\n----\nSubject subject = Subject.getSubject(AccessController.getContext());\n----\n\nYou can configure this integration by using the xref:servlet/appendix/namespace/http.adoc#nsa-http-jaas-api-provision[jaas-api-provision] attribute.\nThis feature is useful when integrating with legacy or external API's that rely on the JAAS Subject being populated.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/jaas.adoc", "title": "jaas", "heading": "Running as a Subject", "heading_level": 2, "file_order": 101, "section_index": 8, "content_hash": "1ff4d6c0dbf379cbf1552648ae9e098877528000486a549a8116ef03f2cc2c6c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/jaas.adoc"}}
{"id": "sha256:d5670b2ef74956d88892a44a32ef2c3424823abc5935df5fa8f57becd78e6d15", "content": "[[jc-logout]]\n\nIn an application where end users can xref:servlet/authentication/index.adoc[login], they should also be able to logout.\n\nBy default, Spring Security stands up a `/logout` endpoint, so no additional code is necessary.\n\nThe rest of this section covers a number of use cases for you to consider:\n\n* I want to <<logout-java-configuration,understand logout's architecture>>\n* I want to <<customizing-logout-uris, customize the logout or logout success URI>>\n* I want to know when I need to <<permit-logout-endpoints, explicitly permit the `/logout` endpoint>>\n* I want to <<clear-all-site-data, clear cookies, storage, and/or cache>> when the user logs out\n* I am using OAuth 2.0 and I want to xref:servlet/oauth2/login/advanced.adoc#oauth2login-advanced-oidc-logout[coordinate logout with an Authorization Server]\n* I am using SAML 2.0 and I want to xref:servlet/saml2/logout.adoc[coordinate logout with an Identity Provider]\n* I am using CAS and I want to xref:servlet/authentication/cas.adoc#cas-singlelogout[coordinate logout with an Identity Provider]\n\n[[logout-architecture]]\n[[logout-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/logout.adoc", "title": "logout", "heading": "logout", "heading_level": 1, "file_order": 102, "section_index": 0, "content_hash": "d5670b2ef74956d88892a44a32ef2c3424823abc5935df5fa8f57becd78e6d15", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/logout.adoc"}}
{"id": "sha256:3ed8fc105479ce90c0f0febe5b0c385e8df2f224913a51a26e141626afdaa42b", "content": "When you include {spring-boot-reference-url}reference/using/build-systems.html#using.build-systems.starters[the `spring-boot-starter-security` dependency] or use the `@EnableWebSecurity` annotation, Spring Security will add its logout support and by default respond both to `GET /logout` and `POST /logout`.\n\nIf you request `GET /logout`, then Spring Security displays a logout confirmation page.\nAside from providing a valuable double-checking mechanism for the user, it also provides a simple way to provide xref:servlet/exploits/csrf.adoc[the needed CSRF token] to `POST /logout`.\n\nPlease note that if xref:servlet/exploits/csrf.adoc[CSRF protection] is disabled in configuration, no logout confirmation page is shown to the user and the logout is performed directly.\n\n[TIP]\nIn your application it is not necessary to use `GET /logout` to perform a logout.\nSo long as xref:servlet/exploits/csrf.adoc[the needed CSRF token] is present in the request, your application can simply `POST /logout` to induce a logout.\n\nIf you request `POST /logout`, then it will perform the following default operations using a series of javadoc:org.springframework.security.web.authentication.logout.LogoutHandler[] instances:\n\n- Invalidate the HTTP session (javadoc:org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler[])\n- Clear the xref:servlet/authentication/session-management.adoc#use-securitycontextholderstrategy[`SecurityContextHolderStrategy`] (javadoc:org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler[])\n- Clear the xref:servlet/authentication/persistence.adoc#securitycontextrepository[`SecurityContextRepository`] (javadoc:org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler[])\n- Clean up any xref:servlet/authentication/rememberme.adoc[RememberMe authentication] (`TokenRememberMeServices` / `PersistentTokenRememberMeServices`)\n- Clear out any saved xref:servlet/exploits/csrf.adoc[CSRF token] (javadoc:org.springframework.security.web.csrf.CsrfLogoutHandler[])\n- xref:servlet/authentication/events.adoc[Fire] a `LogoutSuccessEvent` (javadoc:org.springframework.security.web.authentication.logout.LogoutSuccessEventPublishingLogoutHandler[])\n\nOnce completed, then it will exercise its default javadoc:org.springframework.security.web.authentication.logout.LogoutSuccessHandler[] which redirects to `/login?logout`.\n\n[[customizing-logout-uris]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/logout.adoc", "title": "logout", "heading": "Understanding Logout's Architecture", "heading_level": 2, "file_order": 102, "section_index": 1, "content_hash": "3ed8fc105479ce90c0f0febe5b0c385e8df2f224913a51a26e141626afdaa42b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/logout.adoc"}}
{"id": "sha256:60ae1e6c6f69889f3bcbe6f0643766cf5d677bea941b0ca7c6470ae944b3ce3c", "content": "Since the `LogoutFilter` appears before xref:servlet/authorization/authorize-http-requests.adoc[the `AuthorizationFilter`] in xref:servlet/architecture.adoc#servlet-filterchain-figure[the filter chain], it is not necessary by default to explicitly permit the `/logout` endpoint.\nThus, only <<permit-logout-endpoints,custom logout endpoints>> that you create yourself generally require a `permitAll` configuration to be reachable.\n\nFor example, if you want to simply change the URI that Spring Security is matching, you can do so in the `logout` DSL in following way:\n\n.Custom Logout Uri\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .logout((logout) -> logout.logoutUrl(\"/my/logout/uri\"))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n logout {\n logoutUrl = \"/my/logout/uri\"\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<logout logout-url=\"/my/logout/uri\"/>\n----\n======\n\nand no authorization changes are necessary since it simply adjusts the `LogoutFilter`.\n\n[[permit-logout-endpoints]]\nHowever, if you stand up your own logout success endpoint (or in a rare case, <<creating-custom-logout-endpoint, your own logout endpoint>>), say using {spring-framework-reference-url}web.html#spring-web[Spring MVC], you will need to permit it in Spring Security.\nThis is because Spring MVC processes your request after Spring Security does.\n\nYou can do this using `authorizeHttpRequests` or `<intercept-url>` like so:\n\n.Custom Logout Endpoint\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/my/success/endpoint\").permitAll()\n // ...\n )\n .logout((logout) -> logout.logoutSuccessUrl(\"/my/success/endpoint\"))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n authorizeHttpRequests {\n authorize(\"/my/success/endpoint\", permitAll)\n }\n logout {\n logoutSuccessUrl = \"/my/success/endpoint\"\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <filter-url pattern=\"/my/success/endpoint\" access=\"permitAll\"/>\n <logout logout-success-url=\"/my/success/endpoint\"/>\n</http>\n----\n======\n\nIn this example, you tell the `LogoutFilter` to redirect to `/my/success/endpoint` when it is done.\nAnd, you explicitly permit the `/my/success/endpoint` endpoint in xref:servlet/authorization/authorize-http-requests.adoc[the `AuthorizationFilter`].\n\nSpecifying it twice can be cumbersome, though.\nIf you are using Java configuration, you can instead set the `permitAll` property in the logout DSL like so:\n\n.Permitting Custom Logout Endpoints\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n // ...\n )\n .logout((logout) -> logout\n .logoutSuccessUrl(\"/my/success/endpoint\")\n .permitAll()\n )\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp\n authorizeHttpRequests {\n // ...\n }\n logout {\n logoutSuccessUrl = \"/my/success/endpoint\"\n permitAll = true\n }\n----\n======\n\nwhich will add all logout URIs to the permit list for you.\n\n[[add-logout-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/logout.adoc", "title": "logout", "heading": "Customizing Logout URIs", "heading_level": 2, "file_order": 102, "section_index": 2, "content_hash": "60ae1e6c6f69889f3bcbe6f0643766cf5d677bea941b0ca7c6470ae944b3ce3c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/logout.adoc"}}
{"id": "sha256:8054bf4395e7dc197039df23a38e923fa0bef8296627b7535d3a9c249f761770", "content": "If you are using Java configuration, you can add clean up actions of your own by calling the `addLogoutHandler` method in the `logout` DSL, like so:\n\n.Custom Logout Handler\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nCookieClearingLogoutHandler cookies = new CookieClearingLogoutHandler(\"our-custom-cookie\");\nhttp\n .logout((logout) -> logout.addLogoutHandler(cookies))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n logout {\n addLogoutHandler(CookieClearingLogoutHandler(\"our-custom-cookie\"))\n }\n}\n----\n======\n\n[NOTE]\nBecause javadoc:org.springframework.security.web.authentication.logout.LogoutHandler[] instances are for the purposes of cleanup, they should not throw exceptions.\n\n[TIP]\nSince javadoc:org.springframework.security.web.authentication.logout.LogoutHandler[] is a functional interface, you can provide a custom one as a lambda.\n\nSome logout handler configurations are common enough that they are exposed directly in the `logout` DSL and `<logout>` element.\nOne example is configuring session invalidation and another is which additional cookies should be deleted.\n\nFor example, you can configure the javadoc:org.springframework.security.web.authentication.logout.CookieClearingLogoutHandler[] as seen above.\n\n[[delete-cookies]]\nOr you can instead set the appropriate configuration value like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .logout((logout) -> logout.deleteCookies(\"our-custom-cookie\"))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n logout {\n deleteCookies(\"our-custom-cookie\")\n }\n}\n----\n\nXml::\n+\n[source,kotlin,role=\"secondary\"]\n----\n<http>\n <logout delete-cookies=\"our-custom-cookie\"/>\n</http>\n----\n======\n\n[NOTE]\nSpecifying that the `JSESSIONID` cookie is not necessary since javadoc:org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler[] removes it by virtue of invalidating the session.\n\n[[clear-all-site-data]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/logout.adoc", "title": "logout", "heading": "Adding Clean-up Actions", "heading_level": 2, "file_order": 102, "section_index": 3, "content_hash": "8054bf4395e7dc197039df23a38e923fa0bef8296627b7535d3a9c249f761770", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/logout.adoc"}}
{"id": "sha256:7e438eca2f7df0c6e49be800f75ebd5545de1618568038ba128fe771919f06e2", "content": "The `Clear-Site-Data` HTTP header is one that browsers support as an instruction to clear cookies, storage, and cache that belong to the owning website.\nThis is a handy and secure way to ensure that everything, including the session cookie, is cleaned up on logout.\n\nYou can add configure Spring Security to write the `Clear-Site-Data` header on logout like so:\n\n.Using Clear-Site-Data\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nHeaderWriterLogoutHandler clearSiteData = new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(Directives.ALL));\nhttp\n .logout((logout) -> logout.addLogoutHandler(clearSiteData))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval clearSiteData = HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter(Directives.ALL))\nhttp {\n logout {\n addLogoutHandler(clearSiteData)\n }\n}\n----\n======\n\nYou give the `ClearSiteDataHeaderWriter` constructor the list of things that you want to be cleared out.\n\nThe above configuration clears out all site data, but you can also configure it to remove just cookies like so:\n\n.Using Clear-Site-Data to Clear Cookies\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nHeaderWriterLogoutHandler clearSiteData = new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(Directive.COOKIES));\nhttp\n .logout((logout) -> logout.addLogoutHandler(clearSiteData))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval clearSiteData = HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter(Directive.COOKIES))\nhttp {\n logout {\n addLogoutHandler(clearSiteData)\n }\n}\n----\n======\n\n[[customizing-logout-success]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/logout.adoc", "title": "logout", "heading": "Using Clear-Site-Data to Log Out the User", "heading_level": 3, "file_order": 102, "section_index": 4, "content_hash": "7e438eca2f7df0c6e49be800f75ebd5545de1618568038ba128fe771919f06e2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/logout.adoc"}}
{"id": "sha256:efcc24bb327ac2f85ff7bfeef7f98eb8395ea3f7a4e21bd0cb2971d6660ea032", "content": "While using `logoutSuccessUrl` will suffice for most cases, you may need to do something different from redirecting to a URL once logout is complete.\njavadoc:org.springframework.security.web.authentication.logout.LogoutSuccessHandler[] is the Spring Security component for customizing logout success actions.\n\nFor example, instead of redirecting, you may want to only return a status code.\nIn this case, you can provide a success handler instance, like so:\n\n.Customizing Logout Success to Return HTTP Status Code\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .logout((logout) -> logout.logoutSuccessHandler(new HttpStatusReturningLogoutSuccessHandler()))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n logout {\n logoutSuccessHandler = HttpStatusReturningLogoutSuccessHandler()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<bean name=\"mySuccessHandlerBean\" class=\"org.springframework.security.web.authentication.logout.HttpStatusReturningLogoutSuccessHandler\"/>\n<http>\n <logout success-handler-ref=\"mySuccessHandlerBean\"/>\n</http>\n----\n======\n\n[TIP]\nSince javadoc:org.springframework.security.web.authentication.logout.LogoutSuccessHandler[] is a functional interface, you can provide a custom one as a lambda.\n\n[[creating-custom-logout-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/logout.adoc", "title": "logout", "heading": "Customizing Logout Success", "heading_level": 2, "file_order": 102, "section_index": 5, "content_hash": "efcc24bb327ac2f85ff7bfeef7f98eb8395ea3f7a4e21bd0cb2971d6660ea032", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/logout.adoc"}}
{"id": "sha256:47f13ac0d23283f75b27ecfa12daaab320310d418b5e90f9de97e3d67ed100c9", "content": "It is strongly recommended that you use the provided `logout` DSL to configure logout.\nOne reason is that its easy to forget to call the needed Spring Security components to ensure a proper and complete logout.\n\nIn fact, it is often simpler to <<add-logout-handler, register a custom `LogoutHandler`>> than create a {spring-framework-reference-url}web.html#spring-web[Spring MVC] endpoint for performing logout.\n\nThat said, if you find yourself in a circumstance where a custom logout endpoint is needed, like the following one:\n\n.Custom Logout Endpoint\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PostMapping(\"/my/logout\")\npublic String performLogout() {\n // .. perform logout\n return \"redirect:/home\";\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PostMapping(\"/my/logout\")\nfun performLogout(): String {\n // .. perform logout\n return \"redirect:/home\"\n}\n----\n======\n\nthen you will need to have that endpoint invoke Spring Security's javadoc:org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler[] to ensure a secure and complete logout.\nSomething like the following is needed at a minimum:\n\n.Custom Logout Endpoint\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nSecurityContextLogoutHandler logoutHandler = new SecurityContextLogoutHandler();\n\n@PostMapping(\"/my/logout\")\npublic String performLogout(Authentication authentication, HttpServletRequest request, HttpServletResponse response) {\n // .. perform logout\n this.logoutHandler.logout(request, response, authentication);\n return \"redirect:/home\";\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval logoutHandler = SecurityContextLogoutHandler()\n\n@PostMapping(\"/my/logout\")\nfun performLogout(val authentication: Authentication, val request: HttpServletRequest, val response: HttpServletResponse): String {\n // .. perform logout\n this.logoutHandler.logout(request, response, authentication)\n return \"redirect:/home\"\n}\n----\n======\n\nSuch will clear out the javadoc:org.springframework.security.core.context.SecurityContextHolderStrategy[] and javadoc:org.springframework.security.web.context.SecurityContextRepository[] as needed.\n\nAlso, you'll need to <<permit-logout-endpoints, explicitly permit the endpoint>>.\n\n[WARNING]\nFailing to call javadoc:org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler[] means that xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontext[the `SecurityContext`] could still be available on subsequent requests, meaning that the user is not actually logged out.\n\n[[testing-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/logout.adoc", "title": "logout", "heading": "Creating a Custom Logout Endpoint", "heading_level": 2, "file_order": 102, "section_index": 6, "content_hash": "47f13ac0d23283f75b27ecfa12daaab320310d418b5e90f9de97e3d67ed100c9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/logout.adoc"}}
{"id": "sha256:8139c796c7b46e8fca6e2cf804a340a87b62ac89fddb7db80ea62dee0e14dd13", "content": "Once you have logout configured you can test it using xref:servlet/test/mockmvc/logout.adoc[Spring Security's MockMvc support].\n\n[[jc-logout-references]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/logout.adoc", "title": "logout", "heading": "Testing Logout", "heading_level": 2, "file_order": 102, "section_index": 7, "content_hash": "8139c796c7b46e8fca6e2cf804a340a87b62ac89fddb7db80ea62dee0e14dd13", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/logout.adoc"}}
{"id": "sha256:d30e1fcf3d0ac18a2fde95b06470e35a99100bb8468368a08e26295db634b904", "content": "- xref:servlet/test/mockmvc/logout.adoc#test-logout[Testing Logout]\n- xref:servlet/integrations/servlet-api.adoc#servletapi-logout[HttpServletRequest.logout()]\n- xref:servlet/authentication/rememberme.adoc#remember-me-impls[Remember-Me Interfaces and Implementations]\n- xref:servlet/exploits/csrf.adoc#csrf-considerations-logout[Logging Out] in section CSRF Caveats\n- Section xref:servlet/authentication/cas.adoc#cas-singlelogout[Single Logout] (CAS protocol)\n- Documentation for the xref:servlet/appendix/namespace/http.adoc#nsa-logout[logout element] in the Spring Security XML Namespace section", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/logout.adoc", "title": "logout", "heading": "Further Logout-Related References", "heading_level": 2, "file_order": 102, "section_index": 8, "content_hash": "d30e1fcf3d0ac18a2fde95b06470e35a99100bb8468368a08e26295db634b904", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/logout.adoc"}}
{"id": "sha256:26e7a211030b19f9e3ec359a86f9811d32e208f2df1cc0930d7185a36c8677ed", "content": "https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html[Multi-Factor Authentication (MFA)] requires that a user provide factors in order to authenticate.\nOWASP places factors into the following categories:\n\n- Something the user knows (e.g. a password)\n- Something that the user has (e.g. access to SMS or email)\n- Something you are (e.g. biometrics)\n- Somewhere you are (e.g. geolocation)\n- Something you do (e.g. Behavior Profiling)", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/mfa.adoc", "title": "Multi-Factor Authentication", "heading": "Multi-Factor Authentication", "heading_level": 1, "file_order": 103, "section_index": 0, "content_hash": "26e7a211030b19f9e3ec359a86f9811d32e208f2df1cc0930d7185a36c8677ed", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/mfa.adoc"}}
{"id": "sha256:00e8d11092c49ba324dde896a3e752ecd1c32d13c72c010e7a23a4c80287e0ad", "content": "At the time of authentication, Spring Security's authentication mechanisms add a javadoc:org.springframework.security.core.authority.FactorGrantedAuthority[].\nFor example, when a user authenticates using a password a `FactorGrantedAuthority` with the `authority` of `FactorGrantedAuthority.PASSWORD_AUTHORITY` is automatically added to the `Authentication`.\nIn order to require MFA with Spring Security you must:\n\n- Specify an authorization rule that requires multiple factors\n- Setup authentication for each of those factors\n\n[[emfa]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/mfa.adoc", "title": "Multi-Factor Authentication", "heading": "`FactorGrantedAuthority`", "heading_level": 2, "file_order": 103, "section_index": 1, "content_hash": "00e8d11092c49ba324dde896a3e752ecd1c32d13c72c010e7a23a4c80287e0ad", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/mfa.adoc"}}
{"id": "sha256:70f4569a5e526c648061c22468025c63cbf4b62485651d09d32832d1bfe90122", "content": "javadoc:org.springframework.security.config.annotation.authorization.EnableMultiFactorAuthentication[format=annotation] makes it easy to enable multifactor authentication.\nBelow you can find a configuration that adds the requirement for both passwords and OTT to every authorization rule.\n\ninclude-code::./EnableMultiFactorAuthenticationConfiguration[tag=enable-mfa,indent=0]\n\nWe are now able to concisely create a configuration that always requires multiple factors.\n\ninclude-code::./EnableMultiFactorAuthenticationConfiguration[tag=httpSecurity,indent=0]\n<1> URLs that begin with `/admin/**` require the authorities `FACTOR_OTT`, `FACTOR_PASSWORD`, `ROLE_ADMIN`.\n<2> Every other URL requires the authorities `FACTOR_OTT`, `FACTOR_PASSWORD`\n<3> Set up the authentication mechanisms that can provide the required factors.\n\nSpring Security behind the scenes knows which endpoint to go to depending on which authority is missing.\nIf the user logged in initially with their username and password, then Spring Security redirects to the One-Time-Token Login page.\nIf the user logged in initially with a token, then Spring Security redirects to the Username/Password Login page.\n\n[[authorization-manager-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/mfa.adoc", "title": "Multi-Factor Authentication", "heading": "@EnableMultiFactorAuthentication", "heading_level": 2, "file_order": 103, "section_index": 2, "content_hash": "70f4569a5e526c648061c22468025c63cbf4b62485651d09d32832d1bfe90122", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/mfa.adoc"}}
{"id": "sha256:058f15f5604741716e416f7abb6c2724f293347c90f2904eb3bbb7778891992d", "content": "The `@EnableMultiFactorAuthentication` `authorities` property is just a shortcut for publishing an javadoc:org.springframework.security.authorization.AuthorizationManagerFactory[] Bean.\nWhen an `AuthorizationManagerFactory` Bean is available, it is used by Spring Security to create authorization rules, like `hasAnyRole(String)`, that are defined on the `AuthorizationManagerFactory` Bean interface.\nThe implementation published by `@EnableMultiFactorAuthentication` will ensure that each authorization is combined with the requirement of having the specified factors.\n\nThe `AuthorizationManagerFactory` Bean below is what is published in the previously discussed xref:./mfa.adoc#emfa[`@EnableMultiFactorAuthentication` example].\n\ninclude-code::./UseAuthorizationManagerFactoryConfiguration[tag=authorizationManagerFactoryBean,indent=0]\n\n[[selective-mfa]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/mfa.adoc", "title": "Multi-Factor Authentication", "heading": "AuthorizationManagerFactory", "heading_level": 2, "file_order": 103, "section_index": 3, "content_hash": "058f15f5604741716e416f7abb6c2724f293347c90f2904eb3bbb7778891992d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/mfa.adoc"}}
{"id": "sha256:8e7d632d4f75483861221cc721e52e5724d15985ff8e1810bd778be07e7dc0ea", "content": "We have demonstrated how to configure an entire application to require MFA by using xref:./mfa.adoc#emfa[``@EnableMultiFactorAuthentication``s] `authorities` property.\nHowever, there are times that an application only wants parts of the application to require MFA.\nConsider the following requirements:\n\n- URLs that begin with `/admin/` should require the authorities `FACTOR_OTT`, `FACTOR_PASSWORD`, `ROLE_ADMIN`.\n- URLs that begin with `/user/settings` should require the authorities `FACTOR_OTT`, `FACTOR_PASSWORD`\n- Every other URL requires an authenticated user\n\nIn this case, some URLs require MFA while others do not.\nThis means that the global approach that we saw before does not work.\nFortunately, we can use what we learned in xref:./mfa.adoc#authorization-manager-factory[] to solve this in a concise manner.\n\nStart by specifying `@EnableMultiFactorAuthentication` without any authorities.\nBy doing so we enable MFA support, but no `AuthorizationManagerFactory` Bean is published.\n\ninclude-code::./SelectiveMfaConfiguration[tag=enable-mfa,indent=0]\n\nNext create an `AuthorizationManagerFactory` instance, but do not publish it as a Bean.\n\ninclude-code::./SelectiveMfaConfiguration[tag=httpSecurity,indent=0]\n<1> Create a `DefaultAuthorizationManagerFactory` as we did previously, but do not publish it as a Bean.\nBy not publishing it as a Bean, we are able to selectively use the `AuthorizationManagerFactory` instead of using it for every authorization rule.\n<2> Explicitly use `AuthorizationManagerFactory` so that URLs that begin with `/admin/**` require `FACTOR_OTT`, `FACTOR_PASSWORD`, and `ROLE_ADMIN`.\n<3> Explicitly use `AuthorizationManagerFactory` so that URLs that begin with `/user/settings` require `FACTOR_OTT` and `FACTOR_PASSWORD`\n<4> Otherwise, the request must be authenticated.\nThere is no MFA requirement, because the `AuthorizationManagerFactory` is not used.\n<5> Set up the authentication mechanisms that can provide the required factors.\n\n[[valid-duration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/mfa.adoc", "title": "Multi-Factor Authentication", "heading": "Selectively Requiring MFA", "heading_level": 2, "file_order": 103, "section_index": 4, "content_hash": "8e7d632d4f75483861221cc721e52e5724d15985ff8e1810bd778be07e7dc0ea", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/mfa.adoc"}}
{"id": "sha256:ee4335bca34e4e22e0674e44e0686b4a6d2df9de35ea635c5edee93189af9a47", "content": "At times, we may want to define authorization rules based upon how recently we authenticated.\nFor example, an application may want to require that the user has authenticated within the last hour in order to allow access to the `/user/settings` endpoint.\n\nRemember at the time of authentication, a `FactorGrantedAuthority` is added to the `Authentication`.\nThe `FactorGrantedAuthority` specifies when it was `issuedAt`, but does not describe how long it is valid for.\nThis is intentional, because it allows a single `FactorGrantedAuthority` to be used with different ``validDuration``s.\n\nLet's take a look at an example that illustrates how to meet the following requirements:\n\n- URLs that begin with `/admin/` should require that a password has been provided within the last 30 minutes\n- URLs that being with `/user/settings` should require that a password has been provided within the last hour\n- Otherwise, authentication is required, but it does not care if it is a password or how long ago authentication occurred\n\ninclude-code::./ValidDurationConfiguration[tag=httpSecurity,indent=0]\n<1> First we define `passwordIn30m` as a requirement for a password within 30 minutes\n<2> Next, we define `passwordInHour` as a requirement for a password within an hour\n<3> We use `passwordIn30m` to require that URLs that begin with `/admin/` should require that a password has been provided in the last 30 minutes and that the user has the `ROLE_ADMIN` authority\n<4> We use `passwordInHour` to require that URLs that begin with `/user/settings` should require that a password has been provided in the last hour\n<5> Otherwise, authentication is required, but it does not care if it is a password or how long ago authentication occurred\n<6> Set up the authentication mechanisms that can provide the required factors.\n\n[[programmatic-mfa]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/mfa.adoc", "title": "Multi-Factor Authentication", "heading": "Specifying a Valid Duration", "heading_level": 2, "file_order": 103, "section_index": 5, "content_hash": "ee4335bca34e4e22e0674e44e0686b4a6d2df9de35ea635c5edee93189af9a47", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/mfa.adoc"}}
{"id": "sha256:92fe3910572ebfa1c94a95fa9d90caac3de6b5eb3557631cb9edd26b15b4271f", "content": "In our previous examples, MFA is a static decision per request.\nThere are times when we might want to require MFA for some users, but not others.\nDetermining if MFA is enabled per user can be achieved by creating a custom `AuthorizationManager` that conditionally requires factors based upon the `Authentication`.\n\ninclude-code::./AdminMfaAuthorizationManagerConfiguration[tag=authorizationManager,indent=0]\n<1> MFA is required for the user with the username `admin`\n<2> Otherwise, MFA is not required\n\nTo enable the MFA rules globally, we can publish an `AuthorizationManagerFactory` Bean.\n\ninclude-code::./AdminMfaAuthorizationManagerConfiguration[tag=authorizationManagerFactory,indent=0]\n<1> Inject the custom `AuthorizationManager` as the javadoc:org.springframework.security.authorization.DefaultAuthorizationManagerFactory#setAdditionalAuthorization(org.springframework.security.authorization.AuthorizationManager)[DefaultAuthorization.additionalAuthorization].\nThis instructs `DefaultAuthorizationManagerFactory` that any authorization rule should apply our custom `AuthorizationManager` along with any authorization requirements defined by the application (e.g. `hasRole(\"ADMIN\")`).\n<2> Publish `DefaultAuthorizationManagerFactory` as a Bean, so it is used globally\n\nThis should feel very similar to our previous example in xref:./mfa.adoc#authorization-manager-factory[].\nThe difference is that in the previous example, the `AuthorizationManagerFactories` is setting `DefaultAuthorization.additionalAuthorization` with a built in `AuthorizationManager` that always requires the same authorities.\n\nWe can now define our authorization rules which are combined with `AdminMfaAuthorizationManager`.\n\ninclude-code::./AdminMfaAuthorizationManagerConfiguration[tag=httpSecurity,indent=0]\n<1> URLs that begin with `/admin/**` require `ROLE_ADMIN`.\nIf the username is `admin`, then `FACTOR_OTT` and `FACTOR_PASSWORD` are also required.\n<2> Otherwise, the request must be authenticated.\nIf the username is `admin`, then `FACTOR_OTT` and `FACTOR_PASSWORD` are also required.\n\nNOTE: MFA is enabled by username and not role because that is how we implemented `RequiredAuthoritiesAuthorizationManagerConfiguration`.\nIf we preferred, we could change our logic to enable MFA based upon the roles rather than the username.\n\n[[raam-mfa]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/mfa.adoc", "title": "Multi-Factor Authentication", "heading": "Programmatic MFA", "heading_level": 2, "file_order": 103, "section_index": 6, "content_hash": "92fe3910572ebfa1c94a95fa9d90caac3de6b5eb3557631cb9edd26b15b4271f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/mfa.adoc"}}
{"id": "sha256:e556debdf32392e4b222db9d9e87b70cf8a95feeee2c05abbe4c79ec12bb9b17", "content": "We've demonstrated how we can dynamically determine the authorities for a particular user in xref:./mfa.adoc#programmatic-mfa[] using a custom `AuthorizationManager`.\nHowever, this is such a common scenario that Spring Security provides built in support using javadoc:org.springframework.security.authorization.RequiredAuthoritiesAuthorizationManager[] and javadoc:org.springframework.security.authorization.RequiredAuthoritiesRepository[].\n\nLet's implement the same requirement that we did in xref:./mfa.adoc#programmatic-mfa[] using the built-in support.\n\nWe start by creating the `RequiredAuthoritiesAuthorizationManager` Bean to use.\n\ninclude-code::./RequiredAuthoritiesAuthorizationManagerConfiguration[tag=authorizationManager,indent=0]\n<1> Create a javadoc:org.springframework.security.authorization.MapRequiredAuthoritiesRepository[] that maps users with the username `admin` to require MFA.\n<2> Return a `RequiredAuthoritiesAuthorizationManager` that is injected with the `MapRequiredAuthoritiesRepository`.\n\nNext we can define an `AuthorizationManagerFactory` that uses the `RequiredAuthoritiesAuthorizationManager`.\n\ninclude-code::./RequiredAuthoritiesAuthorizationManagerConfiguration[tag=authorizationManagerFactory,indent=0]\n<1> Inject the `RequiredAuthoritiesAuthorizationManager` as the javadoc:org.springframework.security.authorization.DefaultAuthorizationManagerFactory#setAdditionalAuthorization(org.springframework.security.authorization.AuthorizationManager)[DefaultAuthorization.additionalAuthorization].\nThis instructs `DefaultAuthorizationManagerFactory` that any authorization rule should apply `RequiredAuthoritiesAuthorizationManager` along with any authorization requirements defined by the application (e.g. `hasRole(\"ADMIN\")`).\n<2> Publish `DefaultAuthorizationManagerFactory` as a Bean, so it is used globally\n\nWe can now define our authorization rules which are combined with `RequiredAuthoritiesAuthorizationManager`.\n\ninclude-code::./RequiredAuthoritiesAuthorizationManagerConfiguration[tag=httpSecurity,indent=0]\n<1> URLs that begin with `/admin/**` require `ROLE_ADMIN`.\nIf the username is `admin`, then `FACTOR_OTT` and `FACTOR_PASSWORD` are also required.\n<2> Otherwise, the request must be authenticated.\nIf the username is `admin`, then `FACTOR_OTT` and `FACTOR_PASSWORD` are also required.\n\nOur example uses an in memory mapping of usernames to the additional required authorities.\nFor more dynamic use cases that can be determined by the username, a custom implementation of javadoc:org.springframework.security.authorization.RequiredAuthoritiesRepository[] can be created.\nPossible examples would be looking up if a user has enabled MFA in an explicit setting, determining if a user has registered a passkey, etc.\n\nFor cases that need to determine MFA based upon the `Authentication`, a custom `AuthorizationManger` can be used as demonstrated in xref:./mfa.adoc#programmatic-mfa[].\n\n[[hasallauthorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/mfa.adoc", "title": "Multi-Factor Authentication", "heading": "RequiredAuthoritiesAuthorizationManager", "heading_level": 2, "file_order": 103, "section_index": 7, "content_hash": "e556debdf32392e4b222db9d9e87b70cf8a95feeee2c05abbe4c79ec12bb9b17", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/mfa.adoc"}}
{"id": "sha256:b8428c05f27a026a391d6c2141ed20dce2c8492a15250ae19abc8a2576b3382c", "content": "We've shown a lot of additional infrastructure for supporting MFA.\nHowever, for simple MFA use-cases, using `hasAllAuthorities` to require multiple factors is effective.\n\ninclude-code::./ListAuthoritiesConfiguration[tag=httpSecurity,indent=0]\n<1> Require `FACTOR_PASSWORD` and `FACTOR_OTT` for every request\n<2> Set up the authentication mechanisms that can provide the required factors.\n\nThe configuration above works well only for the most simple use-cases.\nIf you have lots of endpoints, you probably do not want to repeat the requirements for MFA in every authorization rule.\n\nFor example, consider the following configuration:\n\ninclude-code::./MultipleAuthorizationRulesConfiguration[tag=httpSecurity,indent=0]\n<1> For URLs that begin with `/admin/**`, the following authorities are required `FACTOR_OTT`, `FACTOR_PASSWORD`, `ROLE_ADMIN`.\n<2> For every other URL, the following authorities are required `FACTOR_OTT`, `FACTOR_PASSWORD`, `ROLE_USER`.\n<3> Set up the authentication mechanisms that can provide the required factors.\n\nThe configuration only specifies two authorization rules, but it is enough to see that the duplication is not desirable.\nCan you imagine what it would be like to declare hundreds of rules like this?\n\nWhat's more that it becomes difficult to express more complicated authorization rules.\nFor example, how would you require two factors and either `ROLE_ADMIN` or `ROLE_USER`?\n\nThe answer to these questions, as we have already seen, is to use xref:./mfa.adoc#emfa[]\n\n[[re-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/mfa.adoc", "title": "Multi-Factor Authentication", "heading": "Using hasAllAuthorities", "heading_level": 2, "file_order": 103, "section_index": 8, "content_hash": "b8428c05f27a026a391d6c2141ed20dce2c8492a15250ae19abc8a2576b3382c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/mfa.adoc"}}
{"id": "sha256:eb5a6d7f488a0dbeadf287cf516f763a98b773798f3bbf5a2f9d73fdb569087a", "content": "The most common of these is re-authentication.\nImagine an application configured in the following way:\n\ninclude-code::./SimpleConfiguration[tag=httpSecurity,indent=0]\n\nBy default, this application has two authentication mechanisms that it allows, meaning that the user could use either one and be fully-authenticated.\n\nIf there is a set of endpoints that require a specific factor, we can specify that in `authorizeHttpRequests` as follows:\n\ninclude-code::./RequireOttConfiguration[tag=httpSecurity,indent=0]\n<1> States that all `/profile/**` endpoints require one-time-token login to be authorized\n\nGiven the above configuration, users can log in with any mechanism that you support.\nAnd, if they want to visit the profile page, then Spring Security will redirect them to the One-Time-Token Login page to obtain it.\n\nIn this way, the authority given to a user is directly proportional to the amount of proof given.\nThis adaptive approach allows users to give only the proof needed to perform their intended operations.\n\n[[obtaining-more-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/mfa.adoc", "title": "Multi-Factor Authentication", "heading": "Re-authentication", "heading_level": 2, "file_order": 103, "section_index": 9, "content_hash": "eb5a6d7f488a0dbeadf287cf516f763a98b773798f3bbf5a2f9d73fdb569087a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/mfa.adoc"}}
{"id": "sha256:730e60535136101c031abc8a805cfc1af8a46f9f267cde49e499cdbdb5da6998", "content": "You can also configure exception handling to direct Spring Security on how to obtain a missing scope.\n\nConsider an application that requires a specific OAuth 2.0 scope for a given endpoint:\n\ninclude-code::./ScopeConfiguration[tag=httpSecurity,indent=0]\n\nIf this is also configured with an `AuthorizationManagerFactory` bean like this one:\n\ninclude-code::./MissingAuthorityConfiguration[tag=authorizationManagerFactoryBean,indent=0]\n\nThen the application will require an X.509 certificate as well as authorization from an OAuth 2.0 authorization server.\n\nIn the event that the user does not consent to `profile:read`, this application as it stands will issue a 403.\nHowever, if you have a way for the application to re-ask for consent, then you can implement this in an `AuthenticationEntryPoint` like the following:\n\ninclude-code::./MissingAuthorityConfiguration[tag=authenticationEntryPoint,indent=0]\n\nThen, your filter chain declaration can bind this entry point to the given authority like so:\n\ninclude-code::./MissingAuthorityConfiguration[tag=httpSecurity,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/mfa.adoc", "title": "Multi-Factor Authentication", "heading": "Authorizing More Scopes", "heading_level": 2, "file_order": 103, "section_index": 10, "content_hash": "730e60535136101c031abc8a805cfc1af8a46f9f267cde49e499cdbdb5da6998", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/mfa.adoc"}}
{"id": "sha256:881ac62ae60913aef85df2fc93c45187a97a05f0255d42aabf69b1f153cf5dd9", "content": "[[one-time-token-login]]\n\nSpring Security offers support for One-Time Token (OTT) authentication via the `oneTimeTokenLogin()` DSL.\nBefore diving into implementation details, it's important to clarify the scope of the OTT feature within the framework, highlighting what is supported and what isn't.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "onetimetoken", "heading_level": 1, "file_order": 104, "section_index": 0, "content_hash": "881ac62ae60913aef85df2fc93c45187a97a05f0255d42aabf69b1f153cf5dd9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:080d4b3d2c17e82ed6f8a9ad50b7e782750974a81c002b11e505c918613ff915", "content": "It's common to confuse One-Time Tokens (OTT) with https://en.wikipedia.org/wiki/One-time_password[One-Time Passwords] (OTP), but in Spring Security, these concepts differ in several key ways.\nFor clarity, we'll assume OTP refers to https://en.wikipedia.org/wiki/Time-based_one-time_password[TOTP] (Time-Based One-Time Password) or https://en.wikipedia.org/wiki/HMAC-based_one-time_password[HOTP] (HMAC-Based One-Time Password).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Understanding One-Time Tokens vs. One-Time Passwords", "heading_level": 2, "file_order": 104, "section_index": 1, "content_hash": "080d4b3d2c17e82ed6f8a9ad50b7e782750974a81c002b11e505c918613ff915", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:e3b49faff087f2aed66a165f1421591cc800ecfbf8b0d71f77a8e4e461677d28", "content": "- OTT: No initial setup is required. The user doesn't need to configure anything in advance.\n- OTP: Typically requires setup, such as generating and sharing a secret key with an external tool to produce the one-time passwords.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Setup Requirements", "heading_level": 3, "file_order": 104, "section_index": 2, "content_hash": "e3b49faff087f2aed66a165f1421591cc800ecfbf8b0d71f77a8e4e461677d28", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:7bf387f8836b02fd46c39b9c554b1b38bc0a0b8ea0e8f78f04ae0f9c10c479b9", "content": "- OTT: Usually a custom javadoc:org.springframework.security.web.authentication.ott.OneTimeTokenGenerationSuccessHandler[] must be implemented, responsible for delivering the token to the end user.\n- OTP: The token is often generated by an external tool, so there's no need to send it to the user via the application.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Token Delivery", "heading_level": 3, "file_order": 104, "section_index": 3, "content_hash": "7bf387f8836b02fd46c39b9c554b1b38bc0a0b8ea0e8f78f04ae0f9c10c479b9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:aed59016dd06e415990ea1ddbc901efb94d17ca65ca648725a59a73a909e470f", "content": "- OTT: The javadoc:org.springframework.security.authentication.ott.OneTimeTokenService#generate(org.springframework.security.authentication.ott.GenerateOneTimeTokenRequest)[] method requires a javadoc:org.springframework.security.authentication.ott.OneTimeToken[] to be returned, emphasizing server-side generation.\n- OTP: The token is not necessarily generated on the server side, it's often created by the client using the shared secret.\n\nIn summary, One-Time Tokens (OTT) provide a way to authenticate users without additional account setup, differentiating them from One-Time Passwords (OTP), which typically involve a more complex setup process and rely on external tools for token generation.\n\nThe One-Time Token Login works in two major steps.\n\n1. User requests a token by submitting their user identifier, usually the username, and the token is delivered to them, often as a Magic Link, via e-mail, SMS, etc.\n2. User submits the token to the one-time token login endpoint and, if valid, the user gets logged in.\n\nIn the following sections we will explore how to configure OTT Login for your needs.\n\n- <<default-pages,Understanding the integration with the default generated login page>>\n- <<sending-token-to-user,Sending the token to the user>>\n- <<changing-submit-page-url,Configuring the One-Time Token submit page>>\n- <<changing-generate-url,Changing the One-Time Token generate URL>>\n- <<customize-generate-consume-token,Customize how to generate and consume tokens>>\n\n[[default-pages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Token Generation", "heading_level": 3, "file_order": 104, "section_index": 4, "content_hash": "aed59016dd06e415990ea1ddbc901efb94d17ca65ca648725a59a73a909e470f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:694c6d1ab540e60e6013034f5abec807598e496909e2ae63aa298f7de44ba687", "content": "When the `oneTimeTokenLogin()` DSL is used, by default the One-Time Token Login Page is auto-generated by the org.springframework.security.web.authentication.ui:DefaultLoginPageGeneratingFilter[].\nThe DSL will also set up the javadoc:org.springframework.security.web.authentication.ui.DefaultOneTimeTokenSubmitPageGeneratingFilter[] to generate a default One-Time Token submit page.\n\n[[sending-token-to-user]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Default Login Page and Default One-Time Token Submit Page", "heading_level": 2, "file_order": 104, "section_index": 5, "content_hash": "694c6d1ab540e60e6013034f5abec807598e496909e2ae63aa298f7de44ba687", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:4021d08d906c72885d9cc629cc0547840460f0de383624971c391c4bce85c961", "content": "It is not possible for Spring Security to reasonably determine the way the token should be delivered to your users.\nTherefore, a custom javadoc:org.springframework.security.web.authentication.ott.OneTimeTokenGenerationSuccessHandler[] must be provided to deliver the token to the user based on your needs.\nOne of the most common delivery strategies is a Magic Link, via e-mail, SMS, etc.\nIn the following example, we are going to create a magic link and sent it to the user's email.\n\n.One-Time Token Login Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) {\n http\n // ...\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin(Customizer.withDefaults());\n return http.build();\n }\n\n}\n\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\n\n@Component <1>\npublic class MagicLinkOneTimeTokenGenerationSuccessHandler implements OneTimeTokenGenerationSuccessHandler {\n\n private final MailSender mailSender;\n\n private final OneTimeTokenGenerationSuccessHandler redirectHandler = new RedirectOneTimeTokenGenerationSuccessHandler(\"/ott/sent\");\n\n // constructor omitted\n\n @Override\n public void handle(HttpServletRequest request, HttpServletResponse response, OneTimeToken oneTimeToken) throws IOException, ServletException {\n UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(UrlUtils.buildFullRequestUrl(request))\n .replacePath(request.getContextPath())\n .replaceQuery(null)\n .fragment(null)\n .path(\"/login/ott\")\n .queryParam(\"token\", oneTimeToken.getTokenValue()); <2>\n String magicLink = builder.toUriString();\n String email = getUserEmail(oneTimeToken.getUsername()); <3>\n this.mailSender.send(email, \"Your Spring Security One Time Token\", \"Use the following link to sign in into the application: \" + magicLink); <4>\n this.redirectHandler.handle(request, response, oneTimeToken); <5>\n }\n\n private String getUserEmail() {\n // ...\n }\n\n}\n\n@Controller\nclass PageController {\n\n @GetMapping(\"/ott/sent\")\n String ottSent() {\n return \"my-template\";\n }\n\n}\n\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http{\n formLogin {}\n oneTimeTokenLogin { }\n }\n return http.build()\n }\n}\n\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\n\n@Component (1)\nclass MagicLinkOneTimeTokenGenerationSuccessHandler(\n private val mailSender: MailSender,\n private val redirectHandler: OneTimeTokenGenerationSuccessHandler = RedirectOneTimeTokenGenerationSuccessHandler(\"/ott/sent\")\n) : OneTimeTokenGenerationSuccessHandler {\n\n override fun handle(request: HttpServletRequest, response: HttpServletResponse, oneTimeToken: OneTimeToken) {\n val builder = UriComponentsBuilder.fromHttpUrl(UrlUtils.buildFullRequestUrl(request))\n .replacePath(request.contextPath)\n .replaceQuery(null)\n .fragment(null)\n .path(\"/login/ott\")\n .queryParam(\"token\", oneTimeToken.getTokenValue()) (2)\n val magicLink = builder.toUriString()\n val email = getUserEmail(oneTimeToken.getUsername()) (3)\n this.mailSender.send(email, \"Your Spring Security One Time Token\", \"Use the following link to sign in into the application: $magicLink\")(4)\n this.redirectHandler.handle(request, response, oneTimeToken) (5)\n }\n\n private fun getUserEmail(): String {\n // ...\n }\n}\n\n@Controller\nclass PageController {\n\n @GetMapping(\"/ott/sent\")\n fun ottSent(): String {\n return \"my-template\"\n }\n}\n\n----\n======\n\n<1> Make the `MagicLinkOneTimeTokenGenerationSuccessHandler` a Spring bean\n<2> Create a login processing URL with the `token` as a query param\n<3> Retrieve the user's email based on the username\n<4> Use the `JavaMailSender` API to send the email to the user with the magic link\n<5> Use the `RedirectOneTimeTokenGenerationSuccessHandler` to perform a redirect to your desired URL\n\nThe email content will look similar to:\n\n> Use the following link to sign in into the application: \\http://localhost:8080/login/ott?token=a830c444-29d8-4d98-9b46-6aba7b22fe5b\n\nThe default submit page will detect that the URL has the `token` query param and will automatically fill the form field with the token value.\n\n[[changing-generate-url]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Sending the Token to the User", "heading_level": 2, "file_order": 104, "section_index": 6, "content_hash": "4021d08d906c72885d9cc629cc0547840460f0de383624971c391c4bce85c961", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:93559a22d4bd4344771c48f899aed14a0fba79bba495e7ba1073feab37e54cac", "content": "By default, the javadoc:org.springframework.security.web.authentication.ott.GenerateOneTimeTokenFilter[] listens to `POST /ott/generate` requests.\nThat URL can be changed by using the `generateTokenUrl(String)` DSL method:\n\n.Changing the Generate URL\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) {\n http\n // ...\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin((ott) -> ott\n .generateTokenUrl(\"/ott/my-generate-url\")\n );\n return http.build();\n }\n\n}\n\n@Component\npublic class MagicLinkOneTimeTokenGenerationSuccessHandler implements OneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n //...\n formLogin { }\n oneTimeTokenLogin {\n generateTokenUrl = \"/ott/my-generate-url\"\n }\n }\n return http.build()\n }\n}\n\n@Component\nclass MagicLinkOneTimeTokenGenerationSuccessHandler : OneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n======\n\n[[changing-submit-page-url]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Changing the One-Time Token Generate URL", "heading_level": 2, "file_order": 104, "section_index": 7, "content_hash": "93559a22d4bd4344771c48f899aed14a0fba79bba495e7ba1073feab37e54cac", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:55caa0adbe80cadb359bba20da5a796d99c44291e27ba57f64b833b069664917", "content": "The default One-Time Token submit page is generated by the javadoc:org.springframework.security.web.authentication.ui.DefaultOneTimeTokenSubmitPageGeneratingFilter[] and listens to `GET /login/ott`.\nThe URL can also be changed, like so:\n\n.Configuring the Default Submit Page URL\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) {\n http\n // ...\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin((ott) -> ott\n .submitPageUrl(\"/ott/submit\")\n );\n return http.build();\n }\n\n}\n\n@Component\npublic class MagicLinkGenerationSuccessHandler implements OneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n //...\n formLogin { }\n oneTimeTokenLogin {\n submitPageUrl = \"/ott/submit\"\n }\n }\n return http.build()\n }\n}\n\n@Component\nclass MagicLinkOneTimeTokenGenerationSuccessHandler : OneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n======\n\n[[disabling-default-submit-page]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Changing the Default Submit Page URL", "heading_level": 2, "file_order": 104, "section_index": 8, "content_hash": "55caa0adbe80cadb359bba20da5a796d99c44291e27ba57f64b833b069664917", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:09a507a54fd0463b57346c9f03d3cfa9640b405042917d8d1a2d63a889417342", "content": "If you want to use your own One-Time Token submit page, you can disable the default page and then provide your own endpoint.\n\n.Disabling the Default Submit Page\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/my-ott-submit\").permitAll()\n .anyRequest().authenticated()\n )\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin((ott) -> ott\n .showDefaultSubmitPage(false)\n );\n return http.build();\n }\n\n}\n\n@Controller\npublic class MyController {\n\n @GetMapping(\"/my-ott-submit\")\n public String ottSubmitPage() {\n return \"my-ott-submit\";\n }\n\n}\n\n@Component\npublic class OneTimeTokenGenerationSuccessHandler implements OneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(\"/my-ott-submit\", authenticated)\n authorize(anyRequest, authenticated)\n }\n formLogin { }\n oneTimeTokenLogin {\n showDefaultSubmitPage = false\n }\n }\n return http.build()\n }\n}\n\n@Controller\nclass MyController {\n\n @GetMapping(\"/my-ott-submit\")\n fun ottSubmitPage(): String {\n return \"my-ott-submit\"\n }\n}\n\n@Component\nclass MagicLinkOneTimeTokenGenerationSuccessHandler : OneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n======\n\n[[customize-generate-consume-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Disabling the Default Submit Page", "heading_level": 2, "file_order": 104, "section_index": 9, "content_hash": "09a507a54fd0463b57346c9f03d3cfa9640b405042917d8d1a2d63a889417342", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:376fe36106f903119b0ca11cf54571201ea4d2589051ca9c1bf0fc065dd053ed", "content": "The interface that define the common operations for generating and consuming one-time tokens is the javadoc:org.springframework.security.authentication.ott.OneTimeTokenService[].\nSpring Security uses the javadoc:org.springframework.security.authentication.ott.InMemoryOneTimeTokenService[] as the default implementation of that interface, if none is provided.\nFor production environments consider using javadoc:org.springframework.security.authentication.ott.JdbcOneTimeTokenService[].\n\nSome of the most common reasons to customize the `OneTimeTokenService` are, but not limited to:\n\n- Changing the one-time token expire time\n- Storing more information from the generate token request\n- Changing how the token value is created\n- Additional validation when consuming a one-time token\n\nThere are two options to customize the `OneTimeTokenService`.\nOne option is to provide it as a bean, so it can be automatically be picked-up by the `oneTimeTokenLogin()` DSL:\n\n.Passing the OneTimeTokenService as a Bean\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) {\n http\n // ...\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin(Customizer.withDefaults());\n return http.build();\n }\n\n @Bean\n public OneTimeTokenService oneTimeTokenService() {\n return new MyCustomOneTimeTokenService();\n }\n\n}\n\n@Component\npublic class MagicLinkOneTimeTokenGenerationSuccessHandler implements OneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n //...\n formLogin { }\n oneTimeTokenLogin { }\n }\n return http.build()\n }\n\n @Bean\n open fun oneTimeTokenService(): OneTimeTokenService {\n return MyCustomOneTimeTokenService()\n }\n}\n\n@Component\nclass MagicLinkOneTimeTokenGenerationSuccessHandler : OneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n======\n\nThe second option is to pass the `OneTimeTokenService` instance to the DSL, which is useful if there are multiple `SecurityFilterChain` and a different `OneTimeTokenService` is needed for each of them.\n\n.Passing the OneTimeTokenService using the DSL\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) {\n http\n // ...\n .formLogin(Customizer.withDefaults())\n .oneTimeTokenLogin((ott) -> ott\n .oneTimeTokenService(new MyCustomOneTimeTokenService())\n );\n return http.build();\n }\n\n}\n\n@Component\npublic class MagicLinkOneTimeTokenGenerationSuccessHandler implements OneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n //...\n formLogin { }\n oneTimeTokenLogin {\n oneTimeTokenService = MyCustomOneTimeTokenService()\n }\n }\n return http.build()\n }\n\n}\n\n@Component\nclass MagicLinkOneTimeTokenGenerationSuccessHandler : OneTimeTokenGenerationSuccessHandler {\n // ...\n}\n----\n======\n\n[[customize-generate-token-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Customize How to Generate and Consume One-Time Tokens", "heading_level": 2, "file_order": 104, "section_index": 10, "content_hash": "376fe36106f903119b0ca11cf54571201ea4d2589051ca9c1bf0fc065dd053ed", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:db989f960a973bcf6efda12fb3dbd0aaa3b9f07586f3a352dd7731d8a7dd559e", "content": "There are a number of reasons that you may want to adjust an GenerateOneTimeTokenRequest. For example, you may want expiresIn to be set to 10 mins, which Spring Security sets to 5 mins by default.\n\nYou can customize elements of GenerateOneTimeTokenRequest by publishing an GenerateOneTimeTokenRequestResolver as a @Bean, like so:\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nGenerateOneTimeTokenRequestResolver generateOneTimeTokenRequestResolver() {\n DefaultGenerateOneTimeTokenRequestResolver delegate = new DefaultGenerateOneTimeTokenRequestResolver();\n return (request) -> {\n GenerateOneTimeTokenRequest generate = delegate.resolve(request);\n return new GenerateOneTimeTokenRequest(generate.getUsername(), Duration.ofSeconds(600));\n\t};\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun generateRequestResolver() : GenerateOneTimeTokenRequestResolver {\n return DefaultGenerateOneTimeTokenRequestResolver().apply {\n this.setExpiresIn(Duration.ofMinutes(10))\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc", "title": "onetimetoken", "heading": "Customize GenerateOneTimeTokenRequest Instance", "heading_level": 2, "file_order": 104, "section_index": 11, "content_hash": "db989f960a973bcf6efda12fb3dbd0aaa3b9f07586f3a352dd7731d8a7dd559e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/onetimetoken.adoc"}}
{"id": "sha256:a7539dfcfe2b78bfdd8b2ffb4e59e9c5d9408e6812cc538655102cea64455693", "content": "[[passkeys]]\n\nSpring Security provides support for https://www.passkeys.com[passkeys].\nPasskeys are a more secure method of authenticating than passwords and are built using https://www.w3.org/TR/webauthn-3/[WebAuthn].\n\nIn order to use a passkey to authenticate, a user must first xref:servlet/authentication/passkeys.adoc#passkeys-register[Register a New Credential].\nAfter the credential is registered, it can be used to authenticate by xref:servlet/authentication/passkeys.adoc#passkeys-verify[verifying an authentication assertion].\n\n[[passkeys-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc", "title": "passkeys", "heading": "passkeys", "heading_level": 1, "file_order": 105, "section_index": 0, "content_hash": "a7539dfcfe2b78bfdd8b2ffb4e59e9c5d9408e6812cc538655102cea64455693", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc"}}
{"id": "sha256:5e548430e145f06f2f351564329dc12ce9dbb1c9ad1425c60bd25de6fc4a5b33", "content": "To get started, add the `webauthn4j-core` dependency to your project.\n\n[NOTE]\n====\nThis assumes that you are managing Spring Security's versions with Spring Boot or Spring Security's BOM as described in xref:getting-spring-security.adoc[].\n====\n\n.Passkeys Dependencies\n[tabs]\n======\nMaven::\n+\n[source,xml,role=\"primary\",subs=\"verbatim,attributes\"]\n----\n<dependency>\n <groupId>org.springframework.security</groupId>\n <artifactId>spring-security-web</artifactId>\n</dependency>\n<dependency>\n <groupId>com.webauthn4j</groupId>\n <artifactId>webauthn4j-core</artifactId>\n <version>{webauthn4j-core-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,role=\"secondary\",subs=\"verbatim,attributes\"]\n----\ndependencies {\n implementation \"org.springframework.security:spring-security-web\"\n implementation \"com.webauthn4j:webauthn4j-core:{webauthn4j-core-version}\"\n}\n----\n======\n\n[[passkeys-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc", "title": "passkeys", "heading": "Required Dependencies", "heading_level": 2, "file_order": 105, "section_index": 1, "content_hash": "5e548430e145f06f2f351564329dc12ce9dbb1c9ad1425c60bd25de6fc4a5b33", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc"}}
{"id": "sha256:473bef8e389643f275c63982ecfb657e55cb7e34847dbeb72e82155c62942e61", "content": "The following configuration enables passkey authentication.\nIt provides a way to xref:./passkeys.adoc#passkeys-register[] at `/webauthn/register` and a default log in page that allows xref:./passkeys.adoc#passkeys-verify[authenticating with passkeys].\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain filterChain(HttpSecurity http) {\n\t// ...\n\thttp\n // ...\n .formLogin(withDefaults())\n .webAuthn((webAuthn) -> webAuthn\n .rpId(\"example.com\")\n .allowedOrigins(\"https://example.com\")\n // optional properties\n .creationOptionsRepository(new CustomPublicKeyCredentialCreationOptionsRepository())\n .messageConverter(new CustomHttpMessageConverter())\n );\n\treturn http.build();\n}\n\n@Bean\nUserDetailsService userDetailsService() {\n\tUserDetails userDetails = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .roles(\"USER\")\n .build();\n\n\treturn new InMemoryUserDetailsManager(userDetails);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n\t// ...\n\thttp {\n webAuthn {\n rpId = \"example.com\"\n allowedOrigins = setOf(\"https://example.com\")\n // optional properties\n creationOptionsRepository = CustomPublicKeyCredentialCreationOptionsRepository()\n messageConverter = CustomHttpMessageConverter()\n }\n\t}\n}\n\n@Bean\nopen fun userDetailsService(): UserDetailsService {\n\tval userDetails = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .roles(\"USER\")\n .build()\n\treturn InMemoryUserDetailsManager(userDetails)\n}\n----\n======\n\n[[passkeys-configuration-persistence]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc", "title": "passkeys", "heading": "Configuration", "heading_level": 2, "file_order": 105, "section_index": 2, "content_hash": "473bef8e389643f275c63982ecfb657e55cb7e34847dbeb72e82155c62942e61", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc"}}
{"id": "sha256:7292a4270fa0136f4971efb57eca87013530cb03029c88937f5a678c508118c1", "content": "WebAuthn performs persistence with javadoc:org.springframework.security.web.webauthn.management.PublicKeyCredentialUserEntityRepository[] and javadoc:org.springframework.security.web.webauthn.management.UserCredentialRepository[].\nThe default is to use in memory persistence, but JDBC persistence is support with javadoc:org.springframework.security.web.webauthn.management.JdbcPublicKeyCredentialUserEntityRepository[] and javadoc:org.springframework.security.web.webauthn.management.JdbcUserCredentialRepository[].\nTo configure JDBC based persistence, expose the repositories as a Bean:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJdbcPublicKeyCredentialUserEntityRepository jdbcPublicKeyCredentialRepository(JdbcOperations jdbc) {\n\treturn new JdbcPublicKeyCredentialUserEntityRepository(jdbc);\n}\n\n@Bean\nJdbcUserCredentialRepository jdbcUserCredentialRepository(JdbcOperations jdbc) {\n\treturn new JdbcUserCredentialRepository(jdbc);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jdbcPublicKeyCredentialRepository(jdbc: JdbcOperations): JdbcPublicKeyCredentialUserEntityRepository {\n return JdbcPublicKeyCredentialUserEntityRepository(jdbc)\n}\n\n@Bean\nfun jdbcUserCredentialRepository(jdbc: JdbcOperations): JdbcUserCredentialRepository {\n return JdbcUserCredentialRepository(jdbc)\n}\n----\n======\n\nIf JDBC does not meet your needs, you can create your own implementations of the interfaces and use them by exposing them as a Bean similar to the example above.\n\n[[passkeys-configuration-pkccor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc", "title": "passkeys", "heading": "JDBC & Custom Persistence", "heading_level": 3, "file_order": 105, "section_index": 3, "content_hash": "7292a4270fa0136f4971efb57eca87013530cb03029c88937f5a678c508118c1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc"}}
{"id": "sha256:aea56899c9f7d5aa736a2f453dae10f9f08942e97e121731f4a0ee5db2649363", "content": "The `PublicKeyCredentialCreationOptionsRepository` is used to persist the `PublicKeyCredentialCreationOptions` between requests.\nThe default is to persist it the `HttpSession`, but at times users may need to customize this behavior.\nThis can be done by setting the optional property `creationOptionsRepository` demonstrated in xref:./passkeys.adoc#passkeys-configuration[Configuration] or by exposing a `PublicKeyCredentialCreationOptionsRepository` Bean:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nCustomPublicKeyCredentialCreationOptionsRepository creationOptionsRepository() {\n\treturn new CustomPublicKeyCredentialCreationOptionsRepository();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun creationOptionsRepository(): CustomPublicKeyCredentialCreationOptionsRepository {\n\treturn CustomPublicKeyCredentialCreationOptionsRepository()\n}\n----\n======\n\n[[passkeys-register]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc", "title": "passkeys", "heading": "Custom PublicKeyCredentialCreationOptionsRepository", "heading_level": 3, "file_order": 105, "section_index": 4, "content_hash": "aea56899c9f7d5aa736a2f453dae10f9f08942e97e121731f4a0ee5db2649363", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc"}}
{"id": "sha256:f9d275b51971df54000c34b1f25da1981f09f805ebdcd75114cfaeccbd811e10", "content": "In order to use a passkey, a user must first https://www.w3.org/TR/webauthn-3/#sctn-registering-a-new-credential[Register a New Credential].\n\nRegistering a new credential is composed of two steps:\n\n1. Requesting the Registration Options\n2. Registering the Credential\n\n[[passkeys-register-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc", "title": "passkeys", "heading": "Register a New Credential", "heading_level": 2, "file_order": 105, "section_index": 5, "content_hash": "f9d275b51971df54000c34b1f25da1981f09f805ebdcd75114cfaeccbd811e10", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc"}}
{"id": "sha256:aa8256c9753c3bd9384f5ff46b6c383143551189eb0b9f924d8756b53b20790f", "content": "The first step in registration of a new credential is to request the registration options.\nIn Spring Security, a request for the registration options is typically done using JavaScript and looks like:\n\n[NOTE]\n====\nSpring Security provides a default registration page that can be used as a reference on how to register credentials.\n====\n\n.Request for Registration Options\n[source,http]\n----\nPOST /webauthn/register/options\nX-CSRF-TOKEN: 4bfd1575-3ad1-4d21-96c7-4ef2d9f86721\n----\n\nThe request above will obtain the registration options for the currently authenticated user.\nSince the challenge is persisted (state is changed) to be compared at the time of registration, the request must be a POST and include a CSRF token.\n\n.Response for Registration Options\n[source,json]\n----\n{\n \"rp\": {\n \"name\": \"SimpleWebAuthn Example\",\n \"id\": \"example.localhost\"\n },\n \"user\": {\n \"name\": \"user@example.localhost\",\n \"id\": \"oWJtkJ6vJ_m5b84LB4_K7QKTCTEwLIjCh4tFMCGHO4w\",\n \"displayName\": \"user@example.localhost\"\n },\n \"challenge\": \"q7lCdd3SVQxdC-v8pnRAGEn1B2M-t7ZECWPwCAmhWvc\",\n \"pubKeyCredParams\": [\n {\n \"type\": \"public-key\",\n \"alg\": -8\n },\n {\n \"type\": \"public-key\",\n \"alg\": -7\n },\n {\n \"type\": \"public-key\",\n \"alg\": -257\n }\n ],\n \"timeout\": 300000,\n \"excludeCredentials\": [],\n \"authenticatorSelection\": {\n \"residentKey\": \"required\",\n \"userVerification\": \"preferred\"\n },\n \"attestation\": \"none\",\n \"extensions\": {\n \"credProps\": true\n }\n}\n----\n\n[[passkeys-register-create]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc", "title": "passkeys", "heading": "Request the Registration Options", "heading_level": 3, "file_order": 105, "section_index": 6, "content_hash": "aa8256c9753c3bd9384f5ff46b6c383143551189eb0b9f924d8756b53b20790f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc"}}
{"id": "sha256:15ce02e48214fc09ea152dca84aaa28ae7f09c881a2f013a62e54878d64ce3d5", "content": "After the registration options are obtained, they are used to create the credentials that are registered.\nTo register a new credential, the application should pass the options to https://w3c.github.io/webappsec-credential-management/#dom-credentialscontainer-create[`navigator.credentials.create`] after base64url decoding the binary values such as `user.id`, `challenge`, and `excludeCredentials[].id`.\n\nThe returned value can then be sent to the server as a JSON request.\nAn example registration request can be found below:\n\n.Example Registration Request\n[source,http]\n----\nPOST /webauthn/register\nX-CSRF-TOKEN: 4bfd1575-3ad1-4d21-96c7-4ef2d9f86721\n\n{\n \"publicKey\": { // <1>\n \"credential\": {\n \"id\": \"dYF7EGnRFFIXkpXi9XU2wg\",\n \"rawId\": \"dYF7EGnRFFIXkpXi9XU2wg\",\n \"response\": {\n \"attestationObject\": \"o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YViUy9GqwTRaMpzVDbXq1dyEAXVOxrou08k22ggRC45MKNhdAAAAALraVWanqkAfvZZFYZpVEg0AEHWBexBp0RRSF5KV4vV1NsKlAQIDJiABIVggQjmrekPGzyqtoKK9HPUH-8Z2FLpoqkklFpFPQVICQ3IiWCD6I9Jvmor685fOZOyGXqUd87tXfvJk8rxj9OhuZvUALA\",\n \"clientDataJSON\": \"eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiSl9RTi10SFJYRWVKYjlNcUNrWmFPLUdOVmlibXpGVGVWMk43Z0ptQUdrQSIsIm9yaWdpbiI6Imh0dHBzOi8vZXhhbXBsZS5sb2NhbGhvc3Q6ODQ0MyIsImNyb3NzT3JpZ2luIjpmYWxzZX0\",\n \"transports\": [\n \"internal\",\n \"hybrid\"\n ]\n },\n \"type\": \"public-key\",\n \"clientExtensionResults\": {},\n \"authenticatorAttachment\": \"platform\"\n },\n \"label\": \"1password\" // <2>\n }\n}\n----\n<1> The result of calling `navigator.credentials.create` with binary values base64url encoded.\n<2> A label that the user selects to have associated with this credential to help the user distinguish the credential.\n\n.Example Successful Registration Response\n[source,http]\n----\nHTTP/1.1 200 OK\n\n{\n \"success\": true\n}\n----\n\n[[passkeys-verify]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc", "title": "passkeys", "heading": "Registering the Credential", "heading_level": 3, "file_order": 105, "section_index": 7, "content_hash": "15ce02e48214fc09ea152dca84aaa28ae7f09c881a2f013a62e54878d64ce3d5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc"}}
{"id": "sha256:b892994c0c5428e9d1ba26658e3e07e5ec8969662de74a0a301147df538c6193", "content": "After xref:./passkeys.adoc#passkeys-register[] the passkey can be https://www.w3.org/TR/webauthn-3/#sctn-verifying-assertion[verified] (authenticated).\n\nVerifying a credential is composed of two steps:\n\n1. Requesting the Verification Options\n2. Verifying the Credential\n\n[[passkeys-verify-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc", "title": "passkeys", "heading": "Verifying an Authentication Assertion", "heading_level": 2, "file_order": 105, "section_index": 8, "content_hash": "b892994c0c5428e9d1ba26658e3e07e5ec8969662de74a0a301147df538c6193", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc"}}
{"id": "sha256:9b387f58c9109d2907cc69978f94ef80603f51e8bdabf13449a573aca270ab12", "content": "The first step in verification of a credential is to request the verification options.\nIn Spring Security, a request for the verification options is typically done using JavaScript and looks like:\n\n[NOTE]\n====\nSpring Security provides a default log in page that can be used as a reference on how to verify credentials.\n====\n\n.Request for Verification Options\n[source,http]\n----\nPOST /webauthn/authenticate/options\nX-CSRF-TOKEN: 4bfd1575-3ad1-4d21-96c7-4ef2d9f86721\n----\n\nThe request above will obtain the verification options.\nSince the challenge is persisted (state is changed) to be compared at the time of authentication, the request must be a POST and include a CSRF token.\n\nThe response will contain the options for obtaining a credential with binary values such as `challenge` base64url encoded.\n\n.Example Response for Verification Options\n[source,json]\n----\n{\n \"challenge\": \"cQfdGrj9zDg3zNBkOH3WPL954FTOShVy0-CoNgSewNM\",\n \"timeout\": 300000,\n \"rpId\": \"example.localhost\",\n \"allowCredentials\": [],\n \"userVerification\": \"preferred\",\n \"extensions\": {}\n}\n----\n\n[[passkeys-verify-get]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc", "title": "passkeys", "heading": "Request the Verification Options", "heading_level": 3, "file_order": 105, "section_index": 9, "content_hash": "9b387f58c9109d2907cc69978f94ef80603f51e8bdabf13449a573aca270ab12", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc"}}
{"id": "sha256:6a30c7d9fd9ed92dab59033e607b97c1ff71696c03e150049ff1862f9ecde427", "content": "After the verification options are obtained, they are used to get a credential.\nTo get a credential, the application should pass the options to https://w3c.github.io/webappsec-credential-management/#dom-credentialscontainer-create[`navigator.credentials.get`] after base64url decoding the binary values such as `challenge`.\n\nThe returned value of `navigator.credentials.get` can then be sent to the server as a JSON request.\nBinary values such as `rawId` and `response.*` must be base64url encoded.\nAn example authentication request can be found below:\n\n.Example Authentication Request\n[source,http]\n----\nPOST /login/webauthn\nX-CSRF-TOKEN: 4bfd1575-3ad1-4d21-96c7-4ef2d9f86721\n\n{\n \"id\": \"dYF7EGnRFFIXkpXi9XU2wg\",\n \"rawId\": \"dYF7EGnRFFIXkpXi9XU2wg\",\n \"response\": {\n \"authenticatorData\": \"y9GqwTRaMpzVDbXq1dyEAXVOxrou08k22ggRC45MKNgdAAAAAA\",\n \"clientDataJSON\": \"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiRFVsRzRDbU9naWhKMG1vdXZFcE9HdUk0ZVJ6MGRRWmxUQmFtbjdHQ1FTNCIsIm9yaWdpbiI6Imh0dHBzOi8vZXhhbXBsZS5sb2NhbGhvc3Q6ODQ0MyIsImNyb3NzT3JpZ2luIjpmYWxzZX0\",\n \"signature\": \"MEYCIQCW2BcUkRCAXDmGxwMi78jknenZ7_amWrUJEYoTkweldAIhAMD0EMp1rw2GfwhdrsFIeDsL7tfOXVPwOtfqJntjAo4z\",\n \"userHandle\": \"Q3_0Xd64_HW0BlKRAJnVagJTpLKLgARCj8zjugpRnVo\"\n },\n \"clientExtensionResults\": {},\n \"authenticatorAttachment\": \"platform\"\n}\n----\n\n.Example Successful Authentication Response\n[source,http]\n----\nHTTP/1.1 200 OK\n\n{\n \"redirectUrl\": \"/\", // <1>\n \"authenticated\": true // <2>\n}\n----\n<1> The URL to redirect to\n<2> Indicates that the user is authenticated\n\n.Example Authentication Failure Response\n[source,http]\n----\nHTTP/1.1 401 OK\n\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc", "title": "passkeys", "heading": "Verifying the Credential", "heading_level": 3, "file_order": 105, "section_index": 10, "content_hash": "6a30c7d9fd9ed92dab59033e607b97c1ff71696c03e150049ff1862f9ecde427", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/passkeys.adoc"}}
{"id": "sha256:cbb7db9f91e5e64fd9b3ee2c7dc929eeab4dc40395e28dc73d63129a0aa1580d", "content": "[[persistant]]\n\nThe first time a user requests a protected resource, they are xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationentrypoint[prompted for credentials].\nOne of the most common ways to prompt for credentials is to redirect the user to a xref:servlet/authentication/passwords/form.adoc[log in page].\nA summarized HTTP exchange for an unauthenticated user requesting a protected resource might look like this:\n\n.Unauthenticated User Requests Protected Resource\n====\n[source,http]\n----\nGET / HTTP/1.1\nHost: example.com\nCookie: SESSION=91470ce0-3f3c-455b-b7ad-079b02290f7b\n----\n\n[source,http]\n----\nHTTP/1.1 302 Found\nLocation: /login\n----\n====\n\nThe user submits their username and password.\n\n.Username and Password Submitted\n[source,http]\n----\nPOST /login HTTP/1.1\nHost: example.com\nCookie: SESSION=91470ce0-3f3c-455b-b7ad-079b02290f7b\n\nusername=user&password=password&_csrf=35942e65-a172-4cd4-a1d4-d16a51147b3e\n----\n\nUpon authenticating the user, the user is associated to a new session id to prevent xref:servlet/authentication/session-management.adoc#ns-session-fixation[session fixation attacks].\n\n.Authenticated User is Associated to New Session\n[source,http]\n----\nHTTP/1.1 302 Found\nLocation: /\nSet-Cookie: SESSION=4c66e474-3f5a-43ed-8e48-cc1d8cb1d1c8; Path=/; HttpOnly; SameSite=Lax\n----\n\nSubsequent requests include the session cookie which is used to authenticate the user for the remainder of the session.\n\n.Authenticated Session Provided as Credentials\n[source,http]\n----\nGET / HTTP/1.1\nHost: example.com\nCookie: SESSION=4c66e474-3f5a-43ed-8e48-cc1d8cb1d1c8\n----\n\n[[securitycontextrepository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/persistence.adoc", "title": "persistence", "heading": "persistence", "heading_level": 1, "file_order": 106, "section_index": 0, "content_hash": "cbb7db9f91e5e64fd9b3ee2c7dc929eeab4dc40395e28dc73d63129a0aa1580d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/persistence.adoc"}}
{"id": "sha256:56105e2aa66051de1955872ebe301f1bbb0888d733edffee71b25c67e0842d2b", "content": "In Spring Security the association of the user to future requests is made using javadoc:org.springframework.security.web.context.SecurityContextRepository[].\nThe default implementation of `SecurityContextRepository` is javadoc:org.springframework.security.web.context.DelegatingSecurityContextRepository[] which delegates to the following:\n\n* <<httpsecuritycontextrepository,`HttpSessionSecurityContextRepository`>>\n* <<requestattributesecuritycontextrepository,`RequestAttributeSecurityContextRepository`>>\n\n[[httpsecuritycontextrepository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/persistence.adoc", "title": "persistence", "heading": "SecurityContextRepository", "heading_level": 2, "file_order": 106, "section_index": 1, "content_hash": "56105e2aa66051de1955872ebe301f1bbb0888d733edffee71b25c67e0842d2b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/persistence.adoc"}}
{"id": "sha256:abeb7f90cfc87c032152ccf2beb40b641aa3de7f6133eccdcce3290ce9ce05fb", "content": "The javadoc:org.springframework.security.web.context.HttpSessionSecurityContextRepository[] associates the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontext[`SecurityContext`] to the `HttpSession`.\nUsers can replace `HttpSessionSecurityContextRepository` with another implementation of `SecurityContextRepository` if they wish to associate the user with subsequent requests in another way or not at all.\n\n[[nullsecuritycontextrepository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/persistence.adoc", "title": "persistence", "heading": "HttpSessionSecurityContextRepository", "heading_level": 3, "file_order": 106, "section_index": 2, "content_hash": "abeb7f90cfc87c032152ccf2beb40b641aa3de7f6133eccdcce3290ce9ce05fb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/persistence.adoc"}}
{"id": "sha256:39053ac4da5003d9a3cf28439a50341bab20a60f7950eecc2e5c1f26f40b1d69", "content": "If it is not desirable to associate the `SecurityContext` to an `HttpSession` (i.e. when authenticating with OAuth) the javadoc:org.springframework.security.web.context.NullSecurityContextRepository[] is an implementation of `SecurityContextRepository` that does nothing.\n\n[[requestattributesecuritycontextrepository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/persistence.adoc", "title": "persistence", "heading": "NullSecurityContextRepository", "heading_level": 3, "file_order": 106, "section_index": 3, "content_hash": "39053ac4da5003d9a3cf28439a50341bab20a60f7950eecc2e5c1f26f40b1d69", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/persistence.adoc"}}
{"id": "sha256:fc68c3430f079cec2298e2c1452a97f687946d5858364b7578614e7bb5bdde5e", "content": "The javadoc:org.springframework.security.web.context.RequestAttributeSecurityContextRepository[] saves the `SecurityContext` as a request attribute to make sure the `SecurityContext` is available for a single request that occurs across dispatch types that may clear out the `SecurityContext`.\n\nFor example, assume that a client makes a request, is authenticated, and then an error occurs.\nDepending on the servlet container implementation, the error means that any `SecurityContext` that was established is cleared out and then the error dispatch is made.\nWhen the error dispatch is made, there is no `SecurityContext` established.\nThis means that the error page cannot use the `SecurityContext` for authorization or displaying the current user unless the `SecurityContext` is persisted somehow.\n\n.Use RequestAttributeSecurityContextRepository\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n\thttp\n // ...\n .securityContext((securityContext) -> securityContext\n .securityContextRepository(new RequestAttributeSecurityContextRepository())\n );\n\treturn http.build();\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http security-context-repository-ref=\"contextRepository\">\n\t<!-- ... -->\n</http>\n<b:bean name=\"contextRepository\"\n\tclass=\"org.springframework.security.web.context.RequestAttributeSecurityContextRepository\" />\n----\n======\n\n[[delegatingsecuritycontextrepository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/persistence.adoc", "title": "persistence", "heading": "RequestAttributeSecurityContextRepository", "heading_level": 3, "file_order": 106, "section_index": 4, "content_hash": "fc68c3430f079cec2298e2c1452a97f687946d5858364b7578614e7bb5bdde5e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/persistence.adoc"}}
{"id": "sha256:88509614d9838afa198948a4e35ccf6d0506f1ce4f692f7a89fba1c6d8abc7df", "content": "The javadoc:org.springframework.security.web.context.DelegatingSecurityContextRepository[] saves the `SecurityContext` to multiple `SecurityContextRepository` delegates and allows retrieval from any of the delegates in a specified order.\n\nThe most useful arrangement for this is configured with the following example, which allows the use of both xref:requestattributesecuritycontextrepository[`RequestAttributeSecurityContextRepository`] and xref:httpsecuritycontextrepository[`HttpSessionSecurityContextRepository`] simultaneously.\n\n.Configure DelegatingSecurityContextRepository\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n\thttp\n // ...\n .securityContext((securityContext) -> securityContext\n .securityContextRepository(new DelegatingSecurityContextRepository(\n new RequestAttributeSecurityContextRepository(),\n new HttpSessionSecurityContextRepository()\n ))\n );\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n\thttp {\n // ...\n securityContext {\n securityContextRepository = DelegatingSecurityContextRepository(\n RequestAttributeSecurityContextRepository(),\n HttpSessionSecurityContextRepository()\n )\n }\n\t}\n\treturn http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http security-context-repository-ref=\"contextRepository\">\n\t<!-- ... -->\n</http>\n<bean name=\"contextRepository\"\n\tclass=\"org.springframework.security.web.context.DelegatingSecurityContextRepository\">\n <constructor-arg>\n <bean class=\"org.springframework.security.web.context.RequestAttributeSecurityContextRepository\" />\n </constructor-arg>\n <constructor-arg>\n <bean class=\"org.springframework.security.web.context.HttpSessionSecurityContextRepository\" />\n </constructor-arg>\n</bean>\n----\n======\n\n[NOTE]\n====\nIn Spring Security 6, the example shown above is the default configuration.\n====\n\n[[securitycontextpersistencefilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/persistence.adoc", "title": "persistence", "heading": "DelegatingSecurityContextRepository", "heading_level": 3, "file_order": 106, "section_index": 5, "content_hash": "88509614d9838afa198948a4e35ccf6d0506f1ce4f692f7a89fba1c6d8abc7df", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/persistence.adoc"}}
{"id": "sha256:ee7ff9889b84f74b0c5a02f81c45bd96d8c491f9d3a232a7562964ff87cc9dc9", "content": "The javadoc:org.springframework.security.web.context.SecurityContextPersistenceFilter[] is responsible for persisting the `SecurityContext` between requests using the xref::servlet/authentication/persistence.adoc#securitycontextrepository[`SecurityContextRepository`].\n\n[.invert-dark]\nimage::{figures}/securitycontextpersistencefilter.png[]\n\nimage:{icondir}/number_1.png[] Before running the rest of the application, `SecurityContextPersistenceFilter` loads the `SecurityContext` from the `SecurityContextRepository` and sets it on the `SecurityContextHolder`.\n\nimage:{icondir}/number_2.png[] Next, the application is run.\n\nimage:{icondir}/number_3.png[] Finally, if the `SecurityContext` has changed, we save the `SecurityContext` using the `SecurityContextRepository`.\nThis means that when using `SecurityContextPersistenceFilter`, just setting the `SecurityContextHolder` will ensure that the `SecurityContext` is persisted using `SecurityContextRepository`.\n\nIn some cases a response is committed and written to the client before the `SecurityContextPersistenceFilter` method completes.\nFor example, if a redirect is sent to the client the response is immediately written back to the client.\nThis means that establishing an `HttpSession` would not be possible in step 3 because the session id could not be included in the already written response.\nAnother situation that can happen is that if a client authenticates successfully, the response is committed before `SecurityContextPersistenceFilter` completes, and the client makes a second request before the `SecurityContextPersistenceFilter` completes. the wrong authentication could be present in the second request.\n\nTo avoid these problems, the `SecurityContextPersistenceFilter` wraps both the `HttpServletRequest` and the `HttpServletResponse` to detect if the `SecurityContext` has changed and if so save the `SecurityContext` just before the response is committed.\n\n[[securitycontextholderfilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/persistence.adoc", "title": "persistence", "heading": "SecurityContextPersistenceFilter", "heading_level": 2, "file_order": 106, "section_index": 6, "content_hash": "ee7ff9889b84f74b0c5a02f81c45bd96d8c491f9d3a232a7562964ff87cc9dc9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/persistence.adoc"}}
{"id": "sha256:e94a6bff88341dd0298c947f380cfe96f790da6211c7375aff31591f0c52a388", "content": "The javadoc:org.springframework.security.web.context.SecurityContextHolderFilter[] is responsible for loading the `SecurityContext` between requests using the xref::servlet/authentication/persistence.adoc#securitycontextrepository[`SecurityContextRepository`].\n\n[.invert-dark]\nimage::{figures}/securitycontextholderfilter.png[]\n\nimage:{icondir}/number_1.png[] Before running the rest of the application, `SecurityContextHolderFilter` loads the `SecurityContext` from the `SecurityContextRepository` and sets it on the `SecurityContextHolder`.\n\nimage:{icondir}/number_2.png[] Next, the application is run.\n\nUnlike, xref:servlet/authentication/persistence.adoc#securitycontextpersistencefilter[`SecurityContextPersistenceFilter`], `SecurityContextHolderFilter` only loads the `SecurityContext` it does not save the `SecurityContext`.\nThis means that when using `SecurityContextHolderFilter`, it is required that the `SecurityContext` is explicitly saved.\n\n.Explicit Saving of SecurityContext\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n\thttp\n\t\t// ...\n\t\t.securityContext((securityContext) -> securityContext\n\t\t\t.requireExplicitSave(true)\n\t\t);\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun springSecurity(http: HttpSecurity): SecurityFilterChain {\n    http {\n        securityContext {\n            requireExplicitSave = true\n        }\n    }\n    return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http security-context-explicit-save=\"true\">\n\t<!-- ... -->\n</http>\n----\n======\n\n\nUpon using the configuration, it is important that any code that sets the `SecurityContextHolder` with a `SecurityContext` also saves the `SecurityContext` to the `SecurityContextRepository` if it should be persisted between requests.\n\nFor example, the following code:\n\n.Setting `SecurityContextHolder` with `SecurityContextPersistenceFilter`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nSecurityContextHolder.setContext(securityContext);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nSecurityContextHolder.setContext(securityContext)\n----\n======\n\nshould be replaced with\n\n.Setting `SecurityContextHolder` with `SecurityContextHolderFilter`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nSecurityContextHolder.setContext(securityContext);\nsecurityContextRepository.saveContext(securityContext, httpServletRequest, httpServletResponse);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nSecurityContextHolder.setContext(securityContext)\nsecurityContextRepository.saveContext(securityContext, httpServletRequest, httpServletResponse)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/persistence.adoc", "title": "persistence", "heading": "SecurityContextHolderFilter", "heading_level": 2, "file_order": 106, "section_index": 7, "content_hash": "e94a6bff88341dd0298c947f380cfe96f790da6211c7375aff31591f0c52a388", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/persistence.adoc"}}
{"id": "sha256:5bc42cfc72a02eecaf19b8cc963e52d10639993363b5d3b9a88f644dbf293e00", "content": "[[servlet-preauth]]\nThere are situations where you want to use Spring Security for authorization, but the user has already been reliably authenticated by some external system prior to accessing the application.\nWe refer to these situations as \"`pre-authenticated`\" scenarios.\nExamples include X.509, Siteminder, and authentication by the Java EE container in which the application runs.\nWhen using pre-authentication, Spring Security has to:\n\n* Identify the user making the request.\n* Obtain the authorities for the user.\n\nThe details depend on the external authentication mechanism.\nA user might be identified by their certificate information in the case of X.509, or by an HTTP request header in the case of Siteminder.\nIf relying on container authentication, the user is identified by calling the `getUserPrincipal()` method on the incoming HTTP request.\nIn some cases, the external mechanism may supply role and authority information for the user. However, in other cases, you must obtain the authorities from a separate source, such as a `UserDetailsService`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/preauth.adoc", "title": "preauth", "heading": "preauth", "heading_level": 1, "file_order": 107, "section_index": 0, "content_hash": "5bc42cfc72a02eecaf19b8cc963e52d10639993363b5d3b9a88f644dbf293e00", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/preauth.adoc"}}
{"id": "sha256:7e5ed7f31ce9e1e3614fcd52d20c1949df26c329d915acab1e5c9ab568485aa8", "content": "Because most pre-authentication mechanisms follow the same pattern, Spring Security has a set of classes that provide an internal framework for implementing pre-authenticated authentication providers.\nThis removes duplication and lets new implementations be added in a structured fashion, without having to write everything from scratch.\nYou need not know about these classes if you want to use something like xref:servlet/authentication/x509.adoc#servlet-x509[X.509 authentication], as it already has a namespace configuration option which is simpler to use and get started with.\nIf you need to use explicit bean configuration or are planning on writing your own implementation, you need an understanding of how the provided implementations work.\nYou can find the classes under the `org.springframework.security.web.authentication.preauth`.\nWe provide only an outline here, so you should consult the Javadoc and source where appropriate.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/preauth.adoc", "title": "preauth", "heading": "Pre-Authentication Framework Classes", "heading_level": 2, "file_order": 107, "section_index": 1, "content_hash": "7e5ed7f31ce9e1e3614fcd52d20c1949df26c329d915acab1e5c9ab568485aa8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/preauth.adoc"}}
{"id": "sha256:a207c32c68e15daaab4150227da6914b74942b5ac4113481d97f7f223d279673", "content": "This class checks the current contents of the security context and, if it is empty, tries to extract user information from the HTTP request and submit it to the `AuthenticationManager`.\nSubclasses override the following methods to obtain this information.\n\n.Override AbstractPreAuthenticatedProcessingFilter\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nprotected abstract Object getPreAuthenticatedPrincipal(HttpServletRequest request);\n\nprotected abstract Object getPreAuthenticatedCredentials(HttpServletRequest request);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nprotected abstract fun getPreAuthenticatedPrincipal(request: HttpServletRequest): Any?\n\nprotected abstract fun getPreAuthenticatedCredentials(request: HttpServletRequest): Any?\n----\n======\n\nAfter calling these, the filter creates a `PreAuthenticatedAuthenticationToken` that contains the returned data and submits it for authentication.\nBy \"`authentication`\" here, we really just mean further processing to perhaps load the user's authorities, but the standard Spring Security authentication architecture is followed.\n\nAs other Spring Security authentication filters, the pre-authentication filter has an `authenticationDetailsSource` property, which, by default, creates a `WebAuthenticationDetails` object to store additional information, such as the session identifier and the originating IP address in the `details` property of the `Authentication` object.\nIn cases where user role information can be obtained from the pre-authentication mechanism, the data is also stored in this property, with the details implementing the `GrantedAuthoritiesContainer` interface.\nThis enables the authentication provider to read the authorities which were externally allocated to the user.\nWe look at a concrete example next.\n\n[[j2ee-preauth-details]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/preauth.adoc", "title": "preauth", "heading": "AbstractPreAuthenticatedProcessingFilter", "heading_level": 3, "file_order": 107, "section_index": 2, "content_hash": "a207c32c68e15daaab4150227da6914b74942b5ac4113481d97f7f223d279673", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/preauth.adoc"}}
{"id": "sha256:a6d31a97468ddb9a2d88dfd0a393f6be3a290d300d3bfb9efd808b762c564229", "content": "If the filter is configured with an `authenticationDetailsSource`, which is an instance of this class, the authority information is obtained by calling the `isUserInRole(String role)` method for each of a pre-determined set of \"`mappable roles`\".\nThe class gets these from a configured `MappableAttributesRetriever`.\nPossible implementations include hard-coding a list in the application context and reading the role information from the `<security-role>` information in a `web.xml` file.\nThe pre-authentication sample application uses the latter approach.\n\nThere is an additional stage where the roles (or attributes) are mapped to Spring Security `GrantedAuthority` objects by using a configured `Attributes2GrantedAuthoritiesMapper`.\nThe default just adds the usual `ROLE_` prefix to the names, but it gives you full control over the behavior.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/preauth.adoc", "title": "preauth", "heading": "J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource", "heading_level": 4, "file_order": 107, "section_index": 3, "content_hash": "a6d31a97468ddb9a2d88dfd0a393f6be3a290d300d3bfb9efd808b762c564229", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/preauth.adoc"}}
{"id": "sha256:3fe798a3f17c5d476dc8b2d4aa95e7cd2cfc911eac0e769ac91d5a4804062c29", "content": "The pre-authenticated provider has little more to do than load the `UserDetails` object for the user.\nIt does this by delegating to an `AuthenticationUserDetailsService`.\nThe latter is similar to the standard `UserDetailsService` but takes an `Authentication` object rather than just user name:\n\n[source,java]\n----\npublic interface AuthenticationUserDetailsService {\n\tUserDetails loadUserDetails(Authentication token) throws UsernameNotFoundException;\n}\n----\n\nThis interface may also have other uses, but, with pre-authentication, it allows access to the authorities that were packaged in the `Authentication` object, as we saw in the previous section.\nThe `PreAuthenticatedGrantedAuthoritiesUserDetailsService` class does this.\nAlternatively, it may delegate to a standard `UserDetailsService` through the `UserDetailsByNameServiceWrapper` implementation.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/preauth.adoc", "title": "preauth", "heading": "PreAuthenticatedAuthenticationProvider", "heading_level": 3, "file_order": 107, "section_index": 4, "content_hash": "3fe798a3f17c5d476dc8b2d4aa95e7cd2cfc911eac0e769ac91d5a4804062c29", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/preauth.adoc"}}
{"id": "sha256:e0abe9f1f4b5d37a4d130f1edc06d1b788f0ce7c544071f96ffae139e7a3d03b", "content": "The xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationentrypoint[`AuthenticationEntryPoint`] is responsible for kick-starting the authentication process for an unauthenticated user (when they try to access a protected resource). However, in the pre-authenticated case, this does not apply.\nYou would only configure the `ExceptionTranslationFilter` with an instance of this class if you do not use pre-authentication in combination with other authentication mechanisms.\nIt is called if the user is rejected by the `AbstractPreAuthenticatedProcessingFilter`, resulting in a null authentication.\nIt always returns a `403`-forbidden response code if called.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/preauth.adoc", "title": "preauth", "heading": "Http403ForbiddenEntryPoint", "heading_level": 3, "file_order": 107, "section_index": 5, "content_hash": "e0abe9f1f4b5d37a4d130f1edc06d1b788f0ce7c544071f96ffae139e7a3d03b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/preauth.adoc"}}
{"id": "sha256:02de1353da1b399a8ac396ae2cef315e48a0c2fb12e8a6a9caa56f54c086afff", "content": "X.509 authentication is covered in its xref:servlet/authentication/x509.adoc#servlet-x509[own chapter].\nHere, we look at some classes which provide support for other pre-authenticated scenarios.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/preauth.adoc", "title": "preauth", "heading": "Concrete Implementations", "heading_level": 2, "file_order": 107, "section_index": 6, "content_hash": "02de1353da1b399a8ac396ae2cef315e48a0c2fb12e8a6a9caa56f54c086afff", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/preauth.adoc"}}
{"id": "sha256:db92c85c7763d9822c5efded043f9f85c5d5a77ee33e0fff109d2628cb9567c0", "content": "An external authentication system may supply information to the application by setting specific headers on the HTTP request.\nA well-known example of this is Siteminder, which passes the username in a header called `SM_USER`.\nThis mechanism is supported by the `RequestHeaderAuthenticationFilter` class, which only extracts the username from the header.\nIt defaults to using a name of `SM_USER` as the header name.\nSee the Javadoc for more details.\n\n[TIP]\n====\nWhen using a system like this, the framework performs no authentication checks at all, and it is _extremely_ important that the external system is configured properly and protects all access to the application.\nIf an attacker is able to forge the headers in their original request without this being detected, they could potentially choose any username they wished.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/preauth.adoc", "title": "preauth", "heading": "Request-Header Authentication (Siteminder)", "heading_level": 3, "file_order": 107, "section_index": 7, "content_hash": "db92c85c7763d9822c5efded043f9f85c5d5a77ee33e0fff109d2628cb9567c0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/preauth.adoc"}}
{"id": "sha256:6e2e6d3d891275070744541b1e50c83d6d9f48cd5bd465605da1b6bfd4c1aabe", "content": "The following example shows a typical configuration that uses this filter:\n\n[source,xml]\n----\n<security:http>\n<!-- Additional http configuration omitted -->\n<security:custom-filter position=\"PRE_AUTH_FILTER\" ref=\"siteminderFilter\" />\n</security:http>\n\n<bean id=\"siteminderFilter\" class=\"org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter\">\n<property name=\"principalRequestHeader\" value=\"SM_USER\"/>\n<property name=\"authenticationManager\" ref=\"authenticationManager\" />\n</bean>\n\n<bean id=\"preauthAuthProvider\" class=\"org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider\">\n<property name=\"preAuthenticatedUserDetailsService\">\n\t<bean id=\"userDetailsServiceWrapper\"\n class=\"org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper\">\n\t<property name=\"userDetailsService\" ref=\"userDetailsService\"/>\n\t</bean>\n</property>\n</bean>\n\n<security:authentication-manager alias=\"authenticationManager\">\n<security:authentication-provider ref=\"preauthAuthProvider\" />\n</security:authentication-manager>\n----\n\nWe've assumed here that the xref:servlet/configuration/xml-namespace.adoc#ns-config[security namespace] is being used for configuration.\nIt's also assumed that you have added a `UserDetailsService` (called \"userDetailsService\") to your configuration to load the user's roles.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/preauth.adoc", "title": "preauth", "heading": "Siteminder Example Configuration", "heading_level": 4, "file_order": 107, "section_index": 8, "content_hash": "6e2e6d3d891275070744541b1e50c83d6d9f48cd5bd465605da1b6bfd4c1aabe", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/preauth.adoc"}}
{"id": "sha256:f1e219101a8cd6102704a2fee610e04e37e8afa11b34bd7d3b7a5fc175d67548", "content": "The `J2eePreAuthenticatedProcessingFilter` class extracts the username from the `userPrincipal` property of the `HttpServletRequest`.\nUse of this filter would usually be combined with the use of Java EE roles, as described earlier in <<j2ee-preauth-details>>.\n\nThere is a {gh-old-samples-url}/xml/preauth[sample application] that uses this approach in the codebase, so get hold of the code from Github and have a look at the application context file if you are interested.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/preauth.adoc", "title": "preauth", "heading": "Java EE Container Authentication", "heading_level": 3, "file_order": 107, "section_index": 9, "content_hash": "f1e219101a8cd6102704a2fee610e04e37e8afa11b34bd7d3b7a5fc175d67548", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/preauth.adoc"}}
{"id": "sha256:211a9bc5afc5e981255c4a1d87393113abea42809a8c742698b28637f5d3ed64", "content": "[[servlet-rememberme]]\n\n[[remember-me-overview]]\nRemember-me or persistent-login authentication refers to web sites being able to remember the identity of a principal between sessions.\nThis is typically accomplished by sending a cookie to the browser, with the cookie being detected during future sessions and causing automated login to take place.\nSpring Security provides the necessary hooks for these operations to take place and has two concrete remember-me implementations.\nOne uses hashing to preserve the security of cookie-based tokens and the other uses a database or other persistent storage mechanism to store the generated tokens.\n\nNote that both implementations require a `UserDetailsService`.\nIf you use an authentication provider that does not use a `UserDetailsService` (for example, the LDAP provider), it does not work unless you also have a `UserDetailsService` bean in your application context.\n\n[[remember-me-hash-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc", "title": "rememberme", "heading": "rememberme", "heading_level": 1, "file_order": 108, "section_index": 0, "content_hash": "211a9bc5afc5e981255c4a1d87393113abea42809a8c742698b28637f5d3ed64", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc"}}
{"id": "sha256:7fafa156165278debc810b50c1780b527af009748bc9a7372f1a9df3375d613f", "content": "This approach uses hashing to achieve a useful remember-me strategy.\nIn essence, a cookie is sent to the browser upon successful interactive authentication, with the cookie being composed as follows:\n\n[source,txt]\n----\nbase64(username + \":\" + expirationTime + \":\" + algorithmName + \":\"\nalgorithmHex(username + \":\" + expirationTime + \":\" password + \":\" + key))\n\nusername: As identifiable to the UserDetailsService\npassword: That matches the one in the retrieved UserDetails\nexpirationTime: The date and time when the remember-me token expires, expressed in milliseconds\nkey: A private key to prevent modification of the remember-me token\nalgorithmName: The algorithm used to generate and to verify the remember-me token signature\n----\n\nThe remember-me token is valid only for the period specified and only if the username, password, and key do not change.\nNotably, this has a potential security issue, in that a captured remember-me token is usable from any user agent until such time as the token expires.\nThis is the same issue as with digest authentication.\nIf a principal is aware that a token has been captured, they can easily change their password and immediately invalidate all remember-me tokens on issue.\nIf more significant security is needed, you should use the approach described in the next section.\nAlternatively, remember-me services should not be used at all.\n\nIf you are familiar with the topics discussed in the chapter on xref:servlet/configuration/xml-namespace.adoc#ns-config[namespace configuration], you can enable remember-me authentication by adding the `<remember-me>` element:\n\n[source,xml]\n----\n<http>\n...\n<remember-me key=\"myAppKey\"/>\n</http>\n----\n\nThe `UserDetailsService` is normally selected automatically.\nIf you have more than one in your application context, you need to specify which one should be used with the `user-service-ref` attribute, where the value is the name of your `UserDetailsService` bean.\n\n[[remember-me-persistent-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc", "title": "rememberme", "heading": "Simple Hash-Based Token Approach", "heading_level": 2, "file_order": 108, "section_index": 1, "content_hash": "7fafa156165278debc810b50c1780b527af009748bc9a7372f1a9df3375d613f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc"}}
{"id": "sha256:47a4160e4483413e90040953abd3c02c26e1dc3559081642495abefbed2f2935", "content": "This approach is based on the article https://web.archive.org/web/20180819014446/http://jaspan.com/improved_persistent_login_cookie_best_practice[Improved Persistent Login Cookie Best Practice] with some minor modifications footnote:[Essentially, the username is not included in the cookie, to prevent exposing a valid login name unnecessarily.\nThere is a discussion on this in the comments section of this article.].\nTo use this approach with namespace configuration, you would supply a datasource reference:\n\n[source,xml]\n----\n<http>\n...\n<remember-me data-source-ref=\"someDataSource\"/>\n</http>\n----\n\nThe database should contain a `persistent_logins` table, created by using the following SQL (or equivalent):\n\n[source,ddl]\n----\ncreate table persistent_logins (username varchar(64) not null,\n series varchar(64) primary key,\n token varchar(64) not null,\n last_used timestamp not null)\n----\n\n[[remember-me-impls]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc", "title": "rememberme", "heading": "Persistent Token Approach", "heading_level": 2, "file_order": 108, "section_index": 2, "content_hash": "47a4160e4483413e90040953abd3c02c26e1dc3559081642495abefbed2f2935", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc"}}
{"id": "sha256:11830a60422e4a79bff77e0bd99ca999d9e633b0ba38bde8518f157467353969", "content": "Remember-me is used with `UsernamePasswordAuthenticationFilter` and is implemented through hooks in the `AbstractAuthenticationProcessingFilter` superclass.\nIt is also used within `BasicAuthenticationFilter`.\nThe hooks invoke a concrete `RememberMeServices` at the appropriate times.\nThe following listing shows the interface:\n\n[source,java]\n----\nAuthentication autoLogin(HttpServletRequest request, HttpServletResponse response);\n\nvoid loginFail(HttpServletRequest request, HttpServletResponse response);\n\nvoid loginSuccess(HttpServletRequest request, HttpServletResponse response,\n\tAuthentication successfulAuthentication);\n----\n\nSee the Javadoc for javadoc:org.springframework.security.web.authentication.RememberMeServices[] for a fuller discussion on what the methods do, although note that, at this stage, `AbstractAuthenticationProcessingFilter` calls only the `loginFail()` and `loginSuccess()` methods.\nThe `autoLogin()` method is called by `RememberMeAuthenticationFilter` whenever the `SecurityContextHolder` does not contain an `Authentication`.\nThis interface, therefore, provides the underlying remember-me implementation with sufficient notification of authentication-related events and delegates to the implementation whenever a candidate web request might contain a cookie and wish to be remembered.\nThis design allows any number of remember-me implementation strategies.\n\nWe have seen earlier that Spring Security provides two implementations.\nWe look at each of these in turn.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc", "title": "rememberme", "heading": "Remember-Me Interfaces and Implementations", "heading_level": 2, "file_order": 108, "section_index": 3, "content_hash": "11830a60422e4a79bff77e0bd99ca999d9e633b0ba38bde8518f157467353969", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc"}}
{"id": "sha256:749ec7f436df8a618d35d7636e3398497b72c976f9fd51394947904c00d46395", "content": "This implementation supports the simpler approach described in <<remember-me-hash-token>>.\n`TokenBasedRememberMeServices` generates a `RememberMeAuthenticationToken`, which is processed by `RememberMeAuthenticationProvider`.\nA `key` is shared between this authentication provider and the `TokenBasedRememberMeServices`.\nIn addition, `TokenBasedRememberMeServices` requires a `UserDetailsService`, from which it can retrieve the username and password for signature comparison purposes and generate the `RememberMeAuthenticationToken` to contain the correct `GrantedAuthority` instances.\n`TokenBasedRememberMeServices` also implements Spring Security's `LogoutHandler` interface so that it can be used with `LogoutFilter` to have the cookie cleared automatically.\n\nBy default, this implementation uses the SHA-256 algorithm to encode the token signature.\nTo verify the token signature, the algorithm retrieved from `algorithmName` is parsed and used.\nIf no `algorithmName` is present, the default matching algorithm will be used, which is SHA-256.\nYou can specify different algorithms for signature encoding and for signature matching, this allows users to safely upgrade to a different encoding algorithm while still able to verify old ones if there is no `algorithmName` present.\nTo do that you can specify your customized `TokenBasedRememberMeServices` as a Bean and use it in the configuration.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain securityFilterChain(HttpSecurity http, RememberMeServices rememberMeServices) throws Exception {\n\thttp\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .rememberMe((remember) -> remember\n .rememberMeServices(rememberMeServices)\n );\n\treturn http.build();\n}\n\n@Bean\nRememberMeServices rememberMeServices(UserDetailsService userDetailsService) {\n\tRememberMeTokenAlgorithm encodingAlgorithm = RememberMeTokenAlgorithm.SHA256;\n\tTokenBasedRememberMeServices rememberMe = new TokenBasedRememberMeServices(myKey, userDetailsService, encodingAlgorithm);\n\trememberMe.setMatchingAlgorithm(RememberMeTokenAlgorithm.MD5);\n\treturn rememberMe;\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <remember-me services-ref=\"rememberMeServices\"/>\n</http>\n\n<bean id=\"rememberMeServices\" class=\n\"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices\">\n <property name=\"userDetailsService\" ref=\"myUserDetailsService\"/>\n <property name=\"key\" value=\"springRocks\"/>\n <property name=\"matchingAlgorithm\" value=\"MD5\"/>\n <property name=\"encodingAlgorithm\" value=\"SHA256\"/>\n</bean>\n----\n======\n\nThe following beans are required in an application context to enable remember-me services:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nRememberMeAuthenticationFilter rememberMeFilter() {\n RememberMeAuthenticationFilter rememberMeFilter = new RememberMeAuthenticationFilter();\n rememberMeFilter.setRememberMeServices(rememberMeServices());\n rememberMeFilter.setAuthenticationManager(theAuthenticationManager);\n return rememberMeFilter;\n}\n\n@Bean\nTokenBasedRememberMeServices rememberMeServices() {\n TokenBasedRememberMeServices rememberMeServices = new TokenBasedRememberMeServices();\n rememberMeServices.setUserDetailsService(myUserDetailsService);\n rememberMeServices.setKey(\"springRocks\");\n return rememberMeServices;\n}\n\n@Bean\nRememberMeAuthenticationProvider rememberMeAuthenticationProvider() {\n RememberMeAuthenticationProvider rememberMeAuthenticationProvider = new RememberMeAuthenticationProvider();\n rememberMeAuthenticationProvider.setKey(\"springRocks\");\n return rememberMeAuthenticationProvider;\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<bean id=\"rememberMeFilter\" class=\n\"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter\">\n<property name=\"rememberMeServices\" ref=\"rememberMeServices\"/>\n<property name=\"authenticationManager\" ref=\"theAuthenticationManager\" />\n</bean>\n\n<bean id=\"rememberMeServices\" class=\n\"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices\">\n<property name=\"userDetailsService\" ref=\"myUserDetailsService\"/>\n<property name=\"key\" value=\"springRocks\"/>\n</bean>\n\n<bean id=\"rememberMeAuthenticationProvider\" class=\n\"org.springframework.security.authentication.RememberMeAuthenticationProvider\">\n<property name=\"key\" value=\"springRocks\"/>\n</bean>\n----\n======\n\nRemember to add your `RememberMeServices` implementation to your `UsernamePasswordAuthenticationFilter.setRememberMeServices()` property, include the `RememberMeAuthenticationProvider` in your `AuthenticationManager.setProviders()` list, and add `RememberMeAuthenticationFilter` into your `FilterChainProxy` (typically immediately after your `UsernamePasswordAuthenticationFilter`).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc", "title": "rememberme", "heading": "TokenBasedRememberMeServices", "heading_level": 3, "file_order": 108, "section_index": 4, "content_hash": "749ec7f436df8a618d35d7636e3398497b72c976f9fd51394947904c00d46395", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc"}}
{"id": "sha256:97ea08c40b1503de3e0bfff8db58054903efa7d9e9896a79d76e56cdc49549fa", "content": "You can use this class in the same way as `TokenBasedRememberMeServices`, but it additionally needs to be configured with a `PersistentTokenRepository` to store the tokens.\n\n* `InMemoryTokenRepositoryImpl` which is intended for testing only.\n* `JdbcTokenRepositoryImpl` which stores the tokens in a database.\n\nSee <<remember-me-persistent-token>> for the database schema.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc", "title": "rememberme", "heading": "PersistentTokenBasedRememberMeServices", "heading_level": 3, "file_order": 108, "section_index": 5, "content_hash": "97ea08c40b1503de3e0bfff8db58054903efa7d9e9896a79d76e56cdc49549fa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/rememberme.adoc"}}
{"id": "sha256:06865bb17d3bbe4c4c566672d0b2b09963af15eba206d8b1722295af67bd38ba", "content": "[[runas]]\n\n[[runas-overview]]\nThe `AbstractSecurityInterceptor` is able to temporarily replace the `Authentication` object in the `SecurityContext` and `SecurityContextHolder` during the secure object callback phase.\nThis only occurs if the original `Authentication` object was successfully processed by the `AuthenticationManager` and `AccessDecisionManager`.\nThe `RunAsManager` indicates the replacement `Authentication` object, if any, that should be used during the `SecurityInterceptorCallback`.\n\nBy temporarily replacing the `Authentication` object during the secure object callback phase, the secured invocation can call other objects that require different authentication and authorization credentials.\nIt can also perform any internal security checks for specific `GrantedAuthority` objects.\nBecause Spring Security provides a number of helper classes that automatically configure remoting protocols based on the contents of the `SecurityContextHolder`, these run-as replacements are particularly useful when calling remote web services.\n\n[[runas-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/runas.adoc", "title": "runas", "heading": "runas", "heading_level": 1, "file_order": 109, "section_index": 0, "content_hash": "06865bb17d3bbe4c4c566672d0b2b09963af15eba206d8b1722295af67bd38ba", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/runas.adoc"}}
{"id": "sha256:595abe5e8384ab20d18c868b421d4886f33f1072f345fc70d4725a8d0fb04222", "content": "Spring Security provides a `RunAsManager` interface:\n\n[source,java]\n----\nAuthentication buildRunAs(Authentication authentication, Object object,\n\tList<ConfigAttribute> config);\n\nboolean supports(ConfigAttribute attribute);\n\nboolean supports(Class clazz);\n----\n\nThe first method returns the `Authentication` object that should replace the existing `Authentication` object for the duration of the method invocation.\nIf the method returns `null`, it indicates no replacement should be made.\nThe second method is used by the `AbstractSecurityInterceptor` as part of its startup validation of configuration attributes.\nThe `supports(Class)` method is called by a security interceptor implementation to ensure that the configured `RunAsManager` supports the type of secure object that the security interceptor presents.\n\nSpring Security provides one concrete implementation of `RunAsManager`.\nThe `RunAsManagerImpl` class returns a replacement `RunAsUserToken` if any `ConfigAttribute` starts with `RUN_AS_`.\nIf any such `ConfigAttribute` is found, the replacement `RunAsUserToken` contains the same principal, credentials, and granted authorities as the original `Authentication` object, along with a new `SimpleGrantedAuthority` for each `RUN_AS_` `ConfigAttribute`.\nEach new `SimpleGrantedAuthority` is prefixed with `ROLE_`, followed by the `RUN_AS` `ConfigAttribute`.\nFor example, a `RUN_AS_SERVER` results in the replacement `RunAsUserToken` containing a `ROLE_RUN_AS_SERVER` granted authority.\n\nThe replacement `RunAsUserToken` is like any other `Authentication` object.\nIt needs to be authenticated by the `AuthenticationManager`, probably through delegation to a suitable `AuthenticationProvider`.\nThe `RunAsImplAuthenticationProvider` performs such authentication.\nIt accepts as valid any `RunAsUserToken` presented.\n\nTo ensure malicious code does not create a `RunAsUserToken` and present it for guaranteed acceptance by the `RunAsImplAuthenticationProvider`, the hash of a key is stored in all generated tokens.\nThe `RunAsManagerImpl` and `RunAsImplAuthenticationProvider` is created in the bean context with the same key:\n\n[source,xml]\n----\n<bean id=\"runAsManager\"\n\tclass=\"org.springframework.security.access.intercept.RunAsManagerImpl\">\n<property name=\"key\" value=\"my_run_as_password\"/>\n</bean>\n\n<bean id=\"runAsAuthenticationProvider\"\n\tclass=\"org.springframework.security.access.intercept.RunAsImplAuthenticationProvider\">\n<property name=\"key\" value=\"my_run_as_password\"/>\n</bean>\n----\n\nBy using the same key, each `RunAsUserToken` can be validated because it was created by an approved `RunAsManagerImpl`.\nThe `RunAsUserToken` is immutable after creation, for security reasons.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/runas.adoc", "title": "runas", "heading": "Configuration", "heading_level": 2, "file_order": 109, "section_index": 1, "content_hash": "595abe5e8384ab20d18c868b421d4886f33f1072f345fc70d4725a8d0fb04222", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/runas.adoc"}}
{"id": "sha256:72af6af914ea3c19522c9dac5e901983c81d3220ee98687f7995ff238963ab7a", "content": "[[session-mgmt]]\n\nOnce you have got an application that is xref:servlet/authentication/index.adoc[authenticating requests], it is important to consider how that resulting authentication will be persisted and restored on future requests.\n\nThis is done automatically by default, so no additional code is necessary, though it is important to know what `requireExplicitSave` means in `HttpSecurity`.\n\nIf you like, <<how-it-works-requireexplicitsave,you can read more about what requireExplicitSave is doing>> or <<requireexplicitsave,why it's important>>. Otherwise, in most cases you are done with this section.\n\nBut before you leave, consider if any of these use cases fit your application:\n\n* I want to <<understanding-session-management-components,Understand Session Management's components>>\n* I want to <<ns-concurrent-sessions,restrict the number of times>> a user can be logged in concurrently\n* I want <<store-authentication-manually,to store the authentication directly>> myself instead of Spring Security doing it for me\n* I am storing the authentication manually and I want <<properly-clearing-authentication,to remove it>>\n* I am using <<the-sessionmanagementfilter, `SessionManagementFilter`>> and I need <<moving-away-from-sessionmanagementfilter,guidance on moving away from that>>\n* I want to store the authentication <<customizing-where-authentication-is-stored,in something other than the session>>\n* I am using a <<stateless-authentication, stateless authentication>>, but <<storing-stateless-authentication-in-the-session,I'd still like to store it in the session>>\n* I am using `SessionCreationPolicy.NEVER` but <<never-policy-session-still-created,the application is still creating sessions>>.\n\n[[understanding-session-management-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "session-management", "heading_level": 1, "file_order": 110, "section_index": 0, "content_hash": "72af6af914ea3c19522c9dac5e901983c81d3220ee98687f7995ff238963ab7a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:2add1b3f969a7b8f30cdeea9b0a7e23b60d1717aaf00faa8888da1c01593d756", "content": "The Session Management support is composed of a few components that work together to provide the functionality.\nThose components are, xref:servlet/authentication/persistence.adoc#securitycontextholderfilter[the `SecurityContextHolderFilter`], xref:servlet/authentication/persistence.adoc#securitycontextpersistencefilter[the `SecurityContextPersistenceFilter`] and <<the-sessionmanagementfilter,the `SessionManagementFilter`>>.\n\n[NOTE]\n=====\nIn Spring Security 6, the `SecurityContextPersistenceFilter` and `SessionManagementFilter` are not set by default.\nIn addition to that, any application should only have either `SecurityContextHolderFilter` or `SecurityContextPersistenceFilter` set, never both.\n=====\n\n[[the-sessionmanagementfilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Understanding Session Management's Components", "heading_level": 2, "file_order": 110, "section_index": 1, "content_hash": "2add1b3f969a7b8f30cdeea9b0a7e23b60d1717aaf00faa8888da1c01593d756", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:69aba60e94834f45b428b832f0b8390a628b9c2ef1ca41b4d2b492214bf59d07", "content": "The `SessionManagementFilter` checks the contents of the `SecurityContextRepository` against the current contents of the `SecurityContextHolder` to determine whether a user has been authenticated during the current request, typically by a non-interactive authentication mechanism, such as pre-authentication or remember-me footnote:[\nAuthentication by mechanisms which perform a redirect after authenticating (such as form-login) will not be detected by `SessionManagementFilter`, as the filter will not be invoked during the authenticating request.\nSession-management functionality has to be handled separately in these cases.\n].\nIf the repository contains a security context, the filter does nothing.\nIf it doesn't, and the thread-local `SecurityContext` contains a (non-anonymous) `Authentication` object, the filter assumes they have been authenticated by a previous filter in the stack.\nIt will then invoke the configured `SessionAuthenticationStrategy`.\n\nIf the user is not currently authenticated, the filter will check whether an invalid session ID has been requested (because of a timeout, for example) and will invoke the configured `InvalidSessionStrategy`, if one is set.\nThe most common behaviour is just to redirect to a fixed URL and this is encapsulated in the standard implementation `SimpleRedirectInvalidSessionStrategy`.\nThe latter is also used when configuring an invalid session URL through the namespace, <<session-mgmt,as described earlier>>.\n\n[[moving-away-from-sessionmanagementfilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "The `SessionManagementFilter`", "heading_level": 3, "file_order": 110, "section_index": 2, "content_hash": "69aba60e94834f45b428b832f0b8390a628b9c2ef1ca41b4d2b492214bf59d07", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:0ad25eafdc728cc31088a928d1c4cb8a5d28ce92800348bccaa33364f6c1846a", "content": "In Spring Security 5, the default configuration relies on `SessionManagementFilter` to detect if a user just authenticated and invoke the javadoc:org.springframework.security.web.authentication.session.SessionAuthenticationStrategy[SessionAuthenticationStrategy].\nThe problem with this is that it means that in a typical setup, the `HttpSession` must be read for every request.\n\nIn Spring Security 6, the default is that authentication mechanisms themselves must invoke the `SessionAuthenticationStrategy`.\nThis means that there is no need to detect when `Authentication` is done and thus the `HttpSession` does not need to be read for every request.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Moving Away From `SessionManagementFilter`", "heading_level": 4, "file_order": 110, "section_index": 3, "content_hash": "0ad25eafdc728cc31088a928d1c4cb8a5d28ce92800348bccaa33364f6c1846a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:98463897c9c478ada065d2cffcd0781276446112802698345a32cdf9199e8cfe", "content": "In Spring Security 6, the `SessionManagementFilter` is not used by default, therefore, some methods from the `sessionManagement` DSL will not have any effect.\n\n|===\n|Method |Replacement\n\n|`sessionAuthenticationErrorUrl`\n|Configure an javadoc:org.springframework.security.web.authentication.AuthenticationFailureHandler[] in your authentication mechanism\n\n|`sessionAuthenticationFailureHandler`\n|Configure an javadoc:org.springframework.security.web.authentication.AuthenticationFailureHandler[] in your authentication mechanism\n\n|`sessionAuthenticationStrategy`\n|Configure an `SessionAuthenticationStrategy` in your authentication mechanism as <<moving-away-from-sessionmanagementfilter,discussed above>>\n|===\n\nIf you try to use any of these methods, an exception will be thrown.\n\n[[customizing-where-authentication-is-stored]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Things To Consider When Moving Away From `SessionManagementFilter`", "heading_level": 4, "file_order": 110, "section_index": 4, "content_hash": "98463897c9c478ada065d2cffcd0781276446112802698345a32cdf9199e8cfe", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:22350f25bc0af2142418a00f5bb00060f1871648b1c91d0d80637caf5b9e8efd", "content": "By default, Spring Security stores the security context for you in the HTTP session. However, here are several reasons you may want to customize that:\n\n* You may want to call individual setters on the `HttpSessionSecurityContextRepository` instance\n* You may want to store the security context in a cache or database to enable horizontal scaling\n\nFirst, you need to create an implementation of `SecurityContextRepository` or use an existing implementation like `HttpSessionSecurityContextRepository`, then you can set it in `HttpSecurity`.\n\n[[customizing-the-securitycontextrepository]]\n.Customizing the `SecurityContextRepository`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n SecurityContextRepository repo = new MyCustomSecurityContextRepository();\n http\n // ...\n .securityContext((context) -> context\n .securityContextRepository(repo)\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n val repo = MyCustomSecurityContextRepository()\n http {\n // ...\n securityContext {\n securityContextRepository = repo\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http security-context-repository-ref=\"repo\">\n <!-- ... -->\n</http>\n<bean name=\"repo\" class=\"com.example.MyCustomSecurityContextRepository\" />\n----\n======\n\n[NOTE]\n====\nThe above configuration sets the `SecurityContextRepository` on the `SecurityContextHolderFilter` and **participating** authentication filters, like `UsernamePasswordAuthenticationFilter`.\nTo also set it in stateless filters, please see <<storing-stateless-authentication-in-the-session,how to customize the `SecurityContextRepository` for Stateless Authentication>>.\n====\n\nIf you are using a custom authentication mechanism, you might want to <<store-authentication-manually,store the `Authentication` by yourself>>.\n\n[[store-authentication-manually]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Customizing Where the Authentication Is Stored", "heading_level": 2, "file_order": 110, "section_index": 5, "content_hash": "22350f25bc0af2142418a00f5bb00060f1871648b1c91d0d80637caf5b9e8efd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:fa4fe3b8c93f61588b455eefc8426cb35428ac038f1ac13c6f6c33900dae5229", "content": "In some cases, for example, you might be authenticating a user manually instead of relying on Spring Security filters.\nYou can use a custom filters or a {spring-framework-reference-url}/web.html#mvc-controller[Spring MVC controller] endpoint to do that.\nIf you want to save the authentication between requests, in the `HttpSession`, for example, you have to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nprivate SecurityContextRepository securityContextRepository =\n new HttpSessionSecurityContextRepository(); <1>\n\n@PostMapping(\"/login\")\npublic void login(@RequestBody LoginRequest loginRequest, HttpServletRequest request, HttpServletResponse response) { <2>\n UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(\n loginRequest.getUsername(), loginRequest.getPassword()); <3>\n Authentication authentication = authenticationManager.authenticate(token); <4>\n SecurityContext context = securityContextHolderStrategy.createEmptyContext();\n context.setAuthentication(authentication); <5>\n securityContextHolderStrategy.setContext(context);\n securityContextRepository.saveContext(context, request, response); <6>\n}\n\nclass LoginRequest {\n\n private String username;\n private String password;\n\n // getters and setters\n}\n----\n======\n\n<1> Add the `SecurityContextRepository` to the controller\n<2> Inject the `HttpServletRequest` and `HttpServletResponse` to be able to save the `SecurityContext`\n<3> Create an unauthenticated `UsernamePasswordAuthenticationToken` using the provided credentials\n<4> Call `AuthenticationManager#authenticate` to authenticate the user\n<5> Create a `SecurityContext` and set the `Authentication` in it\n<6> Save the `SecurityContext` in the `SecurityContextRepository`\n\nAnd that's it.\nIf you are not sure what `securityContextHolderStrategy` is in the above example, you can read more about it in the <<use-securitycontextholderstrategy, Using `SecurityContextStrategy` section>>.\n\n[[properly-clearing-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Storing the `Authentication` manually", "heading_level": 3, "file_order": 110, "section_index": 6, "content_hash": "fa4fe3b8c93f61588b455eefc8426cb35428ac038f1ac13c6f6c33900dae5229", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:00de0938c66f75282522aabee2a4ace113cbfaca1b21c59402a6a519cf80d99e", "content": "If you are using Spring Security's xref:servlet/authentication/logout.adoc[Logout Support] then it handles a lot of stuff for you including clearing and saving the context.\nBut, let's say you need to manually log users out of your app. In that case, you'll need to make sure you're xref:servlet/authentication/logout.adoc#creating-custom-logout-endpoint[clearing and saving the context properly].\n\n[[stateless-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Properly Clearing an Authentication", "heading_level": 3, "file_order": 110, "section_index": 7, "content_hash": "00de0938c66f75282522aabee2a4ace113cbfaca1b21c59402a6a519cf80d99e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:b1fb01ac760b0a710dafd01a5078c0530f4f358cd1c8694b5465975d6bd57a53", "content": "Sometimes there is no need to create and maintain a `HttpSession` for example, to persist the authentication across requests.\nSome authentication mechanisms like xref:servlet/authentication/passwords/basic.adoc[HTTP Basic] are stateless and, therefore, re-authenticates the user on every request.\n\nIf you do not wish to create sessions, you can use `SessionCreationPolicy.STATELESS`, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n http\n // ...\n .sessionManagement((session) -> session\n .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n sessionManagement {\n sessionCreationPolicy = SessionCreationPolicy.STATELESS\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http create-session=\"stateless\">\n <!-- ... -->\n</http>\n----\n======\n\nThe above configuration is <<customizing-where-authentication-is-stored, configuring the `SecurityContextRepository`>> to use a `NullSecurityContextRepository` and is also xref:servlet/architecture.adoc#requestcache-prevent-saved-request[preventing the request from being saved in the session].\n\n[[never-policy-session-still-created]]\nIf you are using `SessionCreationPolicy.NEVER`, you might notice that the application is still creating a `HttpSession`.\nIn most cases, this happens because the xref:servlet/architecture.adoc#savedrequests[request is saved in the session] for the authenticated resource to re-request after authentication is successful.\nTo avoid that, please refer to xref:servlet/architecture.adoc#requestcache-prevent-saved-request[how to prevent the request of being saved] section.\n\n[[storing-stateless-authentication-in-the-session]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Configuring Persistence for Stateless Authentication", "heading_level": 3, "file_order": 110, "section_index": 8, "content_hash": "b1fb01ac760b0a710dafd01a5078c0530f4f358cd1c8694b5465975d6bd57a53", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:0c37b5f8e48ddf9892300c8434ddfeada344f2deea95b1b0c298438c2b4ade34", "content": "If, for some reason, you are using a stateless authentication mechanism, but you still want to store the authentication in the session you can use the `HttpSessionSecurityContextRepository` instead of the `NullSecurityContextRepository`.\n\nFor the xref:servlet/authentication/passwords/basic.adoc[HTTP Basic], you can add xref:servlet/configuration/java.adoc#post-processing-configured-objects[a `ObjectPostProcessor`] that changes the `SecurityContextRepository` used by the `BasicAuthenticationFilter`:\n\n.Store HTTP Basic authentication in the `HttpSession`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain web(HttpSecurity http) throws Exception {\n http\n // ...\n .httpBasic((basic) -> basic\n .addObjectPostProcessor(new ObjectPostProcessor<BasicAuthenticationFilter>() {\n @Override\n public <O extends BasicAuthenticationFilter> O postProcess(O filter) {\n filter.setSecurityContextRepository(new HttpSessionSecurityContextRepository());\n return filter;\n }\n })\n );\n\n return http.build();\n}\n----\n======\n\nThe above also applies to others authentication mechanisms, like xref:servlet/oauth2/resource-server/index.adoc[Bearer Token Authentication].\n\n[[requireexplicitsave]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Storing Stateless Authentication in the Session", "heading_level": 4, "file_order": 110, "section_index": 9, "content_hash": "0c37b5f8e48ddf9892300c8434ddfeada344f2deea95b1b0c298438c2b4ade34", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:5889ff6a9e66526a2401e6c521a4c917bc30365a0c8cf4e5e12871c695a3ad5e", "content": "In Spring Security 5, the default behavior is for the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontext[`SecurityContext`] to automatically be saved to the xref:servlet/authentication/persistence.adoc#securitycontextrepository[`SecurityContextRepository`] using the <<securitycontextpersistencefilter, `SecurityContextPersistenceFilter`>>.\nSaving must be done just prior to the `HttpServletResponse` being committed and just before `SecurityContextPersistenceFilter`.\nUnfortunately, automatic persistence of the `SecurityContext` can surprise users when it is done prior to the request completing (i.e. just prior to committing the `HttpServletResponse`).\nIt also is complex to keep track of the state to determine if a save is necessary causing unnecessary writes to the `SecurityContextRepository` (i.e. `HttpSession`) at times.\n\nFor these reasons, the `SecurityContextPersistenceFilter` has been deprecated to be replaced with the `SecurityContextHolderFilter`.\nIn Spring Security 6, the default behavior is that xref:servlet/authentication/persistence.adoc#securitycontextholderfilter[the `SecurityContextHolderFilter`] will only read the `SecurityContext` from `SecurityContextRepository` and populate it in the `SecurityContextHolder`.\nUsers now must explicitly save the `SecurityContext` with the `SecurityContextRepository` if they want the `SecurityContext` to persist between requests.\nThis removes ambiguity and improves performance by only requiring writing to the `SecurityContextRepository` (i.e. `HttpSession`) when it is necessary.\n\n[[how-it-works-requireexplicitsave]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Understanding Require Explicit Save", "heading_level": 2, "file_order": 110, "section_index": 10, "content_hash": "5889ff6a9e66526a2401e6c521a4c917bc30365a0c8cf4e5e12871c695a3ad5e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:52d686ba8132ea168f064f26b5557738aee042f1d0633d853fb5199841589507", "content": "In summary, when `requireExplicitSave` is `true`, Spring Security sets up xref:servlet/authentication/persistence.adoc#securitycontextholderfilter[the `SecurityContextHolderFilter`] instead of xref:servlet/authentication/persistence.adoc#securitycontextpersistencefilter[the `SecurityContextPersistenceFilter`]\n\n[[ns-concurrent-sessions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "How it works", "heading_level": 3, "file_order": 110, "section_index": 11, "content_hash": "52d686ba8132ea168f064f26b5557738aee042f1d0633d853fb5199841589507", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:e467e19d8da704fef2647bcce967106cb2034e451dd71b8f86b7775aab8e9e52", "content": "If you wish to place constraints on a single user's ability to log in to your application, Spring Security supports this out of the box with the following simple additions.\nFirst, you need to add the following listener to your configuration to keep Spring Security updated about session lifecycle events:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic HttpSessionEventPublisher httpSessionEventPublisher() {\n return new HttpSessionEventPublisher();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun httpSessionEventPublisher(): HttpSessionEventPublisher {\n return HttpSessionEventPublisher()\n}\n----\n\nweb.xml::\n+\n[source,xml,role=\"secondary\"]\n----\n<listener>\n<listener-class>\n org.springframework.security.web.session.HttpSessionEventPublisher\n</listener-class>\n</listener>\n----\n======\n\nThen add the following lines to your security configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n http\n .sessionManagement((session) -> session\n .maximumSessions(1)\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n sessionManagement {\n sessionConcurrency {\n maximumSessions = 1\n }\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n...\n<session-management>\n <concurrency-control max-sessions=\"1\" />\n</session-management>\n</http>\n----\n======\n\nThis will prevent a user from logging in multiple times - a second login will cause the first to be invalidated.\n\nYou can also adjust this based on who the user is.\nFor example, administrators may be able to have more than one session:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n\tAuthorizationManager<?> isAdmin = AuthorityAuthorizationManager.hasRole(\"ADMIN\");\n http\n .sessionManagement((session) -> session\n .maximumSessions((authentication) -> isAdmin.authorize(() -> authentication, null).isGranted() ? -1 : 1)\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n val isAdmin: AuthorizationManager<*> = AuthorityAuthorizationManager.hasRole(\"ADMIN\")\n http {\n sessionManagement {\n sessionConcurrency {\n maximumSessions {\n authentication -> if (isAdmin.authorize({ authentication }, null)!!.isGranted) -1 else 1\n }\n }\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n...\n<session-management>\n <concurrency-control max-sessions-ref=\"sessionLimit\" />\n</session-management>\n</http>\n\n<b:bean id=\"sessionLimit\" class=\"my.SessionLimitImplementation\"/>\n----\n======\n\nUsing Spring Boot, you can test the above configurations in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureMockMvc\npublic class MaximumSessionsTests {\n\n @Autowired\n private MockMvc mvc;\n\n @Test\n void loginOnSecondLoginThenFirstSessionTerminated() throws Exception {\n MvcResult mvcResult = this.mvc.perform(formLogin())\n .andExpect(authenticated())\n .andReturn();\n\n MockHttpSession firstLoginSession = (MockHttpSession) mvcResult.getRequest().getSession();\n\n this.mvc.perform(get(\"/\").session(firstLoginSession))\n .andExpect(authenticated());\n\n this.mvc.perform(formLogin()).andExpect(authenticated());\n\n // first session is terminated by second login\n this.mvc.perform(get(\"/\").session(firstLoginSession))\n .andExpect(unauthenticated());\n }\n\n}\n----\n======\n\nYou can try it using the {gh-samples-url}/servlet/spring-boot/java/session-management/maximum-sessions[Maximum Sessions sample].\n\nIt is also common that you would prefer to prevent a second login, in which case you can use:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n http\n .sessionManagement((session) -> session\n .maximumSessions(1)\n .maxSessionsPreventsLogin(true)\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n sessionManagement {\n sessionConcurrency {\n maximumSessions = 1\n maxSessionsPreventsLogin = true\n }\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n<session-management>\n <concurrency-control max-sessions=\"1\" error-if-maximum-exceeded=\"true\" />\n</session-management>\n</http>\n----\n======\n\nThe second login will then be rejected.\nBy \"rejected\", we mean that the user will be sent to the `authentication-failure-url` if form-based login is being used.\nIf the second authentication takes place through another non-interactive mechanism, such as \"remember-me\", an \"unauthorized\" (401) error will be sent to the client.\nIf instead you want to use an error page, you can add the attribute `session-authentication-error-url` to the `session-management` element.\n\nUsing Spring Boot, you can test the above configuration the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@AutoConfigureMockMvc\npublic class MaximumSessionsPreventLoginTests {\n\n @Autowired\n private MockMvc mvc;\n\n @Test\n void loginOnSecondLoginThenPreventLogin() throws Exception {\n MvcResult mvcResult = this.mvc.perform(formLogin())\n .andExpect(authenticated())\n .andReturn();\n\n MockHttpSession firstLoginSession = (MockHttpSession) mvcResult.getRequest().getSession();\n\n this.mvc.perform(get(\"/\").session(firstLoginSession))\n .andExpect(authenticated());\n\n // second login is prevented\n this.mvc.perform(formLogin()).andExpect(unauthenticated());\n\n // first session is still valid\n this.mvc.perform(get(\"/\").session(firstLoginSession))\n .andExpect(authenticated());\n }\n\n}\n----\n======\n\nIf you are using a customized authentication filter for form-based login, then you have to configure concurrent session control support explicitly.\nYou can try it using the {gh-samples-url}/servlet/spring-boot/java/session-management/maximum-sessions-prevent-login[Maximum Sessions Prevent Login sample].\n\n[NOTE]\n=====\nIf you are using a custom implementation of `UserDetails`, ensure you override the **equals()** and **hashCode()** methods.\nThe default `SessionRegistry` implementation in Spring Security relies on an in-memory Map that uses these methods to correctly identify and manage user sessions.\nFailing to override them may lead to issues where session tracking and user comparison behave unexpectedly.\n=====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Configuring Concurrent Session Control", "heading_level": 2, "file_order": 110, "section_index": 12, "content_hash": "e467e19d8da704fef2647bcce967106cb2034e451dd71b8f86b7775aab8e9e52", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:a25d32539eeea4d6af3438945cdf7a9f220c8a9a7bf0d48f05ad52eb9e2d9b19", "content": "Sessions expire on their own, and there is nothing that needs to be done to ensure that a security context gets removed.\nThat said, Spring Security can detect when a session has expired and take specific actions that you indicate.\nFor example, you may want to redirect to a specific endpoint when a user makes a request with an already-expired session.\nThis is achieved through the `invalidSessionUrl` in `HttpSecurity`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n http\n .sessionManagement((session) -> session\n .invalidSessionUrl(\"/invalidSession\")\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n sessionManagement {\n invalidSessionUrl = \"/invalidSession\"\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n...\n<session-management invalid-session-url=\"/invalidSession\" />\n</http>\n----\n======\n\nNote that if you use this mechanism to detect session timeouts, it may falsely report an error if the user logs out and then logs back in without closing the browser.\nThis is because the session cookie is not cleared when you invalidate the session and will be resubmitted even if the user has logged out.\nIf that is your case, you might want to <<clearing-session-cookie-on-logout,configure logout to clear the session cookie>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Detecting Timeouts", "heading_level": 2, "file_order": 110, "section_index": 13, "content_hash": "a25d32539eeea4d6af3438945cdf7a9f220c8a9a7bf0d48f05ad52eb9e2d9b19", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:9e6b51c4f279e15cff2d39a3106e9b8dcf05488e0905d9696570292b74cbf04e", "content": "The `invalidSessionUrl` is a convenience method for setting the `InvalidSessionStrategy` using the javadoc:org.springframework.security.web.session.SimpleRedirectInvalidSessionStrategy[`SimpleRedirectInvalidSessionStrategy` implementation].\nIf you want to customize the behavior, you can implement the javadoc:org.springframework.security.web.session.InvalidSessionStrategy[] interface and configure it using the `invalidSessionStrategy` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n http\n .sessionManagement((session) -> session\n .invalidSessionStrategy(new MyCustomInvalidSessionStrategy())\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n sessionManagement {\n invalidSessionStrategy = MyCustomInvalidSessionStrategy()\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n...\n<session-management invalid-session-strategy-ref=\"myCustomInvalidSessionStrategy\" />\n<bean name=\"myCustomInvalidSessionStrategy\" class=\"com.example.MyCustomInvalidSessionStrategy\" />\n</http>\n----\n======\n\n[[clearing-session-cookie-on-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Customizing the Invalid Session Strategy", "heading_level": 3, "file_order": 110, "section_index": 14, "content_hash": "9e6b51c4f279e15cff2d39a3106e9b8dcf05488e0905d9696570292b74cbf04e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:6563b8d03201d55d70dacf13b3df93c94132bfd1b068256e3b7c010c45907a73", "content": "You can explicitly delete the JSESSIONID cookie on logging out, for example by using the https://w3c.github.io/webappsec-clear-site-data/[`Clear-Site-Data` header] in the logout handler:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n http\n .logout((logout) -> logout\n .addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(COOKIES)))\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n logout {\n addLogoutHandler(HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter(COOKIES)))\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n<logout success-handler-ref=\"clearSiteDataHandler\" />\n<b:bean id=\"clearSiteDataHandler\" class=\"org.springframework.security.web.authentication.logout.HeaderWriterLogoutHandler\">\n <b:constructor-arg>\n <b:bean class=\"org.springframework.security.web.header.writers.ClearSiteDataHeaderWriter\">\n <b:constructor-arg>\n <b:list>\n <b:value>COOKIES</b:value>\n </b:list>\n </b:constructor-arg>\n </b:bean>\n </b:constructor-arg>\n</b:bean>\n</http>\n----\n======\n\nThis has the advantage of being container agnostic and will work with any container that supports the `Clear-Site-Data` header.\n\nAs an alternative, you can also use the following syntax in the logout handler:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n http\n .logout((logout) -> logout\n .deleteCookies(\"JSESSIONID\")\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n logout {\n deleteCookies(\"JSESSIONID\")\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <logout delete-cookies=\"JSESSIONID\" />\n</http>\n----\n======\n\nUnfortunately, this cannot be guaranteed to work with every servlet container, so you need to test it in your environment.\n\n[NOTE]\n=====\nIf you run your application behind a proxy, you may also be able to remove the session cookie by configuring the proxy server.\nFor example, by using Apache HTTPD's `mod_headers`, the following directive deletes the `JSESSIONID` cookie by expiring it in the response to a logout request (assuming the application is deployed under the `/tutorial` path):\n=====\n\n[source,xml]\n----\n<LocationMatch \"/tutorial/logout\">\nHeader always set Set-Cookie \"JSESSIONID=;Path=/tutorial;Expires=Thu, 01 Jan 1970 00:00:00 GMT\"\n</LocationMatch>\n----\n\nMore details on the xref:servlet/exploits/headers.adoc#servlet-headers-clear-site-data[Clear Site Data] and xref:servlet/authentication/logout.adoc[Logout sections].\n\n[[ns-session-fixation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Clearing Session Cookies on Logout", "heading_level": 2, "file_order": 110, "section_index": 15, "content_hash": "6563b8d03201d55d70dacf13b3df93c94132bfd1b068256e3b7c010c45907a73", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:6e96692eebe09f061aadaf21440eae4c114bd532b86491742029c8c4807b293c", "content": "https://en.wikipedia.org/wiki/Session_fixation[Session fixation] attacks are a potential risk where it is possible for a malicious attacker to create a session by accessing a site, then persuade another user to log in with the same session (by sending them a link containing the session identifier as a parameter, for example).\nSpring Security protects against this automatically by creating a new session or otherwise changing the session ID when a user logs in.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Understanding Session Fixation Attack Protection", "heading_level": 2, "file_order": 110, "section_index": 16, "content_hash": "6e96692eebe09f061aadaf21440eae4c114bd532b86491742029c8c4807b293c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:1004b779a83f73203c57d07c1b181ed008061609c5c2a0ae5845ba49cc91837b", "content": "You can control the strategy for Session Fixation Protection by choosing between three recommended options:\n\n* `changeSessionId` - Do not create a new session.\nInstead, use the session fixation protection provided by the Servlet container (`HttpServletRequest#changeSessionId()`).\nThis option is only available in Servlet 3.1 (Java EE 7) and newer containers.\nSpecifying it in older containers will result in an exception.\nThis is the default in Servlet 3.1 and newer containers.\n\n* `newSession` - Create a new \"clean\" session, without copying the existing session data (Spring Security-related attributes will still be copied).\n\n* `migrateSession` - Create a new session and copy all existing session attributes to the new session.\nThis is the default in Servlet 3.0 or older containers.\n\nYou can configure the session fixation protection by doing:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n http\n .sessionManagement((session) -> session\n .sessionFixation((sessionFixation) -> sessionFixation\n .newSession()\n )\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n sessionManagement {\n sessionFixation {\n newSession()\n }\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <session-management session-fixation-protection=\"newSession\" />\n</http>\n----\n======\n\nWhen session fixation protection occurs, it results in a `SessionFixationProtectionEvent` being published in the application context.\nIf you use `changeSessionId`, this protection will __also__ result in any ``jakarta.servlet.http.HttpSessionIdListener``s being notified, so use caution if your code listens for both events.\n\nYou can also set the session fixation protection to `none` to disable it, but this is not recommended as it leaves your application vulnerable.\n\n[[use-securitycontextholderstrategy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Configuring Session Fixation Protection", "heading_level": 3, "file_order": 110, "section_index": 17, "content_hash": "1004b779a83f73203c57d07c1b181ed008061609c5c2a0ae5845ba49cc91837b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:97de3a6213ae539b5f2bcdbce2b98a81d9bda04b3c632273ac95a10641101879", "content": "Consider the following block of code:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nUsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(\n loginRequest.getUsername(), loginRequest.getPassword());\nAuthentication authentication = this.authenticationManager.authenticate(token);\nSecurityContext context = SecurityContextHolder.createEmptyContext(); <1>\ncontext.setAuthentication(authentication); <2>\nSecurityContextHolder.setContext(context); <3>\n----\n======\n\n1. Creates an empty `SecurityContext` instance by accessing the `SecurityContextHolder` statically.\n2. Sets the `Authentication` object in the `SecurityContext` instance.\n3. Sets the `SecurityContext` instance in the `SecurityContextHolder` statically.\n\nWhile the above code works fine, it can produce some undesired effects: when components access the `SecurityContext` statically through `SecurityContextHolder`, this can create race conditions when there are multiple application contexts that want to specify the `SecurityContextHolderStrategy`.\nThis is because in `SecurityContextHolder` there is one strategy per classloader instead of one per application context.\n\nTo address this, components can wire `SecurityContextHolderStrategy` from the application context.\nBy default, they will still look up the strategy from `SecurityContextHolder`.\n\nThese changes are largely internal, but they present the opportunity for applications to autowire the `SecurityContextHolderStrategy` instead of accessing the `SecurityContext` statically.\nTo do so, you should change the code to the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class SomeClass {\n\n private final SecurityContextHolderStrategy securityContextHolderStrategy = SecurityContextHolder.getContextHolderStrategy();\n\n public void someMethod() {\n UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(\n loginRequest.getUsername(), loginRequest.getPassword());\n Authentication authentication = this.authenticationManager.authenticate(token);\n // ...\n SecurityContext context = this.securityContextHolderStrategy.createEmptyContext(); <1>\n context.setAuthentication(authentication); <2>\n this.securityContextHolderStrategy.setContext(context); <3>\n }\n\n}\n----\n======\n\n1. Creates an empty `SecurityContext` instance using the configured `SecurityContextHolderStrategy`.\n2. Sets the `Authentication` object in the `SecurityContext` instance.\n3. Sets the `SecurityContext` instance in the `SecurityContextHolderStrategy`.\n\n[[session-mgmt-force-session-creation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Using `SecurityContextHolderStrategy`", "heading_level": 2, "file_order": 110, "section_index": 18, "content_hash": "97de3a6213ae539b5f2bcdbce2b98a81d9bda04b3c632273ac95a10641101879", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:4817e1a942b1ae4a734f920f121337502d1b248147c416fd7c47bb7ebad16059", "content": "At times, it can be valuable to eagerly create sessions.\nThis can be done by using the javadoc:org.springframework.security.web.session.ForceEagerSessionCreationFilter[] which can be configured using:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) {\n http\n .sessionManagement((session) -> session\n .sessionCreationPolicy(SessionCreationPolicy.ALWAYS)\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n sessionManagement {\n sessionCreationPolicy = SessionCreationPolicy.ALWAYS\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http create-session=\"ALWAYS\">\n\n</http>\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "Forcing Eager Session Creation", "heading_level": 2, "file_order": 110, "section_index": 19, "content_hash": "4817e1a942b1ae4a734f920f121337502d1b248147c416fd7c47bb7ebad16059", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:17a23b567093e74b431ada7976bb86548043b61e20163b5ede39ac9a17211c21", "content": "- Clustered sessions with https://docs.spring.io/spring-session/reference/index.html[Spring Session]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/session-management.adoc", "title": "session-management", "heading": "What to read next", "heading_level": 2, "file_order": 110, "section_index": 20, "content_hash": "17a23b567093e74b431ada7976bb86548043b61e20163b5ede39ac9a17211c21", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/session-management.adoc"}}
{"id": "sha256:aac6d13fb0330731b9361c78dd41a65d6a22bf92a677d89879aebef486850924", "content": "[[servlet-x509]]\n\n[[x509-overview]]\nThe most common use of X.509 certificate authentication is in verifying the identity of a server when using SSL, most commonly when using HTTPS from a browser.\nThe browser automatically checks that the certificate presented by a server has been issued (digitally signed) by one of a list of trusted certificate authorities that it maintains.\n\nYou can also use SSL with \"`mutual authentication`\". The server then requests a valid certificate from the client as part of the SSL handshake.\nThe server authenticates the client by checking that its certificate is signed by an acceptable authority.\nIf a valid certificate has been provided, it can be obtained through the servlet API in an application.\nFor example, if you use Tomcat, you should read the https://tomcat.apache.org/tomcat-10.1-doc/ssl-howto.html[Tomcat SSL instructions].\nYou should get this working before trying it out with Spring Security.\n\nThe Spring Security X.509 module extracts the certificate by using a filter.\nIt maps the certificate to an application user and loads that user's set of granted authorities for use with the standard Spring Security infrastructure, specifically including at least the `FACTOR_X509` authority when <<servlet-x509-config, using the `HttpSecurity` DSL>>.\n\n[[servlet-x509-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/x509.adoc", "title": "x509", "heading": "x509", "heading_level": 1, "file_order": 111, "section_index": 0, "content_hash": "aac6d13fb0330731b9361c78dd41a65d6a22bf92a677d89879aebef486850924", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/x509.adoc"}}
{"id": "sha256:25de45dd0df26d74a510545a1466c466b53553856c44038224e735c07377d038", "content": "Similar to xref:reactive/authentication/x509.adoc[Reactive X.509 authentication], the servlet x509 authentication filter allows extracting an authentication token from a certificate provided by a client.\n\nThe following example shows a reactive x509 security configuration:\n\ninclude-code::./DefaultX509Configuration[tag=springSecurity,indent=0]\n\nIn the preceding configuration, when neither `principalExtractor` nor `authenticationManager` is provided, defaults are used.\nThe default principal extractor is `SubjectX500PrincipalExtractor`, which extracts the CN (common name) field from a certificate provided by a client.\nThe default authentication manager is `ReactivePreAuthenticatedAuthenticationManager`, which performs user account validation, checking that a user account with a name extracted by `principalExtractor` exists and that it is not locked, disabled, or expired.\n\nThe following example demonstrates how these defaults can be overridden:\n\ninclude-code::./CustomX509Configuration[tag=springSecurity,indent=0]\n\nIn the previous example, a username is extracted from the `emailAddress` field of a client certificate instead of CN, and account lookup uses a custom `ReactiveAuthenticationManager` instance.\n\nFor an example of configuring Netty and `WebClient` or `curl` command-line tool to use mutual TLS and enable X.509 authentication, see https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration/authentication/x509.\n\n[[x509-ssl-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/x509.adoc", "title": "x509", "heading": "Adding X.509 Authentication to Your Web Application", "heading_level": 2, "file_order": 111, "section_index": 1, "content_hash": "25de45dd0df26d74a510545a1466c466b53553856c44038224e735c07377d038", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/x509.adoc"}}
{"id": "sha256:5350eeecaacbdfc934cd648d3213b35515135baf6db32f365358b7bddfe2e66c", "content": "There are some pre-generated certificates in the {gh-samples-url}/servlet/java-configuration/authentication/x509/server[Spring Security Samples repository].\nYou can use these to enable SSL for testing if you do not want to generate your own.\nThe `server.jks` file contains the server certificate, the private key, and the issuing authority certificate.\nThere are also some client certificate files for the users from the sample applications.\nYou can install these in your browser to enable SSL client authentication.\n\nTo run tomcat with SSL support, drop the `server.jks` file into the tomcat `conf` directory and add the following connector to the `server.xml` file:\n\n[source,xml]\n----\n<Connector port=\"8443\" protocol=\"HTTP/1.1\" SSLEnabled=\"true\" scheme=\"https\" secure=\"true\"\n clientAuth=\"true\" sslProtocol=\"TLS\"\n keystoreFile=\"${catalina.home}/conf/server.jks\"\n keystoreType=\"JKS\" keystorePass=\"password\"\n truststoreFile=\"${catalina.home}/conf/server.jks\"\n truststoreType=\"JKS\" truststorePass=\"password\"\n/>\n----\n\n`clientAuth` can also be set to `want` if you still want SSL connections to succeed even if the client does not provide a certificate.\nClients that do not present a certificate cannot access any objects secured by Spring Security unless you use a non-X.509 authentication mechanism, such as form authentication.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authentication/x509.adoc", "title": "x509", "heading": "Setting up SSL in Tomcat", "heading_level": 2, "file_order": 111, "section_index": 2, "content_hash": "5350eeecaacbdfc934cd648d3213b35515135baf6db32f365358b7bddfe2e66c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authentication/x509.adoc"}}
{"id": "sha256:d32124e3995563104f07ffe1081ad74ae0a27a3362f2fd0184e2b7660372ad93", "content": "[[domain-acls]]\n\nThis section describes how Spring Security provides domain object security with Access Control Lists (ACLs).\n\n[[domain-acls-overview]]\nComplex applications often need to define access permissions beyond a web request or method invocation level.\nInstead, security decisions need to comprise who (`Authentication`), where (`MethodInvocation`), and what (`SomeDomainObject`).\nIn other words, authorization decisions also need to consider the actual domain object instance subject of a method invocation.\n\nImagine you are designing an application for a pet clinic.\nThere are two main groups of users of your Spring-based application: staff of the pet clinic and the pet clinic's customers.\nThe staff should have access to all of the data, while your customers should be able to see only their own customer records.\nTo make it a little more interesting, your customers can let other users see their customer records, such as their \"`puppy preschool`\" mentor or the president of their local \"`Pony Club`\".\nWhen you use Spring Security as the foundation, you have several possible approaches:\n\n* Write your business methods to enforce the security.\nYou could consult a collection within the `Customer` domain object instance to determine which users have access.\nBy using `SecurityContextHolder.getContext().getAuthentication()`, you can access the `Authentication` object.\n* Write an `AuthorizationManager` to enforce the security from the `GrantedAuthority[]` instances stored in the `Authentication` object.\nThis means that your `AuthenticationManager` needs to populate the `Authentication` with custom `GrantedAuthority[]` objects to represent each of the `Customer` domain object instances to which the principal has access.\n* Write an `AuthorizationManager` to enforce the security and open the target `Customer` domain object directly.\nThis would mean your voter needs access to a DAO that lets it retrieve the `Customer` object.\nIt can then access the `Customer` object's collection of approved users and make the appropriate decision.\n\nEach one of these approaches is perfectly legitimate.\nHowever, the first couples your authorization checking to your business code.\nThe main problems with this include the enhanced difficulty of unit testing and the fact that it would be more difficult to reuse the `Customer` authorization logic elsewhere.\nObtaining the `GrantedAuthority[]` instances from the `Authentication` object is also fine but will not scale to large numbers of `Customer` objects.\nIf a user can access 5,000 `Customer` objects (unlikely in this case, but imagine if it were a popular vet for a large Pony Club!) the amount of memory consumed and the time required to construct the `Authentication` object would be undesirable.\nThe final method, opening the `Customer` directly from external code, is probably the best of the three.\nIt achieves separation of concerns and does not misuse memory or CPU cycles, but it is still inefficient in that both the `AuthorizationManager` and the eventual business method itself perform a call to the DAO responsible for retrieving the `Customer` object.\nTwo accesses per method invocation is clearly undesirable.\nIn addition, with every approach listed, you need to write your own access control list (ACL) persistence and business logic from scratch.\n\nFortunately, there is another alternative, which we discuss later.\n\n[[domain-acls-key-concepts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/acls.adoc", "title": "acls", "heading": "acls", "heading_level": 1, "file_order": 112, "section_index": 0, "content_hash": "d32124e3995563104f07ffe1081ad74ae0a27a3362f2fd0184e2b7660372ad93", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/acls.adoc"}}
{"id": "sha256:2da97e71e4d3b47212145bb6f7df137459b0d50b2141de0bb4a48fff052bf894", "content": "Spring Security's ACL services are shipped in the `spring-security-acl-xxx.jar`.\nYou need to add this JAR to your classpath to use Spring Security's domain object instance security capabilities.\n\n[NOTE]\n====\nIf you need access to the legacy Access API that includes `AclEntryVoter`, please also include `spring-security-access-xxx.jar`.\n====\n\nSpring Security's domain object instance security capabilities center on the concept of an access control list (ACL).\nEvery domain object instance in your system has its own ACL, and the ACL records details of who can and cannot work with that domain object.\nWith this in mind, Spring Security provides three main ACL-related capabilities to your application:\n\n* A way to efficiently retrieve ACL entries for all of your domain objects (and modifying those ACLs)\n* A way to ensure a given principal is permitted to work with your objects before methods are called\n* A way to ensure a given principal is permitted to work with your objects (or something they return) after methods are called\n\nAs indicated by the first bullet point, one of the main capabilities of the Spring Security ACL module is providing a high-performance way of retrieving ACLs.\nThis ACL repository capability is extremely important, because every domain object instance in your system might have several access control entries, and each ACL might inherit from other ACLs in a tree-like structure (this is supported by Spring Security, and it is very commonly used).\nSpring Security's ACL capability has been carefully designed to provide high performance retrieval of ACLs, together with pluggable caching, deadlock-minimizing database updates, independence from ORM frameworks (we use JDBC directly), proper encapsulation, and transparent database updating.\n\nGiven that databases are central to the operation of the ACL module, we need explore the four main tables used by default in the implementation.\nThe tables are presented in order of size in a typical Spring Security ACL deployment, with the table with the most rows listed last:\n\n[[acl_tables]]\n* `ACL_SID` lets us uniquely identify any principal or authority in the system (\"`SID`\" stands for \"`Security IDentity`\").\nThe only columns are the ID, a textual representation of the SID, and a flag to indicate whether the textual representation refers to a principal name or a `GrantedAuthority`.\nThus, there is a single row for each unique principal or `GrantedAuthority`.\nWhen used in the context of receiving a permission, an SID is generally called a \"`recipient`\".\n\n* `ACL_CLASS` lets us uniquely identify any domain object class in the system.\nThe only columns are the ID and the Java class name.\nThus, there is a single row for each unique Class for which we wish to store ACL permissions.\n\n* `ACL_OBJECT_IDENTITY` stores information for each unique domain object instance in the system.\nColumns include the ID, a foreign key to the ACL_CLASS table, a unique identifier so we know the ACL_CLASS instance for which we provide information, the parent, a foreign key to the ACL_SID table to represent the owner of the domain object instance, and whether we allow ACL entries to inherit from any parent ACL.\nWe have a single row for every domain object instance for which we store ACL permissions.\n\n* Finally, `ACL_ENTRY` stores the individual permissions assigned to each recipient.\nColumns include a foreign key to the `ACL_OBJECT_IDENTITY`, the recipient (i.e. a foreign key to ACL_SID), whether we'll be auditing or not, and the integer bit mask that represents the actual permission being granted or denied.\nWe have a single row for every recipient that receives a permission to work with a domain object.\n\nAs mentioned in the last paragraph, the ACL system uses integer bit masking.\nHowever, you need not be aware of the finer points of bit shifting to use the ACL system.\nSuffice it to say that we have 32 bits we can switch on or off.\nEach of these bits represents a permission. By default, the permissions are read (bit 0), write (bit 1), create (bit 2), delete (bit 3), and administer (bit 4).\nYou can implement your own `Permission` instance if you wish to use other permissions, and the remainder of the ACL framework operates without knowledge of your extensions.\n\nYou should understand that the number of domain objects in your system has absolutely no bearing on the fact that we have chosen to use integer bit masking.\nWhile you have 32 bits available for permissions, you could have billions of domain object instances (which means billions of rows in ACL_OBJECT_IDENTITY and, probably, ACL_ENTRY).\nWe make this point because we have found that people sometimes mistakenly that believe they need a bit for each potential domain object, which is not the case.\n\nNow that we have provided a basic overview of what the ACL system does, and what it looks like at a table-structure level, we need to explore the key interfaces:\n\n* `Acl`: Every domain object has one and only one `Acl` object, which internally holds the `AccessControlEntry` objects and knows the owner of the `Acl`.\nAn Acl does not refer directly to the domain object, but instead to an `ObjectIdentity`.\nThe `Acl` is stored in the `ACL_OBJECT_IDENTITY` table.\n\n* `AccessControlEntry`: An `Acl` holds multiple `AccessControlEntry` objects, which are often abbreviated as ACEs in the framework.\nEach ACE refers to a specific tuple of `Permission`, `Sid`, and `Acl`.\nAn ACE can also be granting or non-granting and contain audit settings.\nThe ACE is stored in the `ACL_ENTRY` table.\n\n* `Permission`: A permission represents a particular immutable bit mask and offers convenience functions for bit masking and outputting information.\nThe basic permissions presented above (bits 0 through 4) are contained in the `BasePermission` class.\n\n* `Sid`: The ACL module needs to refer to principals and `GrantedAuthority[]` instances.\nA level of indirection is provided by the `Sid` interface. (\"`SID`\" is an abbreviation of \"`Security IDentity`\".)\nCommon classes include `PrincipalSid` (to represent the principal inside an `Authentication` object) and `GrantedAuthoritySid`.\nThe security identity information is stored in the `ACL_SID` table.\n\n* `ObjectIdentity`: Each domain object is represented internally within the ACL module by an `ObjectIdentity`.\nThe default implementation is called `ObjectIdentityImpl`.\n\n* `AclService`: Retrieves the `Acl` applicable for a given `ObjectIdentity`.\nIn the included implementation (`JdbcAclService`), retrieval operations are delegated to a `LookupStrategy`.\nThe `LookupStrategy` provides a highly optimized strategy for retrieving ACL information, using batched retrievals (`BasicLookupStrategy`) and supporting custom implementations that use materialized views, hierarchical queries, and similar performance-centric, non-ANSI SQL capabilities.\n\n* `MutableAclService`: Lets a modified `Acl` be presented for persistence.\nUse of this interface is optional.\n\nNote that our `AclService` and related database classes all use ANSI SQL.\nThis should therefore work with all major databases.\nAt the time of writing, the system had been successfully tested with Hypersonic SQL, PostgreSQL, Microsoft SQL Server, and Oracle.\n\nTwo samples ship with Spring Security that demonstrate the ACL module.\nThe first is the {gh-samples-url}/servlet/xml/java/contacts[Contacts Sample], and the other is the {gh-samples-url}/servlet/xml/java/dms[Document Management System (DMS) Sample].\nWe suggest taking a look at these examples.\n\n[[domain-acls-getting-started]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/acls.adoc", "title": "acls", "heading": "Key Concepts", "heading_level": 2, "file_order": 112, "section_index": 1, "content_hash": "2da97e71e4d3b47212145bb6f7df137459b0d50b2141de0bb4a48fff052bf894", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/acls.adoc"}}
{"id": "sha256:f4c1b120ccf199de06983e3d3b6a6c8472405423718ba5b036bb67798504615d", "content": "To get starting with Spring Security's ACL capability, you need to store your ACL information somewhere.\nThis necessitates the instantiation of a `DataSource` in Spring.\nThe `DataSource` is then injected into a `JdbcMutableAclService` and a `BasicLookupStrategy` instance.\nThe former provides mutator capabilities, and the latter provides high-performance ACL retrieval capabilities.\nSee one of the {gh-samples-url}[samples] that ship with Spring Security for an example configuration.\nYou also need to populate the database with the <<acl_tables,four ACL-specific tables>> listed in the previous section (see the ACL samples for the appropriate SQL statements).\n\nOnce you have created the required schema and instantiated `JdbcMutableAclService`, you need to ensure your domain model supports interoperability with the Spring Security ACL package.\nHopefully, `ObjectIdentityImpl` proves sufficient, as it provides a large number of ways in which it can be used.\nMost people have domain objects that contain a `public Serializable getId()` method.\nIf the return type is `long` or compatible with `long` (such as an `int`), you may find that you need not give further consideration to `ObjectIdentity` issues.\nMany parts of the ACL module rely on long identifiers.\nIf you do not use `long` (or an `int`, `byte`, and so on), you probably need to reimplement a number of classes.\nWe do not intend to support non-long identifiers in Spring Security's ACL module, as longs are already compatible with all database sequences, are the most common identifier data type, and are of sufficient length to accommodate all common usage scenarios.\n\nThe following fragment of code shows how to create an `Acl` or modify an existing `Acl`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nObjectIdentity oi = new ObjectIdentityImpl(Foo.class, new Long(44));\nSid sid = new PrincipalSid(\"Samantha\");\nPermission p = BasePermission.ADMINISTRATION;\n\nMutableAcl acl = null;\ntry {\nacl = (MutableAcl) aclService.readAclById(oi);\n} catch (NotFoundException nfe) {\nacl = aclService.createAcl(oi);\n}\n\nacl.insertAce(acl.getEntries().length, p, sid, true);\naclService.updateAcl(acl);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval oi: ObjectIdentity = ObjectIdentityImpl(Foo::class.java, 44)\nval sid: Sid = PrincipalSid(\"Samantha\")\nval p: Permission = BasePermission.ADMINISTRATION\n\nvar acl: MutableAcl? = null\nacl = try {\naclService.readAclById(oi) as MutableAcl\n} catch (nfe: NotFoundException) {\naclService.createAcl(oi)\n}\n\nacl!!.insertAce(acl.entries.size, p, sid, true)\naclService.updateAcl(acl)\n----\n======\n\nIn the preceding example, we retrieve the ACL associated with the `Foo` domain object with identifier number 44.\nWe then add an ACE so that a principal named \"`Samantha`\" can \"`administer`\" the object.\nThe code fragment is relatively self-explanatory, except for the `insertAce` method.\nThe first argument to the `insertAce` method determine position in the Acl at which the new entry is inserted.\nIn the preceding example, we put the new ACE at the end of the existing ACEs.\nThe final argument is a Boolean indicating whether the ACE is granting or denying.\nMost of the time it grants (`true`). However, if it denies (`false`), the permissions are effectively being blocked.\n\nSpring Security does not provide any special integration to automatically create, update, or delete ACLs as part of your DAO or repository operations.\nInstead, you need to write code similar to that shown in the preceding example for your individual domain objects.\nYou should consider using AOP on your services layer to automatically integrate the ACL information with your services layer operations.\nWe have found this approach to be effective.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/acls.adoc", "title": "acls", "heading": "Getting Started", "heading_level": 2, "file_order": 112, "section_index": 2, "content_hash": "f4c1b120ccf199de06983e3d3b6a6c8472405423718ba5b036bb67798504615d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/acls.adoc"}}
{"id": "sha256:04d8640f6d57e4569e59ba0c1d99e3d3c6ce13a0a6a6ddbf254f6dd3c76c2ef7", "content": "Once you have used the techniques described here to store some ACL information in the database, the next step is to actually use the ACL information as part of authorization decision logic.\n\nYou have a number of choices here with the primary one being using `AclPermissionEvaluator` in your `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, and `@PostFilter` annotation expressions.\n\nThis is a sample listing of the components needed to wire an `AclPersmissionEvaluator` into your authorization logic:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@EnableMethodSecurity\n@Configuration\nclass SecurityConfig {\n\t@Bean\n\tstatic MethodSecurityExpressionHandler expressionHandler(AclPermissionEvaluator aclPermissionEvaluator) {\n final DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();\n expressionHandler.setPermissionEvaluator(aclPermissionEvaluator);\n return expressionHandler;\n\t}\n\n\t@Bean\n\tstatic AclPermissionEvaluator aclPermissionEvaluator(AclService aclService) {\n return new AclPermissionEvaluator(aclService);\n\t}\n\n\t@Bean\n\tstatic JdbcMutableAclService aclService(DataSource dataSource, LookupStrategy lookupStrategy, AclCache aclCache) {\n return new JdbcMutableAclService(dataSource, lookupStrategy, aclCache);\n\t}\n\n\t@Bean\n\tstatic LookupStrategy lookupStrategy(DataSource dataSource, AclCache cache,\n AclAuthorizationStrategy aclAuthorizationStrategy, PermissionGrantingStrategy permissionGrantingStrategy) {\n return new BasicLookupStrategy(dataSource, cache, aclAuthorizationStrategy, permissionGrantingStrategy);\n\t}\n\n\t@Bean\n\tstatic AclCache aclCache(PermissionGrantingStrategy permissionGrantingStrategy,\n AclAuthorizationStrategy aclAuthorizationStrategy) {\n Cache cache = new ConcurrentMapCache(\"aclCache\");\n return new SpringCacheBasedAclCache(cache, permissionGrantingStrategy, aclAuthorizationStrategy);\n\t}\n\n\t@Bean\n\tstatic AclAuthorizationStrategy aclAuthorizationStrategy() {\n return new AclAuthorizationStrategyImpl(new SimpleGrantedAuthority(\"ADMIN\"));\n\t}\n\n\t@Bean\n\tstatic PermissionGrantingStrategy permissionGrantingStrategy() {\n return new DefaultPermissionGrantingStrategy(new ConsoleAuditLogger());\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@EnableMethodSecurity\n@Configuration\ninternal object SecurityConfig {\n @Bean\n fun expressionHandler(aclPermissionEvaluator: AclPermissionEvaluator?): MethodSecurityExpressionHandler {\n val expressionHandler = DefaultMethodSecurityExpressionHandler()\n expressionHandler.setPermissionEvaluator(aclPermissionEvaluator)\n return expressionHandler\n }\n\n @Bean\n fun aclPermissionEvaluator(aclService: AclService?): AclPermissionEvaluator {\n return AclPermissionEvaluator(aclService)\n }\n\n @Bean\n fun aclService(dataSource: DataSource?, lookupStrategy: LookupStrategy?, aclCache: AclCache?): JdbcMutableAclService {\n return JdbcMutableAclService(dataSource, lookupStrategy, aclCache)\n }\n\n @Bean\n fun lookupStrategy(dataSource: DataSource?, cache: AclCache?,\n aclAuthorizationStrategy: AclAuthorizationStrategy?, permissionGrantingStrategy: PermissionGrantingStrategy?): LookupStrategy {\n return BasicLookupStrategy(dataSource, cache, aclAuthorizationStrategy, permissionGrantingStrategy)\n }\n\n @Bean\n fun aclCache(permissionGrantingStrategy: PermissionGrantingStrategy?,\n aclAuthorizationStrategy: AclAuthorizationStrategy?): AclCache {\n val cache: Cache = ConcurrentMapCache(\"aclCache\")\n return SpringCacheBasedAclCache(cache, permissionGrantingStrategy, aclAuthorizationStrategy)\n }\n\n @Bean\n fun aclAuthorizationStrategy(): AclAuthorizationStrategy {\n return AclAuthorizationStrategyImpl(SimpleGrantedAuthority(\"ADMIN\"))\n }\n\n @Bean\n fun permissionGrantingStrategy(): PermissionGrantingStrategy {\n return DefaultPermissionGrantingStrategy(ConsoleAuditLogger())\n }\n}\n----\n======\n\nThen using xref:servlet/authorization/method-security.adoc#authorizing-with-annotations[method-based security] you can use `hasPermission` in your annotation expressions like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping\n@PostFilter(\"hasPermission(filterObject, read)\")\nIterable<Message> getAll() {\n\treturn this.messagesRepository.findAll();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping\n@PostFilter(\"hasPermission(filterObject, read)\")\nfun getAll(): Iterable<Message> {\n return this.messagesRepository.findAll()\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/acls.adoc", "title": "acls", "heading": "Using the PermissionEvaluator", "heading_level": 2, "file_order": 112, "section_index": 3, "content_hash": "04d8640f6d57e4569e59ba0c1d99e3d3c6ce13a0a6a6ddbf254f6dd3c76c2ef7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/acls.adoc"}}
{"id": "sha256:3f57682e8c661a83eb4f2c13e2362ac50fa178ea98f7be232bf4a751be41e55c", "content": "[[authz-arch]]\n\nThis section describes the Spring Security architecture that applies to authorization.\n\n[[authz-authorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "architecture", "heading_level": 1, "file_order": 113, "section_index": 0, "content_hash": "3f57682e8c661a83eb4f2c13e2362ac50fa178ea98f7be232bf4a751be41e55c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:ca6c5178f8db8961b01846fedf2339bcf88e35ff4ba7cbb9e8ae7e3fab2e3348", "content": "xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`] discusses how all `Authentication` implementations store a list of `GrantedAuthority` objects.\nThese represent the authorities that have been granted to the principal.\nThe `GrantedAuthority` objects are inserted into the `Authentication` object by the `AuthenticationManager` and are later read by `AuthorizationManager` instances when making authorization decisions.\n\nThe `GrantedAuthority` interface has only one method:\n\n[source,java]\n----\n\nString getAuthority();\n\n----\n\nThis method is used by an\n`AuthorizationManager` instance to obtain a precise `String` representation of the `GrantedAuthority`.\nBy returning a representation as a `String`, a `GrantedAuthority` can be easily \"read\" by most `AuthorizationManager` implementations.\nIf a `GrantedAuthority` cannot be precisely represented as a `String`, the `GrantedAuthority` is considered \"complex\" and `getAuthority()` must return `null`.\n\nAn example of a complex `GrantedAuthority` would be an implementation that stores a list of operations and authority thresholds that apply to different customer account numbers.\nRepresenting this complex `GrantedAuthority` as a `String` would be quite difficult. As a result, the `getAuthority()` method should return `null`.\nThis indicates to any `AuthorizationManager` that it needs to support the specific `GrantedAuthority` implementation to understand its contents.\n\nSpring Security includes one concrete `GrantedAuthority` implementation: `SimpleGrantedAuthority`.\nThis implementation lets any user-specified `String` be converted into a `GrantedAuthority`.\nAll `AuthenticationProvider` instances included with the security architecture use `SimpleGrantedAuthority` to populate the `Authentication` object.\n\n[[jc-method-security-custom-granted-authority-defaults]]\nBy default, role-based authorization rules include `ROLE_` as a prefix.\nThis means that if there is an authorization rule that requires a security context to have a role of \"USER\", Spring Security will by default look for a `GrantedAuthority#getAuthority` that returns \"ROLE_USER\".\n\nYou can customize this with `GrantedAuthorityDefaults`.\n`GrantedAuthorityDefaults` exists to allow customizing the prefix to use for role-based authorization rules.\n\nYou can configure the authorization rules to use a different prefix by exposing a `GrantedAuthorityDefaults` bean, like so:\n\n.Custom MethodSecurityExpressionHandler\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nstatic GrantedAuthorityDefaults grantedAuthorityDefaults() {\n\treturn new GrantedAuthorityDefaults(\"MYPREFIX_\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ncompanion object {\n\t@Bean\n\tfun grantedAuthorityDefaults() : GrantedAuthorityDefaults {\n return GrantedAuthorityDefaults(\"MYPREFIX_\");\n\t}\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<bean id=\"grantedAuthorityDefaults\" class=\"org.springframework.security.config.core.GrantedAuthorityDefaults\">\n\t<constructor-arg value=\"MYPREFIX_\"/>\n</bean>\n----\n======\n\n[TIP]\n====\nYou expose `GrantedAuthorityDefaults` using a `static` method to ensure that Spring publishes it before it initializes Spring Security's method security `@Configuration` classes\n====\n\n[[authz-pre-invocation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "Authorities", "heading_level": 2, "file_order": 113, "section_index": 1, "content_hash": "ca6c5178f8db8961b01846fedf2339bcf88e35ff4ba7cbb9e8ae7e3fab2e3348", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:4b8a0253d5db0dc0507c0ee50492caf2974bc88c4fc71d7ab705235e4fac186a", "content": "Spring Security provides interceptors that control access to secure objects, such as method invocations or web requests.\nA pre-invocation decision on whether the invocation is allowed to proceed is made by `AuthorizationManager` instances.\nAlso post-invocation decisions on whether a given value may be returned is made by `AuthorizationManager` instances.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "Invocation Handling", "heading_level": 2, "file_order": 113, "section_index": 2, "content_hash": "4b8a0253d5db0dc0507c0ee50492caf2974bc88c4fc71d7ab705235e4fac186a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:895d508ae2de4cc24af1e8b36ab6d4ec5b13e0f544202b130b46e977e8d0633a", "content": "`AuthorizationManager` supersedes both <<authz-legacy-note,`AccessDecisionManager` and `AccessDecisionVoter`>>.\n\nApplications that customize an `AccessDecisionManager` or `AccessDecisionVoter` are encouraged to <<authz-voter-adaptation,change to using `AuthorizationManager`>>.\n\n``AuthorizationManager``s are called by Spring Security's xref:servlet/authorization/authorize-http-requests.adoc[request-based], xref:servlet/authorization/method-security.adoc[method-based], and xref:servlet/integrations/websocket.adoc[message-based] authorization components and are responsible for making final access control decisions.\nThe `AuthorizationManager` interface contains two methods:\n\n[source,java]\n----\nAuthorizationResult authorize(Supplier<Authentication> authentication, Object secureObject);\n\ndefault void verify(Supplier<Authentication> authentication, Object secureObject)\n throws AccessDeniedException {\n // ...\n}\n----\n\nThe ``AuthorizationManager``'s `authorize` method is passed all the relevant information it needs in order to make an authorization decision.\nIn particular, passing the secure `Object` enables those arguments contained in the actual secure object invocation to be inspected.\nFor example, let's assume the secure object was a `MethodInvocation`.\nIt would be easy to query the `MethodInvocation` for any `Customer` argument, and then implement some sort of security logic in the `AuthorizationManager` to ensure the principal is permitted to operate on that customer.\nImplementations are expected to return a positive `AuthorizationDecision` if access is granted, negative `AuthorizationDecision` if access is denied, and a null `AuthorizationDecision` when abstaining from making a decision.\n\n`verify` calls `authorize` and subsequently throws an `AccessDeniedException` in the case of a negative `AuthorizationDecision`.\n\n[[authz-delegate-authorization-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "The AuthorizationManager", "heading_level": 3, "file_order": 113, "section_index": 3, "content_hash": "895d508ae2de4cc24af1e8b36ab6d4ec5b13e0f544202b130b46e977e8d0633a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:9e347a7add3b880318166f5d5b6e7bc5c3a57a93f729754a447acc179bf3a506", "content": "Whilst users can implement their own `AuthorizationManager` to control all aspects of authorization, Spring Security ships with a delegating `AuthorizationManager` that can collaborate with individual ``AuthorizationManager``s.\n\n`RequestMatcherDelegatingAuthorizationManager` will match the request with the most appropriate delegate `AuthorizationManager`.\nFor method security, you can use `AuthorizationManagerBeforeMethodInterceptor` and `AuthorizationManagerAfterMethodInterceptor`.\n\n<<authz-authorization-manager-implementations>> illustrates the relevant classes.\n\n[[authz-authorization-manager-implementations]]\n.Authorization Manager Implementations\n[.invert-dark]\nimage::{figures}/authorizationhierarchy.png[]\n\nUsing this approach, a composition of `AuthorizationManager` implementations can be polled on an authorization decision.\n\n[[authz-authority-authorization-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "Delegate-based AuthorizationManager Implementations", "heading_level": 3, "file_order": 113, "section_index": 4, "content_hash": "9e347a7add3b880318166f5d5b6e7bc5c3a57a93f729754a447acc179bf3a506", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:c9d6fbd84a3742b40b91b52f756485a41d75b3440cad2ef926e9ffba8d3f3faa", "content": "The most common `AuthorizationManager` provided with Spring Security is `AuthorityAuthorizationManager`.\nIt is configured with a given set of authorities to look for on the current `Authentication`.\nIt will return positive `AuthorizationDecision` should the `Authentication` contain any of the configured authorities.\nIt will return a negative `AuthorizationDecision` otherwise.\n\n[[authz-authenticated-authorization-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "AuthorityAuthorizationManager", "heading_level": 4, "file_order": 113, "section_index": 5, "content_hash": "c9d6fbd84a3742b40b91b52f756485a41d75b3440cad2ef926e9ffba8d3f3faa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:e76a63c016334177061377bc749e25740912a92f54a4919cb3573cf46a787296", "content": "Another manager is the `AuthenticatedAuthorizationManager`.\nIt can be used to differentiate between anonymous, fully-authenticated and remember-me authenticated users.\nMany sites allow certain limited access under remember-me authentication, but require a user to confirm their identity by logging in for full access.\n\n[[authz-authorization-manager-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "AuthenticatedAuthorizationManager", "heading_level": 4, "file_order": 113, "section_index": 6, "content_hash": "e76a63c016334177061377bc749e25740912a92f54a4919cb3573cf46a787296", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:a2d87a4a74e38568c5ce4560a6640c8e2e4f31f17cf367343a66369ce29a4b40", "content": "The javadoc:org.springframework.security.authorization.AuthorizationManagerFactory[] interface (introduced in Spring Security 7.0) is used to create generic ``AuthorizationManager``s in xref:servlet/authorization/authorize-http-requests.adoc[request-based] and xref:servlet/authorization/method-security.adoc[method-based] authorization components.\nThe following is a sketch of the `AuthorizationManagerFactory` interface:\n\n[source,java]\n----\npublic interface AuthorizationManagerFactory<T> {\n\tAuthorizationManager<T> permitAll();\n\tAuthorizationManager<T> denyAll();\n\tAuthorizationManager<T> hasRole(String role);\n\tAuthorizationManager<T> hasAnyRole(String... roles);\n\tAuthorizationManager<T> hasAllRoles(String... roles);\n\tAuthorizationManager<T> hasAuthority(String authority);\n\tAuthorizationManager<T> hasAnyAuthority(String... authorities);\n\tAuthorizationManager<T> hasAllAuthorities(String... authorities);\n\tAuthorizationManager<T> authenticated();\n\tAuthorizationManager<T> fullyAuthenticated();\n\tAuthorizationManager<T> rememberMe();\n\tAuthorizationManager<T> anonymous();\n}\n----\n\nThe default implementation is javadoc:org.springframework.security.authorization.DefaultAuthorizationManagerFactory[], which allows for customizing the `rolePrefix` (defaults to `\"ROLE_\"`), `RoleHierarchy` and `AuthenticationTrustManager` that are provided to the ``AuthorizationManager``s created by the factory.\n\nIn order to customize the default instance used by Spring Security, simply publish a bean as in the following example:\n\ninclude-code::./AuthorizationManagerFactoryConfiguration[tag=config,indent=0]\n\n[TIP]\nIt is also possible to target a specific usage of this factory within Spring Security by providing a concrete parameterized type instead of a generic type.\nSee examples of each in the xref:servlet/authorization/authorize-http-requests.adoc#customizing-authorization-managers[request-based] and xref:servlet/authorization/method-security.adoc#customizing-authorization-managers[method-based] sections of the documentation.\n\nIn addition to simply customizing the default instance of `AuthorizationManagerFactory`, you can provide your own implementation to fully customize the instances created by the factory and provide your own implementations.\n\n[NOTE]\nThe {gh-url}/core/src/main/java/org/springframework/security/authorization/AuthorizationManagerFactory.java[actual interface] provides default implementations for all factory methods, which allows custom implementations to only implement the methods that need to be customized.\n\n[[authz-authorization-managers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "Creating AuthorizationManager instances", "heading_level": 3, "file_order": 113, "section_index": 7, "content_hash": "a2d87a4a74e38568c5ce4560a6640c8e2e4f31f17cf367343a66369ce29a4b40", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:1f881a8bd380c4c4b89b458f2cc5c9860880817d631d962cb74d8c9614d6bef0", "content": "There are also helpful static factories in javadoc:org.springframework.security.authorization.AuthorizationManagers[] for composing individual ``AuthorizationManager``s into more sophisticated expressions.\n\n[[authz-custom-authorization-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "AuthorizationManagers", "heading_level": 4, "file_order": 113, "section_index": 8, "content_hash": "1f881a8bd380c4c4b89b458f2cc5c9860880817d631d962cb74d8c9614d6bef0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:c7afbdd70c5827913c3c0ebc44a37ae041d17972b4cce7d3dfcd7a86a6fba489", "content": "Obviously, you can also implement a custom `AuthorizationManager` and you can put just about any access-control logic you want in it.\nIt might be specific to your application (business-logic related) or it might implement some security administration logic.\nFor example, you can create an implementation that can query Open Policy Agent or your own authorization database.\n\n[TIP]\nYou'll find a https://spring.io/blog/2009/01/03/spring-security-customization-part-2-adjusting-secured-session-in-real-time[blog article] on the Spring web site which describes how to use the legacy `AccessDecisionVoter` to deny access in real-time to users whose accounts have been suspended.\nYou can achieve the same outcome by implementing `AuthorizationManager` instead.\n\n[[authz-voter-adaptation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "Custom Authorization Managers", "heading_level": 4, "file_order": 113, "section_index": 9, "content_hash": "c7afbdd70c5827913c3c0ebc44a37ae041d17972b4cce7d3dfcd7a86a6fba489", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:2efb0b743cdc94c6f41bdbee380149fceea55f7de12dc69fadc4fa4b00a6e582", "content": "Previous to `AuthorizationManager`, Spring Security published <<authz-legacy-note,`AccessDecisionManager` and `AccessDecisionVoter`>>.\n\nIn some cases, like migrating an older application, it may be desirable to introduce an `AuthorizationManager` that invokes an `AccessDecisionManager` or `AccessDecisionVoter`.\n\nTo call an existing `AccessDecisionManager`, you can do:\n\n.Adapting an AccessDecisionManager\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class AccessDecisionManagerAuthorizationManagerAdapter implements AuthorizationManager {\n private final AccessDecisionManager accessDecisionManager;\n private final SecurityMetadataSource securityMetadataSource;\n\n @Override\n public AuthorizationResult authorize(Supplier<Authentication> authentication, Object object) {\n try {\n Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object);\n this.accessDecisionManager.decide(authentication.get(), object, attributes);\n return new AuthorizationDecision(true);\n } catch (AccessDeniedException ex) {\n return new AuthorizationDecision(false);\n }\n }\n\n @Override\n public void verify(Supplier<Authentication> authentication, Object object) {\n Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object);\n this.accessDecisionManager.decide(authentication.get(), object, attributes);\n }\n}\n----\n======\n\nAnd then wire it into your `SecurityFilterChain`.\n\nOr to only call an `AccessDecisionVoter`, you can do:\n\n.Adapting an AccessDecisionVoter\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class AccessDecisionVoterAuthorizationManagerAdapter implements AuthorizationManager {\n private final AccessDecisionVoter accessDecisionVoter;\n private final SecurityMetadataSource securityMetadataSource;\n\n @Override\n public AuthorizationResult authorize(Supplier<Authentication> authentication, Object object) {\n Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object);\n int decision = this.accessDecisionVoter.vote(authentication.get(), object, attributes);\n switch (decision) {\n case ACCESS_GRANTED:\n return new AuthorizationDecision(true);\n case ACCESS_DENIED:\n return new AuthorizationDecision(false);\n }\n return null;\n }\n}\n----\n======\n\nAnd then wire it into your `SecurityFilterChain`.\n\n[[authz-hierarchical-roles]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "Adapting AccessDecisionManager and AccessDecisionVoters", "heading_level": 2, "file_order": 113, "section_index": 10, "content_hash": "2efb0b743cdc94c6f41bdbee380149fceea55f7de12dc69fadc4fa4b00a6e582", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:379288609bc401170b5ef3e2ac6e4a026c49ef800e361860e48851535312c811", "content": "It is a common requirement that a particular role in an application should automatically \"include\" other roles.\nFor example, in an application which has the concept of an \"admin\" and a \"user\" role, you may want an admin to be able to do everything a normal user can.\nTo achieve this, you can either make sure that all admin users are also assigned the \"user\" role.\nAlternatively, you can modify every access constraint which requires the \"user\" role to also include the \"admin\" role.\nThis can get quite complicated if you have a lot of different roles in your application.\n\nThe use of a role-hierarchy allows you to configure which roles (or authorities) should include others.\nThis is supported for filter-based authorization in `HttpSecurity#authorizeHttpRequests` and for method-based authorization through `DefaultMethodSecurityExpressionHandler` for pre-post annotations, `SecuredAuthorizationManager` for `@Secured`, and `Jsr250AuthorizationManager` for JSR-250 annotations.\nYou can configure the behavior for all of them at once in the following way:\n\n.Hierarchical Roles Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nstatic RoleHierarchy roleHierarchy() {\n return RoleHierarchyImpl.withDefaultRolePrefix()\n .role(\"ADMIN\").implies(\"STAFF\")\n .role(\"STAFF\").implies(\"USER\")\n .role(\"USER\").implies(\"GUEST\")\n .build();\n}\n\n@Bean\nstatic MethodSecurityExpressionHandler methodSecurityExpressionHandler(RoleHierarchy roleHierarchy) {\n\tDefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();\n\texpressionHandler.setRoleHierarchy(roleHierarchy);\n\treturn expressionHandler;\n}\n----\n\nXml::\n+\n[source,java,role=\"secondary\"]\n----\n<bean id=\"roleHierarchy\"\n class=\"org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl\" factory-method=\"fromHierarchy\">\n\t<constructor-arg>\n <value>\n ROLE_ADMIN > ROLE_STAFF\n ROLE_STAFF > ROLE_USER\n ROLE_USER > ROLE_GUEST\n </value>\n\t</constructor-arg>\n</bean>\n\n<!-- and, if using method security also add -->\n<bean id=\"methodSecurityExpressionHandler\"\n class=\"org.springframework.security.access.expression.method.MethodSecurityExpressionHandler\">\n <property ref=\"roleHierarchy\"/>\n</bean>\n----\n======\n\nHere we have four roles in a hierarchy `ROLE_ADMIN => ROLE_STAFF => ROLE_USER => ROLE_GUEST`.\nA user who is authenticated with `ROLE_ADMIN`, will behave as if they have all four roles when security constraints are evaluated against any filter- or method-based rules.\n\n[TIP]\nThe `>` symbol can be thought of as meaning \"includes\".\n\nRole hierarchies offer a convenient means of simplifying the access-control configuration data for your application and/or reducing the number of authorities which you need to assign to a user.\nFor more complex requirements you may wish to define a logical mapping between the specific access-rights your application requires and the roles that are assigned to users, translating between the two when loading the user information.\n\n[[authz-legacy-note]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "Hierarchical Roles", "heading_level": 2, "file_order": 113, "section_index": 11, "content_hash": "379288609bc401170b5ef3e2ac6e4a026c49ef800e361860e48851535312c811", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:f16e612fea4156818a3e1b226d559357e1155d698e0562798ef2a687efba30dd", "content": "[NOTE]\nSpring Security contains some legacy components.\nSince they are not yet removed, documentation is included for historical purposes.\nTheir recommended replacements are above.\n\nWhen accessing legacy authorization components, please also include the `spring-security-access` dependency like so:\n\n[tabs]\n======\nMaven::\n+\n[source,xml,role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.security</groupId>\n <artifactId>spring-security-access</artifactId>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,role=\"primary\"]\n----\nimplementation('org.springframework.security:spring-security-access')\n----\n======\n\n[[authz-access-decision-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "Legacy Authorization Components", "heading_level": 2, "file_order": 113, "section_index": 12, "content_hash": "f16e612fea4156818a3e1b226d559357e1155d698e0562798ef2a687efba30dd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:b66fed84067729f260923f23c2f60d7071adad842ac2bc826a09ef97e918cb7a", "content": "The `AccessDecisionManager` is called by the `AbstractSecurityInterceptor` and is responsible for making final access control decisions.\nThe `AccessDecisionManager` interface contains three methods:\n\n[source,java]\n----\nvoid decide(Authentication authentication, Object secureObject,\n\tCollection<ConfigAttribute> attrs) throws AccessDeniedException;\n\nboolean supports(ConfigAttribute attribute);\n\nboolean supports(Class clazz);\n----\n\nThe `decide` method of the `AccessDecisionManager` is passed all the relevant information it needs to make an authorization decision.\nIn particular, passing the secure `Object` lets those arguments contained in the actual secure object invocation be inspected.\nFor example, assume the secure object is a `MethodInvocation`.\nYou can query the `MethodInvocation` for any `Customer` argument and then implement some sort of security logic in the `AccessDecisionManager` to ensure the principal is permitted to operate on that customer.\nImplementations are expected to throw an `AccessDeniedException` if access is denied.\n\nThe `supports(ConfigAttribute)` method is called by the `AbstractSecurityInterceptor` at startup time to determine if the `AccessDecisionManager` can process the passed `ConfigAttribute`.\nThe `supports(Class)` method is called by a security interceptor implementation to ensure the configured `AccessDecisionManager` supports the type of secure object that the security interceptor presents.\n\n[[authz-voting-based]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "The AccessDecisionManager", "heading_level": 3, "file_order": 113, "section_index": 13, "content_hash": "b66fed84067729f260923f23c2f60d7071adad842ac2bc826a09ef97e918cb7a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:1b7384025d30f647c6ec88e3b1e875ac91d79a07f3228f9ab8d04ebb00d9d792", "content": "While users can implement their own `AccessDecisionManager` to control all aspects of authorization, Spring Security includes several `AccessDecisionManager` implementations that are based on voting.\n<<authz-access-voting>> describes the relevant classes.\n\nThe following image shows the `AccessDecisionManager` interface:\n\n[[authz-access-voting]]\n.Voting Decision Manager\n[.invert-dark]\nimage::{figures}/access-decision-voting.png[]\n\nBy using this approach, a series of `AccessDecisionVoter` implementations are polled on an authorization decision.\nThe `AccessDecisionManager` then decides whether or not to throw an `AccessDeniedException` based on its assessment of the votes.\n\nThe `AccessDecisionVoter` interface has three methods:\n\n[source,java]\n----\nint vote(Authentication authentication, Object object, Collection<ConfigAttribute> attrs);\n\nboolean supports(ConfigAttribute attribute);\n\nboolean supports(Class clazz);\n----\n\nConcrete implementations return an `int`, with possible values being reflected in the `AccessDecisionVoter` static fields named `ACCESS_ABSTAIN`, `ACCESS_DENIED` and `ACCESS_GRANTED`.\nA voting implementation returns `ACCESS_ABSTAIN` if it has no opinion on an authorization decision.\nIf it does have an opinion, it must return either `ACCESS_DENIED` or `ACCESS_GRANTED`.\n\nThere are three concrete `AccessDecisionManager` implementations provided with Spring Security to tally the votes.\nThe `ConsensusBased` implementation grants or denies access based on the consensus of non-abstain votes.\nProperties are provided to control behavior in the event of an equality of votes or if all votes are abstain.\nThe `AffirmativeBased` implementation grants access if one or more `ACCESS_GRANTED` votes were received (in other words, a deny vote will be ignored, provided there was at least one grant vote).\nLike the `ConsensusBased` implementation, there is a parameter that controls the behavior if all voters abstain.\nThe `UnanimousBased` provider expects unanimous `ACCESS_GRANTED` votes in order to grant access, ignoring abstains.\nIt denies access if there is any `ACCESS_DENIED` vote.\nLike the other implementations, there is a parameter that controls the behavior if all voters abstain.\n\nYou can implement a custom `AccessDecisionManager` that tallies votes differently.\nFor example, votes from a particular `AccessDecisionVoter` might receive additional weighting, while a deny vote from a particular voter may have a veto effect.\n\n[[authz-role-voter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "Voting-Based AccessDecisionManager Implementations", "heading_level": 3, "file_order": 113, "section_index": 14, "content_hash": "1b7384025d30f647c6ec88e3b1e875ac91d79a07f3228f9ab8d04ebb00d9d792", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:603f52e09c908b3de3d632190a434526070b3072c7a88fc5fba583b6e8842423", "content": "The most commonly used `AccessDecisionVoter` provided with Spring Security is the `RoleVoter`, which treats configuration attributes as role names and votes to grant access if the user has been assigned that role.\n\nIt votes if any `ConfigAttribute` begins with the `ROLE_` prefix.\nIt votes to grant access if there is a `GrantedAuthority` that returns a `String` representation (from the `getAuthority()` method) exactly equal to one or more `ConfigAttributes` that start with the `ROLE_` prefix.\nIf there is no exact match of any `ConfigAttribute` starting with `ROLE_`, `RoleVoter` votes to deny access.\nIf no `ConfigAttribute` begins with `ROLE_`, the voter abstains.\n\n[[authz-authenticated-voter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "RoleVoter", "heading_level": 4, "file_order": 113, "section_index": 15, "content_hash": "603f52e09c908b3de3d632190a434526070b3072c7a88fc5fba583b6e8842423", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:9a19bfb9df78ac4d741c5f8429f5320728c74e69e59ef1c946324330aaf9d195", "content": "Another voter which we have implicitly seen is the `AuthenticatedVoter`, which can be used to differentiate between anonymous, fully-authenticated, and remember-me authenticated users.\nMany sites allow certain limited access under remember-me authentication but require a user to confirm their identity by logging in for full access.\n\nWhen we have used the `IS_AUTHENTICATED_ANONYMOUSLY` attribute to grant anonymous access, this attribute was being processed by the `AuthenticatedVoter`.\nFor more information, see\njavadoc:org.springframework.security.access.vote.AuthenticatedVoter[].\n\n[[authz-custom-voter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "AuthenticatedVoter", "heading_level": 4, "file_order": 113, "section_index": 16, "content_hash": "9a19bfb9df78ac4d741c5f8429f5320728c74e69e59ef1c946324330aaf9d195", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:8e5e16294389375c75ec35ddc7d5e5d3d53e19ba67a9a740554735515b1d8729", "content": "You can also implement a custom `AccessDecisionVoter` and put just about any access-control logic you want in it.\nIt might be specific to your application (business-logic related) or it might implement some security administration logic.\nFor example, on the Spring web site, you can find a https://spring.io/blog/2009/01/03/spring-security-customization-part-2-adjusting-secured-session-in-real-time[blog article] that describes how to use a voter to deny access in real-time to users whose accounts have been suspended.\n\n[[authz-after-invocation]]\n.After Invocation Implementation\n[.invert-dark]\nimage::{figures}/after-invocation.png[]\n\nLike many other parts of Spring Security, `AfterInvocationManager` has a single concrete implementation, `AfterInvocationProviderManager`, which polls a list of ``AfterInvocationProvider``s.\nEach `AfterInvocationProvider` is allowed to modify the return object or throw an `AccessDeniedException`.\nIndeed multiple providers can modify the object, as the result of the previous provider is passed to the next in the list.\n\nPlease be aware that if you're using `AfterInvocationManager`, you will still need configuration attributes that allow the ``MethodSecurityInterceptor``'s `AccessDecisionManager` to allow an operation.\nIf you're using the typical Spring Security included `AccessDecisionManager` implementations, having no configuration attributes defined for a particular secure method invocation will cause each `AccessDecisionVoter` to abstain from voting.\nIn turn, if the `AccessDecisionManager` property \"`allowIfAllAbstainDecisions`\" is `false`, an `AccessDeniedException` will be thrown.\nYou may avoid this potential issue by either (i) setting \"`allowIfAllAbstainDecisions`\" to `true` (although this is generally not recommended) or (ii) simply ensure that there is at least one configuration attribute that an `AccessDecisionVoter` will vote to grant access for.\nThis latter (recommended) approach is usually achieved through a `ROLE_USER` or `ROLE_AUTHENTICATED` configuration attribute.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/architecture.adoc", "title": "architecture", "heading": "Custom Voters", "heading_level": 4, "file_order": 113, "section_index": 17, "content_hash": "8e5e16294389375c75ec35ddc7d5e5d3d53e19ba67a9a740554735515b1d8729", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/architecture.adoc"}}
{"id": "sha256:af7e9d6c06903246c00051c3ddb641371ef5a75570a00c209e98ab630bafb4ad", "content": "[[servlet-authorization-authorizationfilter]]\n\nSpring Security allows you to xref:servlet/authorization/index.adoc[model your authorization] at the request level.\nFor example, with Spring Security you can say that all pages under `/admin` require one authority while all other pages simply require authentication.\n\nBy default, Spring Security requires that every request be authenticated.\nThat said, any time you use xref:servlet/configuration/java.adoc#jc-httpsecurity[an `HttpSecurity` instance], it's necessary to declare your authorization rules.\n\n[[activate-request-security]]\nWhenever you have an `HttpSecurity` instance, you should at least do:\n\n.Use authorizeHttpRequests\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-url pattern=\"/**\" access=\"authenticated\"/>\n</http>\n----\n======\n\nThis tells Spring Security that any endpoint in your application requires that the security context at a minimum be authenticated in order to allow it.\n\nIn many cases, your authorization rules will be more sophisticated than that, so please consider the following use cases:\n\n* I have an app that uses `authorizeRequests` and I want to <<migrate-authorize-requests,migrate it to `authorizeHttpRequests`>>\n* I want to <<request-authorization-architecture,understand how the `AuthorizationFilter` components work>>\n* I want to <<match-requests, match requests>> based on a pattern; specifically <<match-by-regex,regex>>\n* I want to match request, and I map Spring MVC to <<mvc-not-default-servlet, something other than the default servlet>>\n* I want to <<authorize-requests, authorize requests>>\n* I want to <<match-by-custom, match a request programmatically>>\n* I want to <<authorize-requests, authorize a request programmatically>>\n* I want to <<remote-authorization-manager, delegate request authorization>> to a policy agent\n* I want to <<customizing-authorization-managers,customize how authorization managers are created>>\n\n[[request-authorization-architecture]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "authorize-http-requests", "heading_level": 1, "file_order": 114, "section_index": 0, "content_hash": "af7e9d6c06903246c00051c3ddb641371ef5a75570a00c209e98ab630bafb4ad", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:02833044a90e39312a88a721f6a47ad6bf7a0de02e452d1d8add8e8b62c60b62", "content": "[NOTE]\nThis section builds on xref:servlet/architecture.adoc#servlet-architecture[Servlet Architecture and Implementation] by digging deeper into how xref:servlet/authorization/index.adoc#servlet-authorization[authorization] works at the request level in Servlet-based applications.\n\n.Authorize HttpServletRequest\n[.invert-dark]\nimage::{figures}/authorizationfilter.png[]\n\n* image:{icondir}/number_1.png[] First, the `AuthorizationFilter` constructs a `Supplier` that retrieves an xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[Authentication] from the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[SecurityContextHolder].\n* image:{icondir}/number_2.png[] Second, it passes the `Supplier<Authentication>` and the `HttpServletRequest` to the xref:servlet/architecture.adoc#authz-authorization-manager[`AuthorizationManager`].\nThe `AuthorizationManager` matches the request to the patterns in `authorizeHttpRequests`, and runs the corresponding rule.\n** image:{icondir}/number_3.png[] If authorization is denied, xref:servlet/authorization/events.adoc[an `AuthorizationDeniedEvent` is published], and an `AccessDeniedException` is thrown.\nIn this case the xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[`ExceptionTranslationFilter`] handles the `AccessDeniedException`.\n** image:{icondir}/number_4.png[] If access is granted, xref:servlet/authorization/events.adoc[an `AuthorizationGrantedEvent` is published] and `AuthorizationFilter` continues with the xref:servlet/architecture.adoc#servlet-filters-review[FilterChain] which allows the application to process normally.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Understanding How Request Authorization Components Work", "heading_level": 2, "file_order": 114, "section_index": 1, "content_hash": "02833044a90e39312a88a721f6a47ad6bf7a0de02e452d1d8add8e8b62c60b62", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:537c4a99929f0a6ec9383f43014494b7a65b54d0b4359c4d17c5ba3d4f091b11", "content": "The `AuthorizationFilter` is last in xref:servlet/architecture.adoc#servlet-filterchain-figure[the Spring Security filter chain] by default.\nThis means that Spring Security's xref:servlet/authentication/index.adoc[authentication filters], xref:servlet/exploits/index.adoc[exploit protections], and other filter integrations do not require authorization.\nIf you add filters of your own before the `AuthorizationFilter`, they will also not require authorization; otherwise, they will.\n\nA place where this typically becomes important is when you are adding {spring-framework-reference-url}web.html#spring-web[Spring MVC] endpoints.\nBecause they are executed by the {spring-framework-reference-url}web.html#mvc-servlet[`DispatcherServlet`] and this comes after the `AuthorizationFilter`, your endpoints need to be <<authorizing-endpoints,included in `authorizeHttpRequests` to be permitted>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "`AuthorizationFilter` Is Last By Default", "heading_level": 3, "file_order": 114, "section_index": 2, "content_hash": "537c4a99929f0a6ec9383f43014494b7a65b54d0b4359c4d17c5ba3d4f091b11", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:152771ecc5595ab15f1fb751b0a90a30d7fba1f460c4a84cfa9f133d567e62bc", "content": "The `AuthorizationFilter` runs not just on every request, but on every dispatch.\nThis means that the `REQUEST` dispatch needs authorization, but also ``FORWARD``s, ``ERROR``s, and ``INCLUDE``s.\n\nFor example, {spring-framework-reference-url}web.html#spring-web[Spring MVC] can `FORWARD` the request to a view resolver that renders a Thymeleaf template, like so:\n\n.Sample Forwarding Spring MVC Controller\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class MyController {\n @GetMapping(\"/endpoint\")\n public String endpoint() {\n return \"endpoint\";\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nclass MyController {\n @GetMapping(\"/endpoint\")\n fun endpoint(): String {\n return \"endpoint\"\n }\n}\n----\n======\n\nIn this case, authorization happens twice; once for authorizing `/endpoint` and once for forwarding to Thymeleaf to render the \"endpoint\" template.\n\nFor that reason, you may want to <<match-by-dispatcher-type, permit all `FORWARD` dispatches>>.\n\nAnother example of this principle is {spring-boot-reference-url}reference/web/servlet.html#web.servlet.spring-mvc.error-handling[how Spring Boot handles errors].\nIf the container catches an exception, say like the following:\n\n.Sample Erroring Spring MVC Controller\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class MyController {\n @GetMapping(\"/endpoint\")\n public String endpoint() {\n throw new UnsupportedOperationException(\"unsupported\");\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nclass MyController {\n @GetMapping(\"/endpoint\")\n fun endpoint(): String {\n throw UnsupportedOperationException(\"unsupported\")\n }\n}\n----\n======\n\nthen Boot will dispatch it to the `ERROR` dispatch.\n\nIn that case, authorization also happens twice; once for authorizing `/endpoint` and once for dispatching the error.\n\nFor that reason, you may want to <<match-by-dispatcher-type, permit all `ERROR` dispatches>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "All Dispatches Are Authorized", "heading_level": 3, "file_order": 114, "section_index": 3, "content_hash": "152771ecc5595ab15f1fb751b0a90a30d7fba1f460c4a84cfa9f133d567e62bc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:cc8ec22f0eb278e5183848c2f7ca800c69c44fbf346af3526a4195ae6c681b0d", "content": "Remember that xref:servlet/authorization/architecture.adoc#_the_authorizationmanager[the `AuthorizationManager` API uses a `Supplier<Authentication>`].\n\nThis matters with `authorizeHttpRequests` when requests are <<authorize-requests,always permitted or always denied>>.\nIn those cases, xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[the `Authentication`] is not queried, making for a faster request.\n\n[[authorizing-endpoints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "`Authentication` Lookup is Deferred", "heading_level": 3, "file_order": 114, "section_index": 4, "content_hash": "cc8ec22f0eb278e5183848c2f7ca800c69c44fbf346af3526a4195ae6c681b0d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:35cf19b56d8ab0111db6b11dab7b4963cc44c36f4a69215007c13c81213fe1f3", "content": "You can configure Spring Security to have different rules by adding more rules in order of precedence.\n\nIf you want to require that `/endpoint` only be accessible by end users with the `USER` authority, then you can do:\n\n.Authorize an Endpoint\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain web(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/endpoint\").hasAuthority(\"USER\")\n .anyRequest().authenticated()\n );\n // ...\n\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun web(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(\"/endpoint\", hasAuthority(\"USER\"))\n authorize(anyRequest, authenticated)\n }\n }\n\n return http.build()\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-url pattern=\"/endpoint\" access=\"hasAuthority('USER')\"/>\n <intercept-url pattern=\"/**\" access=\"authenticated\"/>\n</http>\n----\n======\n\nAs you can see, the declaration can be broken up in to pattern/rule pairs.\n\n`AuthorizationFilter` processes these pairs in the order listed, applying only the first match to the request.\nThis means that even though `/**` would also match for `/endpoint` the above rules are not a problem.\nThe way to read the above rules is \"if the request is `/endpoint`, then require the `USER` authority; else, only require authentication\".\n\nSpring Security supports several patterns and several rules; you can also programmatically create your own of each.\n\nOnce authorized, you can test it using xref:servlet/test/method.adoc#test-method-withmockuser[Security's test support] in the following way:\n\n.Test Endpoint Authorization\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@WithMockUser(authorities=\"USER\")\n@Test\nvoid endpointWhenUserAuthorityThenAuthorized() {\n this.mvc.perform(get(\"/endpoint\"))\n .andExpect(status().isOk());\n}\n\n@WithMockUser\n@Test\nvoid endpointWhenNotUserAuthorityThenForbidden() {\n this.mvc.perform(get(\"/endpoint\"))\n .andExpect(status().isForbidden());\n}\n\n@Test\nvoid anyWhenUnauthenticatedThenUnauthorized() {\n this.mvc.perform(get(\"/any\"))\n .andExpect(status().isUnauthorized());\n}\n----\n======\n\n[[match-requests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Authorizing an Endpoint", "heading_level": 2, "file_order": 114, "section_index": 5, "content_hash": "35cf19b56d8ab0111db6b11dab7b4963cc44c36f4a69215007c13c81213fe1f3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:0c091c152221dcaf43323f97aaba66d7f280546b813a0023956d660a00dbf947", "content": "Above you've already seen <<authorizing-endpoints, two ways to match requests>>.\n\nThe first you saw was the simplest, which is to match any request.\n\nThe second is to match by a URI pattern.\nSpring Security supports two languages for URI pattern-matching: <<match-by-ant,Ant>> (as seen above) and <<match-by-regex,Regular Expressions>>.\n\n[[match-by-ant]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Matching Requests", "heading_level": 2, "file_order": 114, "section_index": 6, "content_hash": "0c091c152221dcaf43323f97aaba66d7f280546b813a0023956d660a00dbf947", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:17fbc0e342de70f2b9f6bba2cb09a058faf4f726a8c6efef015862b3bd696de6", "content": "Ant is the default language that Spring Security uses to match requests.\n\nYou can use it to match a single endpoint or a directory, and you can even capture placeholders for later use.\nYou can also refine it to match a specific set of HTTP methods.\n\nLet's say that you instead of wanting to match the `/endpoint` endpoint, you want to match all endpoints under the `/resource` directory.\nIn that case, you can do something like the following:\n\n.Match with Ant\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/resource/**\").hasAuthority(\"USER\")\n .anyRequest().authenticated()\n )\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n authorizeHttpRequests {\n authorize(\"/resource/**\", hasAuthority(\"USER\"))\n authorize(anyRequest, authenticated)\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-url pattern=\"/resource/**\" access=\"hasAuthority('USER')\"/>\n <intercept-url pattern=\"/**\" access=\"authenticated\"/>\n</http>\n----\n======\n\nThe way to read this is \"if the request is `/resource` or some subdirectory, require the `USER` authority; otherwise, only require authentication\"\n\nYou can also extract path values from the request, as seen below:\n\n.Authorize and Extract\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/resource/{name}\").access(new WebExpressionAuthorizationManager(\"#name == authentication.name\"))\n .anyRequest().authenticated()\n )\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n authorizeHttpRequests {\n authorize(\"/resource/{name}\", WebExpressionAuthorizationManager(\"#name == authentication.name\"))\n authorize(anyRequest, authenticated)\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-url pattern=\"/resource/{name}\" access=\"#name == authentication.name\"/>\n <intercept-url pattern=\"/**\" access=\"authenticated\"/>\n</http>\n----\n======\n\nOnce authorized, you can test it using xref:servlet/test/method.adoc#test-method-withmockuser[Security's test support] in the following way:\n\n.Test Directory Authorization\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@WithMockUser(authorities=\"USER\")\n@Test\nvoid endpointWhenUserAuthorityThenAuthorized() {\n this.mvc.perform(get(\"/resource/jon\"))\n .andExpect(status().isOk());\n}\n\n@WithMockUser\n@Test\nvoid endpointWhenNotUserAuthorityThenForbidden() {\n this.mvc.perform(get(\"/resource/jon\"))\n .andExpect(status().isForbidden());\n}\n\n@Test\nvoid anyWhenUnauthenticatedThenUnauthorized() {\n this.mvc.perform(get(\"/any\"))\n .andExpect(status().isUnauthorized());\n}\n----\n======\n\n[NOTE]\nSpring Security only matches paths.\nIf you want to match query parameters, you will need a custom request matcher.\n\n[[match-by-regex]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Matching Using Ant", "heading_level": 3, "file_order": 114, "section_index": 7, "content_hash": "17fbc0e342de70f2b9f6bba2cb09a058faf4f726a8c6efef015862b3bd696de6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:e11e8d71611f73ad32b7ca683eeebad03b1d6fcd751a4511a905c2c9e62475f5", "content": "Spring Security supports matching requests against a regular expression.\nThis can come in handy if you want to apply more strict matching criteria than `**` on a subdirectory.\n\nFor example, consider a path that contains the username and the rule that all usernames must be alphanumeric.\nYou can use javadoc:org.springframework.security.web.util.matcher.RegexRequestMatcher[] to respect this rule, like so:\n\n.Match with Regex\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(RegexRequestMatcher.regexMatcher(\"/resource/[A-Za-z0-9]+\")).hasAuthority(\"USER\")\n .anyRequest().denyAll()\n )\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n authorizeHttpRequests {\n authorize(RegexRequestMatcher.regexMatcher(\"/resource/[A-Za-z0-9]+\"), hasAuthority(\"USER\"))\n authorize(anyRequest, denyAll)\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-url request-matcher=\"regex\" pattern=\"/resource/[A-Za-z0-9]+\" access=\"hasAuthority('USER')\"/>\n <intercept-url pattern=\"/**\" access=\"denyAll\"/>\n</http>\n----\n======\n\n[[match-by-httpmethod]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Matching Using Regular Expressions", "heading_level": 3, "file_order": 114, "section_index": 8, "content_hash": "e11e8d71611f73ad32b7ca683eeebad03b1d6fcd751a4511a905c2c9e62475f5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:7834723ca2f3303d1f493936a172e4cbc3c680aba021882c18a4eb78f3bc66b7", "content": "You can also match rules by HTTP method.\nOne place where this is handy is when authorizing by permissions granted, like being granted a `read` or `write` privilege.\n\nTo require all ``GET``s to have the `read` permission and all ``POST``s to have the `write` permission, you can do something like this:\n\n.Match by HTTP Method\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(HttpMethod.GET).hasAuthority(\"read\")\n .requestMatchers(HttpMethod.POST).hasAuthority(\"write\")\n .anyRequest().denyAll()\n )\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n authorizeHttpRequests {\n authorize(HttpMethod.GET, hasAuthority(\"read\"))\n authorize(HttpMethod.POST, hasAuthority(\"write\"))\n authorize(anyRequest, denyAll)\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-url http-method=\"GET\" pattern=\"/**\" access=\"hasAuthority('read')\"/>\n <intercept-url http-method=\"POST\" pattern=\"/**\" access=\"hasAuthority('write')\"/>\n <intercept-url pattern=\"/**\" access=\"denyAll\"/>\n</http>\n----\n======\n\nThese authorization rules should read as: \"if the request is a GET, then require `read` permission; else, if the request is a POST, then require `write` permission; else, deny the request\"\n\n[TIP]\nDenying the request by default is a healthy security practice since it turns the set of rules into an allow list.\n\nOnce authorized, you can test it using xref:servlet/test/method.adoc#test-method-withmockuser[Security's test support] in the following way:\n\n.Test Http Method Authorization\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@WithMockUser(authorities=\"read\")\n@Test\nvoid getWhenReadAuthorityThenAuthorized() {\n this.mvc.perform(get(\"/any\"))\n .andExpect(status().isOk());\n}\n\n@WithMockUser\n@Test\nvoid getWhenNoReadAuthorityThenForbidden() {\n this.mvc.perform(get(\"/any\"))\n .andExpect(status().isForbidden());\n}\n\n@WithMockUser(authorities=\"write\")\n@Test\nvoid postWhenWriteAuthorityThenAuthorized() {\n this.mvc.perform(post(\"/any\").with(csrf()))\n .andExpect(status().isOk());\n}\n\n@WithMockUser(authorities=\"read\")\n@Test\nvoid postWhenNoWriteAuthorityThenForbidden() {\n this.mvc.perform(post(\"/any\").with(csrf()))\n .andExpect(status().isForbidden());\n}\n----\n======\n\n[[match-by-dispatcher-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Matching By Http Method", "heading_level": 3, "file_order": 114, "section_index": 9, "content_hash": "7834723ca2f3303d1f493936a172e4cbc3c680aba021882c18a4eb78f3bc66b7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:de7e6f5651818d254558225bf9fadb2e3fd6c57925a5c3114339e30a1aec9758", "content": "[NOTE]\nThis feature is not currently supported in XML\n\nAs stated earlier, Spring Security <<_all_dispatches_are_authorized, authorizes all dispatcher types by default>>.\nAnd even though xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontext[the security context] established on the `REQUEST` dispatch carries over to subsequent dispatches, subtle mismatches can sometimes cause an unexpected `AccessDeniedException`.\n\nTo address that, you can configure Spring Security Java configuration to allow dispatcher types like `FORWARD` and `ERROR`, like so:\n\n.Match by Dispatcher Type\n[tabs]\n======\nJava::\n+\n[source,java,role=\"secondary\"]\n----\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .dispatcherTypeMatchers(DispatcherType.FORWARD, DispatcherType.ERROR).permitAll()\n .requestMatchers(\"/endpoint\").permitAll()\n .anyRequest().denyAll()\n )\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n authorizeHttpRequests {\n authorize(DispatcherTypeRequestMatcher(DispatcherType.FORWARD), permitAll)\n authorize(DispatcherTypeRequestMatcher(DispatcherType.ERROR), permitAll)\n authorize(\"/endpoint\", permitAll)\n authorize(anyRequest, denyAll)\n }\n}\n----\n======\n\n[[match-by-mvc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Matching By Dispatcher Type", "heading_level": 3, "file_order": 114, "section_index": 10, "content_hash": "de7e6f5651818d254558225bf9fadb2e3fd6c57925a5c3114339e30a1aec9758", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:350946173db4a7eb50d1d21af59116c0fdae7b7e10ba57f1dbedaed037ea55e4", "content": "Generally speaking, you can use `requestMatchers(String)` as demonstrated above.\n\nHowever, if you have authorization rules from multiple servlets, you need to specify those:\n\n.Match by PathPatternRequestMatcher\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.web.servlet.util.matcher.PathPatternRequestMatcher.withDefaults;\n\n@Bean\nSecurityFilterChain appEndpoints(HttpSecurity http) {\n\tPathPatternRequestMatcher.Builder mvc = withDefaults().basePath(\"/spring-mvc\");\n\thttp\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(mvc.matcher(\"/admin/**\")).hasAuthority(\"admin\")\n .requestMatchers(mvc.matcher(\"/my/controller/**\")).hasAuthority(\"controller\")\n .anyRequest().authenticated()\n );\n\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun appEndpoints(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(\"/spring-mvc\", \"/admin/**\", hasAuthority(\"admin\"))\n authorize(\"/spring-mvc\", \"/my/controller/**\", hasAuthority(\"controller\"))\n authorize(anyRequest, authenticated)\n }\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-url servlet-path=\"/spring-mvc\" pattern=\"/admin/**\" access=\"hasAuthority('admin')\"/>\n <intercept-url servlet-path=\"/spring-mvc\" pattern=\"/my/controller/**\" access=\"hasAuthority('controller')\"/>\n <intercept-url pattern=\"/**\" access=\"authenticated\"/>\n</http>\n----\n======\n\nThis is because Spring Security requires all URIs to be absolute (minus the context path).\n\n[TIP]\n=====\nThere are several other components that create request matchers for you like {spring-boot-api-url}org/springframework/boot/security/autoconfigure/web/servlet/PathRequest.html[`PathRequest#toStaticResources#atCommonLocations`]\n=====\n\n[[match-by-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Matching by Servlet Path", "heading_level": 3, "file_order": 114, "section_index": 11, "content_hash": "350946173db4a7eb50d1d21af59116c0fdae7b7e10ba57f1dbedaed037ea55e4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:ded66c3bc496c22114070e8b12d373c574b08a3886ecd0f52822726879f2ec8d", "content": "[NOTE]\nThis feature is not currently supported in XML\n\nIn Java configuration, you can create your own javadoc:org.springframework.security.web.util.matcher.RequestMatcher[] and supply it to the DSL like so:\n\n.Authorize by Dispatcher Type\n[tabs]\n======\nJava::\n+\n[source,java,role=\"secondary\"]\n----\nRequestMatcher printview = (request) -> request.getParameter(\"print\") != null;\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(printview).hasAuthority(\"print\")\n .anyRequest().authenticated()\n )\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval printview: RequestMatcher = { (request) -> request.getParameter(\"print\") != null }\nhttp {\n authorizeHttpRequests {\n authorize(printview, hasAuthority(\"print\"))\n authorize(anyRequest, authenticated)\n }\n}\n----\n======\n\n[TIP]\nBecause javadoc:org.springframework.security.web.util.matcher.RequestMatcher[] is a functional interface, you can supply it as a lambda in the DSL.\nHowever, if you want to extract values from the request, you will need to have a concrete class since that requires overriding a `default` method.\n\nOnce authorized, you can test it using xref:servlet/test/method.adoc#test-method-withmockuser[Security's test support] in the following way:\n\n.Test Custom Authorization\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@WithMockUser(authorities=\"print\")\n@Test\nvoid printWhenPrintAuthorityThenAuthorized() {\n this.mvc.perform(get(\"/any?print\"))\n .andExpect(status().isOk());\n}\n\n@WithMockUser\n@Test\nvoid printWhenNoPrintAuthorityThenForbidden() {\n this.mvc.perform(get(\"/any?print\"))\n .andExpect(status().isForbidden());\n}\n----\n======\n\n[[authorize-requests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Using a Custom Matcher", "heading_level": 3, "file_order": 114, "section_index": 12, "content_hash": "ded66c3bc496c22114070e8b12d373c574b08a3886ecd0f52822726879f2ec8d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:2ac07617c40b38c10b02af8b753f5737fff105ce0baf323bb4fb5066bccdf086", "content": "Once a request is matched, you can authorize it in several ways <<match-requests, already seen>> like `permitAll`, `denyAll`, and `hasAuthority`.\n\nAs a quick summary, here are the authorization rules built into the DSL:\n\n* `permitAll` - The request requires no authorization and is a public endpoint; note that in this case, xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[the `Authentication`] is never retrieved from the session\n* `denyAll` - The request is not allowed under any circumstances; note that in this case, the `Authentication` is never retrieved from the session\n* `hasAuthority` - The request requires that the `Authentication` have xref:servlet/authorization/architecture.adoc#authz-authorities[a `GrantedAuthority`] that matches the given value\n* `hasRole` - A shortcut for `hasAuthority` that prefixes `ROLE_` or whatever is configured as the default prefix\n* `hasAnyAuthority` - The request requires that the `Authentication` have a `GrantedAuthority` that matches any of the given values\n* `hasAnyRole` - A shortcut for `hasAnyAuthority` that prefixes `ROLE_` or whatever is configured as the default prefix\n* `hasAllRoles` - A shortcut for `hasAllAuthorities` that prefixes `ROLE_` or whatever is configured as the default prefix\n* `hasAllAuthorities` - The request requires that the `Authentication` have a `GrantedAuthority` that matches all of the given values\n* `access` - The request uses this custom `AuthorizationManager` to determine access\n\nHaving now learned the patterns, rules, and how they can be paired together, you should be able to understand what is going on in this more complex example:\n\n.Authorize Requests\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static jakarta.servlet.DispatcherType.*;\n\nimport static org.springframework.security.authorization.AuthorizationManagers.allOf;\nimport static org.springframework.security.authorization.AuthorityAuthorizationManager.hasAuthority;\nimport static org.springframework.security.authorization.AuthorityAuthorizationManager.hasRole;\n\n@Bean\nSecurityFilterChain web(HttpSecurity http) throws Exception {\n\thttp\n // ...\n .authorizeHttpRequests((authorize) -> authorize // <1>\n .dispatcherTypeMatchers(FORWARD, ERROR).permitAll() // <2>\n .requestMatchers(\"/static/**\", \"/signup\", \"/about\").permitAll() // <3>\n .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\") // <4>\n .requestMatchers(\"/db/**\").hasAllAuthorities(\"db\", \"ROLE_ADMIN\") // <5>\n .anyRequest().denyAll() // <6>\n );\n\n\treturn http.build();\n}\n----\n======\n<1> There are multiple authorization rules specified.\nEach rule is considered in the order they were declared.\n<2> Dispatches `FORWARD` and `ERROR` are permitted to allow {spring-framework-reference-url}web.html#spring-web[Spring MVC] to render views and Spring Boot to render errors\n<3> We specified multiple URL patterns that any user can access.\nSpecifically, any user can access a request if the URL starts with \"/static/\", equals \"/signup\", or equals \"/about\".\n<4> Any URL that starts with \"/admin/\" will be restricted to users who have the role \"ROLE_ADMIN\".\nYou will notice that since we are invoking the `hasRole` method we do not need to specify the \"ROLE_\" prefix.\n<5> Any URL that starts with \"/db/\" requires the user to have both been granted the \"db\" permission as well as be a \"ROLE_ADMIN\".\nYou will notice that since we are using the `hasAllAuthorities` expression we must specify the \"ROLE_\" prefix.\n<6> Any URL that has not already been matched on is denied access.\nThis is a good strategy if you do not want to accidentally forget to update your authorization rules.\n\n[[customizing-authorization-managers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Authorizing Requests", "heading_level": 2, "file_order": 114, "section_index": 13, "content_hash": "2ac07617c40b38c10b02af8b753f5737fff105ce0baf323bb4fb5066bccdf086", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:32a25f7825a43d7fa156e91a65541d9c6bdb190cdad8f6b9fdf962e24b838839", "content": "When you use the `authorizeHttpRequests` DSL, Spring Security takes care of creating the appropriate `AuthorizationManager` instances for you.\nIn certain cases, you may want to customize what is created in order to have complete control over how authorization decisions are made xref:servlet/authorization/architecture.adoc#authz-delegate-authorization-manager[at the framework level].\n\nIn order to take control of creating instances of `AuthorizationManager` for authorizing HTTP requests, you can create a custom xref:servlet/authorization/architecture.adoc#authz-authorization-manager-factory[`AuthorizationManagerFactory`].\nFor example, let's say you want to create a convention that authenticated users must be authenticated _AND_ have the `USER` role.\nTo do this, you can create a custom implementation for HTTP requests as in the following example:\n\ninclude-code::./CustomHttpRequestsAuthorizationManagerFactory[tag=class,indent=0]\n\nNow, whenever you <<activate-request-security,require authentication>>, Spring Security will automatically invoke your custom factory to create an instance of `AuthorizationManager` that requires authentication _AND_ the `USER` role.\n\n[TIP]\nWe use this as a simple example of creating a custom `AuthorizationManagerFactory`, though it is also possible (and often simpler) to replace a specific `AuthorizationManager` only for a particular request.\nSee <<remote-authorization-manager>> for an example.\n\n[[authorization-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Customizing Authorization Managers", "heading_level": 2, "file_order": 114, "section_index": 14, "content_hash": "32a25f7825a43d7fa156e91a65541d9c6bdb190cdad8f6b9fdf962e24b838839", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:24fa3e290072833cd4ca29b50ed9c69d59a2e624a5b78447317ae1224445a45f", "content": "While using a concrete `AuthorizationManager` is recommended, there are some cases where an expression is necessary, like with `<intercept-url>` or with JSP Taglibs.\nFor that reason, this section will focus on examples from those domains.\n\nGiven that, let's cover Spring Security's Web Security Authorization SpEL API a bit more in depth.\n\nSpring Security encapsulates all of its authorization fields and methods in a set of root objects.\nThe most generic root object is called `SecurityExpressionRoot` and it forms the basis for `WebSecurityExpressionRoot`.\nSpring Security supplies this root object to `StandardEvaluationContext` when preparing to evaluate an authorization expression.\n\n[[using-authorization-expression-fields-and-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Expressing Authorization with SpEL", "heading_level": 2, "file_order": 114, "section_index": 15, "content_hash": "24fa3e290072833cd4ca29b50ed9c69d59a2e624a5b78447317ae1224445a45f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:7221d0489c9356ccbbc8ed7f68a90a44dba7d044d774e86dd2a68a705c7bc053", "content": "The first thing this provides is an enhanced set of authorization fields and methods to your SpEL expressions.\nWhat follows is a quick overview of the most common methods:\n\n* `permitAll` - The request requires no authorization to be invoked; note that in this case, xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[the `Authentication`] is never retrieved from the session\n* `denyAll` - The request is not allowed under any circumstances; note that in this case, the `Authentication` is never retrieved from the session\n* `hasAuthority` - The request requires that the `Authentication` have xref:servlet/authorization/architecture.adoc#authz-authorities[a `GrantedAuthority`] that matches the given value\n* `hasRole` - A shortcut for `hasAuthority` that prefixes `ROLE_` or whatever is configured as the default prefix\n* `hasAnyAuthority` - The request requires that the `Authentication` have a `GrantedAuthority` that matches any of the given values\n* `hasAnyRole` - A shortcut for `hasAnyAuthority` that prefixes `ROLE_` or whatever is configured as the default prefix\n* `hasPermission` - A hook into your `PermissionEvaluator` instance for doing object-level authorization\n\nAnd here is a brief look at the most common fields:\n\n* `authentication` - The `Authentication` instance associated with this method invocation\n* `principal` - The `Authentication#getPrincipal` associated with this method invocation\n\nHaving now learned the patterns, rules, and how they can be paired together, you should be able to understand what is going on in this more complex example:\n\n.Authorize Requests Using SpEL\n[tabs]\n======\nXml::\n+\n[source,java,role=\"primary\"]\n----\n<http>\n <intercept-url pattern=\"/static/**\" access=\"permitAll\"/> <1>\n <intercept-url pattern=\"/admin/**\" access=\"hasRole('ADMIN')\"/> <2>\n <intercept-url pattern=\"/db/**\" access=\"hasAuthority('db') and hasRole('ADMIN')\"/> <3>\n <intercept-url pattern=\"/**\" access=\"denyAll\"/> <4>\n</http>\n----\n======\n<1> We specified a URL pattern that any user can access.\nSpecifically, any user can access a request if the URL starts with \"/static/\".\n<2> Any URL that starts with \"/admin/\" will be restricted to users who have the role \"ROLE_ADMIN\".\nYou will notice that since we are invoking the `hasRole` method we do not need to specify the \"ROLE_\" prefix.\n<3> Any URL that starts with \"/db/\" requires the user to have both been granted the \"db\" permission as well as be a \"ROLE_ADMIN\".\nYou will notice that since we are using the `hasRole` expression we do not need to specify the \"ROLE_\" prefix.\n<4> Any URL that has not already been matched on is denied access.\nThis is a good strategy if you do not want to accidentally forget to update your authorization rules.\n\n[[using_path_parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Using Authorization Expression Fields and Methods", "heading_level": 3, "file_order": 114, "section_index": 16, "content_hash": "7221d0489c9356ccbbc8ed7f68a90a44dba7d044d774e86dd2a68a705c7bc053", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:8c100edee91e264c8f9c43ab9d354d20519c394f7b964be81bbcc58d9157cbaa", "content": "Additionally, Spring Security provides a mechanism for discovering path parameters so they can also be accessed in the SpEL expression as well.\n\nFor example, you can access a path parameter in your SpEL expression in the following way:\n\n.Authorize Request using SpEL path variable\n[tabs]\n======\nXml::\n+\n[source,xml,role=\"primary\"]\n----\n<http>\n <intercept-url pattern=\"/resource/{name}\" access=\"#name == authentication.name\"/>\n <intercept-url pattern=\"/**\" access=\"authenticated\"/>\n</http>\n----\n======\n\nThis expression refers to the path variable after `/resource/` and requires that it is equal to `Authentication#getName`.\n\n[[remote-authorization-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Using Path Parameters", "heading_level": 3, "file_order": 114, "section_index": 17, "content_hash": "8c100edee91e264c8f9c43ab9d354d20519c394f7b964be81bbcc58d9157cbaa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:d9cfa2c4391a3290a367a40cbbab47eaaf010bdddd192efbf7a4f39e51847ac5", "content": "If you want to configure Spring Security to use a separate service for authorization, you can create your own `AuthorizationManager` and match it to `anyRequest`.\n\nFirst, your `AuthorizationManager` may look something like this:\n\n.Open Policy Agent Authorization Manager\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic final class OpenPolicyAgentAuthorizationManager implements AuthorizationManager<RequestAuthorizationContext> {\n @Override\n public AuthorizationResult authorize(Supplier<Authentication> authentication, RequestAuthorizationContext context) {\n // make request to Open Policy Agent\n }\n}\n----\n======\n\nThen, you can wire it into Spring Security in the following way:\n\n.Any Request Goes to Remote Service\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain web(HttpSecurity http, AuthorizationManager<RequestAuthorizationContext> authz) throws Exception {\n\thttp\n // ...\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().access(authz)\n );\n\n\treturn http.build();\n}\n----\n======\n\n[[favor-permitall]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Use an Authorization Database, Policy Agent, or Other Service", "heading_level": 3, "file_order": 114, "section_index": 18, "content_hash": "d9cfa2c4391a3290a367a40cbbab47eaaf010bdddd192efbf7a4f39e51847ac5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:0bfd1983233c438c6079337369ed03525456fc11c58548dadfe3412722253745", "content": "When you have static resources it can be tempting to configure the filter chain to ignore these values.\nA more secure approach is to permit them using `permitAll` like so:\n\n.Permit Static Resources\n[tabs]\n======\nJava::\n+\n[source,java,role=\"secondary\"]\n----\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/css/**\").permitAll()\n .anyRequest().authenticated()\n )\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n authorizeHttpRequests {\n authorize(\"/css/**\", permitAll)\n authorize(anyRequest, authenticated)\n }\n}\n----\n======\n\nIt's more secure because even with static resources it's important to write secure headers, which Spring Security cannot do if the request is ignored.\n\nIn this past, this came with a performance tradeoff since the session was consulted by Spring Security on every request.\nAs of Spring Security 6, however, the session is no longer pinged unless required by the authorization rule.\nBecause the performance impact is now addressed, Spring Security recommends using at least `permitAll` for all requests.\n\n[[migrate-authorize-requests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Favor `permitAll` over `ignoring`", "heading_level": 3, "file_order": 114, "section_index": 19, "content_hash": "0bfd1983233c438c6079337369ed03525456fc11c58548dadfe3412722253745", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:3c42ec7f7705e453bf56673277f9ef65b89acc07ccb6b21310f3400f90728f20", "content": "[NOTE]\n`AuthorizationFilter` supersedes javadoc:org.springframework.security.web.access.intercept.FilterSecurityInterceptor[].\nTo remain backward compatible, `FilterSecurityInterceptor` remains the default.\nThis section discusses how `AuthorizationFilter` works and how to override the default configuration.\n\nThe javadoc:org.springframework.security.web.access.intercept.AuthorizationFilter[] provides xref:servlet/authorization/index.adoc#servlet-authorization[authorization] for ``HttpServletRequest``s.\nIt is inserted into the xref:servlet/architecture.adoc#servlet-filterchainproxy[FilterChainProxy] as one of the xref:servlet/architecture.adoc#servlet-security-filters[Security Filters].\n\nYou can override the default when you declare a `SecurityFilterChain`.\nInstead of using javadoc:org.springframework.security.config.annotation.web.builders.HttpSecurity#authorizeRequests()[authorizeRequests], use `authorizeHttpRequests`, like so:\n\n.Use authorizeHttpRequests\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain web(HttpSecurity http) throws AuthenticationException {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated();\n )\n // ...\n\n return http.build();\n}\n----\n======\n\nThis improves on `authorizeRequests` in a number of ways:\n\n1. Uses the simplified `AuthorizationManager` API instead of metadata sources, config attributes, decision managers, and voters.\nThis simplifies reuse and customization.\n2. Delays `Authentication` lookup.\nInstead of the authentication needing to be looked up for every request, it will only look it up in requests where an authorization decision requires authentication.\n3. Bean-based configuration support.\n\nWhen `authorizeHttpRequests` is used instead of `authorizeRequests`, then javadoc:org.springframework.security.web.access.intercept.AuthorizationFilter[] is used instead of javadoc:org.springframework.security.web.access.intercept.FilterSecurityInterceptor[].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Migrating from `authorizeRequests`", "heading_level": 2, "file_order": 114, "section_index": 20, "content_hash": "3c42ec7f7705e453bf56673277f9ef65b89acc07ccb6b21310f3400f90728f20", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:aac29edd0b3a9140d169e5d1fa02862de955ce88dde0c7b7d2d877c7a58f7832", "content": "Where possible, it is recommended that you use type-safe authorization managers instead of SpEL.\nFor Java configuration, javadoc:org.springframework.security.web.access.expression.WebExpressionAuthorizationManager[] is available to help migrate legacy SpEL.\n\nTo use `WebExpressionAuthorizationManager`, you can construct one with the expression you are trying to migrate, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n.requestMatchers(\"/test/**\").access(new WebExpressionAuthorizationManager(\"hasRole('ADMIN') && hasRole('USER')\"))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n.requestMatchers(\"/test/**\").access(WebExpressionAuthorizationManager(\"hasRole('ADMIN') && hasRole('USER')\"))\n----\n======\n\nTo migrate several, you can use `WebExpressionAuthorizationManager#withDefaults`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nWebExpressionAuthorizationManager.Builder authz = WebExpressionAuthorizationManager.withDefaults();\n.requestMatchers(\"/test/**\").access(authz.expression(\"hasRole('ADMIN') && hasRole('USER')\"))\n.requestMatchers(\"/test/**\").access(authz.expression(\"permitAll\"))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nvar authz = WebExpressionAuthorizationManager.withDefaults()\n.requestMatchers(\"/test/**\").access(authz.expression(\"hasRole('ADMIN') && hasRole('USER')\"))\n.requestMatchers(\"/test/**\").access(authz.expression(\"permitAll\"))\n----\n======\n\nIf you are referring to a bean in your expression like so: `@webSecurity.check(authentication, request)`, it's recommended that you instead call the bean directly, which will look something like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n.requestMatchers(\"/test/**\").access((authentication, context) ->\n new AuthorizationDecision(webSecurity.check(authentication.get(), context.getRequest())))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n.requestMatchers(\"/test/**\").access((authentication, context): AuthorizationManager<RequestAuthorizationContext> ->\n AuthorizationDecision(webSecurity.check(authentication.get(), context.getRequest())))\n----\n======\n\nFor complex instructions that include bean references as well as other expressions, it is recommended that you change those to implement `AuthorizationManager` and refer to them by calling `.access(AuthorizationManager)`.\n\nIf you are not able to do that, you can publish javadoc:org.springframework.security.web.access.expression.WebExpressionAuthorizationManager$Builder[] as a bean:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nWebExpressionAuthorizationManager.Builder authz() {\n\treturn WebExpressionAuthorizationManager.withDefaults();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authz(): WebExpressionAuthorizationManager.Builder {\n\treturn WebExpressionAuthorizationManager.withDefaults()\n}\n----\n======\n\nThen, expressions passed to that builder will be able to refer to beans.\n\n[[security-matchers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Migrating Expressions", "heading_level": 3, "file_order": 114, "section_index": 21, "content_hash": "aac29edd0b3a9140d169e5d1fa02862de955ce88dde0c7b7d2d877c7a58f7832", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:fe453f7a5ae19d010435b15ed1f371aaff7a0e046e72c84735f3bf0971a1a91b", "content": "The javadoc:org.springframework.security.web.util.matcher.RequestMatcher[] interface is used to determine if a request matches a given rule.\nWe use `securityMatchers` to determine if xref:servlet/configuration/java.adoc#jc-httpsecurity[a given `HttpSecurity`] should be applied to a given request.\nThe same way, we can use `requestMatchers` to determine the authorization rules that we should apply to a given request.\nLook at the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n .securityMatcher(\"/api/**\") <1>\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/api/user/**\").hasRole(\"USER\") <2>\n .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\") <3>\n .anyRequest().authenticated() <4>\n )\n .formLogin(withDefaults());\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nopen class SecurityConfig {\n\n @Bean\n open fun web(http: HttpSecurity): SecurityFilterChain {\n http {\n securityMatcher(\"/api/**\") <1>\n authorizeHttpRequests {\n authorize(\"/api/user/**\", hasRole(\"USER\")) <2>\n authorize(\"/api/admin/**\", hasRole(\"ADMIN\")) <3>\n authorize(anyRequest, authenticated) <4>\n }\n }\n return http.build()\n }\n\n}\n----\n======\n\n<1> Configure `HttpSecurity` to only be applied to URLs that start with `/api/`\n<2> Allow access to URLs that start with `/api/user/` to users with the `USER` role\n<3> Allow access to URLs that start with `/api/admin/` to users with the `ADMIN` role\n<4> Any other request that doesn't match the rules above, will require authentication\n\nThe `securityMatcher(s)` and `requestMatcher(s)` methods will construct ``RequestMatcher``s using a javadoc:org.springframework.security.web.servlet.util.matcher.PathPatternRequestMatcher$Builder[] bean, if available.\nYou can read more about the Spring MVC integration xref:servlet/integrations/mvc.adoc[here].\n\nIf you want to use a specific `RequestMatcher`, just pass an implementation to the `securityMatcher` and/or `requestMatcher` methods:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.web.servlet.util.matcher.PathPatternRequestMatcher.withDefaults; <1>\nimport static org.springframework.security.web.util.matcher.RegexRequestMatcher.regexMatcher;\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n .securityMatcher(antMatcher(\"/api/**\")) <2>\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(withDefaults().matcher(\"/api/user/**\")).hasRole(\"USER\") <3>\n .requestMatchers(regexMatcher(\"/api/admin/.*\")).hasRole(\"ADMIN\") <4>\n .requestMatchers(new MyCustomRequestMatcher()).hasRole(\"SUPERVISOR\") <5>\n .anyRequest().authenticated()\n )\n .formLogin(withDefaults());\n return http.build();\n\t}\n}\n\npublic class MyCustomRequestMatcher implements RequestMatcher {\n\n @Override\n public boolean matches(HttpServletRequest request) {\n // ...\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.web.servlet.util.matcher.PathPatternRequestMatcher.withDefaults <1>\nimport org.springframework.security.web.util.matcher.RegexRequestMatcher.regexMatcher\n\n@Configuration\n@EnableWebSecurity\nopen class SecurityConfig {\n\n @Bean\n open fun web(http: HttpSecurity): SecurityFilterChain {\n http {\n securityMatcher(antMatcher(\"/api/**\")) <2>\n authorizeHttpRequests {\n authorize(withDefaults().matcher(\"/api/user/**\"), hasRole(\"USER\")) <3>\n authorize(regexMatcher(\"/api/admin/**\"), hasRole(\"ADMIN\")) <4>\n authorize(MyCustomRequestMatcher(), hasRole(\"SUPERVISOR\")) <5>\n authorize(anyRequest, authenticated)\n }\n }\n return http.build()\n }\n\n}\n----\n======\n\n<1> Import the static factory methods from `PathPatternRequestMatcher` and `RegexRequestMatcher` to create `RequestMatcher` instances.\n<2> Configure `HttpSecurity` to only be applied to URLs that start with `/api/`, using `PathPatternRequestMatcher`\n<3> Allow access to URLs that start with `/api/user/` to users with the `USER` role, using `PathPatternRequestMatcher`\n<4> Allow access to URLs that start with `/api/admin/` to users with the `ADMIN` role, using `RegexRequestMatcher`\n<5> Allow access to URLs that match the `MyCustomRequestMatcher` to users with the `SUPERVISOR` role, using a custom `RequestMatcher`", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Security Matchers", "heading_level": 2, "file_order": 114, "section_index": 22, "content_hash": "fe453f7a5ae19d010435b15ed1f371aaff7a0e046e72c84735f3bf0971a1a91b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:19ba417cc3d49fee104fae741db196e241cca867d587fdd4e95daf99621dac1f", "content": "Now that you have secured your application's requests, consider xref:servlet/authorization/method-security.adoc[securing its methods].\nYou can also read further on xref:servlet/test/index.adoc[testing your application] or on integrating Spring Security with other aspects of your application like xref:servlet/integrations/data.adoc[the data layer] or xref:servlet/integrations/observability.adoc[tracing and metrics].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc", "title": "authorize-http-requests", "heading": "Further Reading", "heading_level": 2, "file_order": 114, "section_index": 23, "content_hash": "19ba417cc3d49fee104fae741db196e241cca867d587fdd4e95daf99621dac1f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/authorize-http-requests.adoc"}}
{"id": "sha256:c77a4d6f794bd49c5f67c5872f7fc81390d3efec5ab04edd3f34b615da65ba29", "content": "[[servlet-events]]\n\nFor each authorization that is denied, an `AuthorizationDeniedEvent` is fired.\nAlso, it's possible to fire an `AuthorizationGrantedEvent` for authorizations that are granted.\n\nTo listen for these events, you must first publish an `AuthorizationEventPublisher`.\n\nSpring Security's `SpringAuthorizationEventPublisher` will probably do fine.\nIt comes publishes authorization events using Spring's `ApplicationEventPublisher`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic AuthorizationEventPublisher authorizationEventPublisher\n (ApplicationEventPublisher applicationEventPublisher) {\n return new SpringAuthorizationEventPublisher(applicationEventPublisher);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizationEventPublisher\n (applicationEventPublisher: ApplicationEventPublisher?): AuthorizationEventPublisher {\n return SpringAuthorizationEventPublisher(applicationEventPublisher)\n}\n----\n======\n\nThen, you can use Spring's `@EventListener` support:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class AuthenticationEvents {\n\n @EventListener\n public void onFailure(AuthorizationDeniedEvent failure) {\n // ...\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass AuthenticationEvents {\n\n @EventListener\n fun onFailure(failure: AuthorizationDeniedEvent?) {\n // ...\n }\n}\n----\n======\n\n[[authorization-granted-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/events.adoc", "title": "events", "heading": "events", "heading_level": 1, "file_order": 115, "section_index": 0, "content_hash": "c77a4d6f794bd49c5f67c5872f7fc81390d3efec5ab04edd3f34b615da65ba29", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/events.adoc"}}
{"id": "sha256:005f36139b7e3467531d1c61a3f1cf028b7138deebd577e2f29081ff26e81a49", "content": "Because ``AuthorizationGrantedEvent``s have the potential to be quite noisy, they are not published by default.\n\nIn fact, publishing these events will likely require some business logic on your part to ensure that your application is not inundated with noisy authorization events.\n\nYou can provide your own predicate that filters success events.\nFor example, the following publisher only publishes authorization grants where `ROLE_ADMIN` was required:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nAuthorizationEventPublisher authorizationEventPublisher() {\n SpringAuthorizationEventPublisher eventPublisher = new SpringAuthorizationEventPublisher();\n eventPublisher.setShouldPublishEvent((result) -> {\n if (!result.isGranted()) {\n return true;\n }\n if (result instanceof AuthorityAuthorizationDecision decision) {\n Collection<GrantedAuthority> authorities = decision.getAuthorities();\n return AuthorityUtils.authorityListToSet(authorities).contains(\"ROLE_ADMIN\");\n }\n return false;\n });\n return eventPublisher;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizationEventPublisher(): AuthorizationEventPublisher {\n val eventPublisher = SpringAuthorizationEventPublisher()\n eventPublisher.setShouldPublishEvent { (result) ->\n if (!result.isGranted()) {\n return true\n }\n if (decision is AuthorityAuthorizationDecision) {\n val authorities = decision.getAuthorities()\n return AuthorityUtils.authorityListToSet(authorities).contains(\"ROLE_ADMIN\")\n }\n return false\n }\n return eventPublisher\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/events.adoc", "title": "events", "heading": "Authorization Granted Events", "heading_level": 2, "file_order": 115, "section_index": 1, "content_hash": "005f36139b7e3467531d1c61a3f1cf028b7138deebd577e2f29081ff26e81a49", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/events.adoc"}}
{"id": "sha256:853a8b5d36e5f862610162d04e20accaa08811bc9b9d0bee8058c3915fe51fe7", "content": "[[servlet-authorization]]\n\nHaving established xref:servlet/authentication/index.adoc[how users will authenticate], you also need to configure your application's authorization rules.\n\nThe advanced authorization capabilities within Spring Security represent one of the most compelling reasons for its popularity.\nIrrespective of how you choose to authenticate (whether using a Spring Security-provided mechanism and provider or integrating with a container or other non-Spring Security authentication authority), the authorization services can be used within your application in a consistent and simple way.\n\nYou should consider attaching authorization rules to xref:servlet/authorization/authorize-http-requests.adoc[request URIs] and xref:servlet/authorization/method-security.adoc[methods] to begin.\nIn either case, you can listen and react to xref:servlet/authorization/events.adoc[authorization events] that each authorization check publishes.\nBelow there is also wealth of detail about xref:servlet/authorization/architecture.adoc[how Spring Security authorization works] and how, having established a basic model, it can be fine-tuned.\n\n[NOTE]\n====\nAs of Spring Security 7, the Access API (`AccessDecisionManager`, `AccessDecisionVoter`, etc.) are moved to a legacy module, `spring-security-access`.\nFor new applications, there is no need to include the dependency.\nFor older applications that have not yet migrated to the Authorization API, this module is available to assist your continued migration efforts.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 116, "section_index": 0, "content_hash": "853a8b5d36e5f862610162d04e20accaa08811bc9b9d0bee8058c3915fe51fe7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/index.adoc"}}
{"id": "sha256:6ecaeb323c180b42307450cfc0709e7d55ef5ad58abd95a0d47b6312f920ed18", "content": "[[jc-method]]\n\nIn addition to xref:servlet/authorization/authorize-http-requests.adoc[modeling authorization at the request level], Spring Security also supports modeling at the method level.\n\n[[activate-method-security]]\nYou can activate it in your application by annotating any `@Configuration` class with `@EnableMethodSecurity` or adding `<method-security>` to any XML configuration file, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@EnableMethodSecurity\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@EnableMethodSecurity\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<sec:method-security/>\n----\n======\n\nThen, you are immediately able to annotate any Spring-managed class or method with <<use-preauthorize, `@PreAuthorize`>>, <<use-postauthorize,`@PostAuthorize`>>, <<use-prefilter,`@PreFilter`>>, and <<use-postfilter,`@PostFilter`>> to authorize method invocations, including the input parameters and return values.\n\n[NOTE]\n{spring-boot-reference-url}reference/using/build-systems.html#using.build-systems.starters[Spring Boot Starter Security] does not activate method-level authorization by default.\n\nMethod Security supports many other use cases as well including <<use-aspectj, AspectJ support>>, <<use-programmatic-authorization,custom annotations>>, and several configuration points.\nConsider learning about the following use cases:\n\n* <<migration-enableglobalmethodsecurity, Migrating from `@EnableGlobalMethodSecurity`>>\n* Understanding <<method-security-architecture,how method security works>> and reasons to use it\n* Comparing <<request-vs-method,request-level and method-level authorization>>\n* Authorizing methods with <<use-preauthorize,`@PreAuthorize`>> and <<use-postauthorize,`@PostAuthorize`>>\n* Providing <<fallback-values-authorization-denied,fallback values when authorization is denied>>\n* Filtering methods with <<use-prefilter,`@PreFilter`>> and <<use-postfilter,`@PostFilter`>>\n* Authorizing methods with <<use-jsr250,JSR-250 annotations>>\n* Authorizing methods with <<use-aspectj,AspectJ expressions>>\n* Integrating with <<weave-aspectj,AspectJ byte-code weaving>>\n* Coordinating with <<changing-the-order,@Transactional and other AOP-based annotations>>\n* Customizing <<customizing-expression-handling,SpEL expression handling>>\n* Integrating with <<custom-authorization-managers,custom authorization systems>>\n\n[[method-security-architecture]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "method-security", "heading_level": 1, "file_order": 117, "section_index": 0, "content_hash": "6ecaeb323c180b42307450cfc0709e7d55ef5ad58abd95a0d47b6312f920ed18", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:1c6ffff3070b72e808366c7de4e64b3cbca86903e9e058ecb9cdd2528eb6e91e", "content": "Spring Security's method authorization support is handy for:\n\n* Extracting fine-grained authorization logic; for example, when the method parameters and return values contribute to the authorization decision.\n* Enforcing security at the service layer\n* Stylistically favoring annotation-based over `HttpSecurity`-based configuration\n\nAnd since Method Security is built using {spring-framework-reference-url}core.html#aop-api[Spring AOP], you have access to all its expressive power to override Spring Security's defaults as needed.\n\nAs already mentioned, you begin by adding `@EnableMethodSecurity` to a `@Configuration` class or `<sec:method-security/>` in a Spring XML configuration file.\n\n[[use-method-security]]\n[NOTE]\n====\nThis annotation and XML element supercede `@EnableGlobalMethodSecurity` and `<sec:global-method-security/>`, respectively.\nThey offer the following improvements:\n\n1. Uses the simplified `AuthorizationManager` API instead of metadata sources, config attributes, decision managers, and voters.\nThis simplifies reuse and customization.\n2. Favors direct bean-based configuration, instead of requiring extending `GlobalMethodSecurityConfiguration` to customize beans\n3. Is built using native Spring AOP, removing abstractions and allowing you to use Spring AOP building blocks to customize\n4. Checks for conflicting annotations to ensure an unambiguous security configuration\n5. Complies with JSR-250\n6. Enables `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, and `@PostFilter` by default\n\nIf you are using `@EnableGlobalMethodSecurity` or `<global-method-security/>`, these are now deprecated, and you are encouraged to migrate.\n====\n\nMethod authorization is a combination of before- and after-method authorization.\nConsider a service bean that is annotated in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Service\npublic class MyCustomerService {\n @PreAuthorize(\"hasAuthority('permission:read')\")\n @PostAuthorize(\"returnObject.owner == authentication.name\")\n public Customer readCustomer(String id) { ... }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Service\nopen class MyCustomerService {\n @PreAuthorize(\"hasAuthority('permission:read')\")\n @PostAuthorize(\"returnObject.owner == authentication.name\")\n fun readCustomer(id: String): Customer { ... }\n}\n----\n======\n\nA given invocation to `MyCustomerService#readCustomer` may look something like this when Method Security <<activate-method-security,is activated>>:\n\n[.invert-dark]\nimage::{figures}/methodsecurity.png[]\n\n1. Spring AOP invokes its proxy method for `readCustomer`. Among the proxy's other advisors, it invokes an javadoc:org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor[] that matches <<annotation-method-pointcuts,the `@PreAuthorize` pointcut>>\n2. The interceptor invokes javadoc:org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager[`PreAuthorizeAuthorizationManager#authorize`]\n3. The authorization manager uses a `MethodSecurityExpressionHandler` to parse the annotation's <<authorization-expressions,SpEL expression>> and constructs a corresponding `EvaluationContext` from a `MethodSecurityExpressionRoot` containing xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[a `Supplier<Authentication>`] and `MethodInvocation`.\n4. The interceptor uses this context to evaluate the expression; specifically, it reads xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[the `Authentication`] from the `Supplier` and checks whether it has `permission:read` in its collection of xref:servlet/authorization/architecture.adoc#authz-authorities[authorities]\n5. If the evaluation passes, then Spring AOP proceeds to invoke the method.\n6. If not, the interceptor publishes an `AuthorizationDeniedEvent` and throws an javadoc:org.springframework.security.access.AccessDeniedException[] which xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[the `ExceptionTranslationFilter`] catches and returns a 403 status code to the response\n7. After the method returns, Spring AOP invokes an javadoc:org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor[] that matches <<annotation-method-pointcuts,the `@PostAuthorize` pointcut>>, operating the same as above, but with javadoc:org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager[]\n8. If the evaluation passes (in this case, the return value belongs to the logged-in user), processing continues normally\n9. If not, the interceptor publishes an `AuthorizationDeniedEvent` and throws an javadoc:org.springframework.security.access.AccessDeniedException[], which xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[the `ExceptionTranslationFilter`] catches and returns a 403 status code to the response\n\n[NOTE]\nIf the method is not being called in the context of an HTTP request, you will likely need to handle the `AccessDeniedException` yourself\n\n[[unanimous-based-authorization-decisions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "How Method Security Works", "heading_level": 2, "file_order": 117, "section_index": 1, "content_hash": "1c6ffff3070b72e808366c7de4e64b3cbca86903e9e058ecb9cdd2528eb6e91e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:0d8f52bf1018c0e30e83947fcf989f1ca22eea4d3797dbffdff6b0e42eea64ce", "content": "As demonstrated above, if a method invocation involves multiple <<authorizing-with-annotations,Method Security annotations>>, each of those is processed one at a time.\nThis means that they can collectively be thought of as being \"anded\" together.\nIn other words, for an invocation to be authorized, all annotation inspections need to pass authorization.\n\n[[repeated-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Multiple Annotations Are Computed In Series", "heading_level": 3, "file_order": 117, "section_index": 2, "content_hash": "0d8f52bf1018c0e30e83947fcf989f1ca22eea4d3797dbffdff6b0e42eea64ce", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:c674a73ffcb24f4a293f66d35b4075095d753f2043229ac0506023604fcc1ad0", "content": "That said, it is not supported to repeat the same annotation on the same method.\nFor example, you cannot place `@PreAuthorize` twice on the same method.\n\nInstead, use SpEL's boolean support or its support for delegating to a separate bean.\n\n[[annotation-method-pointcuts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Repeated Annotations Are Not Supported", "heading_level": 3, "file_order": 117, "section_index": 3, "content_hash": "c674a73ffcb24f4a293f66d35b4075095d753f2043229ac0506023604fcc1ad0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:d5eaa7a506adb55bd80fc066d24659041363e03aa030146f88c20f99d4f4c02d", "content": "Each annotation has its own pointcut instance that looks for that annotation or its <<meta-annotations,meta-annotation>> counterparts across the entire object hierarchy, starting at <<class-or-interface-annotations,the method and its enclosing class>>.\n\n[[annotation-method-interceptors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Each Annotation Has Its Own Pointcut", "heading_level": 3, "file_order": 117, "section_index": 4, "content_hash": "d5eaa7a506adb55bd80fc066d24659041363e03aa030146f88c20f99d4f4c02d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:0d3917ddbfdc02d8164a85116cdec41c89ad61b7771fca0ab9d76d23eb7d3fec", "content": "Each annotation has its own dedicated method interceptor.\nThe reason for this is to make things more composable.\nFor example, if needed, you can disable the Spring Security defaults and <<_enabling_certain_annotations,publish only the `@PostAuthorize` method interceptor>>.\n\nThe method interceptors are as follows:\n\n* For <<use-preauthorize,`@PreAuthorize`>>, Spring Security uses javadoc:org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor[`AuthorizationManagerBeforeMethodInterceptor#preAuthorize`], which in turn uses javadoc:org.springframework.security.authorization.method.PreAuthorizeAuthorizationManager[]\n* For <<use-postauthorize,`@PostAuthorize`>>, Spring Security uses javadoc:org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor[`AuthorizationManagerAfterMethodInterceptor#postAuthorize`], which in turn uses javadoc:org.springframework.security.authorization.method.PostAuthorizeAuthorizationManager[]\n* For <<use-prefilter,`@PreFilter`>>, Spring Security uses javadoc:org.springframework.security.authorization.method.PreFilterAuthorizationMethodInterceptor[]\n* For <<use-postfilter,`@PostFilter`>>, Spring Security uses javadoc:org.springframework.security.authorization.method.PostFilterAuthorizationMethodInterceptor[]\n* For <<use-secured,`@Secured`>>, Spring Security uses javadoc:org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor[`AuthorizationManagerBeforeMethodInterceptor#secured`], which in turn uses javadoc:org.springframework.security.authorization.method.SecuredAuthorizationManager[]\n* For JSR-250 annotations, Spring Security uses javadoc:org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor[`AuthorizationManagerBeforeMethodInterceptor#jsr250`], which in turn uses javadoc:org.springframework.security.authorization.method.Jsr250AuthorizationManager[]\n\nGenerally speaking, you can consider the following listing as representative of what interceptors Spring Security publishes when you add `@EnableMethodSecurity`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\nstatic Advisor preAuthorizeMethodInterceptor() {\n return AuthorizationManagerBeforeMethodInterceptor.preAuthorize();\n}\n\n@Bean\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\nstatic Advisor postAuthorizeMethodInterceptor() {\n return AuthorizationManagerAfterMethodInterceptor.postAuthorize();\n}\n\n@Bean\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\nstatic Advisor preFilterMethodInterceptor() {\n return AuthorizationManagerBeforeMethodInterceptor.preFilter();\n}\n\n@Bean\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\nstatic Advisor postFilterMethodInterceptor() {\n return AuthorizationManagerAfterMethodInterceptor.postFilter();\n}\n----\n======\n\n[[favor-granting-authorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Each Annotation Has Its Own Method Interceptor", "heading_level": 3, "file_order": 117, "section_index": 5, "content_hash": "0d3917ddbfdc02d8164a85116cdec41c89ad61b7771fca0ab9d76d23eb7d3fec", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:19f4963c2c6b42f379a064cc4c725ae96062527d19b58849ee6213133a78e048", "content": "Quite often it can be tempting to introduce a complicated SpEL expression like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PreAuthorize(\"hasAuthority('permission:read') || hasRole('ADMIN')\")\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PreAuthorize(\"hasAuthority('permission:read') || hasRole('ADMIN')\")\n----\n======\n\nHowever, you could instead grant `permission:read` to those with `ROLE_ADMIN`.\nOne way to do this is with a `RoleHierarchy` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nstatic RoleHierarchy roleHierarchy() {\n return RoleHierarchyImpl.fromHierarchy(\"ROLE_ADMIN > permission:read\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ncompanion object {\n @Bean\n fun roleHierarchy(): RoleHierarchy {\n return RoleHierarchyImpl.fromHierarchy(\"ROLE_ADMIN > permission:read\")\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<bean id=\"roleHierarchy\"\n class=\"org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl\" factory-method=\"fromHierarchy\">\n <constructor-arg value=\"ROLE_ADMIN > permission:read\"/>\n</bean>\n----\n======\n\nand then <<customizing-expression-handling,set that in a `MethodSecurityExpressionHandler` instance>>.\nThis then allows you to have a simpler <<use-preauthorize,`@PreAuthorize`>> expression like this one:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PreAuthorize(\"hasAuthority('permission:read')\")\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PreAuthorize(\"hasAuthority('permission:read')\")\n----\n======\n\nOr, where possible, adapt application-specific authorization logic into granted authorities at login time.\n\n[[request-vs-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Favor Granting Authorities Over Complicated SpEL Expressions", "heading_level": 3, "file_order": 117, "section_index": 6, "content_hash": "19f4963c2c6b42f379a064cc4c725ae96062527d19b58849ee6213133a78e048", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:b108132650a4b292f82ced738294ecef0e5c1d294caae6b06aea7641c4f5a77c", "content": "When should you favor method-level authorization over xref:servlet/authorization/authorize-http-requests.adoc[request-level authorization]?\nSome of it comes down to taste; however, consider the following strengths list of each to help you decide.\n\n|===\n|| *request-level* | *method-level*\n| *authorization type* | coarse-grained | fine-grained\n| *configuration location* | declared in a config class | local to method declaration\n| *configuration style* | DSL | Annotations\n| *authorization definitions* | programmatic | SpEL\n|===\n\nThe main tradeoff seems to be where you want your authorization rules to live.\n\n[NOTE]\nIt's important to remember that when you use annotation-based Method Security, then unannotated methods are not secured.\nTo protect against this, declare xref:servlet/authorization/authorize-http-requests.adoc#activate-request-security[a catch-all authorization rule] in your xref:servlet/configuration/java.adoc#jc-httpsecurity[`HttpSecurity`] instance.\n\n[[authorizing-with-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Comparing Request-level vs Method-level Authorization", "heading_level": 2, "file_order": 117, "section_index": 7, "content_hash": "b108132650a4b292f82ced738294ecef0e5c1d294caae6b06aea7641c4f5a77c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:2970eb023bb1a7791b6e27f6aebb6d0776676e78797d12abd8c242c4712449f6", "content": "The primary way Spring Security enables method-level authorization support is through annotations that you can add to methods, classes, and interfaces.\n\n[[use-preauthorize]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Authorizing with Annotations", "heading_level": 2, "file_order": 117, "section_index": 8, "content_hash": "2970eb023bb1a7791b6e27f6aebb6d0776676e78797d12abd8c242c4712449f6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:c18cf34c64a422bb10d90d4ce4fb9dd36c04298da4f8ff77326b633564104575", "content": "When <<activate-method-security,Method Security is active>>, you can annotate a method with the javadoc:org.springframework.security.access.prepost.PreAuthorize[format=annotation] annotation like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class BankService {\n\t@PreAuthorize(\"hasRole('ADMIN')\")\n\tpublic Account readAccount(Long id) {\n // ... is only invoked if the `Authentication` has the `ROLE_ADMIN` authority\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class BankService {\n\t@PreAuthorize(\"hasRole('ADMIN')\")\n\tfun readAccount(id: Long): Account {\n // ... is only invoked if the `Authentication` has the `ROLE_ADMIN` authority\n\t}\n}\n----\n======\n\nThis is meant to indicate that the method can only be invoked if the provided expression `hasRole('ADMIN')` passes.\n\nYou can then xref:servlet/test/method.adoc[test the class] to confirm it is enforcing the authorization rule like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nBankService bankService;\n\n@WithMockUser(roles=\"ADMIN\")\n@Test\nvoid readAccountWithAdminRoleThenInvokes() {\n Account account = this.bankService.readAccount(\"12345678\");\n // ... assertions\n}\n\n@WithMockUser(roles=\"WRONG\")\n@Test\nvoid readAccountWithWrongRoleThenAccessDenied() {\n assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(\n () -> this.bankService.readAccount(\"12345678\"));\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@WithMockUser(roles=\"ADMIN\")\n@Test\nfun readAccountWithAdminRoleThenInvokes() {\n val account: Account = this.bankService.readAccount(\"12345678\")\n // ... assertions\n}\n\n@WithMockUser(roles=\"WRONG\")\n@Test\nfun readAccountWithWrongRoleThenAccessDenied() {\n assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy {\n this.bankService.readAccount(\"12345678\")\n }\n}\n----\n======\n\n[TIP]\n`@PreAuthorize` also can be a <<meta-annotations, meta-annotation>>, be defined <<class-or-interface-annotations,at the class or interface level>>, and use <<authorization-expressions, SpEL Authorization Expressions>>.\n\nWhile `@PreAuthorize` is quite helpful for declaring needed authorities, it can also be used to evaluate more complex <<using_method_parameters,expressions that involve the method parameters>>.\n\n[[use-postauthorize]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Authorizing Method Invocation with `@PreAuthorize`", "heading_level": 3, "file_order": 117, "section_index": 9, "content_hash": "c18cf34c64a422bb10d90d4ce4fb9dd36c04298da4f8ff77326b633564104575", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:b95130a196d05cc8d0bbb3fff87e8cefb216ca7eb0c1680e394ec75dd991f93e", "content": "When Method Security is active, you can annotate a method with the javadoc:org.springframework.security.access.prepost.PostAuthorize[format=annotation] annotation like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class BankService {\n\t@PostAuthorize(\"returnObject.owner == authentication.name\")\n\tpublic Account readAccount(Long id) {\n // ... is only returned if the `Account` belongs to the logged in user\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class BankService {\n\t@PostAuthorize(\"returnObject.owner == authentication.name\")\n\tfun readAccount(id: Long): Account {\n // ... is only returned if the `Account` belongs to the logged in user\n\t}\n}\n----\n======\n\nThis is meant to indicate that the method can only return the value if the provided expression `returnObject.owner == authentication.name` passes.\n`returnObject` represents the `Account` object to be returned.\n\nYou can then xref:servlet/test/method.adoc[test the class] to confirm it is enforcing the authorization rule:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nBankService bankService;\n\n@WithMockUser(username=\"owner\")\n@Test\nvoid readAccountWhenOwnedThenReturns() {\n Account account = this.bankService.readAccount(\"12345678\");\n // ... assertions\n}\n\n@WithMockUser(username=\"wrong\")\n@Test\nvoid readAccountWhenNotOwnedThenAccessDenied() {\n assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(\n () -> this.bankService.readAccount(\"12345678\"));\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@WithMockUser(username=\"owner\")\n@Test\nfun readAccountWhenOwnedThenReturns() {\n val account: Account = this.bankService.readAccount(\"12345678\")\n // ... assertions\n}\n\n@WithMockUser(username=\"wrong\")\n@Test\nfun readAccountWhenNotOwnedThenAccessDenied() {\n assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy {\n this.bankService.readAccount(\"12345678\")\n }\n}\n----\n======\n\n[TIP]\n`@PostAuthorize` also can be a <<meta-annotations,meta-annotation>>, be defined <<class-or-interface-annotations,at the class or interface level>>, and use <<authorization-expressions, SpEL Authorization Expressions>>.\n\n`@PostAuthorize` is particularly helpful when defending against https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html[Insecure Direct Object Reference].\nIn fact, it can be defined as a <<meta-annotations,meta-annotation>> like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Target({ ElementType.METHOD, ElementType.TYPE })\n@Retention(RetentionPolicy.RUNTIME)\n@PostAuthorize(\"returnObject.owner == authentication.name\")\npublic @interface RequireOwnership {}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Target(ElementType.METHOD, ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@PostAuthorize(\"returnObject.owner == authentication.name\")\nannotation class RequireOwnership\n----\n======\n\nAllowing you to instead annotate the service in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class BankService {\n\t@RequireOwnership\n\tpublic Account readAccount(Long id) {\n // ... is only returned if the `Account` belongs to the logged in user\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class BankService {\n\t@RequireOwnership\n\tfun readAccount(id: Long): Account {\n // ... is only returned if the `Account` belongs to the logged in user\n\t}\n}\n----\n======\n\nThe result is that the above method will only return the `Account` if its `owner` attribute matches the logged-in user's `name`.\nIf not, Spring Security will throw an `AccessDeniedException` and return a 403 status code.\n\n[NOTE]\n=====\nNote that `@PostAuthorize` is not recommended for classes that perform database writes since that typically means that a database change was made before the security invariants were checked.\nA common example of doing this is if you have `@Transactional` and `@PostAuthorize` on the same method.\nInstead, read the value first, using `@PostAuthorize` on the read, and then perform the database write, should that read is authorized.\nIf you must do something like this, you can <<changing-the-order, ensure that `@EnableTransactionManagement` comes before `@EnableMethodSecurity`>>.\n=====\n\n[[use-prefilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Authorization Method Results with `@PostAuthorize`", "heading_level": 3, "file_order": 117, "section_index": 10, "content_hash": "b95130a196d05cc8d0bbb3fff87e8cefb216ca7eb0c1680e394ec75dd991f93e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:269cb7698f1c7297caccd650fd45d3ecef5b3ad2cd150492314b8a503b40a63f", "content": "When Method Security is active, you can annotate a method with the javadoc:org.springframework.security.access.prepost.PreFilter[format=annotation] annotation like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class BankService {\n\t@PreFilter(\"filterObject.owner == authentication.name\")\n\tpublic Collection<Account> updateAccounts(Account... accounts) {\n // ... `accounts` will only contain the accounts owned by the logged-in user\n return updated;\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class BankService {\n\t@PreFilter(\"filterObject.owner == authentication.name\")\n\tfun updateAccounts(vararg accounts: Account): Collection<Account> {\n // ... `accounts` will only contain the accounts owned by the logged-in user\n return updated\n\t}\n}\n----\n======\n\nThis is meant to filter out any values from `accounts` where the expression `filterObject.owner == authentication.name` fails.\n`filterObject` represents each `account` in `accounts` and is used to test each `account`.\n\nYou can then test the class in the following way to confirm it is enforcing the authorization rule:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nBankService bankService;\n\n@WithMockUser(username=\"owner\")\n@Test\nvoid updateAccountsWhenOwnedThenReturns() {\n Account ownedBy = ...\n Account notOwnedBy = ...\n Collection<Account> updated = this.bankService.updateAccounts(ownedBy, notOwnedBy);\n assertThat(updated).containsOnly(ownedBy);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Autowired\nlateinit var bankService: BankService\n\n@WithMockUser(username=\"owner\")\n@Test\nfun updateAccountsWhenOwnedThenReturns() {\n val ownedBy: Account = ...\n val notOwnedBy: Account = ...\n val updated: Collection<Account> = bankService.updateAccounts(ownedBy, notOwnedBy)\n assertThat(updated).containsOnly(ownedBy)\n}\n----\n======\n\n[TIP]\n`@PreFilter` also can be a <<meta-annotations,meta-annotation>>, be defined <<class-or-interface-annotations,at the class or interface level>>, and use <<authorization-expressions, SpEL Authorization Expressions>>.\n\n`@PreFilter` supports arrays, collections, maps, and streams (so long as the stream is still open).\n\nFor example, the above `updateAccounts` declaration will function the same way as the following other four:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PreFilter(\"filterObject.owner == authentication.name\")\npublic Collection<Account> updateAccounts(Account[] accounts)\n\n@PreFilter(\"filterObject.owner == authentication.name\")\npublic Collection<Account> updateAccounts(Collection<Account> accounts)\n\n@PreFilter(\"filterObject.value.owner == authentication.name\")\npublic Collection<Account> updateAccounts(Map<String, Account> accounts)\n\n@PreFilter(\"filterObject.owner == authentication.name\")\npublic Collection<Account> updateAccounts(Stream<Account> accounts)\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PreFilter(\"filterObject.owner == authentication.name\")\nfun updateAccounts(accounts: Array<Account>): Collection<Account>\n\n@PreFilter(\"filterObject.owner == authentication.name\")\nfun updateAccounts(accounts: Collection<Account>): Collection<Account>\n\n@PreFilter(\"filterObject.value.owner == authentication.name\")\nfun updateAccounts(accounts: Map<String, Account>): Collection<Account>\n\n@PreFilter(\"filterObject.owner == authentication.name\")\nfun updateAccounts(accounts: Stream<Account>): Collection<Account>\n----\n======\n\nThe result is that the above method will only have the `Account` instances where their `owner` attribute matches the logged-in user's `name`.\n\n[[use-postfilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Filtering Method Parameters with `@PreFilter`", "heading_level": 3, "file_order": 117, "section_index": 11, "content_hash": "269cb7698f1c7297caccd650fd45d3ecef5b3ad2cd150492314b8a503b40a63f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:0b95d5a75fab8cf280fd8dec970eafb8c04835128905364aaf527d97345ad435", "content": "When Method Security is active, you can annotate a method with the javadoc:org.springframework.security.access.prepost.PostFilter[format=annotation] annotation like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class BankService {\n\t@PostFilter(\"filterObject.owner == authentication.name\")\n\tpublic Collection<Account> readAccounts(String... ids) {\n // ... the return value will be filtered to only contain the accounts owned by the logged-in user\n return accounts;\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class BankService {\n\t@PostFilter(\"filterObject.owner == authentication.name\")\n\tfun readAccounts(vararg ids: String): Collection<Account> {\n // ... the return value will be filtered to only contain the accounts owned by the logged-in user\n return accounts\n\t}\n}\n----\n======\n\nThis is meant to filter out any values from the return value where the expression `filterObject.owner == authentication.name` fails.\n`filterObject` represents each `account` in `accounts` and is used to test each `account`.\n\nYou can then test the class like so to confirm it is enforcing the authorization rule:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nBankService bankService;\n\n@WithMockUser(username=\"owner\")\n@Test\nvoid readAccountsWhenOwnedThenReturns() {\n Collection<Account> accounts = this.bankService.updateAccounts(\"owner\", \"not-owner\");\n assertThat(accounts).hasSize(1);\n assertThat(accounts.get(0).getOwner()).isEqualTo(\"owner\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Autowired\nlateinit var bankService: BankService\n\n@WithMockUser(username=\"owner\")\n@Test\nfun readAccountsWhenOwnedThenReturns() {\n val accounts: Collection<Account> = bankService.updateAccounts(\"owner\", \"not-owner\")\n assertThat(accounts).hasSize(1)\n assertThat(accounts[0].owner).isEqualTo(\"owner\")\n}\n----\n======\n\n[TIP]\n`@PostFilter` also can be a <<meta-annotations,meta-annotation>>, be defined <<class-or-interface-annotations,at the class or interface level>>, and use <<authorization-expressions, SpEL Authorization Expressions>>.\n\n`@PostFilter` supports arrays, collections, maps, and streams (so long as the stream is still open).\n\nFor example, the above `readAccounts` declaration will function the same way as the following other four:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PostFilter(\"filterObject.owner == authentication.name\")\npublic Collection<Account> readAccounts(String... ids)\n\n@PostFilter(\"filterObject.owner == authentication.name\")\npublic Account[] readAccounts(String... ids)\n\n@PostFilter(\"filterObject.value.owner == authentication.name\")\npublic Map<String, Account> readAccounts(String... ids)\n\n@PostFilter(\"filterObject.owner == authentication.name\")\npublic Stream<Account> readAccounts(String... ids)\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PostFilter(\"filterObject.owner == authentication.name\")\nfun readAccounts(vararg ids: String): Collection<Account>\n\n@PostFilter(\"filterObject.owner == authentication.name\")\nfun readAccounts(vararg ids: String): Array<Account>\n\n@PostFilter(\"filterObject.owner == authentication.name\")\nfun readAccounts(vararg ids: String): Map<String, Account>\n\n@PostFilter(\"filterObject.owner == authentication.name\")\nfun readAccounts(vararg ids: String): Stream<Account>\n----\n======\n\nThe result is that the above method will return the `Account` instances where their `owner` attribute matches the logged-in user's `name`.\n\n[NOTE]\nIn-memory filtering can obviously be expensive, and so be considerate of whether it is better to xref:servlet/integrations/data.adoc[filter the data in the data layer] instead.\n\n[[use-secured]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Filtering Method Results with `@PostFilter`", "heading_level": 3, "file_order": 117, "section_index": 12, "content_hash": "0b95d5a75fab8cf280fd8dec970eafb8c04835128905364aaf527d97345ad435", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:857240505bcff78d6aa861459575e006e928dc92e34ecccbe1ee9716d93d2ca7", "content": "javadoc:org.springframework.security.access.annotation.Secured[format=annotation] is a legacy option for authorizing invocations.\n<<use-preauthorize,`@PreAuthorize`>> supersedes it and is recommended instead.\n\nTo use the `@Secured` annotation, you should first change your Method Security declaration to enable it like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@EnableMethodSecurity(securedEnabled = true)\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@EnableMethodSecurity(securedEnabled = true)\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<sec:method-security secured-enabled=\"true\"/>\n----\n======\n\nThis will cause Spring Security to publish <<annotation-method-interceptors,the corresponding method interceptor>> that authorizes methods, classes, and interfaces annotated with `@Secured`.\n\n[[use-jsr250]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Authorizing Method Invocation with `@Secured`", "heading_level": 3, "file_order": 117, "section_index": 13, "content_hash": "857240505bcff78d6aa861459575e006e928dc92e34ecccbe1ee9716d93d2ca7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:c4624d13b20cb564497e2a56a9369065c6eb7d99a49b9ab879333e2245b5df89", "content": "In case you would like to use https://jcp.org/en/jsr/detail?id=250[JSR-250] annotations, Spring Security also supports that.\n<<use-preauthorize,`@PreAuthorize`>> has more expressive power and is thus recommended.\n\nTo use the JSR-250 annotations, you should first change your Method Security declaration to enable them like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@EnableMethodSecurity(jsr250Enabled = true)\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@EnableMethodSecurity(jsr250Enabled = true)\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<sec:method-security jsr250-enabled=\"true\"/>\n----\n======\n\nThis will cause Spring Security to publish <<annotation-method-interceptors,the corresponding method interceptor>> that authorizes methods, classes, and interfaces annotated with `@RolesAllowed`, `@PermitAll`, and `@DenyAll`.\n\n[[class-or-interface-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Authorizing Method Invocation with JSR-250 Annotations", "heading_level": 3, "file_order": 117, "section_index": 14, "content_hash": "c4624d13b20cb564497e2a56a9369065c6eb7d99a49b9ab879333e2245b5df89", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:b9bb8476301e595d087a4eb65b9066550ff3879bd7d295c76dbadff11aa769ef", "content": "It's also supported to have Method Security annotations at the class and interface level.\n\nIf it is at the class level like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\n@PreAuthorize(\"hasAuthority('ROLE_USER')\")\npublic class MyController {\n @GetMapping(\"/endpoint\")\n public String endpoint() { ... }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\n@PreAuthorize(\"hasAuthority('ROLE_USER')\")\nopen class MyController {\n @GetMapping(\"/endpoint\")\n fun endpoint(): String { ... }\n}\n----\n======\n\nthen all methods inherit the class-level behavior.\n\nOr, if it's declared like the following at both the class and method level:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\n@PreAuthorize(\"hasAuthority('ROLE_USER')\")\npublic class MyController {\n @GetMapping(\"/endpoint\")\n @PreAuthorize(\"hasAuthority('ROLE_ADMIN')\")\n public String endpoint() { ... }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\n@PreAuthorize(\"hasAuthority('ROLE_USER')\")\nopen class MyController {\n @GetMapping(\"/endpoint\")\n @PreAuthorize(\"hasAuthority('ROLE_ADMIN')\")\n fun endpoint(): String { ... }\n}\n----\n======\n\nthen methods declaring the annotation override the class-level annotation.\n\nThe same is true for interfaces, with the exception that if a class inherits the annotation from two different interfaces, then startup will fail.\nThis is because Spring Security has no way to tell which one you want to use.\n\nIn cases like this, you can resolve the ambiguity by adding the annotation to the concrete method.\n\n[[meta-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Declaring Annotations at the Class or Interface Level", "heading_level": 3, "file_order": 117, "section_index": 15, "content_hash": "b9bb8476301e595d087a4eb65b9066550ff3879bd7d295c76dbadff11aa769ef", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:5c453a8c3dffbb2f7b126aafd12ed29427451a1195b8e311446fc18f8c6fe450", "content": "Method Security supports meta annotations.\nThis means that you can take any annotation and improve readability based on your application-specific use cases.\n\nFor example, you can simplify `@PreAuthorize(\"hasRole('ADMIN')\")` to `@IsAdmin` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Target({ ElementType.METHOD, ElementType.TYPE })\n@Retention(RetentionPolicy.RUNTIME)\n@PreAuthorize(\"hasRole('ADMIN')\")\npublic @interface IsAdmin {}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Target(ElementType.METHOD, ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@PreAuthorize(\"hasRole('ADMIN')\")\nannotation class IsAdmin\n----\n======\n\nAnd the result is that on your secured methods you can now do the following instead:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class BankService {\n\t@IsAdmin\n\tpublic Account readAccount(Long id) {\n // ... is only returned if the `Account` belongs to the logged in user\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class BankService {\n\t@IsAdmin\n\tfun readAccount(id: Long): Account {\n // ... is only returned if the `Account` belongs to the logged in user\n\t}\n}\n----\n======\n\nThis results in more readable method definitions.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Using Meta Annotations", "heading_level": 3, "file_order": 117, "section_index": 16, "content_hash": "5c453a8c3dffbb2f7b126aafd12ed29427451a1195b8e311446fc18f8c6fe450", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:a1b099b914c558e20cae370f6e7c86cb06f53695b71bb4a3e8ea6ee57b3c65a1", "content": "You can also opt into using meta-annotation templates, which allow for much more powerful annotation definitions.\n\nFirst, publish the following bean:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nstatic AnnotationTemplateExpressionDefaults templateExpressionDefaults() {\n\treturn new AnnotationTemplateExpressionDefaults();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ncompanion object {\n @Bean\n fun templateExpressionDefaults(): AnnotationTemplateExpressionDefaults {\n return AnnotationTemplateExpressionDefaults()\n }\n}\n----\n======\n\nNow instead of `@IsAdmin`, you can create something more powerful like `@HasRole` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Target({ ElementType.METHOD, ElementType.TYPE })\n@Retention(RetentionPolicy.RUNTIME)\n@PreAuthorize(\"hasRole('{value}')\")\npublic @interface HasRole {\n\tString value();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Target(ElementType.METHOD, ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@PreAuthorize(\"hasRole('{value}')\")\nannotation class HasRole(val value: String)\n----\n======\n\nAnd the result is that on your secured methods you can now do the following instead:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class BankService {\n\t@HasRole(\"ADMIN\")\n\tpublic Account readAccount(Long id) {\n // ... is only returned if the `Account` belongs to the logged in user\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class BankService {\n\t@HasRole(\"ADMIN\")\n\tfun readAccount(id: Long): Account {\n // ... is only returned if the `Account` belongs to the logged in user\n\t}\n}\n----\n======\n\nNote that this works with method variables and all annotation types, too, though you will want to be careful to correctly take care of quotation marks so the resulting SpEL expression is correct.\n\nFor example, consider the following `@HasAnyRole` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Target({ ElementType.METHOD, ElementType.TYPE })\n@Retention(RetentionPolicy.RUNTIME)\n@PreAuthorize(\"hasAnyRole({roles})\")\npublic @interface HasAnyRole {\n\tString[] roles();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Target(ElementType.METHOD, ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@PreAuthorize(\"hasAnyRole({roles})\")\nannotation class HasAnyRole(val roles: Array<String>)\n----\n======\n\nIn that case, you'll notice that you should not use the quotation marks in the expression, but instead in the parameter value like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class BankService {\n\t@HasAnyRole(roles = { \"'USER'\", \"'ADMIN'\" })\n\tpublic Account readAccount(Long id) {\n // ... is only returned if the `Account` belongs to the logged in user\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class BankService {\n\t@HasAnyRole(roles = arrayOf(\"'USER'\", \"'ADMIN'\"))\n\tfun readAccount(id: Long): Account {\n // ... is only returned if the `Account` belongs to the logged in user\n\t}\n}\n----\n======\n\nso that, once replaced, the expression becomes `@PreAuthorize(\"hasAnyRole('USER', 'ADMIN')\")`.\n\n[[enable-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Templating Meta-Annotation Expressions", "heading_level": 4, "file_order": 117, "section_index": 17, "content_hash": "a1b099b914c558e20cae370f6e7c86cb06f53695b71bb4a3e8ea6ee57b3c65a1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:3ef92c56ea325765567928096f938c3c11aa69d9b2ffca0d59d0e52d8e9815ac", "content": "You can turn off ``@EnableMethodSecurity``'s pre-configuration and replace it with you own.\nYou may choose to do this if you want to <<custom-authorization-managers,customize the `AuthorizationManager`>> or `Pointcut`.\nOr you may simply want to only enable a specific annotation, like `@PostAuthorize`.\n\nYou can do this in the following way:\n\n.Only @PostAuthorize Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableMethodSecurity(prePostEnabled = false)\nclass MethodSecurityConfig {\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tAdvisor postAuthorize() {\n return AuthorizationManagerAfterMethodInterceptor.postAuthorize();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableMethodSecurity(prePostEnabled = false)\nclass MethodSecurityConfig {\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tfun postAuthorize() : Advisor {\n return AuthorizationManagerAfterMethodInterceptor.postAuthorize()\n\t}\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<sec:method-security pre-post-enabled=\"false\"/>\n\n<aop:config/>\n\n<bean id=\"postAuthorize\"\n\tclass=\"org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor\"\n\tfactory-method=\"postAuthorize\"/>\n----\n======\n\nThe above snippet achieves this by first disabling Method Security's pre-configurations and then publishing <<annotation-method-interceptors, the `@PostAuthorize` interceptor>> itself.\n\n[[use-intercept-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Enabling Certain Annotations", "heading_level": 3, "file_order": 117, "section_index": 18, "content_hash": "3ef92c56ea325765567928096f938c3c11aa69d9b2ffca0d59d0e52d8e9815ac", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:72d79b8e437cfaa31362395b109e39a7117212086c6e0197683a117aed9794c9", "content": "While using Spring Security's <<authorizing-with-annotations,annotation-based support>> is preferred for method security, you can also use XML to declare bean authorization rules.\n\nIf you need to declare it in your XML configuration instead, you can use xref:servlet/appendix/namespace/method-security.adoc#nsa-intercept-methods[`<intercept-methods>`] like so:\n\n[tabs]\n======\nXml::\n+\n[source,xml,role=\"primary\"]\n----\n<bean class=\"org.mycompany.MyController\">\n <intercept-methods>\n <protect method=\"get*\" access=\"hasAuthority('read')\"/>\n <protect method=\"*\" access=\"hasAuthority('write')\"/>\n </intercept-methods>\n</bean>\n----\n======\n\n[NOTE]\nThis only supports matching method by prefix or by name.\nIf your needs are more complex than that, <<authorizing-with-annotations,use annotation support>> instead.\n\n[[use-programmatic-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Authorizing with `<intercept-methods>`", "heading_level": 2, "file_order": 117, "section_index": 19, "content_hash": "72d79b8e437cfaa31362395b109e39a7117212086c6e0197683a117aed9794c9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:93c88ee07d46b06b48c07ebbdcddd55dd50b6d67077c25b39e101516e18a8908", "content": "As you've already seen, there are several ways that you can specify non-trivial authorization rules using <<authorization-expressions, Method Security SpEL expressions>>.\n\nThere are a number of ways that you can instead allow your logic to be Java-based instead of SpEL-based.\nThis gives use access the entire Java language for increased testability and flow control.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Authorizing Methods Programmatically", "heading_level": 2, "file_order": 117, "section_index": 20, "content_hash": "93c88ee07d46b06b48c07ebbdcddd55dd50b6d67077c25b39e101516e18a8908", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:58bc61b0a410808f4b32a454725fc65c6fcf35cff2854132868237a9808ffa1d", "content": "The first way to authorize a method programmatically is a two-step process.\n\nFirst, declare a bean that has a method that takes a `MethodSecurityExpressionOperations` instance like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component(\"authz\")\npublic class AuthorizationLogic {\n public boolean decide(MethodSecurityExpressionOperations operations) {\n // ... authorization logic\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component(\"authz\")\nopen class AuthorizationLogic {\n fun decide(operations: MethodSecurityExpressionOperations): boolean {\n // ... authorization logic\n }\n}\n----\n======\n\nThen, reference that bean in your annotations in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class MyController {\n @PreAuthorize(\"@authz.decide(#root)\")\n @GetMapping(\"/endpoint\")\n public String endpoint() {\n // ...\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nopen class MyController {\n @PreAuthorize(\"@authz.decide(#root)\")\n @GetMapping(\"/endpoint\")\n fun String endpoint() {\n // ...\n }\n}\n----\n======\n\nSpring Security will invoke the given method on that bean for each method invocation.\n\nWhat's nice about this is all your authorization logic is in a separate class that can be independently unit tested and verified for correctness.\nIt also has access to the full Java language.\n\n[TIP]\nIn addition to returning a `Boolean`, you can also return `null` to indicate that the code abstains from making a decision.\n\nIf you want to include more information about the nature of the decision, you can instead return a custom `AuthorizationDecision` like this:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component(\"authz\")\npublic class AuthorizationLogic {\n public AuthorizationDecision decide(MethodSecurityExpressionOperations operations) {\n // ... authorization logic\n return new MyAuthorizationDecision(false, details);\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component(\"authz\")\nopen class AuthorizationLogic {\n fun decide(operations: MethodSecurityExpressionOperations): AuthorizationDecision {\n // ... authorization logic\n return MyAuthorizationDecision(false, details)\n }\n}\n----\n======\n\nOr throw a custom `AuthorizationDeniedException` instance.\nNote, though, that returning an object is preferred as this doesn't incur the expense of generating a stacktrace.\n\nThen, you can access the custom details when you <<fallback-values-authorization-denied, customize how the authorization result is handled>>.\n\n[TIP]\n====\nFurther, you can return an `AuthorizationManager` itself.\nThis is helpful when unifying custom web authorization rules with method security ones since web security by default requires specifying an `AuthorizationManager` instance.\n====\n\n[[custom-authorization-managers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Using a Custom Bean in SpEL", "heading_level": 3, "file_order": 117, "section_index": 21, "content_hash": "58bc61b0a410808f4b32a454725fc65c6fcf35cff2854132868237a9808ffa1d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:7b106277d1bcfeae74bb00cd865067e27cc685674fcfab1992d9f2d73034f668", "content": "The second way to authorize a method programmatically is to create a custom xref:servlet/authorization/architecture.adoc#_the_authorizationmanager[`AuthorizationManager`].\n\nFirst, declare an authorization manager instance, perhaps like this one:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class MyAuthorizationManager implements AuthorizationManager<MethodInvocation>, AuthorizationManager<MethodInvocationResult> {\n @Override\n public AuthorizationResult authorize(Supplier<Authentication> authentication, MethodInvocation invocation) {\n // ... authorization logic\n }\n\n @Override\n public AuthorizationResult authorize(Supplier<Authentication> authentication, MethodInvocationResult invocation) {\n // ... authorization logic\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass MyAuthorizationManager : AuthorizationManager<MethodInvocation>, AuthorizationManager<MethodInvocationResult> {\n override fun authorize(authentication: Supplier<Authentication>, invocation: MethodInvocation): AuthorizationResult {\n // ... authorization logic\n }\n\n override fun authorize(authentication: Supplier<Authentication>, invocation: MethodInvocationResult): AuthorizationResult {\n // ... authorization logic\n }\n}\n----\n======\n\nThen, publish the method interceptor with a pointcut that corresponds to when you want that `AuthorizationManager` to run.\nFor example, you could replace how `@PreAuthorize` and `@PostAuthorize` work like so:\n\n.Only @PreAuthorize and @PostAuthorize Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableMethodSecurity(prePostEnabled = false)\nclass MethodSecurityConfig {\n @Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tAdvisor preAuthorize(MyAuthorizationManager manager) {\n return AuthorizationManagerBeforeMethodInterceptor.preAuthorize(manager);\n\t}\n\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tAdvisor postAuthorize(MyAuthorizationManager manager) {\n return AuthorizationManagerAfterMethodInterceptor.postAuthorize(manager);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableMethodSecurity(prePostEnabled = false)\nclass MethodSecurityConfig {\n @Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tfun preAuthorize(manager: MyAuthorizationManager) : Advisor {\n return AuthorizationManagerBeforeMethodInterceptor.preAuthorize(manager)\n\t}\n\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tfun postAuthorize(manager: MyAuthorizationManager) : Advisor {\n return AuthorizationManagerAfterMethodInterceptor.postAuthorize(manager)\n\t}\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<sec:method-security pre-post-enabled=\"false\"/>\n\n<aop:config/>\n\n<bean id=\"preAuthorize\"\n\tclass=\"org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor\"\n\tfactory-method=\"preAuthorize\">\n <constructor-arg ref=\"myAuthorizationManager\"/>\n</bean>\n\n<bean id=\"postAuthorize\"\n\tclass=\"org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor\"\n\tfactory-method=\"postAuthorize\">\n <constructor-arg ref=\"myAuthorizationManager\"/>\n</bean>\n----\n======\n\n[TIP]\n====\nYou can place your interceptor in between Spring Security method interceptors using the order constants specified in `AuthorizationInterceptorsOrder`.\n====\n\n[[customizing-expression-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Using a Custom Authorization Manager", "heading_level": 3, "file_order": 117, "section_index": 22, "content_hash": "7b106277d1bcfeae74bb00cd865067e27cc685674fcfab1992d9f2d73034f668", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:1d5925363b99c3e6cb13b7811dcdeefc7404819c5d849c1461df253e7110df8f", "content": "Or, third, you can customize how each SpEL expression is handled.\nTo do that, you can expose a custom javadoc:org.springframework.security.access.expression.method.MethodSecurityExpressionHandler[], like so:\n\n.Custom MethodSecurityExpressionHandler\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nstatic MethodSecurityExpressionHandler methodSecurityExpressionHandler(RoleHierarchy roleHierarchy) {\n\tDefaultMethodSecurityExpressionHandler handler = new DefaultMethodSecurityExpressionHandler();\n\thandler.setRoleHierarchy(roleHierarchy);\n\treturn handler;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ncompanion object {\n\t@Bean\n\tfun methodSecurityExpressionHandler(roleHierarchy: RoleHierarchy) : MethodSecurityExpressionHandler {\n val handler = DefaultMethodSecurityExpressionHandler()\n handler.setRoleHierarchy(roleHierarchy)\n return handler\n\t}\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<sec:method-security>\n\t<sec:expression-handler ref=\"myExpressionHandler\"/>\n</sec:method-security>\n\n<bean id=\"myExpressionHandler\"\n class=\"org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandler\">\n\t<property name=\"roleHierarchy\" ref=\"roleHierarchy\"/>\n</bean>\n----\n======\n\n[TIP]\n====\nWe expose `MethodSecurityExpressionHandler` using a `static` method to ensure that Spring publishes it before it initializes Spring Security's method security `@Configuration` classes\n====\n\nYou can also <<subclass-defaultmethodsecurityexpressionhandler,subclass `DefaultMessageSecurityExpressionHandler`>> to add your own custom authorization expressions beyond the defaults.\n\n[[pre-post-authorize-aot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Customizing Expression Handling", "heading_level": 3, "file_order": 117, "section_index": 23, "content_hash": "1d5925363b99c3e6cb13b7811dcdeefc7404819c5d849c1461df253e7110df8f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:fb2a017e20da6b5d68e68ea182361f68dee516c581092a297d6af0e23868aeab", "content": "Spring Security will scan all beans in the application context for methods that use `@PreAuthorize` or `@PostAuthorize`.\nWhen it finds one, it will resolve any beans used inside the security expression and register the appropriate runtime hints for that bean.\nIf it finds a method that uses `@AuthorizeReturnObject`, it will recursively search inside the method's return type for `@PreAuthorize` and `@PostAuthorize` annotations and register them accordingly.\n\nFor example, consider the following Spring Boot application:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Service\npublic class AccountService { <1>\n\n @PreAuthorize(\"@authz.decide()\") <2>\n @AuthorizeReturnObject <3>\n public Account getAccountById(String accountId) {\n // ...\n }\n\n}\n\npublic class Account {\n\n private final String accountNumber;\n\n // ...\n\n @PreAuthorize(\"@accountAuthz.canViewAccountNumber()\") <4>\n public String getAccountNumber() {\n return this.accountNumber;\n }\n\n @AuthorizeReturnObject <5>\n public User getUser() {\n return new User(\"John Doe\");\n }\n\n}\n\npublic class User {\n\n private final String fullName;\n\n // ...\n\n @PostAuthorize(\"@myOtherAuthz.decide()\") <6>\n public String getFullName() {\n return this.fullName;\n }\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Service\nclass AccountService { <1>\n\n @PreAuthorize(\"@authz.decide()\") <2>\n @AuthorizeReturnObject <3>\n fun getAccountById(accountId: String): Account {\n // ...\n }\n\n}\n\nclass Account(private val accountNumber: String) {\n\n @PreAuthorize(\"@accountAuthz.canViewAccountNumber()\") <4>\n fun getAccountNumber(): String {\n return this.accountNumber\n }\n\n @AuthorizeReturnObject <5>\n fun getUser(): User {\n return User(\"John Doe\")\n }\n\n}\n\nclass User(private val fullName: String) {\n\n @PostAuthorize(\"@myOtherAuthz.decide()\") <6>\n fun getFullName(): String {\n return this.fullName\n }\n\n}\n----\n======\n\n<1> Spring Security finds the `AccountService` bean\n<2> Finding a method that uses `@PreAuthorize`, it will resolve any bean names used inside the expression, `authz` in that case, and register runtime hints for the bean class\n<3> Finding a method that uses `@AuthorizeReturnObject`, it will look into the method's return type for any `@PreAuthorize` or `@PostAuthorize`\n<4> Then, it finds a `@PreAuthorize` with another bean name: `accountAuthz`; the runtime hints are registered for the bean class as well\n<5> Finding another `@AuthorizeReturnObject` it will look again into the method's return type\n<6> Now, a `@PostAuthorize` is found with yet another bean name used: `myOtherAuthz`; the runtime hints are registered for the bean class as well\n\nThere will be many times when Spring Security cannot determine the actual return type of the method ahead of time since it may be hidden in an erased generic type.\n\nConsider the following service:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Service\npublic class AccountService {\n\n @AuthorizeReturnObject\n public List<Account> getAllAccounts() {\n // ...\n }\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Service\nclass AccountService {\n\n @AuthorizeReturnObject\n fun getAllAccounts(): List<Account> {\n // ...\n }\n\n}\n----\n======\n\nIn this case, the generic type is erased and so it isnt apparent to Spring Security ahead-of-time that `Account` needs to be visited in order to check for `@PreAuthorize` and `@PostAuthorize`.\n\nTo address this, you can publish a javadoc:org.springframework.security.aot.hint.PrePostAuthorizeExpressionBeanHintsRegistrar[`PrePostAuthorizeExpressionBeanHintsRegistrar`] like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\nstatic SecurityHintsRegistrar registerTheseToo() {\n return new PrePostAuthorizeExpressionBeanHintsRegistrar(Account.class);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\nfun registerTheseToo(): SecurityHintsRegistrar {\n return PrePostAuthorizeExpressionBeanHintsRegistrar(Account::class.java)\n}\n----\n======\n\n[[use-aspectj]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Working with AOT", "heading_level": 3, "file_order": 117, "section_index": 24, "content_hash": "fb2a017e20da6b5d68e68ea182361f68dee516c581092a297d6af0e23868aeab", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:363980e78019cf161d188d3546b5d5c77358f585d992a42d8dc80b9e5c9c298d", "content": "[[match-by-pointcut]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Authorizing with AspectJ", "heading_level": 2, "file_order": 117, "section_index": 25, "content_hash": "363980e78019cf161d188d3546b5d5c77358f585d992a42d8dc80b9e5c9c298d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:d3bfe9f1eb44cd0277f24e39e01e1637704dbdd64b91981eebd7dcc9fd784569", "content": "Being built on Spring AOP, you can declare patterns that are not related to annotations, similar to xref:servlet/authorization/authorize-http-requests.adoc[request-level authorization].\nThis has the potential advantage of centralizing method-level authorization rules.\n\nFor example, you can use publish your own `Advisor` or use xref:servlet/appendix/namespace/method-security.adoc#nsa-protect-pointcut[`<protect-pointcut>`] to match AOP expressions to authorization rules for your service layer like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.authorization.AuthorityAuthorizationManager.hasRole\n\n@Bean\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\nstatic Advisor protectServicePointcut() {\n AspectJExpressionPointcut pattern = new AspectJExpressionPointcut()\n pattern.setExpression(\"execution(* com.mycompany.*Service.*(..))\")\n return new AuthorizationManagerBeforeMethodInterceptor(pattern, hasRole(\"USER\"))\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport static org.springframework.security.authorization.AuthorityAuthorizationManager.hasRole\n\ncompanion object {\n @Bean\n @Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n fun protectServicePointcut(): Advisor {\n val pattern = AspectJExpressionPointcut()\n pattern.setExpression(\"execution(* com.mycompany.*Service.*(..))\")\n return new AuthorizationManagerBeforeMethodInterceptor(pattern, hasRole(\"USER\"))\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<sec:method-security>\n <protect-pointcut expression=\"execution(* com.mycompany.*Service.*(..))\" access=\"hasRole('USER')\"/>\n</sec:method-security>\n----\n======\n\n[[weave-aspectj]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Matching Methods with Custom Pointcuts", "heading_level": 3, "file_order": 117, "section_index": 26, "content_hash": "d3bfe9f1eb44cd0277f24e39e01e1637704dbdd64b91981eebd7dcc9fd784569", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:c63c1c542c758c9eebdf3fab614ea637598c8cdb770a4c1732a8fd2ac2c2db86", "content": "Performance can at times be enhanced by using AspectJ to weave Spring Security advice into the byte code of your beans.\n\nAfter setting up AspectJ, you can quite simply state in the `@EnableMethodSecurity` annotation or `<method-security>` element that you are using AspectJ:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@EnableMethodSecurity(mode=AdviceMode.ASPECTJ)\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@EnableMethodSecurity(mode=AdviceMode.ASPECTJ)\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<sec:method-security mode=\"aspectj\"/>\n----\n======\n\nAnd the result will be that Spring Security will publish its advisors as AspectJ advice so that they can be woven in accordingly.\n\n[[changing-the-order]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Integrate with AspectJ Byte-weaving", "heading_level": 3, "file_order": 117, "section_index": 27, "content_hash": "c63c1c542c758c9eebdf3fab614ea637598c8cdb770a4c1732a8fd2ac2c2db86", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:4645144c63d924ae94b5f0d9f0e076c48bba493b673fc60c5c0e52cfd950c39f", "content": "As already noted, there is a Spring AOP method interceptor for each annotation, and each of these has a location in the Spring AOP advisor chain.\n\nNamely, the `@PreFilter` method interceptor's order is 100, ``@PreAuthorize``'s is 200, and so on.\n\nYou can use the `offset` parameter on `@EnableMethodSecurity` to move all interceptors en masse to provide their advice earlier or later in a method invocation.\n\n[[authorization-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Specifying Order", "heading_level": 2, "file_order": 117, "section_index": 28, "content_hash": "4645144c63d924ae94b5f0d9f0e076c48bba493b673fc60c5c0e52cfd950c39f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:90ac3e2111843138813ca5b6faeefe5f906c68c6159ab0f60d5b80cf4e5508ef", "content": "You've already seen several examples using SpEL, so now let's cover the API a bit more in depth.\n\nSpring Security encapsulates all of its authorization fields and methods in a set of root objects.\nThe most generic root object is called `SecurityExpressionRoot` and it forms the basis for `MethodSecurityExpressionRoot`.\nSpring Security supplies this root object to `MethodSecurityEvaluationContext` when preparing to evaluate an authorization expression.\n\n[[using-authorization-expression-fields-and-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Expressing Authorization with SpEL", "heading_level": 2, "file_order": 117, "section_index": 29, "content_hash": "90ac3e2111843138813ca5b6faeefe5f906c68c6159ab0f60d5b80cf4e5508ef", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:a0d128a84d1083f8adf3198b93c3fbcaf2a597339aa7f2cdde6d04c75664e81a", "content": "The first thing this provides is an enhanced set of authorization fields and methods to your SpEL expressions.\nWhat follows is a quick overview of the most common methods:\n\n* `permitAll` - The method requires no authorization to be invoked; note that in this case, xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[the `Authentication`] is never retrieved from the session\n* `denyAll` - The method is not allowed under any circumstances; note that in this case, the `Authentication` is never retrieved from the session\n* `hasAuthority` - The method requires that the `Authentication` have xref:servlet/authorization/architecture.adoc#authz-authorities[a `GrantedAuthority`] that matches the given value\n* `hasRole` - A shortcut for `hasAuthority` that prefixes `ROLE_` or whatever is configured as the default prefix\n* `hasAnyAuthority` - The method requires that the `Authentication` have a `GrantedAuthority` that matches any of the given values\n* `hasAnyRole` - A shortcut for `hasAnyAuthority` that prefixes `ROLE_` or whatever is configured as the default prefix\n* `hasAllAuthorities` - The method requires that the `Authentication` have ``GrantedAuthority``s that matches all of the given values\n* `hasAllRoles` - A shortcut for `hasAllAuthorities` that prefixes `ROLE_` or whatever is configured as the default prefix\n* `hasPermission` - A hook into your `PermissionEvaluator` instance for doing object-level authorization\n\nAnd here is a brief look at the most common fields:\n\n* `authentication` - The `Authentication` instance associated with this method invocation\n* `principal` - The `Authentication#getPrincipal` associated with this method invocation\n\nHaving now learned the patterns, rules, and how they can be paired together, you should be able to understand what is going on in this more complex example:\n\n.Authorize Requests\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class MyService {\n @PreAuthorize(\"denyAll\") <1>\n MyResource myDeprecatedMethod(...);\n\n @PreAuthorize(\"hasRole('ADMIN')\") <2>\n MyResource writeResource(...)\n\n @PreAuthorize(\"hasAuthority('db') and hasRole('ADMIN')\") <3>\n MyResource deleteResource(...)\n\n @PreAuthorize(\"principal.claims['aud'] == 'my-audience'\") <4>\n MyResource readResource(...);\n\n\t@PreAuthorize(\"@authz.check(authentication, #root)\")\n MyResource shareResource(...);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class MyService {\n @PreAuthorize(\"denyAll\") <1>\n fun myDeprecatedMethod(...): MyResource\n\n @PreAuthorize(\"hasRole('ADMIN')\") <2>\n fun writeResource(...): MyResource\n\n @PreAuthorize(\"hasAuthority('db') and hasRole('ADMIN')\") <3>\n fun deleteResource(...): MyResource\n\n @PreAuthorize(\"principal.claims['aud'] == 'my-audience'\") <4>\n fun readResource(...): MyResource\n\n @PreAuthorize(\"@authz.check(#root)\")\n fun shareResource(...): MyResource\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<sec:method-security>\n <protect-pointcut expression=\"execution(* com.mycompany.*Service.myDeprecatedMethod(..))\" access=\"denyAll\"/> <1>\n <protect-pointcut expression=\"execution(* com.mycompany.*Service.writeResource(..))\" access=\"hasRole('ADMIN')\"/> <2>\n <protect-pointcut expression=\"execution(* com.mycompany.*Service.deleteResource(..))\" access=\"hasAuthority('db') and hasRole('ADMIN')\"/> <3>\n <protect-pointcut expression=\"execution(* com.mycompany.*Service.readResource(..))\" access=\"principal.claims['aud'] == 'my-audience'\"/> <4>\n <protect-pointcut expression=\"execution(* com.mycompany.*Service.shareResource(..))\" access=\"@authz.check(#root)\"/> <5>\n</sec:method-security>\n----\n======\n<1> This method may not be invoked by anyone for any reason\n<2> This method may only be invoked by ``Authentication``s granted the `ROLE_ADMIN` authority\n<3> This method may only be invoked by ``Authentication``s granted the `db` and `ROLE_ADMIN` authorities\n<4> This method may only be invoked by ``Princpal``s with an `aud` claim equal to \"my-audience\"\n<5> This method may only be invoked if the bean ``authz``'s `check` method returns `true`\n\n[TIP]\n====\nYou can use a bean like `authz` above to <<_using_a_custom_bean_in_spel, add programmatic authorization>>.\n====\n\n[[using_method_parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Using Authorization Expression Fields and Methods", "heading_level": 3, "file_order": 117, "section_index": 30, "content_hash": "a0d128a84d1083f8adf3198b93c3fbcaf2a597339aa7f2cdde6d04c75664e81a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:7a212b40921d22557e62aa54c9b414d9c8fa3cb5a507549c5b19d488978f73fc", "content": "Additionally, Spring Security provides a mechanism for discovering method parameters so they can also be accessed in the SpEL expression as well.\n\nFor a complete reference, Spring Security uses `DefaultSecurityParameterNameDiscoverer` to discover the parameter names.\nBy default, the following options are tried for a method.\n\n1. If Spring Security's `@P` annotation is present on a single argument to the method, the value is used.\nThe following example uses the `@P` annotation:\n\n+\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport org.springframework.security.access.method.P;\n\n...\n\n@PreAuthorize(\"hasPermission(#c, 'write')\")\npublic void updateContact(@P(\"c\") Contact contact);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.access.method.P\n\n...\n\n@PreAuthorize(\"hasPermission(#c, 'write')\")\nfun doSomething(@P(\"c\") contact: Contact?)\n----\n======\n+\nThe intention of this expression is to require that the current `Authentication` have `write` permission specifically for this `Contact` instance.\n+\nBehind the scenes, this is implemented by using `AnnotationParameterNameDiscoverer`, which you can customize to support the value attribute of any specified annotation.\n\n2. If xref:servlet/integrations/data.adoc[Spring Data's] `@Param` annotation is present on at least one parameter for the method, the value is used.\nThe following example uses the `@Param` annotation:\n+\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport org.springframework.data.repository.query.Param;\n\n...\n\n@PreAuthorize(\"#n == authentication.name\")\nContact findContactByName(@Param(\"n\") String name);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.data.repository.query.Param\n\n...\n\n@PreAuthorize(\"#n == authentication.name\")\nfun findContactByName(@Param(\"n\") name: String?): Contact?\n----\n======\n+\nThe intention of this expression is to require that `name` be equal to `Authentication#getName` for the invocation to be authorized.\n+\nBehind the scenes, this is implemented by using `AnnotationParameterNameDiscoverer`, which you can customize to support the value attribute of any specified annotation.\n\n3. If you compile your code with the `-parameters` argument, the standard JDK reflection API is used to discover the parameter names.\nThis works on both classes and interfaces.\n\n4. Finally, if you compile your code with debug symbols, the parameter names are discovered by using the debug symbols.\nThis does not work for interfaces, since they do not have debug information about the parameter names.\nFor interfaces, either annotations or the `-parameters` approach must be used.\n\n[[customizing-authorization-managers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Using Method Parameters", "heading_level": 3, "file_order": 117, "section_index": 31, "content_hash": "7a212b40921d22557e62aa54c9b414d9c8fa3cb5a507549c5b19d488978f73fc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:33a21706ae64ed421333667a211132adfd21bde1ba3d630ea7334177f7f37cfa", "content": "When you use SpEL expressions with <<use-preauthorize,`@PreAuthorize`>>, <<use-postauthorize,`@PostAuthorize`>>, <<use-prefilter,`@PreFilter`>> and <<use-postfilter,`@PostFilter`>>, Spring Security takes care of creating the appropriate `AuthorizationManager` instances for you.\nIn certain cases, you may want to customize what is created in order to have complete control over how authorization decisions are made xref:servlet/authorization/architecture.adoc#authz-delegate-authorization-manager[at the framework level].\n\nIn order to take control of creating instances of `AuthorizationManager` for pre- and post-annotations, you can create a custom xref:servlet/authorization/architecture.adoc#authz-authorization-manager-factory[`AuthorizationManagerFactory`].\nFor example, let's say you want to allow users with the `ADMIN` role whenever any other role is required.\nTo do this, you can create a custom implementation for method security as in the following example:\n\ninclude-code::./CustomMethodInvocationAuthorizationManagerFactory[tag=class,indent=0]\n\nNow, whenever you <<use-preauthorize,use the `@PreAuthorize` annotation>> with `hasRole` or `hasAnyRole`, Spring Security will automatically invoke your custom factory to create an instance of `AuthorizationManager` that allows access for the given role(s) _OR_ the `ADMIN` role.\n\n[TIP]\nWe use this as a simple example of creating a custom `AuthorizationManagerFactory`, though the same outcome could be accomplished with <<favor-granting-authorities,a role hierarchy>>.\nUse whichever approach fits best in your situation.\n\n[[authorize-object]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Customizing Authorization Managers", "heading_level": 2, "file_order": 117, "section_index": 32, "content_hash": "33a21706ae64ed421333667a211132adfd21bde1ba3d630ea7334177f7f37cfa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:570a695545a3c3c05bbb37beb364abc739976f233e1d8aba184b76465b4e966e", "content": "Spring Security also supports wrapping any object that is annotated its method security annotations.\n\nThe simplest way to achieve this is to mark any method that returns the object you wish to authorize with the `@AuthorizeReturnObject` annotation.\n\nFor example, consider the following `User` class:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class User {\n\tprivate String name;\n\tprivate String email;\n\n\tpublic User(String name, String email) {\n this.name = name;\n this.email = email;\n\t}\n\n\tpublic String getName() {\n return this.name;\n\t}\n\n @PreAuthorize(\"hasAuthority('user:read')\")\n public String getEmail() {\n return this.email;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass User (val name:String, @get:PreAuthorize(\"hasAuthority('user:read')\") val email:String)\n----\n======\n\nGiven an interface like this one:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class UserRepository {\n\t@AuthorizeReturnObject\n Optional<User> findByName(String name) {\n // ...\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass UserRepository {\n @AuthorizeReturnObject\n fun findByName(name:String?): Optional<User?>? {\n // ...\n }\n}\n----\n======\n\nThen any `User` that is returned from `findById` will be secured like other Spring Security-protected components:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nUserRepository users;\n\n@Test\nvoid getEmailWhenProxiedThenAuthorizes() {\n Optional<User> securedUser = users.findByName(\"name\");\n assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(() -> securedUser.get().getEmail());\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n\nimport jdk.incubator.vector.VectorOperators.Test\nimport java.nio.file.AccessDeniedException\nimport java.util.*\n\n@Autowired\nvar users:UserRepository? = null\n\n@Test\nfun getEmailWhenProxiedThenAuthorizes() {\n val securedUser: Optional<User> = users.findByName(\"name\")\n assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy{securedUser.get().getEmail()}\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Authorizing Arbitrary Objects", "heading_level": 2, "file_order": 117, "section_index": 33, "content_hash": "570a695545a3c3c05bbb37beb364abc739976f233e1d8aba184b76465b4e966e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:ac1383064b053997401bfeb1639ade1fd520b88dbc475aea9169e36519d502f4", "content": "`@AuthorizeReturnObject` can be placed at the class level. Note, though, that this means Spring Security will attempt to proxy any return object, including ``String``, ``Integer`` and other types.\nThis is often not what you want to do.\n\nIf you want to use `@AuthorizeReturnObject` on a class or interface whose methods return value types, like `int`, `String`, `Double` or collections of those types, then you should also publish the appropriate `AuthorizationAdvisorProxyFactory.TargetVisitor` as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory.TargetVisitor;\n\n@Bean\nstatic TargetVisitor skipValueTypes() {\n return TargetVisitor.defaultsSkipValueTypes();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory.TargetVisitor\n\n@Bean\nopen fun skipValueTypes() = TargetVisitor.defaultsSkipValueTypes()\n----\n======\n\n[TIP]\n====\nYou can set your own `AuthorizationAdvisorProxyFactory.TargetVisitor` to customize the proxying for any set of types\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Using `@AuthorizeReturnObject` at the class level", "heading_level": 3, "file_order": 117, "section_index": 34, "content_hash": "ac1383064b053997401bfeb1639ade1fd520b88dbc475aea9169e36519d502f4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:93dae37a21476973492afcd0c35a4e7f2223e973991feac014a95e5a10ad47f0", "content": "You can also programmatically proxy a given object.\n\nTo achieve this, you can autowire the provided `AuthorizationProxyFactory` instance, which is based on which method security interceptors you have configured.\nIf you are using `@EnableMethodSecurity`, then this means that it will by default have the interceptors for `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, and `@PostFilter`.\n\nYou can proxy an instance of user in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nAuthorizationProxyFactory proxyFactory;\n\n@Test\nvoid getEmailWhenProxiedThenAuthorizes() {\n User user = new User(\"name\", \"email\");\n assertThat(user.getEmail()).isNotNull();\n User securedUser = proxyFactory.proxy(user);\n assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(securedUser::getEmail);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Autowired\nvar proxyFactory:AuthorizationProxyFactory? = null\n\n@Test\nfun getEmailWhenProxiedThenAuthorizes() {\n val user: User = User(\"name\", \"email\")\n assertThat(user.getEmail()).isNotNull()\n val securedUser: User = proxyFactory.proxy(user)\n assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy(securedUser::getEmail)\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Programmatically Proxying", "heading_level": 3, "file_order": 117, "section_index": 35, "content_hash": "93dae37a21476973492afcd0c35a4e7f2223e973991feac014a95e5a10ad47f0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:76d733abda792aa5903d8e9655859bb0a4bcbc8e8ace5ef0647bbf61c27b9f72", "content": "You can also define your own instance if you need something different from the Spring Security default.\n\nFor example, if you define an `AuthorizationProxyFactory` instance like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory.TargetVisitor;\nimport static org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor.preAuthorize;\n\nAuthorizationProxyFactory proxyFactory = AuthorizationAdvisorProxyFactory.withDefaults();\nproxyFactory.setTargetVisitor(TargetVisitor.defaultsSkipValueTypes());\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory.TargetVisitor;\nimport org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor.preAuthorize\n\nval proxyFactory: AuthorizationProxyFactory = AuthorizationProxyFactory(preAuthorize())\nproxyFactory.setTargetVisitor(TargetVisitor.defaultsSkipValueTypes())\n----\n======\n\nThen you can wrap any instance of `User` as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Test\nvoid getEmailWhenProxiedThenAuthorizes() {\n\tAuthorizationProxyFactory proxyFactory = AuthorizationAdvisorProxyFactory.withDefaults();\n User user = new User(\"name\", \"email\");\n assertThat(user.getEmail()).isNotNull();\n User securedUser = proxyFactory.proxy(user);\n assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(securedUser::getEmail);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Test\nfun getEmailWhenProxiedThenAuthorizes() {\n val proxyFactory: AuthorizationProxyFactory = AuthorizationAdvisorProxyFactory.withDefaults()\n val user: User = User(\"name\", \"email\")\n assertThat(user.getEmail()).isNotNull()\n val securedUser: User = proxyFactory.proxy(user)\n assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy(securedUser::getEmail)\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Manual Construction", "heading_level": 3, "file_order": 117, "section_index": 36, "content_hash": "76d733abda792aa5903d8e9655859bb0a4bcbc8e8ace5ef0647bbf61c27b9f72", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:d7ced7909615ce8c14679231278b96ad295c39c0be3106b266fb7f57aa3fd2c6", "content": "`AuthorizationProxyFactory` supports Java collections, streams, arrays, optionals, and iterators by proxying the element type and maps by proxying the value type.\n\nThis means that when proxying a `List` of objects, the following also works:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Test\nvoid getEmailWhenProxiedThenAuthorizes() {\n\tAuthorizationProxyFactory proxyFactory = AuthorizationAdvisorProxyFactory.withDefaults();\n List<User> users = List.of(ada, albert, marie);\n List<User> securedUsers = proxyFactory.proxy(users);\n\tsecuredUsers.forEach((securedUser) ->\n assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(securedUser::getEmail));\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Proxying Collections", "heading_level": 3, "file_order": 117, "section_index": 37, "content_hash": "d7ced7909615ce8c14679231278b96ad295c39c0be3106b266fb7f57aa3fd2c6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:b792bbf684ebe4ded96ec125316e3bd3664ec7921e404f02ad9763e13588fd28", "content": "In limited circumstances, it may be valuable to proxy a `Class` itself, and `AuthorizationProxyFactory` also supports this.\nThis is roughly the equivalent of calling `ProxyFactory#getProxyClass` in Spring Framework's support for creating proxies.\n\nOne place where this is handy is when you need to construct the proxy class ahead-of-time, like with Spring AOT.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Proxying Classes", "heading_level": 3, "file_order": 117, "section_index": 38, "content_hash": "b792bbf684ebe4ded96ec125316e3bd3664ec7921e404f02ad9763e13588fd28", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:9fe815f2525545cfffcaa2a6af96eeef6a28abef0aa64a42d385506280fc36f6", "content": "`AuthorizationProxyFactory` supports whichever method security annotations are enabled in your application.\nIt is based off of whatever `AuthorizationAdvisor` classes are published as a bean.\n\nSince `@EnableMethodSecurity` publishes `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, and `@PostFilter` advisors by default, you will typically need to do nothing to activate the ability.\n\n[NOTE]\n====\nSpEL expressions that use `returnObject` or `filterObject` sit behind the proxy and so have full access to the object.\n====\n\n[#custom_advice]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Support for All Method Security Annotations", "heading_level": 3, "file_order": 117, "section_index": 39, "content_hash": "9fe815f2525545cfffcaa2a6af96eeef6a28abef0aa64a42d385506280fc36f6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:3251ddee27e040b4c0a1a7b67539093c9ee10e97d19900f41f81f69ef3d4ce68", "content": "If you have security advice that you also want applied, you can publish your own `AuthorizationAdvisor` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@EnableMethodSecurity\nclass SecurityConfig {\n @Bean\n static AuthorizationAdvisor myAuthorizationAdvisor() {\n return new AuthorizationAdvisor();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@EnableMethodSecurity\ninternal class SecurityConfig {\n @Bean\n fun myAuthorizationAdvisor(): AuthorizationAdvisor {\n return AuthorizationAdvisor()\n }\n]\n----\n======\n\nAnd Spring Security will add that advisor into the set of advice that `AuthorizationProxyFactory` adds when proxying an object.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Custom Advice", "heading_level": 3, "file_order": 117, "section_index": 40, "content_hash": "3251ddee27e040b4c0a1a7b67539093c9ee10e97d19900f41f81f69ef3d4ce68", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:d39c89e9a601b884d7a39d3636244049731406abbefea82ef3450db80cd36ef9", "content": "One powerful use of this feature is to return a secured value from a controller like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic class UserController {\n @Autowired\n AuthorizationProxyFactory proxyFactory;\n\n @GetMapping\n User currentUser(@AuthenticationPrincipal User user) {\n return this.proxyFactory.proxy(user);\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RestController\nclass UserController {\n @Autowired\n var proxyFactory: AuthorizationProxyFactory? = null\n\n @GetMapping\n fun currentUser(@AuthenticationPrincipal user:User?): User {\n return proxyFactory.proxy(user)\n }\n}\n----\n======\n\nYou will need to <<fallback-values-authorization-denied,add a `MethodAuthorizationDeniedHandler`>> like this one:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class Null implements MethodAuthorizationDeniedHandler {\n @Override\n public Object handleDeniedInvocation(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) {\n return null;\n }\n}\n\n@HandleAuthorizationDenied(handlerClass = Null.class)\npublic class User {\n\t...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass Null : MethodAuthorizationDeniedHandler {\n override fun handleDeniedInvocation(methodInvocation: MethodInvocation?, authorizationResult: AuthorizationResult?): Any? {\n return null\n }\n}\n\n@HandleAuthorizationDenied(handlerClass = Null.class)\nopen class User {\n\t...\n}\n----\n======\n\nThen, you'll see a different JSON serialization based on the authorization level of the user.\nIf they don't have the `user:read` authority, then they'll see:\n\n[source,json]\n----\n{\n \"name\" : \"name\",\n \"email\" : null\n}\n----\n\nAnd if they do have that authority, they'll see:\n\n[source,json]\n----\n{\n \"name\" : \"name\",\n \"email\" : \"email\"\n}\n----\n\n[TIP]\n====\nYou can also add the Spring Boot property `spring.jackson.default-property-inclusion=non_null` to exclude the null value from serialization, if you also don't want to reveal the JSON key to an unauthorized user.\n====\n\n[[authorize-return-object-aot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Working with Jackson", "heading_level": 3, "file_order": 117, "section_index": 41, "content_hash": "d39c89e9a601b884d7a39d3636244049731406abbefea82ef3450db80cd36ef9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:cdac6525f3d64ec7246b1d301e9fa56a602d15a3b16a7443c5bb94f8f20e0fe8", "content": "Spring Security will scan all beans in the application context for methods that use `@AuthorizeReturnObject`.\nWhen it finds one, it will create and register the appropriate proxy class ahead of time.\nIt will also recursively search for other nested objects that also use `@AuthorizeReturnObject` and register them accordingly.\n\nFor example, consider the following Spring Boot application:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@SpringBootApplication\npublic class MyApplication {\n\t@RestController\n public static class MyController { <1>\n @GetMapping\n @AuthorizeReturnObject\n Message getMessage() { <2>\n return new Message(someUser, \"hello!\");\n }\n }\n\n\tpublic static class Message { <3>\n User to;\n String text;\n\n // ...\n\n @AuthorizeReturnObject\n public User getTo() { <4>\n return this.to;\n }\n\n // ...\n\t}\n\n\tpublic static class User { <5>\n // ...\n\t}\n\n\tpublic static void main(String[] args) {\n SpringApplication.run(MyApplication.class);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@SpringBootApplication\nopen class MyApplication {\n\t@RestController\n open class MyController { <1>\n @GetMapping\n @AuthorizeReturnObject\n fun getMessage():Message { <2>\n return Message(someUser, \"hello!\")\n }\n }\n\n\topen class Message { <3>\n val to: User\n val test: String\n\n // ...\n\n @AuthorizeReturnObject\n fun getTo(): User { <4>\n return this.to\n }\n\n // ...\n\t}\n\n\topen class User { <5>\n // ...\n\t}\n\n\tfun main(args: Array<String>) {\n SpringApplication.run(MyApplication.class)\n\t}\n}\n----\n======\n<1> - First, Spring Security finds the `MyController` bean\n<2> - Finding a method that uses `@AuthorizeReturnObject`, it proxies `Message`, the return value, and registers that proxy class to `RuntimeHints`\n<3> - Then, it traverses `Message` to see if it uses `@AuthorizeReturnObject`\n<4> - Finding a method that uses `@AuthorizeReturnObject`, it proxies `User`, the return value, and registers that proxy class to `RuntimeHints`\n<5> - Finally, it traverses `User` to see if it uses `@AuthorizeReturnObject`; finding nothing, the algorithm completes\n\nThere will be many times when Spring Security cannot determine the proxy class ahead of time since it may be hidden in an erased generic type.\n\nConsider the following change to `MyController`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic static class MyController {\n @GetMapping\n @AuthorizeReturnObject\n List<Message> getMessages() {\n return List.of(new Message(someUser, \"hello!\"));\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RestController\nstatic class MyController {\n @AuthorizeReturnObject\n @GetMapping\n fun getMessages(): Array<Message> = arrayOf(Message(someUser, \"hello!\"))\n}\n----\n======\n\nIn this case, the generic type is erased and so it isn't apparent to Spring Security ahead-of-time that `Message` will need to be proxied at runtime.\n\nTo address this, you can publish `AuthorizeProxyFactoryHintsRegistrar` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\nstatic SecurityHintsRegsitrar registerTheseToo(AuthorizationProxyFactory proxyFactory) {\n\treturn new AuthorizeReturnObjectHintsRegistrar(proxyFactory, Message.class);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\n@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\nfun registerTheseToo(proxyFactory: AuthorizationProxyFactory?): SecurityHintsRegistrar {\n return AuthorizeReturnObjectHintsRegistrar(proxyFactory, Message::class.java)\n}\n----\n======\n\nSpring Security will register that class and then traverse its type as before.\n\n[[fallback-values-authorization-denied]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Working with AOT", "heading_level": 3, "file_order": 117, "section_index": 42, "content_hash": "cdac6525f3d64ec7246b1d301e9fa56a602d15a3b16a7443c5bb94f8f20e0fe8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:58771bc627cf320c137b0616859d52ba88c9802de29ebc3a9e3d47a96b58214c", "content": "There are some scenarios where you may not wish to throw an `AuthorizationDeniedException` when a method is invoked without the required permissions.\nInstead, you might wish to return a post-processed result, like a masked result, or a default value in cases where authorization denied happened before invoking the method.\n\nSpring Security provides support for handling authorization denied on method invocation by using the javadoc:org.springframework.security.authorization.method.HandleAuthorizationDenied[format=annotation].\nThe handler works for denied authorizations that happened in the <<authorizing-with-annotations,`@PreAuthorize` and `@PostAuthorize` annotations>> as well as javadoc:org.springframework.security.authorization.AuthorizationDeniedException[] thrown from the method invocation itself.\n\nLet's consider the example from the <<authorize-object,previous section>>, but instead of creating the `AccessDeniedExceptionInterceptor` to transform an `AccessDeniedException` to a `null` return value, we will use the `handlerClass` attribute from `@HandleAuthorizationDenied`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class NullMethodAuthorizationDeniedHandler implements MethodAuthorizationDeniedHandler { <1>\n\n @Override\n public Object handleDeniedInvocation(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) {\n return null;\n }\n\n}\n\n@Configuration\n@EnableMethodSecurity\npublic class SecurityConfig {\n\n @Bean <2>\n public NullMethodAuthorizationDeniedHandler nullMethodAuthorizationDeniedHandler() {\n return new NullMethodAuthorizationDeniedHandler();\n }\n\n}\n\npublic class User {\n // ...\n\n @PreAuthorize(value = \"hasAuthority('user:read')\")\n @HandleAuthorizationDenied(handlerClass = NullMethodAuthorizationDeniedHandler.class)\n public String getEmail() {\n return this.email;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass NullMethodAuthorizationDeniedHandler : MethodAuthorizationDeniedHandler { <1>\n\n override fun handleDeniedInvocation(methodInvocation: MethodInvocation, authorizationResult: AuthorizationResult): Any {\n return null\n }\n\n}\n\n@Configuration\n@EnableMethodSecurity\nclass SecurityConfig {\n\n @Bean <2>\n fun nullMethodAuthorizationDeniedHandler(): NullMethodAuthorizationDeniedHandler {\n return MaskMethodAuthorizationDeniedHandler()\n }\n\n}\n\nclass User (val name:String, @PreAuthorize(value = \"hasAuthority('user:read')\") @HandleAuthorizationDenied(handlerClass = NullMethodAuthorizationDeniedHandler::class) val email:String) <3>\n----\n======\n\n<1> Create an implementation of `MethodAuthorizationDeniedHandler` that returns a `null` value\n<2> Register the `NullMethodAuthorizationDeniedHandler` as a bean\n<3> Annotate the method with `@HandleAuthorizationDenied` and pass the `NullMethodAuthorizationDeniedHandler` to the `handlerClass` attribute\n\nAnd then you can verify that a `null` value is returned instead of the `AccessDeniedException`:\n\n[TIP]\n====\nYou can also annotate your class with `@Component` instead of creating a `@Bean` method\n====\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nUserRepository users;\n\n@Test\nvoid getEmailWhenProxiedThenNullEmail() {\n Optional<User> securedUser = users.findByName(\"name\");\n assertThat(securedUser.get().getEmail()).isNull();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Autowired\nvar users:UserRepository? = null\n\n@Test\nfun getEmailWhenProxiedThenNullEmail() {\n val securedUser: Optional<User> = users.findByName(\"name\")\n assertThat(securedUser.get().getEmail()).isNull()\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Providing Fallback Values When Authorization is Denied", "heading_level": 2, "file_order": 117, "section_index": 43, "content_hash": "58771bc627cf320c137b0616859d52ba88c9802de29ebc3a9e3d47a96b58214c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:a0e98b813c550fab107e9664f216c7fe213fd31f1572cf150f62f8b19af0cdd9", "content": "There are some scenarios where you might want to return a secure result derived from the denied result.\nFor example, if a user is not authorized to see email addresses, you might want to apply some masking on the original email address, i.e. _useremail@example.com_ would become _use\\\\******@example.com_.\n\nFor those scenarios, you can override the `handleDeniedInvocationResult` from the `MethodAuthorizationDeniedHandler`, which has the javadoc:org.springframework.security.authorization.method.MethodInvocationResult[] as an argument.\nLet's continue with the previous example, but instead of returning `null`, we will return a masked value of the email:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class EmailMaskingMethodAuthorizationDeniedHandler implements MethodAuthorizationDeniedHandler { <1>\n\n @Override\n public Object handleDeniedInvocation(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) {\n return \"***\";\n }\n\n @Override\n public Object handleDeniedInvocationResult(MethodInvocationResult methodInvocationResult, AuthorizationResult authorizationResult) {\n String email = (String) methodInvocationResult.getResult();\n return email.replaceAll(\"(^[^@]{3}|(?!^)\\\\G)[^@]\", \"$1*\");\n }\n\n}\n\n@Configuration\n@EnableMethodSecurity\npublic class SecurityConfig {\n\n @Bean <2>\n public EmailMaskingMethodAuthorizationDeniedHandler emailMaskingMethodAuthorizationDeniedHandler() {\n return new EmailMaskingMethodAuthorizationDeniedHandler();\n }\n\n}\n\npublic class User {\n // ...\n\n @PostAuthorize(value = \"hasAuthority('user:read')\")\n @HandleAuthorizationDenied(handlerClass = EmailMaskingMethodAuthorizationDeniedHandler.class)\n public String getEmail() {\n return this.email;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass EmailMaskingMethodAuthorizationDeniedHandler : MethodAuthorizationDeniedHandler {\n\n override fun handleDeniedInvocation(methodInvocation: MethodInvocation, authorizationResult: AuthorizationResult): Any {\n return \"***\"\n }\n\n override fun handleDeniedInvocationResult(methodInvocationResult: MethodInvocationResult, authorizationResult: AuthorizationResult): Any {\n val email = methodInvocationResult.result as String\n return email.replace(\"(^[^@]{3}|(?!^)\\\\G)[^@]\".toRegex(), \"$1*\")\n }\n\n}\n\n@Configuration\n@EnableMethodSecurity\nclass SecurityConfig {\n\n @Bean\n fun emailMaskingMethodAuthorizationDeniedHandler(): EmailMaskingMethodAuthorizationDeniedHandler {\n return EmailMaskingMethodAuthorizationDeniedHandler()\n }\n\n}\n\nclass User (val name:String, @PostAuthorize(value = \"hasAuthority('user:read')\") @HandleAuthorizationDenied(handlerClass = EmailMaskingMethodAuthorizationDeniedHandler::class) val email:String) <3>\n----\n======\n\n<1> Create an implementation of `MethodAuthorizationDeniedHandler` that returns a masked value of the unauthorized result value\n<2> Register the `EmailMaskingMethodAuthorizationDeniedHandler` as a bean\n<3> Annotate the method with `@HandleAuthorizationDenied` and pass the `EmailMaskingMethodAuthorizationDeniedHandler` to the `handlerClass` attribute\n\nAnd then you can verify that a masked email is returned instead of an `AccessDeniedException`:\n\n[WARNING]\n====\nSince you have access to the original denied value, make sure that you correctly handle it and do not return it to the caller.\n====\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nUserRepository users;\n\n@Test\nvoid getEmailWhenProxiedThenMaskedEmail() {\n Optional<User> securedUser = users.findByName(\"name\");\n // email is useremail@example.com\n assertThat(securedUser.get().getEmail()).isEqualTo(\"use******@example.com\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Autowired\nvar users:UserRepository? = null\n\n@Test\nfun getEmailWhenProxiedThenMaskedEmail() {\n val securedUser: Optional<User> = users.findByName(\"name\")\n // email is useremail@example.com\n assertThat(securedUser.get().getEmail()).isEqualTo(\"use******@example.com\")\n}\n----\n======\n\nWhen implementing the `MethodAuthorizationDeniedHandler` you have a few options on what type you can return:\n\n- A `null` value.\n- A non-null value, respecting the method's return type.\n- Throw an exception, usually an instance of `AuthorizationDeniedException`. This is the default behavior.\n- A `Mono` type for reactive applications.\n\nNote that since the handler must be registered as beans in your application context, you can inject dependencies into them if you need a more complex logic.\nIn addition to that, you have available the `MethodInvocation` or the `MethodInvocationResult`, as well as the `AuthorizationResult` for more details related to the authorization decision.\n\n[[deciding-return-based-parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Using the Denied Result From the Method Invocation", "heading_level": 3, "file_order": 117, "section_index": 44, "content_hash": "a0e98b813c550fab107e9664f216c7fe213fd31f1572cf150f62f8b19af0cdd9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:d405c4db884a9c182a996e948d84d109787925523fe05e83f633ee907eba143e", "content": "Consider a scenario where there might be multiple mask values for different methods, it would be not so productive if we had to create a handler for each of those methods, although it is perfectly fine to do that.\nIn such cases, we can use the information passed via parameters to decide what to do.\nFor example, we can create a custom `@Mask` annotation and a handler that detects that annotation to decide what mask value to return:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport org.springframework.core.annotation.AnnotationUtils;\n\n@Target({ ElementType.METHOD, ElementType.TYPE })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Mask {\n\n String value();\n\n}\n\npublic class MaskAnnotationDeniedHandler implements MethodAuthorizationDeniedHandler {\n\n @Override\n public Object handleDeniedInvocation(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) {\n Mask mask = AnnotationUtils.getAnnotation(methodInvocation.getMethod(), Mask.class);\n return mask.value();\n }\n\n}\n\n@Configuration\n@EnableMethodSecurity\npublic class SecurityConfig {\n\n @Bean\n public MaskAnnotationDeniedHandler maskAnnotationDeniedHandler() {\n return new MaskAnnotationDeniedHandler();\n }\n\n}\n\n@Component\npublic class MyService {\n\n @PreAuthorize(value = \"hasAuthority('user:read')\")\n @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler.class)\n @Mask(\"***\")\n public String foo() {\n return \"foo\";\n }\n\n @PreAuthorize(value = \"hasAuthority('user:read')\")\n @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler.class)\n @Mask(\"???\")\n public String bar() {\n return \"bar\";\n }\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.core.annotation.AnnotationUtils\n\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class Mask(val value: String)\n\nclass MaskAnnotationDeniedHandler : MethodAuthorizationDeniedHandler {\n\n override fun handleDeniedInvocation(methodInvocation: MethodInvocation, authorizationResult: AuthorizationResult): Any {\n val mask = AnnotationUtils.getAnnotation(methodInvocation.method, Mask::class.java)\n return mask.value\n }\n\n}\n\n@Configuration\n@EnableMethodSecurity\nclass SecurityConfig {\n\n @Bean\n fun maskAnnotationDeniedHandler(): MaskAnnotationDeniedHandler {\n return MaskAnnotationDeniedHandler()\n }\n\n}\n\n@Component\nclass MyService {\n\n @PreAuthorize(value = \"hasAuthority('user:read')\")\n @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler::class)\n @Mask(\"***\")\n fun foo(): String {\n return \"foo\"\n }\n\n @PreAuthorize(value = \"hasAuthority('user:read')\")\n @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler::class)\n @Mask(\"???\")\n fun bar(): String {\n return \"bar\"\n }\n\n}\n----\n======\n\nNow the return values when access is denied will be decided based on the `@Mask` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nMyService myService;\n\n@Test\nvoid fooWhenDeniedThenReturnStars() {\n String value = this.myService.foo();\n assertThat(value).isEqualTo(\"***\");\n}\n\n@Test\nvoid barWhenDeniedThenReturnQuestionMarks() {\n String value = this.myService.bar();\n assertThat(value).isEqualTo(\"???\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Autowired\nvar myService: MyService\n\n@Test\nfun fooWhenDeniedThenReturnStars() {\n val value: String = myService.foo()\n assertThat(value).isEqualTo(\"***\")\n}\n\n@Test\nfun barWhenDeniedThenReturnQuestionMarks() {\n val value: String = myService.bar()\n assertThat(value).isEqualTo(\"???\")\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Deciding What to Return Based on Available Parameters", "heading_level": 3, "file_order": 117, "section_index": 45, "content_hash": "d405c4db884a9c182a996e948d84d109787925523fe05e83f633ee907eba143e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:8c0ade68ff61887b454a7108641a232a17296d0202ef41414914b4134f48dbb5", "content": "You can also combine the `@HandleAuthorizationDenied` with other annotations in order to reduce and simplify the annotations in a method.\nLet's consider the <<deciding-return-based-parameters,example from the previous section>> and merge `@HandleAuthorizationDenied` with `@Mask`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Target({ ElementType.METHOD, ElementType.TYPE })\n@Retention(RetentionPolicy.RUNTIME)\n@HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler.class)\npublic @interface Mask {\n\n String value();\n\n}\n\n@Mask(\"***\")\npublic String myMethod() {\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Target(AnnotationTarget.FUNCTION, AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.RUNTIME)\n@HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler::class)\nannotation class Mask(val value: String)\n\n@Mask(\"***\")\nfun myMethod(): String {\n // ...\n}\n----\n======\n\nNow you do not have to remember to add both annotations when you need a mask behavior in your method.\nMake sure to read the <<meta-annotations,Meta Annotations Support>> section for more details on the usage.\n\n[[migration-enableglobalmethodsecurity]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Combining with Meta Annotation Support", "heading_level": 3, "file_order": 117, "section_index": 46, "content_hash": "8c0ade68ff61887b454a7108641a232a17296d0202ef41414914b4134f48dbb5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:f3e972c0e71806bfe8259ff464217ed5bd08363ceb542addc68eba8602d3e1c6", "content": "If you are using `@EnableGlobalMethodSecurity`, you should migrate to `@EnableMethodSecurity`.\n\nIf you cannot migrate at this time, please include the `spring-security-access` module as a dependency like so:\n\n[tabs]\n======\nMaven::\n+\n[source,xml,role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.security</groupId>\n <artifactId>spring-security-access</artifactId>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,role=\"primary\"]\n----\nimplementation('org.springframework.security:spring-security-access')\n----\n======\n\n[[servlet-replace-globalmethodsecurity-with-methodsecurity]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Migrating from `@EnableGlobalMethodSecurity`", "heading_level": 2, "file_order": 117, "section_index": 47, "content_hash": "f3e972c0e71806bfe8259ff464217ed5bd08363ceb542addc68eba8602d3e1c6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:b99523420f63f2668bdcb0dd0eb2e9bc7dc8cf94e9da75990392456b8c3b669b", "content": "javadoc:org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity[format=annotation] and xref:servlet/appendix/namespace/method-security.adoc#nsa-global-method-security[`<global-method-security>`] are deprecated in favor of javadoc:org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity[`@EnableMethodSecurity`] and xref:servlet/appendix/namespace/method-security.adoc#nsa-method-security[`<method-security>`], respectively.\nThe new annotation and XML element activate Spring's xref:servlet/authorization/method-security.adoc#jc-enable-method-security[pre-post annotations] by default and use `AuthorizationManager` internally.\n\nThis means that the following two listings are functionally equivalent:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<global-method-security pre-post-enabled=\"true\"/>\n----\n======\n\nand:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@EnableMethodSecurity\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@EnableMethodSecurity\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<method-security/>\n----\n======\n\nFor applications not using the pre-post annotations, make sure to turn it off to avoid activating unwanted behavior.\n\nFor example, a listing like:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@EnableGlobalMethodSecurity(securedEnabled = true)\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@EnableGlobalMethodSecurity(securedEnabled = true)\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<global-method-security secured-enabled=\"true\"/>\n----\n======\n\nshould change to:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@EnableMethodSecurity(securedEnabled = true, prePostEnabled = false)\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@EnableMethodSecurity(securedEnabled = true, prePostEnabled = false)\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<method-security secured-enabled=\"true\" pre-post-enabled=\"false\"/>\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Replace xref:servlet/authorization/method-security.adoc#jc-enable-global-method-security[global method security] with xref:servlet/authorization/method-security.adoc#jc-enable-method-security[method security]", "heading_level": 3, "file_order": 117, "section_index": 48, "content_hash": "b99523420f63f2668bdcb0dd0eb2e9bc7dc8cf94e9da75990392456b8c3b669b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:6f0bc29882a0975f9cfbd8b710d473c33a4fc65aac1d28461cd62a2e583c90e2", "content": "As a performance optimization, a new method was introduced to `MethodSecurityExpressionHandler` that takes a `Supplier<Authentication>` instead of an `Authentication`.\n\nThis allows Spring Security to defer the lookup of the `Authentication`, and is taken advantage of automatically when you use `@EnableMethodSecurity` instead of `@EnableGlobalMethodSecurity`.\n\nHowever, let's say that your code extends `DefaultMethodSecurityExpressionHandler` and overrides `createSecurityExpressionRoot(Authentication, MethodInvocation)` to return a custom `SecurityExpressionRoot` instance.\nThis will no longer work because the arrangement that `@EnableMethodSecurity` sets up calls `createEvaluationContext(Supplier<Authentication>, MethodInvocation)` instead.\n\nHappily, such a level of customization is often unnecessary.\nInstead, you can create a custom bean with the authorization methods that you need.\n\nFor example, let's say you are wanting a custom evaluation of `@PostAuthorize(\"hasAuthority('ADMIN')\")`.\nYou can create a custom `@Bean` like this one:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nclass MyAuthorizer {\n\tboolean isAdmin(MethodSecurityExpressionOperations root) {\n boolean decision = root.hasAuthority(\"ADMIN\");\n // custom work ...\n return decision;\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass MyAuthorizer {\n\tfun isAdmin(root: MethodSecurityExpressionOperations): boolean {\n val decision = root.hasAuthority(\"ADMIN\");\n // custom work ...\n return decision;\n\t}\n}\n----\n======\n\nand then refer to it in the annotation like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PreAuthorize(\"@authz.isAdmin(#root)\")\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PreAuthorize(\"@authz.isAdmin(#root)\")\n----\n======\n\n[[subclass-defaultmethodsecurityexpressionhandler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Use a Custom `@Bean` instead of subclassing `DefaultMethodSecurityExpressionHandler`", "heading_level": 3, "file_order": 117, "section_index": 49, "content_hash": "6f0bc29882a0975f9cfbd8b710d473c33a4fc65aac1d28461cd62a2e583c90e2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:f55c9377de5fcd1ef11748abc9f8ac34b63e68b2d1ed64b466da92061c954ce3", "content": "If you must continue subclassing `DefaultMethodSecurityExpressionHandler`, you can still do so.\nInstead, override the `createEvaluationContext(Supplier<Authentication>, MethodInvocation)` method like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\nclass MyExpressionHandler extends DefaultMethodSecurityExpressionHandler {\n @Override\n public EvaluationContext createEvaluationContext(Supplier<Authentication> authentication, MethodInvocation mi) {\n StandardEvaluationContext context = (StandardEvaluationContext) super.createEvaluationContext(authentication, mi);\n MethodSecurityExpressionOperations delegate = (MethodSecurityExpressionOperations) context.getRootObject().getValue();\n MySecurityExpressionRoot root = new MySecurityExpressionRoot(delegate);\n context.setRootObject(root);\n return context;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass MyExpressionHandler: DefaultMethodSecurityExpressionHandler {\n override fun createEvaluationContext(authentication: Supplier<Authentication>,\n val mi: MethodInvocation): EvaluationContext {\n val context = super.createEvaluationContext(authentication, mi) as StandardEvaluationContext\n val delegate = context.getRootObject().getValue() as MethodSecurityExpressionOperations\n val root = MySecurityExpressionRoot(delegate)\n context.setRootObject(root)\n return context\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "I'd still prefer to subclass `DefaultMethodSecurityExpressionHandler`", "heading_level": 4, "file_order": 117, "section_index": 50, "content_hash": "f55c9377de5fcd1ef11748abc9f8ac34b63e68b2d1ed64b466da92061c954ce3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:1c08855e4b4e59e2555e7654c2f94cbb73e7567cd6d2c76c63e0073c43a59a15", "content": "Now that you have secured your application's methods, please xref:servlet/authorization/authorize-http-requests.adoc[secure its requests] if you haven't already.\nYou can also read further on xref:servlet/test/index.adoc[testing your application] or on integrating Spring Security with other aspects of you application like xref:servlet/integrations/data.adoc[the data layer] or xref:servlet/integrations/observability.adoc[tracing and metrics].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/authorization/method-security.adoc", "title": "method-security", "heading": "Further Reading", "heading_level": 2, "file_order": 117, "section_index": 51, "content_hash": "1c08855e4b4e59e2555e7654c2f94cbb73e7567cd6d2c76c63e0073c43a59a15", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/authorization/method-security.adoc"}}
{"id": "sha256:574f4f9e9b0c632e0ced3956d2bae87921c247e3a6f23855aeec2f76c2a358aa", "content": "[[jc]]\n\nGeneral support for {spring-framework-reference-url}core/beans/java.html[Java configuration] was added to Spring Framework in Spring 3.1.\nSpring Security 3.2 introduced Java configuration to let users configure Spring Security without the use of any XML.\n\nIf you are familiar with the xref:servlet/configuration/xml-namespace.adoc#ns-config[Security Namespace Configuration], you should find quite a few similarities between it and Spring Security Java configuration.\n\n[NOTE]\n====\nSpring Security provides https://github.com/spring-projects/spring-security-samples/tree/main/servlet/java-configuration[lots of sample applications] to demonstrate the use of Spring Security Java Configuration.\n====\n\n[[jc-hello-wsca]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "java", "heading_level": 1, "file_order": 118, "section_index": 0, "content_hash": "574f4f9e9b0c632e0ced3956d2bae87921c247e3a6f23855aeec2f76c2a358aa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:430eed4ff7180c753f3662b6f9acb8d406569d562ded5fc3deecde12decf2493", "content": "The first step is to create our Spring Security Java Configuration.\nThe configuration creates a Servlet Filter known as the `springSecurityFilterChain`, which is responsible for all the security (protecting the application URLs, validating submitted username and passwords, redirecting to the log in form, and so on) within your application.\nThe following example shows the most basic example of a Spring Security Java Configuration:\n\n[source,java]\n----\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport org.springframework.context.annotation.*;\nimport org.springframework.security.config.annotation.authentication.builders.*;\nimport org.springframework.security.config.annotation.web.configuration.*;\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic UserDetailsService userDetailsService() {\n InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();\n manager.createUser(User.withDefaultPasswordEncoder().username(\"user\").password(\"password\").roles(\"USER\").build());\n return manager;\n\t}\n}\n----\n\nThis configuration is not complex or extensive, but it does a lot:\n\n* Require authentication to every URL in your application\n* Generate a login form for you\n* Let the user with a *Username* of `user` and a *Password* of `password` authenticate with form based authentication\n* Let the user logout\n* https://en.wikipedia.org/wiki/Cross-site_request_forgery[CSRF attack] prevention\n* https://en.wikipedia.org/wiki/Session_fixation[Session Fixation] protection\n* Security Header integration:\n** https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security[HTTP Strict Transport Security] for secure requests\n** https://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx[X-Content-Type-Options] integration\n** Cache Control (which you can override later in your application to allow caching of your static resources)\n** https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx[X-XSS-Protection] integration\n** X-Frame-Options integration to help prevent https://en.wikipedia.org/wiki/Clickjacking[Clickjacking]\n* Integration with the following Servlet API methods:\n** https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()[`HttpServletRequest#getRemoteUser()`]\n** https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()[`HttpServletRequest#getUserPrincipal()`]\n** https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)[`HttpServletRequest#isUserInRole(java.lang.String)`]\n** https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String,%20java.lang.String)[`HttpServletRequest#login(java.lang.String, java.lang.String)`]\n** https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout()[`HttpServletRequest#logout()`]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "Hello Web Security Java Configuration", "heading_level": 2, "file_order": 118, "section_index": 1, "content_hash": "430eed4ff7180c753f3662b6f9acb8d406569d562ded5fc3deecde12decf2493", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:f314acca73ba86291ea3b5786631279af6d5a189fc8daeccf77c52fa74fef24f", "content": "The next step is to register the `springSecurityFilterChain` with the WAR file.\nYou can do so in Java configuration with {spring-framework-reference-url}web/webmvc/mvc-servlet/container-config.html[Spring's `WebApplicationInitializer` support] in a Servlet 3.0+ environment.\nNot surprisingly, Spring Security provides a base class (`AbstractSecurityWebApplicationInitializer`) to ensure that the `springSecurityFilterChain` gets registered for you.\nThe way in which we use `AbstractSecurityWebApplicationInitializer` differs depending on if we are already using Spring or if Spring Security is the only Spring component in our application.\n\n* <<abstractsecuritywebapplicationinitializer-without-existing-spring>> - Use these instructions if you are not already using Spring\n* <<abstractsecuritywebapplicationinitializer-with-spring-mvc>> - Use these instructions if you are already using Spring\n\n[[abstractsecuritywebapplicationinitializer-without-existing-spring]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "AbstractSecurityWebApplicationInitializer", "heading_level": 3, "file_order": 118, "section_index": 2, "content_hash": "f314acca73ba86291ea3b5786631279af6d5a189fc8daeccf77c52fa74fef24f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:47da9d0705b86cdf1ca4c4670811af23b9f8724e7430869ca34b5010bb880eb2", "content": "If you are not using Spring or Spring MVC, you need to pass the `WebSecurityConfig` to the superclass to ensure the configuration is picked up:\n\n[source,java]\n----\nimport org.springframework.security.web.context.*;\n\npublic class SecurityWebApplicationInitializer\n\textends AbstractSecurityWebApplicationInitializer {\n\n\tpublic SecurityWebApplicationInitializer() {\n super(WebSecurityConfig.class);\n\t}\n}\n----\n\nThe `SecurityWebApplicationInitializer`:\n\n* Automatically registers the `springSecurityFilterChain` Filter for every URL in your application.\n* Add a `ContextLoaderListener` that loads the <<jc-hello-wsca,WebSecurityConfig>>.\n\n[[abstractsecuritywebapplicationinitializer-with-spring-mvc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "AbstractSecurityWebApplicationInitializer without Existing Spring", "heading_level": 3, "file_order": 118, "section_index": 3, "content_hash": "47da9d0705b86cdf1ca4c4670811af23b9f8724e7430869ca34b5010bb880eb2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:5f71146679ad44a3ecdd0829684269213c0e3bdbc1e9b58abda7e6fe049edc22", "content": "If we use Spring elsewhere in our application, we probably already have a `WebApplicationInitializer` that is loading our Spring Configuration.\nIf we use the previous configuration, we would get an error.\nInstead, we should register Spring Security with the existing `ApplicationContext`.\nFor example, if we use Spring MVC, our `SecurityWebApplicationInitializer` could look something like the following:\n\n[source,java]\n----\nimport org.springframework.security.web.context.*;\n\npublic class SecurityWebApplicationInitializer\n\textends AbstractSecurityWebApplicationInitializer {\n\n}\n----\n\nThis only registers the `springSecurityFilterChain` for every URL in your application.\nAfter that, we need to ensure that `WebSecurityConfig` was loaded in our existing `ApplicationInitializer`.\nFor example, if we use Spring MVC it is added in the `getServletConfigClasses()`:\n\n[[message-web-application-inititializer-java]]\n[source,java]\n----\npublic class MvcWebApplicationInitializer extends\n AbstractAnnotationConfigDispatcherServletInitializer {\n\n\t@Override\n\tprotected Class<?>[] getServletConfigClasses() {\n return new Class[] { WebSecurityConfig.class, WebMvcConfig.class };\n\t}\n\n\t// ... other overrides ...\n}\n----\n\nThe reason for this is that Spring Security needs to be able to inspect some Spring MVC configuration in order to appropriately configure xref:servlet/authorization/authorize-http-requests.adoc#authorizing-endpoints[underlying request matchers], so they need to be in the same application context.\nPlacing Spring Security in `getRootConfigClasses` places it into a parent application context that may not be able to find Spring MVC's `PathPatternParser`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "AbstractSecurityWebApplicationInitializer with Spring MVC", "heading_level": 3, "file_order": 118, "section_index": 4, "content_hash": "5f71146679ad44a3ecdd0829684269213c0e3bdbc1e9b58abda7e6fe049edc22", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:03ca02ecd655c7b343f1606b481c4d72abf2e24678553061045ecb253db2172d", "content": "If desired, any Spring Security configuration that is unrelated to Spring MVC may be placed in a different configuration class like so:\n\n[source,java]\n----\npublic class MvcWebApplicationInitializer extends\n AbstractAnnotationConfigDispatcherServletInitializer {\n\n\t@Override\n protected Class<?>[] getRootConfigClasses() {\n return new Class[] { NonWebSecurityConfig.class };\n }\n\n\t@Override\n\tprotected Class<?>[] getServletConfigClasses() {\n return new Class[] { WebSecurityConfig.class, WebMvcConfig.class };\n\t}\n\n\t// ... other overrides ...\n}\n----\n\nThis can be helpful if you have multiple instances of `AbstractAnnotationConfigDispatcherServletInitializer` and don't want to duplicate the general security configuration across both of them.\n\n[[jc-httpsecurity]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "Configuring for Multiple Spring MVC Dispatchers", "heading_level": 4, "file_order": 118, "section_index": 5, "content_hash": "03ca02ecd655c7b343f1606b481c4d72abf2e24678553061045ecb253db2172d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:94a55cc66406b9ed4c400109af9ef88756d28d731f579e3ff4674defbb76b5f6", "content": "Thus far, our <<jc-hello-wsca,`WebSecurityConfig`>> contains only information about how to authenticate our users.\nHow does Spring Security know that we want to require all users to be authenticated?\nHow does Spring Security know we want to support form-based authentication?\nActually, there is a configuration class (called `SecurityFilterChain`) that is being invoked behind the scenes.\nIt is configured with the following default implementation:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n\thttp\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .formLogin(Customizer.withDefaults())\n .httpBasic(Customizer.withDefaults());\n\treturn http.build();\n}\n----\n\nThe default configuration (shown in the preceding example):\n\n* Ensures that any request to our application requires the user to be authenticated\n* Lets users authenticate with form-based login\n* Lets users authenticate with HTTP Basic authentication\n\nNote that this configuration parallels the XML namespace configuration:\n\n[source,xml]\n----\n<http>\n\t<intercept-url pattern=\"/**\" access=\"authenticated\"/>\n\t<form-login />\n\t<http-basic />\n</http>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "HttpSecurity", "heading_level": 2, "file_order": 118, "section_index": 6, "content_hash": "94a55cc66406b9ed4c400109af9ef88756d28d731f579e3ff4674defbb76b5f6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:c0fe2a095aad102f47cbfe2320a5252b62c9509f05cebd9799c5e17d17fc325d", "content": "To effectively manage security in an application where certain areas need different protection, we can employ multiple filter chains alongside the `securityMatcher` DSL method.\nThis approach allows us to define distinct security configurations tailored to specific parts of the application, enhancing overall application security and control.\n\nWe can configure multiple `HttpSecurity` instances just as we can have multiple `<http>` blocks in XML.\nThe key is to register multiple `SecurityFilterChain` ``@Bean``s.\nThe following example has a different configuration for URLs that begin with `/api/`:\n\n[[multiple-httpsecurity-instances-java]]\n[source,java]\n----\n@Configuration\n@EnableWebSecurity\npublic class MultiHttpSecurityConfig {\n\t@Bean <1>\n\tpublic UserDetailsService userDetailsService() throws Exception {\n UserBuilder users = User.withDefaultPasswordEncoder();\n InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();\n manager.createUser(users.username(\"user\").password(\"password\").roles(\"USER\").build());\n manager.createUser(users.username(\"admin\").password(\"password\").roles(\"USER\",\"ADMIN\").build());\n return manager;\n\t}\n\n\t@Bean\n\t@Order(1) <2>\n\tpublic SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception {\n http\n .securityMatcher(\"/api/**\") <3>\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().hasRole(\"ADMIN\")\n )\n .httpBasic(Customizer.withDefaults());\n return http.build();\n\t}\n\n\t@Bean <4>\n\tpublic SecurityFilterChain formLoginFilterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .formLogin(Customizer.withDefaults());\n return http.build();\n\t}\n}\n----\n<1> Configure Authentication as usual.\n<2> Create an instance of `SecurityFilterChain` that contains `@Order` to specify which `SecurityFilterChain` should be considered first.\n<3> The `http.securityMatcher()` states that this `HttpSecurity` is applicable only to URLs that begin with `/api/`.\n<4> Create another instance of `SecurityFilterChain`.\nIf the URL does not begin with `/api/`, this configuration is used.\nThis configuration is considered after `apiFilterChain`, since it has an `@Order` value after `1` (no `@Order` defaults to last).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "Multiple HttpSecurity Instances", "heading_level": 3, "file_order": 118, "section_index": 7, "content_hash": "c0fe2a095aad102f47cbfe2320a5252b62c9509f05cebd9799c5e17d17fc325d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:3658565dde868b4d1500c6f759168e688b2eb1aea8d0818e884d7c0a29bef54a", "content": "A common question is:\n\n> What is the difference between the `http.securityMatcher()` method and `requestMatchers()` used for request authorization (i.e. inside of `http.authorizeHttpRequests()`)?\n\nTo answer this question, it helps to understand that each `HttpSecurity` instance used to build a `SecurityFilterChain` contains a `RequestMatcher` to match incoming requests.\nIf a request does not match a `SecurityFilterChain` with higher priority (e.g. `@Order(1)`), the request can be tried against a filter chain with lower priority (e.g. no `@Order`).\n\n[NOTE]\n====\nThe matching logic for multiple filter chains is performed by the xref:servlet/architecture.adoc#servlet-filterchainproxy[`FilterChainProxy`].\n====\n\nThe default `RequestMatcher` matches *any request* to ensure Spring Security protects *all requests by default*.\n\n[NOTE]\n====\nSpecifying a `securityMatcher` overrides this default.\n====\n\n[WARNING]\n====\nIf no filter chain matches a particular request, the request is *not protected* by Spring Security.\n====\n\nThe following example demonstrates a single filter chain that only protects requests that begin with `/secured/`:\n\n[[choosing-security-matcher-request-matchers-java]]\n[source,java]\n----\n@Configuration\n@EnableWebSecurity\npublic class PartialSecurityConfig {\n\n\t@Bean\n\tpublic UserDetailsService userDetailsService() throws Exception {\n // ...\n\t}\n\n\t@Bean\n\tpublic SecurityFilterChain securedFilterChain(HttpSecurity http) throws Exception {\n http\n .securityMatcher(\"/secured/**\") <1>\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/secured/user\").hasRole(\"USER\") <2>\n .requestMatchers(\"/secured/admin\").hasRole(\"ADMIN\") <3>\n .anyRequest().authenticated() <4>\n )\n .httpBasic(Customizer.withDefaults())\n .formLogin(Customizer.withDefaults());\n return http.build();\n\t}\n}\n----\n<1> Requests that begin with `/secured/` will be protected but any other requests are not protected.\n<2> Requests to `/secured/user` require the `ROLE_USER` authority.\n<3> Requests to `/secured/admin` require the `ROLE_ADMIN` authority.\n<4> Any other requests (such as `/secured/other`) simply require an authenticated user.\n\n[TIP]\n====\nIt is _recommended_ to provide a `SecurityFilterChain` that does not specify any `securityMatcher` to ensure the entire application is protected, as demonstrated in the <<multiple-httpsecurity-instances-java,earlier example>>.\n====\n\nNotice that the `requestMatchers` method only applies to individual authorization rules.\nEach request listed there must also match the overall `securityMatcher` for this particular `HttpSecurity` instance used to create the `SecurityFilterChain`.\nUsing `anyRequest()` in this example matches all other requests within this particular `SecurityFilterChain` (which must begin with `/secured/`).\n\n[NOTE]\n====\nSee xref:servlet/authorization/authorize-http-requests.adoc[Authorize HttpServletRequests] for more information on `requestMatchers`.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "Choosing `securityMatcher` or `requestMatchers`", "heading_level": 3, "file_order": 118, "section_index": 8, "content_hash": "3658565dde868b4d1500c6f759168e688b2eb1aea8d0818e884d7c0a29bef54a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:668f02fdeab6a2b2d424ce37f4cdd6817dccb40d09ffb13d69818eb47b7af92a", "content": "Several filters in the `SecurityFilterChain` directly provide endpoints, such as the `UsernamePasswordAuthenticationFilter` which is set up by `http.formLogin()` and provides the `POST /login` endpoint.\nIn the <<choosing-security-matcher-request-matchers-java,above example>>, the `/login` endpoint is not matched by `http.securityMatcher(\"/secured/**\")` and therefore that application would not have any `GET /login` or `POST /login` endpoint.\nSuch requests would return `404 Not Found`.\nThis is often surprising to users.\n\nSpecifying `http.securityMatcher()` affects what requests are matched by that `SecurityFilterChain`.\nHowever, it does not automatically affect endpoints provided by the filter chain.\nIn such cases, you may need to customize the URL of any endpoints you would like the filter chain to provide.\n\nThe following example demonstrates a configuration that secures requests that begin with `/secured/` and denies all other requests, while also customizing endpoints provided by the `SecurityFilterChain`:\n\n[[security-filter-chain-endpoints-java]]\n[source,java]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecuredSecurityConfig {\n\n\t@Bean\n\tpublic UserDetailsService userDetailsService() throws Exception {\n // ...\n\t}\n\n\t@Bean\n\t@Order(1)\n\tpublic SecurityFilterChain securedFilterChain(HttpSecurity http) throws Exception {\n http\n .securityMatcher(\"/secured/**\") <1>\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated() <2>\n )\n .formLogin((formLogin) -> formLogin <3>\n .loginPage(\"/secured/login\")\n .loginProcessingUrl(\"/secured/login\")\n .permitAll()\n )\n .logout((logout) -> logout <4>\n .logoutUrl(\"/secured/logout\")\n .logoutSuccessUrl(\"/secured/login?logout\")\n .permitAll()\n );\n return http.build();\n\t}\n\n\t@Bean\n\tpublic SecurityFilterChain defaultFilterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().denyAll() <5>\n );\n return http.build();\n\t}\n}\n----\n<1> Requests that begin with `/secured/` will be protected by this filter chain.\n<2> Requests that begin with `/secured/` require an authenticated user.\n<3> Customize form login to prefix URLs with `/secured/`.\n<4> Customize logout to prefix URLs with `/secured/`.\n<5> All other requests will be denied.\n\n[NOTE]\n====\nThis example customizes the login and logout pages, which disables Spring Security's generated pages.\nYou must xref:servlet/authentication/passwords/form.adoc#servlet-authentication-form-custom[provide your own] custom endpoints for `GET /secured/login` and `GET /secured/logout`.\nNote that Spring Security still provides `POST /secured/login` and `POST /secured/logout` endpoints for you.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "`SecurityFilterChain` Endpoints", "heading_level": 3, "file_order": 118, "section_index": 9, "content_hash": "668f02fdeab6a2b2d424ce37f4cdd6817dccb40d09ffb13d69818eb47b7af92a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:17daf69f46ac187f70ad942b662d3aae1019eb86041003120e612f6aff53dd2f", "content": "The following example demonstrates a slightly more real-world configuration putting all of these elements together:\n\n[[real-world-example-java]]\n[source,java]\n----\n@Configuration\n@EnableWebSecurity\npublic class BankingSecurityConfig {\n\n @Bean <1>\n public UserDetailsService userDetailsService() {\n UserBuilder users = User.withDefaultPasswordEncoder();\n InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();\n manager.createUser(users.username(\"user1\").password(\"password\").roles(\"USER\", \"VIEW_BALANCE\").build());\n manager.createUser(users.username(\"user2\").password(\"password\").roles(\"USER\").build());\n manager.createUser(users.username(\"admin\").password(\"password\").roles(\"ADMIN\").build());\n return manager;\n }\n\n @Bean\n @Order(1) <2>\n public SecurityFilterChain approvalsSecurityFilterChain(HttpSecurity http) throws Exception {\n String[] approvalsPaths = { \"/accounts/approvals/**\", \"/loans/approvals/**\", \"/credit-cards/approvals/**\" };\n http\n .securityMatcher(approvalsPaths)\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().hasRole(\"ADMIN\")\n )\n .httpBasic(Customizer.withDefaults());\n return http.build();\n }\n\n @Bean\n @Order(2) <3>\n public SecurityFilterChain bankingSecurityFilterChain(HttpSecurity http) throws Exception {\n String[] bankingPaths = { \"/accounts/**\", \"/loans/**\", \"/credit-cards/**\", \"/balances/**\" };\n String[] viewBalancePaths = { \"/balances/**\" };\n http\n .securityMatcher(bankingPaths)\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(viewBalancePaths).hasRole(\"VIEW_BALANCE\")\n .anyRequest().hasRole(\"USER\")\n );\n return http.build();\n }\n\n @Bean <4>\n public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {\n String[] allowedPaths = { \"/\", \"/user-login\", \"/user-logout\", \"/notices\", \"/contact\", \"/register\" };\n http\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(allowedPaths).permitAll()\n .anyRequest().authenticated()\n )\n .formLogin((formLogin) -> formLogin\n .loginPage(\"/user-login\")\n .loginProcessingUrl(\"/user-login\")\n )\n .logout((logout) -> logout\n .logoutUrl(\"/user-logout\")\n .logoutSuccessUrl(\"/?logout\")\n );\n return http.build();\n }\n}\n----\n<1> Begin by configuring authentication settings.\n<2> Define a `SecurityFilterChain` instance with `@Order(1)`, which means that this filter chain will have the highest priority.\n This filter chain applies only to requests that begin with `/accounts/approvals/`, `/loans/approvals/` or `/credit-cards/approvals/`.\n\tRequests to this filter chain require the `ROLE_ADMIN` authority and allow HTTP Basic Authentication.\n<3> Next, create another `SecurityFilterChain` instance with `@Order(2)` which will be considered second.\n This filter chain applies only to requests that begin with `/accounts/`, `/loans/`, `/credit-cards/`, or `/balances/`.\n\tNotice that because this filter chain is second, any requests that include `/approvals/` will match the previous filter chain and will *not* be matched by this filter chain.\n\tRequests to this filter chain require the `ROLE_USER` authority.\n\tThis filter chain does not define any authentication because the next (default) filter chain contains that configuration.\n<4> Lastly, create an additional `SecurityFilterChain` instance without an `@Order` annotation.\n\tThis configuration will handle requests not covered by the other filter chains and will be processed last (no `@Order` defaults to last).\n\tRequests that match `/`, `/user-login`, `/user-logout`, `/notices`, `/contact` and `/register` allow access without authentication.\n\tAny other requests require the user to be authenticated to access any URL not explicitly allowed or protected by other filter chains.\n\n[[jc-custom-dsls]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "Real World Example", "heading_level": 3, "file_order": 118, "section_index": 10, "content_hash": "17daf69f46ac187f70ad942b662d3aae1019eb86041003120e612f6aff53dd2f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:ba66d172a320d744b4b635cba22dba360d91312f778539c6810a9cb0bf0eef49", "content": "You can provide your own custom DSLs in Spring Security:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class MyCustomDsl extends AbstractHttpConfigurer<MyCustomDsl, HttpSecurity> {\n\tprivate boolean flag;\n\n\t@Override\n\tpublic void init(HttpSecurity http) {\n // any method that adds another configurer\n // must be done in the init method\n http.csrf(csrf -> csrf.disable());\n\t}\n\n\t@Override\n\tpublic void configure(HttpSecurity http) {\n ApplicationContext context = http.getSharedObject(ApplicationContext.class);\n\n // here we lookup from the ApplicationContext. You can also just create a new instance.\n MyFilter myFilter = context.getBean(MyFilter.class);\n myFilter.setFlag(flag);\n http.addFilterBefore(myFilter, UsernamePasswordAuthenticationFilter.class);\n\t}\n\n\tpublic MyCustomDsl flag(boolean value) {\n this.flag = value;\n return this;\n\t}\n\n\tpublic static MyCustomDsl customDsl() {\n return new MyCustomDsl();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass MyCustomDsl : AbstractHttpConfigurer<MyCustomDsl, HttpSecurity>() {\n var flag: Boolean = false\n\n override fun init(http: HttpSecurity) {\n // any method that adds another configurer\n // must be done in the init method\n http.csrf().disable()\n }\n\n override fun configure(http: HttpSecurity) {\n val context: ApplicationContext = http.getSharedObject(ApplicationContext::class.java)\n\n // here we lookup from the ApplicationContext. You can also just create a new instance.\n val myFilter: MyFilter = context.getBean(MyFilter::class.java)\n myFilter.setFlag(flag)\n http.addFilterBefore(myFilter, UsernamePasswordAuthenticationFilter::class.java)\n }\n\n companion object {\n @JvmStatic\n fun customDsl(): MyCustomDsl {\n return MyCustomDsl()\n }\n }\n}\n----\n======\n\n[NOTE]\n====\nThis is actually how methods like `HttpSecurity.authorizeHttpRequests()` are implemented.\n====\n\nYou can then use the custom DSL:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class Config {\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .with(MyCustomDsl.customDsl(), (dsl) -> dsl\n .flag(true)\n )\n // ...\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass Config {\n\n @Bean\n fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http\n .with(MyCustomDsl.customDsl()) {\n flag = true\n }\n // ...\n\n return http.build()\n }\n}\n----\n======\n\nThe code is invoked in the following order:\n\n* Code in the `Config.filterChain` method is invoked\n* Code in the `MyCustomDsl.init` method is invoked\n* Code in the `MyCustomDsl.configure` method is invoked\n\nIf you want, you can have `HttpSecurity` add `MyCustomDsl` by default by using `SpringFactories`.\nFor example, you can create a resource on the classpath named `META-INF/spring.factories` with the following contents:\n\n.META-INF/spring.factories\n[source]\n----\norg.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyCustomDsl\n----\n\nYou can also explicit disable the default:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n\n@Configuration\n@EnableWebSecurity\npublic class Config {\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .with(MyCustomDsl.customDsl(), (dsl) -> dsl\n .disable()\n )\n ...;\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass Config {\n\n @Bean\n fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http\n .with(MyCustomDsl.customDsl()) {\n disable()\n }\n // ...\n return http.build()\n }\n\n}\n----\n======\n\n[[modular-httpsecurity-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "Custom DSLs", "heading_level": 2, "file_order": 118, "section_index": 11, "content_hash": "ba66d172a320d744b4b635cba22dba360d91312f778539c6810a9cb0bf0eef49", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:81f11fb6ac098239fd30cf863a4be91c2dd0cdb3c26624d5f22cc2081fdba35e", "content": "Many users prefer that their Spring Security configuration lives in a centralized place and will choose to configure it in a single `SecurityFilterChain` instance.\nHowever, there are times that users may want to modularize the configuration.\nThis can be done using:\n\n* xref:#httpsecurity-customizer-bean[Customizer<HttpSecurity> Beans]\n* xref:#top-level-customizer-bean[Top Level HttpSecurity Customizer Beans]\n\nNOTE: If you are using Spring Security's xref:servlet/configuration/kotlin.adoc[], then you can also expose `*Dsl -> Unit` Beans as outlined in xref:./kotlin.adoc#modular-httpsecuritydsl-configuration[Modular HttpSecurityDsl Configuration].\n\n[[httpsecurity-customizer-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "Modular HttpSecurity Configuration", "heading_level": 2, "file_order": 118, "section_index": 12, "content_hash": "81f11fb6ac098239fd30cf863a4be91c2dd0cdb3c26624d5f22cc2081fdba35e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:698522c9c771fa354b1040f916f2bd29d615f36cbd2ae32ab72142b67ad99efe", "content": "If you would like to modularize your security configuration you can place logic in a `Customizer<HttpSecurity>` Bean.\nFor example, the following configuration will ensure all `HttpSecurity` instances are configured to:\n\ninclude-code::./HttpSecurityCustomizerBeanConfiguration[tag=httpSecurityCustomizer,indent=0]\n\n<1> Set the xref:servlet/exploits/headers.adoc#servlet-headers-csp[Content Security Policy] to `object-src 'none'`\n<2> xref:servlet/exploits/http.adoc#servlet-http-redirect[Redirect any request to https]\n\n[[top-level-customizer-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "Customizer<HttpSecurity> Beans", "heading_level": 3, "file_order": 118, "section_index": 13, "content_hash": "698522c9c771fa354b1040f916f2bd29d615f36cbd2ae32ab72142b67ad99efe", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:548d98505d860e2c4be17f6e0cc0928c1f8c1ad019ebdf4b4d471b5ca40c0871", "content": "If you prefer to have further modularization of your security configuration, Spring Security will automatically apply any top level `HttpSecurity` `Customizer` Beans.\n\nA top level `HttpSecurity` `Customizer` type can be summarized as any `Customizer<T>` that matches `public HttpSecurity.*(Customizer<T>)`.\nThis translates to any `Customizer<T>` that is a single argument to a public method on javadoc:org.springframework.security.config.annotation.web.builders.HttpSecurity[].\n\nA few examples can help to clarify.\nIf `Customizer<ContentTypeOptionsConfig>` is published as a Bean, it will not be automatically applied because it is an argument to javadoc:org.springframework.security.config.annotation.web.configurers.HeadersConfigurer#contentTypeOptions(org.springframework.security.config.Customizer)[] which is not a method defined on `HttpSecurity`.\nHowever, if `Customizer<HeadersConfigurer<HttpSecurity>>` is published as a Bean, it will be automatically applied because it is an argument to javadoc:org.springframework.security.config.annotation.web.builders.HttpSecurity#headers(org.springframework.security.config.Customizer)[].\n\nFor example, the following configuration will ensure that the xref:servlet/exploits/headers.adoc#servlet-headers-csp[Content Security Policy] is set to `object-src 'none'`:\n\ninclude-code::./TopLevelCustomizerBeanConfiguration[tag=headersCustomizer,indent=0]\n\n[[customizer-bean-ordering]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "Top Level HttpSecurity Customizer Beans", "heading_level": 3, "file_order": 118, "section_index": 14, "content_hash": "548d98505d860e2c4be17f6e0cc0928c1f8c1ad019ebdf4b4d471b5ca40c0871", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:3dcc18b5ba2db5fc3ab7634e3cf053691ce45ddd6f30d33d28c1314b6bede197", "content": "First each xref:#httpsecurity-customizer-bean[Customizer<HttpSecurity> Bean] is applied using https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/ObjectProvider.html#orderedStream()[ObjectProvider#orderedStream()].\nThis means that if there are multiple `Customizer<HttpSecurity>` Beans, the https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/annotation/Order.html[@Order] annotation can be added to the Bean definitions to control the ordering.\n\nNext every xref:#top-level-customizer-bean[Top Level HttpSecurity Customizer Beans] type is looked up and each is applied using `ObjectProvider#orderedStream()`.\nIf there is are two `Customizer<HeadersConfigurer<HttpSecurity>>` beans and two `Customizer<HttpsRedirectConfigurer<HttpSecurity>>` instances, the order that each `Customizer` type is invoked is undefined.\nHowever, the order that each instance of `Customizer<HttpsRedirectConfigurer<HttpSecurity>>` is defined by `ObjectProvider#orderedStream()` and can be controlled using `@Order` on the Bean the definitions.\n\nFinally, the `HttpSecurity` Bean is injected as a Bean.\nAll `Customizer` instances are applied before the `HttpSecurity` Bean is created.\nThis allows overriding the customizations provided by the `Customizer` Beans.\n\nYou can find an example below that illustrates the ordering:\n\ninclude-code::./CustomizerBeanOrderingConfiguration[tag=sample,indent=0]\n\n<1> First all `Customizer<HttpSecurity>` instances are applied.\nThe `adminAuthorization` Bean has the highest `@Order` so it is applied first.\nIf there are no `@Order` annotations on the `Customizer<HttpSecurity>` Beans or the `@Order` annotations had the same value, then the order that the `Customizer<HttpSecurity>` instances are applied is undefined.\n<2> The `userAuthorization` is applied next due to being an instance of `Customizer<HttpSecurity>`\n<3> The order that the `Customizer` types are undefined.\nIn this example, the order of `contentSecurityPolicy`, `contentTypeOptions`, and `httpsRedirect` are undefined.\nIf `@Order(Ordered.HIGHEST_PRECEDENCE)` was added to `contentTypeOptions`, then we would know that `contentTypeOptions` is before `contentSecurityPolicy` (they are the same type), but we do not know if `httpsRedirect` is before or after the `Customizer<HeadersConfigurer<HttpSecurity>>` Beans.\n<4> After all of the `Customizer` Beans are applied, the `HttpSecurity` is passed in as a Bean.\n\n[[post-processing-configured-objects]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "Customizer Bean Ordering", "heading_level": 3, "file_order": 118, "section_index": 15, "content_hash": "3dcc18b5ba2db5fc3ab7634e3cf053691ce45ddd6f30d33d28c1314b6bede197", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:905c68699f6120bf233fde650196c856cf8992306c44f07ede0d11656117ce0c", "content": "Spring Security's Java configuration does not expose every property of every object that it configures.\nThis simplifies the configuration for a majority of users.\nAfter all, if every property were exposed, users could use standard bean configuration.\n\nWhile there are good reasons to not directly expose every property, users may still need more advanced configuration options.\nTo address this issue, Spring Security introduces the concept of an `ObjectPostProcessor`, which can be used to modify or replace many of the `Object` instances created by the Java Configuration.\nFor example, to configure the `filterSecurityPublishAuthorizationSuccess` property on `FilterSecurityInterceptor`, you can use the following:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n\thttp\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n .withObjectPostProcessor(new ObjectPostProcessor<FilterSecurityInterceptor>() {\n public <O extends FilterSecurityInterceptor> O postProcess(\n O fsi) {\n fsi.setPublishAuthorizationSuccess(true);\n return fsi;\n }\n })\n );\n\treturn http.build();\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/java.adoc", "title": "java", "heading": "Post Processing Configured Objects", "heading_level": 2, "file_order": 118, "section_index": 16, "content_hash": "905c68699f6120bf233fde650196c856cf8992306c44f07ede0d11656117ce0c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/java.adoc"}}
{"id": "sha256:3887cc1b1fc4971abf771e0f540e4f8a964419d3b618d722a7ce7dab4341f707", "content": "[[kotlin-config]]\n\nSpring Security Kotlin configuration has been available since Spring Security 5.3.\nIt lets users configure Spring Security by using a native Kotlin DSL.\n\n[NOTE]\n====\nSpring Security provides https://github.com/spring-projects/spring-security-samples/tree/main/servlet/spring-boot/kotlin/hello-security[a sample application] to demonstrate the use of Spring Security Kotlin Configuration.\n====\n\n[[kotlin-config-httpsecurity]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc", "title": "kotlin", "heading": "kotlin", "heading_level": 1, "file_order": 119, "section_index": 0, "content_hash": "3887cc1b1fc4971abf771e0f540e4f8a964419d3b618d722a7ce7dab4341f707", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc"}}
{"id": "sha256:9354485383b42935da6810ec201b5e54930f977edf22476004990b0a71b2de8b", "content": "How does Spring Security know that we want to require all users to be authenticated?\nHow does Spring Security know we want to support form-based authentication?\nThere is a configuration class (called `SecurityFilterChain`) that is being invoked behind the scenes.\nIt is configured with the following default implementation:\n\n[source,kotlin]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n formLogin { }\n httpBasic { }\n }\n return http.build()\n}\n----\n\n[NOTE]\nMake sure to import the `org.springframework.security.config.annotation.web.invoke` function to enable the Kotlin DSL in your class, as the IDE will not always auto-import the method, causing compilation issues.\n\nThe default configuration (shown in the preceding example):\n\n* Ensures that any request to our application requires the user to be authenticated\n* Lets users authenticate with form-based login\n* Lets users authenticate with HTTP Basic authentication\n\nNote that this configuration parallels the XML namespace configuration:\n\n[source,xml]\n----\n<http>\n\t<intercept-url pattern=\"/**\" access=\"authenticated\"/>\n\t<form-login />\n\t<http-basic />\n</http>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc", "title": "kotlin", "heading": "HttpSecurity", "heading_level": 2, "file_order": 119, "section_index": 1, "content_hash": "9354485383b42935da6810ec201b5e54930f977edf22476004990b0a71b2de8b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc"}}
{"id": "sha256:8255b68623b23c5f34e139d919ed3e1480a067b42ba6f3beccac15eeebf212e0", "content": "To effectively manage security in an application where certain areas need different protection, we can employ multiple filter chains alongside the `securityMatcher` DSL method.\nThis approach allows us to define distinct security configurations tailored to specific parts of the application, enhancing overall application security and control.\n\nWe can configure multiple `HttpSecurity` instances just as we can have multiple `<http>` blocks in XML.\nThe key is to register multiple `SecurityFilterChain` ``@Bean``s.\nThe following example has a different configuration for URLs that begin with `/api/`:\n\n[[multiple-httpsecurity-instances-kotlin]]\n[source,kotlin]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass MultiHttpSecurityConfig {\n @Bean <1>\n open fun userDetailsService(): UserDetailsService {\n val users = User.withDefaultPasswordEncoder()\n val manager = InMemoryUserDetailsManager()\n manager.createUser(users.username(\"user\").password(\"password\").roles(\"USER\").build())\n manager.createUser(users.username(\"admin\").password(\"password\").roles(\"USER\",\"ADMIN\").build())\n return manager\n }\n\n @Bean\n @Order(1) <2>\n open fun apiFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n securityMatcher(\"/api/**\") <3>\n authorizeHttpRequests {\n authorize(anyRequest, hasRole(\"ADMIN\"))\n }\n httpBasic { }\n }\n return http.build()\n }\n\n @Bean <4>\n open fun formLoginFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n formLogin { }\n }\n return http.build()\n }\n}\n----\n<1> Configure Authentication as usual.\n<2> Create an instance of `SecurityFilterChain` that contains `@Order` to specify which `SecurityFilterChain` should be considered first.\n<3> The `http.securityMatcher()` states that this `HttpSecurity` is applicable only to URLs that begin with `/api/`.\n<4> Create another instance of `SecurityFilterChain`.\nIf the URL does not begin with `/api/`, this configuration is used.\nThis configuration is considered after `apiFilterChain`, since it has an `@Order` value after `1` (no `@Order` defaults to last).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc", "title": "kotlin", "heading": "Multiple HttpSecurity Instances", "heading_level": 3, "file_order": 119, "section_index": 2, "content_hash": "8255b68623b23c5f34e139d919ed3e1480a067b42ba6f3beccac15eeebf212e0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc"}}
{"id": "sha256:19c56e067484aa5b07b55d6748eb400003b2a21e8ea098a13769a0e6b3480edc", "content": "A common question is:\n\n> What is the difference between the `http.securityMatcher()` method and `requestMatchers()` used for request authorization (i.e. inside of `http.authorizeHttpRequests()`)?\n\nTo answer this question, it helps to understand that each `HttpSecurity` instance used to build a `SecurityFilterChain` contains a `RequestMatcher` to match incoming requests.\nIf a request does not match a `SecurityFilterChain` with higher priority (e.g. `@Order(1)`), the request can be tried against a filter chain with lower priority (e.g. no `@Order`).\n\n[NOTE]\n====\nThe matching logic for multiple filter chains is performed by the xref:servlet/architecture.adoc#servlet-filterchainproxy[`FilterChainProxy`].\n====\n\nThe default `RequestMatcher` matches *any request* to ensure Spring Security protects *all requests by default*.\n\n[NOTE]\n====\nSpecifying a `securityMatcher` overrides this default.\n====\n\n[WARNING]\n====\nIf no filter chain matches a particular request, the request is *not protected* by Spring Security.\n====\n\nThe following example demonstrates a single filter chain that only protects requests that begin with `/secured/`:\n\n[[choosing-security-matcher-request-matchers-kotlin]]\n[source,kotlin]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass PartialSecurityConfig {\n\t@Bean\n\topen fun userDetailsService(): UserDetailsService {\n // ...\n\t}\n\n\t@Bean\n\topen fun securedFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n securityMatcher(\"/secured/**\") <1>\n authorizeHttpRequests {\n authorize(\"/secured/user\", hasRole(\"USER\")) <2>\n authorize(\"/secured/admin\", hasRole(\"ADMIN\")) <3>\n authorize(anyRequest, authenticated) <4>\n }\n httpBasic { }\n formLogin { }\n }\n return http.build()\n\t}\n}\n----\n<1> Requests that begin with `/secured/` will be protected but any other requests are not protected.\n<2> Requests to `/secured/user` require the `ROLE_USER` authority.\n<3> Requests to `/secured/admin` require the `ROLE_ADMIN` authority.\n<4> Any other requests (such as `/secured/other`) simply require an authenticated user.\n\n[TIP]\n====\nIt is _recommended_ to provide a `SecurityFilterChain` that does not specify any `securityMatcher` to ensure the entire application is protected, as demonstrated in the <<multiple-httpsecurity-instances-kotlin,earlier example>>.\n====\n\nNotice that the `requestMatchers` method only applies to individual authorization rules.\nEach request listed there must also match the overall `securityMatcher` for this particular `HttpSecurity` instance used to create the `SecurityFilterChain`.\nUsing `anyRequest()` in this example matches all other requests within this particular `SecurityFilterChain` (which must begin with `/secured/`).\n\n[NOTE]\n====\nSee xref:servlet/authorization/authorize-http-requests.adoc[Authorize HttpServletRequests] for more information on `requestMatchers`.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc", "title": "kotlin", "heading": "Choosing `securityMatcher` or `requestMatchers`", "heading_level": 3, "file_order": 119, "section_index": 3, "content_hash": "19c56e067484aa5b07b55d6748eb400003b2a21e8ea098a13769a0e6b3480edc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc"}}
{"id": "sha256:a0abe80362fa057083d3c1ad28300ede152680c36b023dd7a57a15c6bc1e2c4f", "content": "Several filters in the `SecurityFilterChain` directly provide endpoints, such as the `UsernamePasswordAuthenticationFilter` which is set up by `http.formLogin()` and provides the `POST /login` endpoint.\nIn the <<choosing-security-matcher-request-matchers-kotlin,above example>>, the `/login` endpoint is not matched by `http.securityMatcher(\"/secured/**\")` and therefore that application would not have any `GET /login` or `POST /login` endpoint.\nSuch requests would return `404 Not Found`.\nThis is often surprising to users.\n\nSpecifying `http.securityMatcher()` affects what requests are matched by that `SecurityFilterChain`.\nHowever, it does not automatically affect endpoints provided by the filter chain.\nIn such cases, you may need to customize the URL of any endpoints you would like the filter chain to provide.\n\nThe following example demonstrates a configuration that secures requests that begin with `/secured/` and denies all other requests, while also customizing endpoints provided by the `SecurityFilterChain`:\n\n[[security-filter-chain-endpoints-kotlin]]\n[source,kotlin]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecuredSecurityConfig {\n\t@Bean\n\topen fun userDetailsService(): UserDetailsService {\n // ...\n\t}\n\n\t@Bean\n\t@Order(1)\n\topen fun securedFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n securityMatcher(\"/secured/**\") <1>\n authorizeHttpRequests {\n authorize(anyRequest, authenticated) <2>\n }\n formLogin { <3>\n loginPage = \"/secured/login\"\n loginProcessingUrl = \"/secured/login\"\n permitAll = true\n }\n logout { <4>\n logoutUrl = \"/secured/logout\"\n logoutSuccessUrl = \"/secured/login?logout\"\n permitAll = true\n }\n }\n return http.build()\n\t}\n\n\t@Bean\n open fun defaultFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, denyAll) <5>\n }\n }\n return http.build()\n }\n}\n----\n<1> Requests that begin with `/secured/` will be protected by this filter chain.\n<2> Requests that begin with `/secured/` require an authenticated user.\n<3> Customize form login to prefix URLs with `/secured/`.\n<4> Customize logout to prefix URLs with `/secured/`.\n<5> All other requests will be denied.\n\n[NOTE]\n====\nThis example customizes the login and logout pages, which disables Spring Security's generated pages.\nYou must xref:servlet/authentication/passwords/form.adoc#servlet-authentication-form-custom[provide your own] custom endpoints for `GET /secured/login` and `GET /secured/logout`.\nNote that Spring Security still provides `POST /secured/login` and `POST /secured/logout` endpoints for you.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc", "title": "kotlin", "heading": "`SecurityFilterChain` Endpoints", "heading_level": 3, "file_order": 119, "section_index": 4, "content_hash": "a0abe80362fa057083d3c1ad28300ede152680c36b023dd7a57a15c6bc1e2c4f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc"}}
{"id": "sha256:ec7b84020012907eca05102e6f41138980ca55f4ecb9d3563a13850e0a7cdfee", "content": "The following example demonstrates a slightly more real-world configuration putting all of these elements together:\n\n[[real-world-example-kotlin]]\n[source,kotlin]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass BankingSecurityConfig {\n @Bean <1>\n open fun userDetailsService(): UserDetailsService {\n val users = User.withDefaultPasswordEncoder()\n val manager = InMemoryUserDetailsManager()\n manager.createUser(users.username(\"user1\").password(\"password\").roles(\"USER\", \"VIEW_BALANCE\").build())\n manager.createUser(users.username(\"user2\").password(\"password\").roles(\"USER\").build())\n manager.createUser(users.username(\"admin\").password(\"password\").roles(\"ADMIN\").build())\n return manager\n }\n\n @Bean\n @Order(1) <2>\n open fun approvalsSecurityFilterChain(http: HttpSecurity): SecurityFilterChain {\n val approvalsPaths = arrayOf(\"/accounts/approvals/**\", \"/loans/approvals/**\", \"/credit-cards/approvals/**\")\n http {\n securityMatcher(*approvalsPaths)\n authorizeHttpRequests {\n authorize(anyRequest, hasRole(\"ADMIN\"))\n }\n httpBasic { }\n }\n return http.build()\n }\n\n @Bean\n @Order(2) <3>\n\topen fun bankingSecurityFilterChain(http: HttpSecurity): SecurityFilterChain {\n val bankingPaths = arrayOf(\"/accounts/**\", \"/loans/**\", \"/credit-cards/**\", \"/balances/**\")\n val viewBalancePaths = arrayOf(\"/balances/**\")\n http {\n securityMatcher(*bankingPaths)\n authorizeHttpRequests {\n authorize(viewBalancePaths, hasRole(\"VIEW_BALANCE\"))\n authorize(anyRequest, hasRole(\"USER\"))\n }\n }\n return http.build()\n }\n\n @Bean <4>\n\topen fun defaultSecurityFilterChain(http: HttpSecurity): SecurityFilterChain {\n val allowedPaths = arrayOf(\"/\", \"/user-login\", \"/user-logout\", \"/notices\", \"/contact\", \"/register\")\n http {\n authorizeHttpRequests {\n authorize(allowedPaths, permitAll)\n authorize(anyRequest, authenticated)\n }\n formLogin {\n loginPage = \"/user-login\"\n loginProcessingUrl = \"/user-login\"\n }\n logout {\n logoutUrl = \"/user-logout\"\n logoutSuccessUrl = \"/?logout\"\n }\n }\n return http.build()\n }\n}\n----\n<1> Begin by configuring authentication settings.\n<2> Define a `SecurityFilterChain` instance with `@Order(1)`, which means that this filter chain will have the highest priority.\n This filter chain applies only to requests that begin with `/accounts/approvals/`, `/loans/approvals/` or `/credit-cards/approvals/`.\n\tRequests to this filter chain require the `ROLE_ADMIN` authority and allow HTTP Basic Authentication.\n<3> Next, create another `SecurityFilterChain` instance with `@Order(2)` which will be considered second.\n This filter chain applies only to requests that begin with `/accounts/`, `/loans/`, `/credit-cards/`, or `/balances/`.\n\tNotice that because this filter chain is second, any requests that include `/approvals/` will match the previous filter chain and will *not* be matched by this filter chain.\n\tRequests to this filter chain require the `ROLE_USER` authority.\n\tThis filter chain does not define any authentication because the next (default) filter chain contains that configuration.\n<4> Lastly, create an additional `SecurityFilterChain` instance without an `@Order` annotation.\n\tThis configuration will handle requests not covered by the other filter chains and will be processed last (no `@Order` defaults to last).\n\tRequests that match `/`, `/user-login`, `/user-logout`, `/notices`, `/contact` and `/register` allow access without authentication.\n\tAny other requests require the user to be authenticated to access any URL not explicitly allowed or protected by other filter chains.\n\n[[modular-httpsecuritydsl-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc", "title": "kotlin", "heading": "Real World Example", "heading_level": 3, "file_order": 119, "section_index": 5, "content_hash": "ec7b84020012907eca05102e6f41138980ca55f4ecb9d3563a13850e0a7cdfee", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc"}}
{"id": "sha256:d52d95c810ce750234904f899af920df5ca20ea94b84dfb9907acdfb9e4d482b", "content": "Many users prefer that their Spring Security configuration lives in a centralized place and will choose to configure it in a single `SecurityFilterChain` instance.\nHowever, there are times that users may want to modularize the configuration.\nThis can be done using:\n\n* xref:#httpsecuritydsl-bean[HttpSecurityDsl.() -> Unit Beans]\n* xref:#top-level-dsl-bean[Top Level Security Dsl Beans]\n\nNOTE: Since the Spring Security Kotlin Dsl (`HttpSecurityDsl`) uses `HttpSecurity`, all of the Java xref:./kotlin.adoc#modular-bean-configuration[Modular Bean Customization] is applied before xref:#modular-httpsecuritydsl-configuration[Modular HttpSecurity Configuration].\n\n[[httpsecuritydsl-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc", "title": "kotlin", "heading": "Modular HttpSecurityDsl Configuration", "heading_level": 2, "file_order": 119, "section_index": 6, "content_hash": "d52d95c810ce750234904f899af920df5ca20ea94b84dfb9907acdfb9e4d482b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc"}}
{"id": "sha256:33e65aa1deed89a82c517ea8f3717bb54193ebf33b4f9462af0eb20e6b3b7769", "content": "If you would like to modularize your security configuration you can place logic in a `HttpSecurityDsl.() -> Unit` Bean.\nFor example, the following configuration will ensure all `HttpSecurityDsl` instances are configured to:\n\ninclude-code::./HttpSecurityDslBeanConfiguration[tag=httpSecurityDslBean,indent=0]\n\n<1> Set the xref:servlet/exploits/headers.adoc#servlet-headers-csp[Content Security Policy] to `object-src 'none'`\n<2> xref:servlet/exploits/http.adoc#servlet-http-redirect[Redirect any request to https]\n\n[[top-level-dsl-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc", "title": "kotlin", "heading": "HttpSecurityDsl.() -> Unit Beans", "heading_level": 3, "file_order": 119, "section_index": 7, "content_hash": "33e65aa1deed89a82c517ea8f3717bb54193ebf33b4f9462af0eb20e6b3b7769", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc"}}
{"id": "sha256:1188cbce09944fb980230f72d39dd5485efd82876809b0bbd6bef1b45b800682", "content": "If you prefer to have further modularization of your security configuration, Spring Security will automatically apply any top level Security Dsl Beans.\n\nA top level Security Dsl can be summarized as any class Dsl class that matches `public HttpSecurityDsl.*(<Dsl>)`.\nThis translates to any Security Dsl that is a single argument to a public method on `HttpSecurityDsl`.\n\nA few examples can help to clarify.\nIf `ContentTypeOptionsDsl.() -> Unit` is published as a Bean, it will not be be automatically applied because it is an argument to `HeadersDsl#contentTypeOptions(ContentTypeOptionsDsl.() -> Unit)` and is not an argument to a method defined on `HttpSecurityDsl`.\nHowever, if `HeadersDsl.() -> Unit` is published as a Bean, it will be automatically applied because it is an argument to `HttpSecurityDsl.headers(HeadersDsl.() -> Unit)`.\n\nFor example, the following configuration ensure all `HttpSecurityDsl` instances are configured to:\n\ninclude-code::./TopLevelDslBeanConfiguration[tag=headersSecurity,indent=0]\n\n<1> Set the xref:servlet/exploits/headers.adoc#servlet-headers-csp[Content Security Policy] to `object-src 'none'`\n\n[[dsl-bean-ordering]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc", "title": "kotlin", "heading": "Top Level Security Dsl Beans", "heading_level": 3, "file_order": 119, "section_index": 8, "content_hash": "1188cbce09944fb980230f72d39dd5485efd82876809b0bbd6bef1b45b800682", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc"}}
{"id": "sha256:f9774a6d741effb420483398f9292b018423844b9ddac152f80877fb0b215a17", "content": "First, all xref:servlet/configuration/java.adoc#modular-httpsecurity-configuration[Modular HttpSecurity Configuration] is applied since the Kotlin Dsl uses an `HttpSecurity` Bean.\n\nSecond, each xref:#httpsecuritydsl-bean[HttpSecurityDsl.() -> Unit Beans] is applied using https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/ObjectProvider.html#orderedStream()[ObjectProvider#orderedStream()].\nThis means that if there are multiple `HttpSecurity.() -> Unit` Beans, the https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/annotation/Order.html[@Order] annotation can be added to the Bean definitions to control the ordering.\n\nNext, every xref:#top-level-dsl-bean[Top Level Security Dsl Beans] type is looked up and each is is applied using `ObjectProvider#orderedStream()`.\nIf there is are different types of top level security Beans (e.g. `HeadersDsl.() -> Unit` and `HttpsRedirectDsl.() -> Unit`), then the order that each Dsl type is invoked is undefined.\nHowever, the order that each instance of of the same top level security Bean type is defined by `ObjectProvider#orderedStream()` and can be controlled using `@Order` on the Bean the definitions.\n\nFinally, the `HttpSecurityDsl` Bean is injected as a Bean.\nAll `*Dsl.() -> Unit` Beans are applied before the `HttpSecurityDsl` Bean is created.\nThis allows overriding the customizations provided by the `*Dsl.() -> Unit` Beans.\n\nYou can find an example below that illustrates the ordering:\n\ninclude-code::./DslBeanOrderingConfiguration[tag=sample,indent=0]\n\n<1> All xref:servlet/configuration/java.adoc#modular-httpsecurity-configuration[Modular HttpSecurity Configuration] is applied since the Kotlin Dsl uses an `HttpSecurity` Bean.\n<2> All `HttpSecurity.() -> Unit` instances are applied.\nThe `adminAuthorization` Bean has the highest `@Order` so it is applied first.\nIf there are no `@Order` annotations on the `HttpSecurity.() -> Unit` Beans or the `@Order` annotations had the same value, then the order that the `HttpSecurity.() -> Unit` instances are applied is undefined.\n<3> The `userAuthorization` is applied next due to being an instance of `HttpSecurity.() -> Unit`\n<4> The order that the `*Dsl.() -> Unit` types are undefined.\nIn this example, the order of `contentSecurityPolicy`, `contentTypeOptions`, and `httpsRedirect` are undefined.\nIf `@Order(Ordered.HIGHEST_PRECEDENCE)` was added to `contentTypeOptions`, then we would know that `contentTypeOptions` is before `contentSecurityPolicy` (they are the same type), but we do not know if `httpsRedirect` is before or after the `HeadersDsl.() -> Unit` Beans.\n<5> After all of the `*Dsl.() -> Unit` Beans are applied, the `HttpSecurityDsl` is passed in as a Bean.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc", "title": "kotlin", "heading": "Dsl Bean Ordering", "heading_level": 3, "file_order": 119, "section_index": 9, "content_hash": "f9774a6d741effb420483398f9292b018423844b9ddac152f80877fb0b215a17", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/kotlin.adoc"}}
{"id": "sha256:89c772eea654d7f4500705008a6fc918a63b26d54d640dfa01688085ac1a5850", "content": "[[ns-config]]\n\nNamespace configuration has been available since version 2.0 of the Spring Framework.\nIt lets you supplement the traditional Spring beans application context syntax with elements from additional XML schema.\nYou can find more information in the Spring https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/[Reference Documentation].\nYou can use a namespace element to more concisely configure an individual bean or, more powerfully, to define an alternative configuration syntax that more closely matches the problem domain and hides the underlying complexity from the user.\nA simple element can conceal the fact that multiple beans and processing steps are being added to the application context.\nFor example, adding the following element from the `security` namespace to an application context starts up an embedded LDAP server for testing use within the application:\n\n[source,xml]\n----\n<security:ldap-server />\n----\n\nThis is much simpler than wiring up the equivalent UnboundID Server beans.\nThe most common alternative configuration requirements are supported by attributes on the `ldap-server` element, and the user is isolated from worrying about which beans they need to create and what the bean property names are.\nYou can find out more about the use of the `ldap-server` element in the chapter on xref:servlet/authentication/passwords/ldap.adoc#servlet-authentication-ldap[LDAP Authentication].\nA good XML editor while editing the application context file should provide information on the attributes and elements that are available.\nWe recommend that you try the https://spring.io/tools/sts[Spring Tool Suite], as it has special features for working with standard Spring namespaces.\n\nTo start using the `security` namespace in your application context, add the `spring-security-config` jar to your classpath.\nThen, all you need to do is add the schema declaration to your application context file:\n\n[source,xml]\n----\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\nxmlns:security=\"http://www.springframework.org/schema/security\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n http://www.springframework.org/schema/security\n https://www.springframework.org/schema/security/spring-security.xsd\">\n\t...\n</beans>\n----\n\nIn many of the examples you can see (and in the sample applications), we often use `security` (rather than `beans`) as the default namespace, which means we can omit the prefix on all the security namespace elements, making the content easier to read.\nYou may also want to do this if you have your application context divided up into separate files and have most of your security configuration in one of them.\nYour security application context file would then start like this:\n\n[source,xml]\n----\n<beans:beans xmlns=\"http://www.springframework.org/schema/security\"\nxmlns:beans=\"http://www.springframework.org/schema/beans\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n http://www.springframework.org/schema/security\n https://www.springframework.org/schema/security/spring-security.xsd\">\n\t...\n</beans:beans>\n----\n\nWe assume this syntax is being used from now on in this chapter.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc", "title": "xml-namespace", "heading": "xml-namespace", "heading_level": 1, "file_order": 120, "section_index": 0, "content_hash": "89c772eea654d7f4500705008a6fc918a63b26d54d640dfa01688085ac1a5850", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc"}}
{"id": "sha256:6e7eb4521aebed79299bfaad18cbb198aae6700a91b2ecbc8823c51307e24e99", "content": "The namespace is designed to capture the most common uses of the framework and provide a simplified and concise syntax for enabling them within an application.\nThe design is based around the large-scale dependencies within the framework and can be divided up into the following areas:\n\n* _Web/HTTP Security_ is the most complex part.\nIt sets up the filters and related service beans used to apply the framework authentication mechanisms, to secure URLs, render login and error pages, and much more.\n\n* _Business Object (Method) Security_ defines options for securing the service layer.\n\n* _AuthenticationManager_ handles authentication requests from other parts of the framework.\n\n* _AccessDecisionManager_ provides access decisions for web and method security.\nA default one is registered, but you can choose to use a custom one, declared with normal Spring bean syntax.\n\n* _AuthenticationProvider_ instances provide mechanisms against which the authentication manager authenticates users.\nThe namespace provides supports for several standard options and a means of adding custom beans declared with a traditional syntax.\n\n* _UserDetailsService_ is closely related to authentication providers but is often also required by other beans.\n\nWe see how to configure these in the following sections.\n\n[[ns-getting-started]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc", "title": "xml-namespace", "heading": "Design of the Namespace", "heading_level": 2, "file_order": 120, "section_index": 1, "content_hash": "6e7eb4521aebed79299bfaad18cbb198aae6700a91b2ecbc8823c51307e24e99", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc"}}
{"id": "sha256:c7f396013b9f62963b3b0196da5cf11936b3f95bd4f73bbcd21632fbf14f3757", "content": "This section looks at how you can build up a namespace configuration to use some of the main features of the framework.\nWe assume that you initially want to get up and running as quickly as possible and add authentication support and access control to an existing web application, with a few test logins.\nThen we look at how to change over to authenticating against a database or other security repository.\nIn later sections, we introduce more advanced namespace configuration options.\n\n[[ns-web-xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc", "title": "xml-namespace", "heading": "Getting Started with Security Namespace Configuration", "heading_level": 2, "file_order": 120, "section_index": 2, "content_hash": "c7f396013b9f62963b3b0196da5cf11936b3f95bd4f73bbcd21632fbf14f3757", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc"}}
{"id": "sha256:c610a3a5417c3e768c96a3b4618bc41f5d16b882b455c6da01f1e52a687b879a", "content": "The first thing you need to do is add the following filter declaration to your `web.xml` file:\n\n[source,xml]\n----\n<filter>\n<filter-name>springSecurityFilterChain</filter-name>\n<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n</filter>\n\n<filter-mapping>\n<filter-name>springSecurityFilterChain</filter-name>\n<url-pattern>/*</url-pattern>\n</filter-mapping>\n----\n\n`DelegatingFilterProxy` is a Spring Framework class that delegates to a filter implementation that is defined as a Spring bean in your application context.\nIn this case, the bean is named `springSecurityFilterChain`, which is an internal infrastructure bean created by the namespace to handle web security.\nIn this case, the bean is named \"springSecurityFilterChain\", which is an internal infrastructure bean created by the namespace to handle web security.\nNote that you should not use this bean name yourself.\nOnce you have added this bean to your `web.xml`, you are ready to start editing your application context file.\nWeb security services are configured by the `<http>` element.\n\n[[ns-minimal]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc", "title": "xml-namespace", "heading": "web.xml Configuration", "heading_level": 3, "file_order": 120, "section_index": 3, "content_hash": "c610a3a5417c3e768c96a3b4618bc41f5d16b882b455c6da01f1e52a687b879a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc"}}
{"id": "sha256:f1e41c37054f48cb0196a7db9b70170b2a2292ac50e14108d060fa72b6887b19", "content": "To enable web security, you need the following configuration:\n\n[source,xml]\n----\n<http>\n<intercept-url pattern=\"/**\" access=\"hasRole('USER')\" />\n<form-login />\n<logout />\n</http>\n----\n\nThat listing says that we want:\n\n* All URLs within our application to be secured, requiring the role `ROLE_USER` to access them\n* To log in to the application using a form with username and password\n* A logout URL registered which will allow us to log out of the application\n\nThe `<http>` element is the parent for all web-related namespace functionality.\nThe `<intercept-url>` element defines a `pattern`, which is matched against the URLs of incoming requests using Ant path syntax. See the section on xref:servlet/exploits/firewall.adoc#servlet-httpfirewall[`HttpFirewall`] for more details on how matches are actually performed.\nYou can also use regular-expression matching as an alternative (see the namespace appendix for more details).\nThe `access` attribute defines the access requirements for requests that match the given pattern.\nWith the default configuration, this is typically a comma-separated list of roles, one of which a user must have to be allowed to make the request.\nThe `ROLE_` prefix is a marker that indicates that a simple comparison with the user's authorities should be made.\nIn other words, a normal role-based check should be used.\nAccess-control in Spring Security is not limited to the use of simple roles (hence the use of the prefix to differentiate between different types of security attributes).\nWe see later how the interpretation can vary. The interpretation of the comma-separated values in the `access` attribute depends on the which implementation of the <<ns-access-manager,`AccessDecisionManager`>> is used.\nSince Spring Security 3.0, you can also populate the attribute with an xref:servlet/authorization/authorize-http-requests.adoc#authorization-expressions[EL expression].\n\n[NOTE]\n====\nYou can use multiple `<intercept-url>` elements to define different access requirements for different sets of URLs, but they are evaluated in the order listed and the first match is used.\nSo you must put the most specific matches at the top.\nYou can also add a `method` attribute to limit the match to a particular HTTP method (`GET`, `POST`, `PUT`, and so on).\n====\n\nTo add users, you can define a set of test data directly in the namespace:\n\n[source,xml,attrs=\"-attributes\"]\n----\n<authentication-manager>\n<authentication-provider>\n\t<user-service>\n\t<!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that\n\tNoOpPasswordEncoder should be used. This is not safe for production, but makes reading\n\tin samples easier. Normally passwords should be hashed using BCrypt -->\n\t<user name=\"jimi\" password=\"{noop}jimispassword\" authorities=\"ROLE_USER, ROLE_ADMIN\" />\n\t<user name=\"bob\" password=\"{noop}bobspassword\" authorities=\"ROLE_USER\" />\n\t</user-service>\n</authentication-provider>\n</authentication-manager>\n----\n\nThe preceding listing shows an example of a secure way to store the same passwords.\nThe password is prefixed with `+{bcrypt}+` to instruct `DelegatingPasswordEncoder`, which supports any configured `PasswordEncoder` for matching, that the passwords are hashed using BCrypt:\n\n[source,xml,attrs=\"-attributes\"]\n----\n<authentication-manager>\n<authentication-provider>\n\t<user-service>\n\t<user name=\"jimi\" password=\"{bcrypt}$2a$10$ddEWZUl8aU0GdZPPpy7wbu82dvEw/pBpbRvDQRqA41y6mK1CoH00m\"\n authorities=\"ROLE_USER, ROLE_ADMIN\" />\n\t<user name=\"bob\" password=\"{bcrypt}$2a$10$/elFpMBnAYYig6KRR5bvOOYeZr1ie1hSogJryg9qDlhza4oCw1Qka\"\n authorities=\"ROLE_USER\" />\n\t<user name=\"jimi\" password=\"{noop}jimispassword\" authorities=\"ROLE_USER, ROLE_ADMIN\" />\n\t<user name=\"bob\" password=\"{noop}bobspassword\" authorities=\"ROLE_USER\" />\n\t</user-service>\n</authentication-provider>\n</authentication-manager>\n----\n\n[subs=\"quotes\"]\n****\nThe `<http>` element is responsible for creating a `FilterChainProxy` and the filter beans that it uses.\nPreviously common problems, such as incorrect filter ordering, are no longer an issue, as the filter positions are predefined.\n\nThe `<authentication-provider>` element creates a `DaoAuthenticationProvider` bean, and the `<user-service>` element creates an `InMemoryDaoImpl`.\nAll `authentication-provider` elements must be children of the `<authentication-manager>` element, which creates a `ProviderManager` and registers the authentication providers with it.\nYou can find more detailed information on the beans that are created in the xref:servlet/appendix/namespace/index.adoc#appendix-namespace[namespace appendix].\nYou should cross-check this appendix if you want to start understanding what the important classes in the framework are and how they are used, particularly if you want to customize things later.\n****\n\nThe preceding configuration defines two users, their passwords, and their roles within the application (which are used for access control).\nYou can also possible load user information from a standard properties file by setting the `properties` attribute on the `user-service` element.\nSee the section on xref:servlet/authentication/passwords/in-memory.adoc#servlet-authentication-inmemory[in-memory authentication] for more details on the file format.\nUsing the `<authentication-provider>` element means that the user information is used by the authentication manager to process authentication requests.\nYou can have multiple `<authentication-provider>` elements to define different authentication sources. Each is consulted in turn.\n\nAt this point, you should be able to start up your application, and you should be required to log in to proceed.\nTry it out, or try experimenting with the \"`tutorial`\" sample application that comes with the project.\n\n[[ns-form-target]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc", "title": "xml-namespace", "heading": "A Minimal <http> Configuration", "heading_level": 3, "file_order": 120, "section_index": 4, "content_hash": "f1e41c37054f48cb0196a7db9b70170b2a2292ac50e14108d060fa72b6887b19", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc"}}
{"id": "sha256:a5ac4eeb537607c9b41b34acac5875c53d67159f68273a59f8e7c73cfd45de43", "content": "If a form login is not prompted by an attempt to access a protected resource, the `default-target-url` option comes into play.\nThis is the URL to which the user is taken after successfully logging in. it defaults to `/`.\nYou can also configure things so that the user _always_ ends up at this page (regardless of whether the login was \"`on-demand`\" or they explicitly chose to log in) by setting the `always-use-default-target` attribute to `true`.\nThis is useful if your application always requires that the user starts at a \"`home`\" page, for example:\n\n[source,xml]\n----\n<http pattern=\"/login.htm*\" security=\"none\"/>\n<http use-expressions=\"false\">\n<intercept-url pattern='/**' access='ROLE_USER' />\n<form-login login-page='/login.htm' default-target-url='/home.htm'\n always-use-default-target='true' />\n</http>\n----\n\nFor even more control over the destination, you can use the `authentication-success-handler-ref` attribute as an alternative to `default-target-url`.\nThe referenced bean should be an instance of `AuthenticationSuccessHandler`.\n\n[[ns-web-advanced]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc", "title": "xml-namespace", "heading": "Setting a Default Post-Login Destination", "heading_level": 4, "file_order": 120, "section_index": 5, "content_hash": "a5ac4eeb537607c9b41b34acac5875c53d67159f68273a59f8e7c73cfd45de43", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc"}}
{"id": "sha256:2ba804f0b9958bf0e2ac2bb0fcb718cbf9d7e6d0287f031780b07a2eb993f9f0", "content": "This section covers various features that go beyond the basics.\n\n[[ns-custom-filters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc", "title": "xml-namespace", "heading": "Advanced Web Features", "heading_level": 2, "file_order": 120, "section_index": 6, "content_hash": "2ba804f0b9958bf0e2ac2bb0fcb718cbf9d7e6d0287f031780b07a2eb993f9f0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc"}}
{"id": "sha256:205e52640aadfc08f23ad319dc051f54fbf0f11165768adb907dc825edcf0044", "content": "If you have used Spring Security before, you know that the framework maintains a chain of filters that it uses to apply its services.\nYou may want to add your own filters to the stack at particular locations or use a Spring Security filter for which there is not currently a namespace configuration option (CAS, for example).\nAlternatively, you might want to use a customized version of a standard namespace filter, such as the `UsernamePasswordAuthenticationFilter` (which is created by the `<form-login>` element) to take advantage of some of the extra configuration options that are available when you use the bean explicitly.\nHow can you do this with namespace configuration, since the filter chain is not directly exposed?\n\nThe order of the filters is always strictly enforced when you use the namespace.\nWhen the application context is being created, the filter beans are sorted by the namespace handling code, and the standard Spring Security filters each have an alias in the namespace and a well-known position.\n\n[NOTE]\n====\nIn previous versions, the sorting took place after the filter instances had been created, during post-processing of the application context.\nIn version 3.0+ the sorting is now done at the bean metadata level, before the classes have been instantiated.\nThis has implications for how you add your own filters to the stack as the entire filter list must be known during the parsing of the `<http>` element, so the syntax has changed slightly in 3.0.\n====\n\nThe filters, aliases, and namespace elements and attributes that create the filters are shown in the following table, in the order in which they occur in the filter chain:\n\n[[filter-stack]]\n.Standard Filter Aliases and Ordering\n|===\n| Alias | Filter Class | Namespace Element or Attribute\n\n| DISABLE_ENCODE_URL_FILTER\n| `DisableEncodeUrlFilter`\n| `http@disable-url-rewriting`\n\n| FORCE_EAGER_SESSION_FILTER\n| `ForceEagerSessionCreationFilter`\n| `http@create-session=\"ALWAYS\"`\n\n| CHANNEL_FILTER\n| `ChannelProcessingFilter`\n| `http/intercept-url@requires-channel`\n\n| SECURITY_CONTEXT_FILTER\n| `SecurityContextPersistenceFilter`\n| `http`\n\n| CONCURRENT_SESSION_FILTER\n| `ConcurrentSessionFilter`\n| `session-management/concurrency-control`\n\n| HEADERS_FILTER\n| `HeaderWriterFilter`\n| `http/headers`\n\n| CSRF_FILTER\n| `CsrfFilter`\n| `http/csrf`\n\n| LOGOUT_FILTER\n| `LogoutFilter`\n| `http/logout`\n\n| X509_FILTER\n| `X509AuthenticationFilter`\n| `http/x509`\n\n| PRE_AUTH_FILTER\n| `AbstractPreAuthenticatedProcessingFilter` Subclasses\n| N/A\n\n| CAS_FILTER\n| `CasAuthenticationFilter`\n| N/A\n\n| FORM_LOGIN_FILTER\n| `UsernamePasswordAuthenticationFilter`\n| `http/form-login`\n\n| BASIC_AUTH_FILTER\n| `BasicAuthenticationFilter`\n| `http/http-basic`\n\n| SERVLET_API_SUPPORT_FILTER\n| `SecurityContextHolderAwareRequestFilter`\n| `http/@servlet-api-provision`\n\n| JAAS_API_SUPPORT_FILTER\n| `JaasApiIntegrationFilter`\n| `http/@jaas-api-provision`\n\n| REMEMBER_ME_FILTER\n| `RememberMeAuthenticationFilter`\n| `http/remember-me`\n\n| ANONYMOUS_FILTER\n| `AnonymousAuthenticationFilter`\n| `http/anonymous`\n\n| SESSION_MANAGEMENT_FILTER\n| `SessionManagementFilter`\n| `session-management`\n\n| EXCEPTION_TRANSLATION_FILTER\n| `ExceptionTranslationFilter`\n| `http`\n\n| FILTER_SECURITY_INTERCEPTOR\n| `FilterSecurityInterceptor`\n| `http`\n\n| SWITCH_USER_FILTER\n| `SwitchUserFilter`\n| N/A\n|===\n\nYou can add your own filter to the stack by using the `custom-filter` element and one of these names to specify the position at which your filter should appear:\n\n[source,xml]\n----\n<http>\n<custom-filter position=\"FORM_LOGIN_FILTER\" ref=\"myFilter\" />\n</http>\n\n<beans:bean id=\"myFilter\" class=\"com.mycompany.MySpecialAuthenticationFilter\"/>\n----\n\nYou can also use the `after` or `before` attributes if you want your filter to be inserted before or after another filter in the stack.\nYou can use `FIRST` and `LAST` with the `position` attribute to indicate that you want your filter to appear before or after the entire stack, respectively.\n\n.Avoiding filter position conflicts\n[TIP]\n====\nIf you insert a custom filter that may occupy the same position as one of the standard filters created by the namespace, you should not include the namespace versions by mistake.\nRemove any elements that create filters whose functionality you want to replace.\n\nNote that you cannot replace filters that are created by the use of the `<http>` element itself: `SecurityContextPersistenceFilter`, `ExceptionTranslationFilter`, or `FilterSecurityInterceptor`.\nBy default, an `AnonymousAuthenticationFilter` is added and unless you have xref:servlet/authentication/session-management.adoc#ns-session-fixation[session-fixation protection] disabled, a `SessionManagementFilter` is also added to the filter chain.\n====\n\nIf you replace a namespace filter that requires an authentication entry point (that is, where the authentication process is triggered by an unauthenticated user's attempt to access to a secured resource), you need to add a custom entry-point bean too.\n\n[[ns-method-security]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc", "title": "xml-namespace", "heading": "Adding in Your Own Filters", "heading_level": 3, "file_order": 120, "section_index": 7, "content_hash": "205e52640aadfc08f23ad319dc051f54fbf0f11165768adb907dc825edcf0044", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc"}}
{"id": "sha256:52ba697c81da2982feaf99f178260ce4002cff47a7867ec984da785bce6d9bce", "content": "Since version 2.0, Spring Security has substantial support for adding security to your service layer methods.\nIt provides support for JSR-250 annotation security as well as the framework's original `@Secured` annotation.\nSince version 3.0, you can also make use of xref:servlet/authorization/method-security.adoc#authorizing-with-annotations[expression-based annotations].\nYou can apply security to a single bean (by using the `intercept-methods` element to decorate the bean declaration), or you can secure multiple beans across the entire service layer using the AspectJ style pointcuts.\n\n[[ns-access-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc", "title": "xml-namespace", "heading": "Method Security", "heading_level": 2, "file_order": 120, "section_index": 8, "content_hash": "52ba697c81da2982feaf99f178260ce4002cff47a7867ec984da785bce6d9bce", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc"}}
{"id": "sha256:48e8b783b80d13dc9210f6600757c73fabad607cdde55f98674c11b74881476a", "content": "This section assumes that you have some knowledge of the underlying architecture for access-control within Spring Security.\nIf you do not, you can skip it and come back to it later, as this section is relevant only for people who need to do some customization to use more than simple role-based security.\n\nWhen you use a namespace configuration, a default instance of `AccessDecisionManager` is automatically registered for you and is used to make access decisions for method invocations and web URL access, based on the access attributes you specify in your `intercept-url` and `protect-pointcut` declarations (and in annotations, if you use annotations to secure methods).\n\nThe default strategy is to use an `AffirmativeBased` `AccessDecisionManager` with a `RoleVoter` and an `AuthenticatedVoter`.\nYou can find out more about these in the chapter on xref:servlet/authorization/architecture.adoc#authz-arch[authorization].\n\n[[ns-custom-access-mgr]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc", "title": "xml-namespace", "heading": "The Default AccessDecisionManager", "heading_level": 2, "file_order": 120, "section_index": 9, "content_hash": "48e8b783b80d13dc9210f6600757c73fabad607cdde55f98674c11b74881476a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc"}}
{"id": "sha256:f022003d29072b1760084a4674c756ac2830f4c4b2035df27d02a9ae85a8986d", "content": "If you need to use a more complicated access control strategy, you can set an alternative for both method and web security.\n\nFor method security, you do so by setting the `access-decision-manager-ref` attribute on `global-method-security` to the `id` of the appropriate `AccessDecisionManager` bean in the application context:\n\n[source,xml]\n----\n<global-method-security access-decision-manager-ref=\"myAccessDecisionManagerBean\">\n...\n</global-method-security>\n----\n\nThe syntax for web security is the same, but the attribute is on the `http` element:\n\n[source,xml]\n----\n<http access-decision-manager-ref=\"myAccessDecisionManagerBean\">\n...\n</http>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc", "title": "xml-namespace", "heading": "Customizing the AccessDecisionManager", "heading_level": 3, "file_order": 120, "section_index": 10, "content_hash": "f022003d29072b1760084a4674c756ac2830f4c4b2035df27d02a9ae85a8986d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/configuration/xml-namespace.adoc"}}
{"id": "sha256:2b1af635e14fc2a3c3ffe670374bd1c0003ac725ccac6c0f9573e13024267bbb", "content": "[[servlet-csrf]]\n\nIn an application where end users can xref:servlet/authentication/index.adoc[log in], it is important to consider how to protect against xref:features/exploits/csrf.adoc#csrf[Cross Site Request Forgery (CSRF)].\n\nSpring Security protects against CSRF attacks by default for xref:features/exploits/csrf.adoc#csrf-protection-read-only[unsafe HTTP methods], such as a POST request, so no additional code is necessary.\nYou can specify the default configuration explicitly using the following:\n\n[[csrf-configuration]]\n.Configure CSRF Protection\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .csrf(Customizer.withDefaults());\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n csrf { }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<csrf/>\n</http>\n----\n======\n\nTo learn more about CSRF protection for your application, consider the following use cases:\n\n* I want to <<csrf-components,understand CSRF protection's components>>\n* I need to <<migrating-to-spring-security-6,migrate an application from Spring Security 5 to 6>>\n* I want to <<csrf-token-repository-cookie,store the `CsrfToken` in a cookie>> instead of <<csrf-token-repository-httpsession,the session>>\n* I want to <<csrf-token-repository-custom,store the `CsrfToken` in a custom location>>\n* I want to <<deferred-csrf-token-opt-out,opt-out of deferred tokens>>\n* I want to <<csrf-token-request-handler-opt-out-of-breach,opt-out of BREACH protection>>\n* I need guidance integrating <<csrf-integration-form,Thymeleaf, JSPs or another view technology>> with the backend\n* I need guidance integrating <<csrf-integration-javascript,Angular or another JavaScript framework>> with the backend\n* I need guidance integrating <<csrf-integration-mobile,a mobile application or another client>> with the backend\n* I need guidance on <<csrf-access-denied-handler,handling errors>>\n* I want to <<csrf-testing,test CSRF protection>>\n* I need guidance on <<disable-csrf,disabling CSRF protection>>\n\n[[csrf-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "csrf", "heading_level": 1, "file_order": 121, "section_index": 0, "content_hash": "2b1af635e14fc2a3c3ffe670374bd1c0003ac725ccac6c0f9573e13024267bbb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:221985c4ea69c3320bd0c122339855070076ba1d113d74887cf6971da77b72e5", "content": "CSRF protection is provided by several components that are composed within the javadoc:org.springframework.security.web.csrf.CsrfFilter[]:\n\n.`CsrfFilter` Components\n[.invert-dark]\nimage::{figures}/csrf.png[]\n\nCSRF protection is divided into two parts:\n\n1. Make the javadoc:org.springframework.security.web.csrf.CsrfToken[] available to the application by delegating to the <<csrf-token-request-handler,`CsrfTokenRequestHandler`>>.\n2. Determine if the request requires CSRF protection, load and validate the token, and <<csrf-access-denied-handler,handle `AccessDeniedException`>>.\n\n.`CsrfFilter` Processing\n[.invert-dark]\nimage::{figures}/csrf-processing.png[]\n\n* image:{icondir}/number_1.png[] First, the javadoc:org.springframework.security.web.csrf.DeferredCsrfToken[] is loaded, which holds a reference to the <<csrf-token-repository,`CsrfTokenRepository`>> so that the persisted `CsrfToken` can be loaded later (in image:{icondir}/number_4.png[]).\n* image:{icondir}/number_2.png[] Second, a `Supplier<CsrfToken>` (created from `DeferredCsrfToken`) is given to the <<csrf-token-request-handler,`CsrfTokenRequestHandler`>>, which is responsible for populating a request attribute to make the `CsrfToken` available to the rest of the application.\n* image:{icondir}/number_3.png[] Next, the main CSRF protection processing begins and checks if the current request requires CSRF protection. If not required, the filter chain is continued and processing ends.\n* image:{icondir}/number_4.png[] If CSRF protection is required, the persisted `CsrfToken` is finally loaded from the `DeferredCsrfToken`.\n* image:{icondir}/number_5.png[] Continuing, the actual CSRF token provided by the client (if any) is resolved using the <<csrf-token-request-handler,`CsrfTokenRequestHandler`>>.\n* image:{icondir}/number_6.png[] The actual CSRF token is compared against the persisted `CsrfToken`. If valid, the filter chain is continued and processing ends.\n* image:{icondir}/number_7.png[] If the actual CSRF token is invalid (or missing), an `AccessDeniedException` is passed to the <<csrf-access-denied-handler,`AccessDeniedHandler`>> and processing ends.\n\n[[migrating-to-spring-security-6]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Understanding CSRF Protection's Components", "heading_level": 2, "file_order": 121, "section_index": 1, "content_hash": "221985c4ea69c3320bd0c122339855070076ba1d113d74887cf6971da77b72e5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:aa98ef6af1b52e984e6b6a8437244b8e3f4b12f767193536fe131746ff681108", "content": "When migrating from Spring Security 5 to 6, there are a few changes that may impact your application.\nThe following is an overview of the aspects of CSRF protection that have changed in Spring Security 6:\n\n* Loading of the `CsrfToken` is now <<deferred-csrf-token,deferred by default>> to improve performance by no longer requiring the session to be loaded on every request.\n* The `CsrfToken` now includes <<csrf-token-request-handler-breach,randomness on every request by default>> to protect the CSRF token from a https://en.wikipedia.org/wiki/BREACH[BREACH] attack.\n\n[TIP]\n====\nThe changes in Spring Security 6 require additional configuration for single-page applications, and as such you may find the <<csrf-integration-javascript-spa>> section particularly useful.\n====\n\nSee the https://docs.spring.io/spring-security/reference/5.8/migration/servlet/exploits.html[Exploit Protection] section of the https://docs.spring.io/spring-security/reference/5.8/migration/index.html[Migration] chapter for more information on migrating a Spring Security 5 application.\n\n[[csrf-token-repository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Migrating to Spring Security 6", "heading_level": 2, "file_order": 121, "section_index": 2, "content_hash": "aa98ef6af1b52e984e6b6a8437244b8e3f4b12f767193536fe131746ff681108", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:57ff630a56e944085ad1de260e65bccc2cd5b892cd1c071597d36c56141dffcd", "content": "The `CsrfToken` is persisted using a `CsrfTokenRepository`.\n\nBy default, the <<csrf-token-repository-httpsession,`HttpSessionCsrfTokenRepository`>> is used for storing tokens in a session.\nSpring Security also provides the <<csrf-token-repository-cookie,`CookieCsrfTokenRepository`>> for storing tokens in a cookie.\nYou can also specify <<csrf-token-repository-custom,your own implementation>> to store tokens wherever you like.\n\n[[csrf-token-repository-httpsession]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Persisting the `CsrfToken`", "heading_level": 2, "file_order": 121, "section_index": 3, "content_hash": "57ff630a56e944085ad1de260e65bccc2cd5b892cd1c071597d36c56141dffcd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:322a6d62419924e7d177ffaaf8e7e1d16af9f366d13abb9ae780d1a30e4e1a54", "content": "By default, Spring Security stores the expected CSRF token in the `HttpSession` by using javadoc:org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository[], so no additional code is necessary.\n\nThe `HttpSessionCsrfTokenRepository` reads the token from a session (whether in-memory, cache, or database). If you need to access the session attribute directly, please first configure the session attribute name using `HttpSessionCsrfTokenRepository#setSessionAttributeName`.\n\nYou can specify the default configuration explicitly using the following configuration:\n\n[[csrf-token-repository-httpsession-configuration]]\n.Configure `HttpSessionCsrfTokenRepository`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .csrf((csrf) -> csrf\n .csrfTokenRepository(new HttpSessionCsrfTokenRepository())\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n csrf {\n csrfTokenRepository = HttpSessionCsrfTokenRepository()\n }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<csrf token-repository-ref=\"tokenRepository\"/>\n</http>\n<b:bean id=\"tokenRepository\"\n\tclass=\"org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository\"/>\n----\n======\n\n[[csrf-token-repository-cookie]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Using the `HttpSessionCsrfTokenRepository`", "heading_level": 3, "file_order": 121, "section_index": 4, "content_hash": "322a6d62419924e7d177ffaaf8e7e1d16af9f366d13abb9ae780d1a30e4e1a54", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:29178179b6f7a5accffbb7ba0c21b246621fb0d93f72926d971dbf8f97bdd309", "content": "You can persist the `CsrfToken` in a cookie to <<csrf-integration-javascript,support a JavaScript-based application>> using the javadoc:org.springframework.security.web.csrf.CookieCsrfTokenRepository[].\n\nThe `CookieCsrfTokenRepository` writes to a cookie named `XSRF-TOKEN` and reads it from an HTTP request header named `X-XSRF-TOKEN` or the request parameter `_csrf` by default.\nThese defaults come from Angular and its predecessor https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS].\n\n[TIP]\n====\nSee the https://angular.dev/best-practices/security#httpclient-xsrf-csrf-security[HttpClient XSRF/CSRF security] and the https://angular.dev/api/common/http/withXsrfConfiguration[withXsrfConfiguration] for more recent information on this topic.\n====\n\nYou can configure the `CookieCsrfTokenRepository` using the following configuration:\n\n[[csrf-token-repository-cookie-configuration]]\n.Configure `CookieCsrfTokenRepository`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .csrf((csrf) -> csrf\n .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n csrf {\n csrfTokenRepository = CookieCsrfTokenRepository.withHttpOnlyFalse()\n }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<csrf token-repository-ref=\"tokenRepository\"/>\n</http>\n<b:bean id=\"tokenRepository\"\n\tclass=\"org.springframework.security.web.csrf.CookieCsrfTokenRepository\"\n\tp:cookieHttpOnly=\"false\"/>\n----\n======\n\n[NOTE]\n====\nThe example explicitly sets `HttpOnly` to `false`.\nThis is necessary to let JavaScript frameworks (such as Angular) read it.\nIf you do not need the ability to read the cookie with JavaScript directly, we _recommend_ omitting `HttpOnly` (by using `new CookieCsrfTokenRepository()` instead) to improve security.\n====\n\n[[csrf-token-repository-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Using the `CookieCsrfTokenRepository`", "heading_level": 3, "file_order": 121, "section_index": 5, "content_hash": "29178179b6f7a5accffbb7ba0c21b246621fb0d93f72926d971dbf8f97bdd309", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:9d1f03dba602417df79f17a6e659260888f9be627883fd22d65bddf04dfd8ce5", "content": "There can be cases where you want to implement a custom javadoc:org.springframework.security.web.csrf.CsrfTokenRepository[].\n\nOnce you've implemented the `CsrfTokenRepository` interface, you can configure Spring Security to use it with the following configuration:\n\n[[csrf-token-repository-custom-configuration]]\n.Configure Custom `CsrfTokenRepository`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .csrf((csrf) -> csrf\n .csrfTokenRepository(new CustomCsrfTokenRepository())\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n csrf {\n csrfTokenRepository = CustomCsrfTokenRepository()\n }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<csrf token-repository-ref=\"tokenRepository\"/>\n</http>\n<b:bean id=\"tokenRepository\"\n\tclass=\"example.CustomCsrfTokenRepository\"/>\n----\n======\n\n[[csrf-token-request-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Customizing the `CsrfTokenRepository`", "heading_level": 3, "file_order": 121, "section_index": 6, "content_hash": "9d1f03dba602417df79f17a6e659260888f9be627883fd22d65bddf04dfd8ce5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:27ab51ee55305110f1756918af5b4e060c1fa659cac3428164d706b90b941393", "content": "The `CsrfToken` is made available to an application using a `CsrfTokenRequestHandler`.\nThis component is also responsible for resolving the `CsrfToken` from HTTP headers or request parameters.\n\nBy default, the <<csrf-token-request-handler-breach,`XorCsrfTokenRequestAttributeHandler`>> is used for providing https://en.wikipedia.org/wiki/BREACH[BREACH] protection of the `CsrfToken`.\nSpring Security also provides the <<csrf-token-request-handler-plain,`CsrfTokenRequestAttributeHandler`>> for opting out of BREACH protection.\nYou can also specify <<csrf-token-request-handler-custom,your own implementation>> to customize the strategy for handling and resolving tokens.\n\n[[csrf-token-request-handler-breach]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Handling the `CsrfToken`", "heading_level": 2, "file_order": 121, "section_index": 7, "content_hash": "27ab51ee55305110f1756918af5b4e060c1fa659cac3428164d706b90b941393", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:1b3f3af10bba1eb227fd0d7ae585f4d4cb5691610f725bad6c5100ecd115d1bd", "content": "The `XorCsrfTokenRequestAttributeHandler` makes the `CsrfToken` available as an `HttpServletRequest` attribute called `_csrf`, and additionally provides protection for https://en.wikipedia.org/wiki/BREACH[BREACH].\n\n[NOTE]\n====\nThe `CsrfToken` is also made available as a request attribute using the name `CsrfToken.class.getName()`.\nThis name is not configurable, but the name `_csrf` can be changed using `XorCsrfTokenRequestAttributeHandler#setCsrfRequestAttributeName`.\n====\n\nThis implementation also resolves the token value from the request as either a request header (one of <<csrf-token-repository-httpsession,`X-CSRF-TOKEN`>> or <<csrf-token-repository-cookie,`X-XSRF-TOKEN`>> by default) or a request parameter (`_csrf` by default).\n\n[NOTE]\n====\nBREACH protection is provided by encoding randomness into the CSRF token value to ensure the returned `CsrfToken` changes on every request.\nWhen the token is later resolved as a header value or request parameter, it is decoded to obtain the raw token which is then compared to the <<csrf-token-repository,persisted `CsrfToken`>>.\n====\n\nSpring Security protects the CSRF token from a BREACH attack by default, so no additional code is necessary.\nYou can specify the default configuration explicitly using the following configuration:\n\n[[csrf-token-request-handler-breach-configuration]]\n.Configure BREACH protection\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .csrf((csrf) -> csrf\n .csrfTokenRequestHandler(new XorCsrfTokenRequestAttributeHandler())\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n csrf {\n csrfTokenRequestHandler = XorCsrfTokenRequestAttributeHandler()\n }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<csrf request-handler-ref=\"requestHandler\"/>\n</http>\n<b:bean id=\"requestHandler\"\n\tclass=\"org.springframework.security.web.csrf.XorCsrfTokenRequestAttributeHandler\"/>\n----\n======\n\n[[csrf-token-request-handler-plain]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Using the `XorCsrfTokenRequestAttributeHandler` (BREACH)", "heading_level": 3, "file_order": 121, "section_index": 8, "content_hash": "1b3f3af10bba1eb227fd0d7ae585f4d4cb5691610f725bad6c5100ecd115d1bd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:0dafa95d22280ffb986f86f4831fe75402b6739a1c874a1ae626da40ade79f4f", "content": "The `CsrfTokenRequestAttributeHandler` makes the `CsrfToken` available as an `HttpServletRequest` attribute called `_csrf`.\n\n[NOTE]\n====\nThe `CsrfToken` is also made available as a request attribute using the name `CsrfToken.class.getName()`.\nThis name is not configurable, but the name `_csrf` can be changed using `CsrfTokenRequestAttributeHandler#setCsrfRequestAttributeName`.\n====\n\nThis implementation also resolves the token value from the request as either a request header (one of <<csrf-token-repository-httpsession,`X-CSRF-TOKEN`>> or <<csrf-token-repository-cookie,`X-XSRF-TOKEN`>> by default) or a request parameter (`_csrf` by default).\n\n[[csrf-token-request-handler-opt-out-of-breach]]\nThe primary use of `CsrfTokenRequestAttributeHandler` is to opt-out of BREACH protection of the `CsrfToken`, which can be configured using the following configuration:\n\n.Opt-out of BREACH protection\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .csrf((csrf) -> csrf\n .csrfTokenRequestHandler(new CsrfTokenRequestAttributeHandler())\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n csrf {\n csrfTokenRequestHandler = CsrfTokenRequestAttributeHandler()\n }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<csrf request-handler-ref=\"requestHandler\"/>\n</http>\n<b:bean id=\"requestHandler\"\n\tclass=\"org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler\"/>\n----\n======\n\n[[csrf-token-request-handler-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Using the `CsrfTokenRequestAttributeHandler`", "heading_level": 3, "file_order": 121, "section_index": 9, "content_hash": "0dafa95d22280ffb986f86f4831fe75402b6739a1c874a1ae626da40ade79f4f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:d12d9e10717e27d3931507c0fe9626a891f7e9a1465089a40cbe89f30aa1f78e", "content": "You can implement the `CsrfTokenRequestHandler` interface to customize the strategy for handling and resolving tokens.\n\n[TIP]\n====\nThe `CsrfTokenRequestHandler` interface is a `@FunctionalInterface` that can be implemented using a lambda expression to customize request handling.\nYou will need to implement the full interface to customize how tokens are resolved from the request.\nSee <<csrf-integration-javascript-spa-configuration>> for an example that uses delegation to implement a custom strategy for handling and resolving tokens.\n====\n\nOnce you've implemented the `CsrfTokenRequestHandler` interface, you can configure Spring Security to use it with the following configuration:\n\n[[csrf-token-request-handler-custom-configuration]]\n.Configure Custom `CsrfTokenRequestHandler`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .csrf((csrf) -> csrf\n .csrfTokenRequestHandler(new CustomCsrfTokenRequestHandler())\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n csrf {\n csrfTokenRequestHandler = CustomCsrfTokenRequestHandler()\n }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<csrf request-handler-ref=\"requestHandler\"/>\n</http>\n<b:bean id=\"requestHandler\"\n\tclass=\"example.CustomCsrfTokenRequestHandler\"/>\n----\n======\n\n[[deferred-csrf-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Customizing the `CsrfTokenRequestHandler`", "heading_level": 3, "file_order": 121, "section_index": 10, "content_hash": "d12d9e10717e27d3931507c0fe9626a891f7e9a1465089a40cbe89f30aa1f78e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:10c400c369815ce9450cb2e8b0d1c6b9e44c13402292757ece0993dc63082b0d", "content": "By default, Spring Security defers loading of the `CsrfToken` until it is needed.\n\n[NOTE]\n====\nThe `CsrfToken` is needed whenever a request is made with an xref:features/exploits/csrf.adoc#csrf-protection-read-only[unsafe HTTP method], such as a POST.\nAdditionally, it is needed by any request that renders the token to the response, such as a web page with a `<form>` tag that includes a hidden `<input>` for the CSRF token.\n====\n\nBecause Spring Security also stores the `CsrfToken` in the `HttpSession` by default, deferred CSRF tokens can improve performance by not requiring the session to be loaded on every request.\n\n[[deferred-csrf-token-opt-out]]\nIn the event that you want to opt-out of deferred tokens and cause the `CsrfToken` to be loaded on every request, you can do so with the following configuration:\n\n[[deferred-csrf-token-opt-out-configuration]]\n.Opt-out of Deferred CSRF Tokens\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n XorCsrfTokenRequestAttributeHandler requestHandler = new XorCsrfTokenRequestAttributeHandler();\n // set the name of the attribute the CsrfToken will be populated on\n requestHandler.setCsrfRequestAttributeName(null);\n http\n // ...\n .csrf((csrf) -> csrf\n .csrfTokenRequestHandler(requestHandler)\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n val requestHandler = XorCsrfTokenRequestAttributeHandler()\n // set the name of the attribute the CsrfToken will be populated on\n requestHandler.setCsrfRequestAttributeName(null)\n http {\n // ...\n csrf {\n csrfTokenRequestHandler = requestHandler\n }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<csrf request-handler-ref=\"requestHandler\"/>\n</http>\n<b:bean id=\"requestHandler\"\n\tclass=\"org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler\">\n\t<b:property name=\"csrfRequestAttributeName\">\n <b:null/>\n\t</b:property>\n</b:bean>\n----\n======\n\n[NOTE]\n====\nBy setting the `csrfRequestAttributeName` to `null`, the `CsrfToken` must first be loaded to determine what attribute name to use.\nThis causes the `CsrfToken` to be loaded on every request.\n====\n\n[[csrf-integration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Deferred Loading of the `CsrfToken`", "heading_level": 2, "file_order": 121, "section_index": 11, "content_hash": "10c400c369815ce9450cb2e8b0d1c6b9e44c13402292757ece0993dc63082b0d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:709cda3c084dd070d5c288e23ec20fd2b5b13189d09a8dd2b6e05d94c8430473", "content": "For the xref:features/exploits/csrf.adoc#csrf-protection-stp[synchronizer token pattern] to protect against CSRF attacks, we must include the actual CSRF token in the HTTP request.\nThis must be included in a part of the request (a form parameter, an HTTP header, or other part) that is not automatically included in the HTTP request by the browser.\n\nThe following sections describe the various ways a frontend or client application can integrate with a CSRF-protected backend application:\n\n* <<csrf-integration-form>>\n* <<csrf-integration-javascript>>\n* <<csrf-integration-mobile>>\n\n[[csrf-integration-form]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Integrating with CSRF Protection", "heading_level": 2, "file_order": 121, "section_index": 12, "content_hash": "709cda3c084dd070d5c288e23ec20fd2b5b13189d09a8dd2b6e05d94c8430473", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:a0b7afca340da019cf5d0dc7f7ac99fbc2db8761cc03537b671377c7a22d8191", "content": "To submit an HTML form, the CSRF token must be included in the form as a hidden input.\nFor example, the rendered HTML might look like:\n\n.CSRF Token in HTML Form\n[source,html]\n----\n<input type=\"hidden\"\n\tname=\"_csrf\"\n\tvalue=\"4bfd1575-3ad1-4d21-96c7-4ef2d9f86721\"/>\n----\n\nThe following view technologies automatically include the actual CSRF token in a form that has an unsafe HTTP method, such as a POST:\n\n* https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view-jsp-formtaglib[Springs form tag library]\n* https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor[Thymeleaf]\n* Any other view technology that integrates with {spring-framework-api-url}org/springframework/web/servlet/support/RequestDataValueProcessor.html[`RequestDataValueProcessor`] (via javadoc:org.springframework.security.web.servlet.support.csrf.CsrfRequestDataValueProcessor[])\n* You can also include the token yourself via the xref:servlet/integrations/jsp-taglibs.adoc#taglibs-csrfinput[csrfInput] tag\n\nIf these options are not available, you can take advantage of the fact that the `CsrfToken` is exposed as an <<csrf-token-request-handler,`HttpServletRequest` attribute named `_csrf`>>.\nThe following example does this with a JSP:\n\n.CSRF Token in HTML Form with Request Attribute\n[source,xml]\n----\n<c:url var=\"logoutUrl\" value=\"/logout\"/>\n<form action=\"${logoutUrl}\"\n\tmethod=\"post\">\n<input type=\"submit\"\n\tvalue=\"Log out\" />\n<input type=\"hidden\"\n\tname=\"${_csrf.parameterName}\"\n\tvalue=\"${_csrf.token}\"/>\n</form>\n----\n\n[[csrf-integration-javascript]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "HTML Forms", "heading_level": 3, "file_order": 121, "section_index": 13, "content_hash": "a0b7afca340da019cf5d0dc7f7ac99fbc2db8761cc03537b671377c7a22d8191", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:37ac10a3186108c7e0224fcca6d7f1e5fbd1898e2c1cb73049e405ba2b9b67b3", "content": "JavaScript applications typically use JSON instead of HTML.\nIf you use JSON, you can submit the CSRF token within an HTTP request header instead of a request parameter.\n\nIn order to obtain the CSRF token, you can configure Spring Security to store the expected CSRF token <<csrf-token-repository-cookie,in a cookie>>.\nBy storing the expected token in a cookie, JavaScript frameworks such as https://angular.io/api/common/http/HttpClientXsrfModule[Angular] can automatically include the actual CSRF token as an HTTP request header.\n\n[TIP]\n====\nThere are special considerations for BREACH protection and deferred tokens when integrating a single-page application (SPA) with Spring Security's CSRF protection.\nA full configuration example is provided in the <<csrf-integration-javascript-spa,next section>>.\n====\n\nYou can read about different types of JavaScript applications in the following sections:\n\n* <<csrf-integration-javascript-spa>>\n* <<csrf-integration-javascript-mpa>>\n* <<csrf-integration-javascript-other>>\n\n[[csrf-integration-javascript-spa]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "JavaScript Applications", "heading_level": 3, "file_order": 121, "section_index": 14, "content_hash": "37ac10a3186108c7e0224fcca6d7f1e5fbd1898e2c1cb73049e405ba2b9b67b3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:2fd0e79d68d26307483f9bcccb1754a12b7a76831108dc9a77c6c9d11021a6a5", "content": "There are special considerations for integrating a single-page application (SPA) with Spring Security's CSRF protection.\n\nRecall that Spring Security provides <<csrf-token-request-handler-breach,BREACH protection of the `CsrfToken`>> by default.\nWhen storing the expected CSRF token <<csrf-token-repository-cookie,in a cookie>>, JavaScript applications will only have access to the plain token value and _will not_ have access to the encoded value.\nA <<csrf-token-request-handler-custom,customized request handler>> for resolving the actual token value will need to be provided.\n\nIn addition, the cookie storing the CSRF token will be cleared upon authentication success and logout success.\nSpring Security defers loading a new CSRF token by default, and additional work is required to return a fresh cookie.\n\n[NOTE]\n====\nRefreshing the token after authentication success and logout success is required because the javadoc:org.springframework.security.web.csrf.CsrfAuthenticationStrategy[] and javadoc:org.springframework.security.web.csrf.CsrfLogoutHandler[] will clear the previous token.\nThe client application will not be able to perform an unsafe HTTP request, such as a POST, without obtaining a fresh token.\n====\n\nIn order to easily integrate a single-page application with Spring Security, the following configuration can be used:\n\n[[csrf-integration-javascript-spa-configuration]]\n.Configure CSRF for Single-Page Application\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .csrf((csrf) -> csrf.spa());\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n csrf {\n spa()\n }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<csrf>\n <spa />\n </csrf>\n</http>\n----\n======\n\n[[csrf-integration-javascript-mpa]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Single-Page Applications", "heading_level": 4, "file_order": 121, "section_index": 15, "content_hash": "2fd0e79d68d26307483f9bcccb1754a12b7a76831108dc9a77c6c9d11021a6a5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:4338779b56f9d4c75d12fe5d4a7e3e83c5be5905f357126be915eb20962665fa", "content": "For multi-page applications where JavaScript is loaded on each page, an alternative to exposing the CSRF token <<csrf-token-repository-cookie,in a cookie>> is to include the CSRF token within your `meta` tags.\nThe HTML might look something like this:\n\n.CSRF Token in HTML Meta Tag\n[source,html]\n----\n<html>\n<head>\n\t<meta name=\"_csrf\" content=\"4bfd1575-3ad1-4d21-96c7-4ef2d9f86721\"/>\n\t<meta name=\"_csrf_header\" content=\"X-CSRF-TOKEN\"/>\n\t<!-- ... -->\n</head>\n<!-- ... -->\n</html>\n----\n\nIn order to include the CSRF token in the request, you can take advantage of the fact that the `CsrfToken` is exposed as an <<csrf-token-request-handler,`HttpServletRequest` attribute named `_csrf`>>.\nThe following example does this with a JSP:\n\n.CSRF Token in HTML Meta Tag with Request Attribute\n[source,html]\n----\n<html>\n<head>\n\t<meta name=\"_csrf\" content=\"${_csrf.token}\"/>\n\t<!-- default header name is X-CSRF-TOKEN -->\n\t<meta name=\"_csrf_header\" content=\"${_csrf.headerName}\"/>\n\t<!-- ... -->\n</head>\n<!-- ... -->\n</html>\n----\n\nOnce the meta tags contain the CSRF token, the JavaScript code can read the meta tags and include the CSRF token as a header.\nIf you use jQuery, you can do this with the following code:\n\n.Include CSRF Token in AJAX Request\n[source,javascript]\n----\n$(function () {\n\tvar token = $(\"meta[name='_csrf']\").attr(\"content\");\n\tvar header = $(\"meta[name='_csrf_header']\").attr(\"content\");\n\t$(document).ajaxSend(function(e, xhr, options) {\n xhr.setRequestHeader(header, token);\n\t});\n});\n----\n\n[[csrf-integration-javascript-other]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Multi-Page Applications", "heading_level": 4, "file_order": 121, "section_index": 16, "content_hash": "4338779b56f9d4c75d12fe5d4a7e3e83c5be5905f357126be915eb20962665fa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:c052cc9b52b12a3862eec6ab413b81eb677462f37b88353a1abf3df12a10234e", "content": "Another option for JavaScript applications is to include the CSRF token in an HTTP response header.\n\nOne way to achieve this is through the use of a `@ControllerAdvice` with the xref:servlet/integrations/mvc.adoc#mvc-csrf-resolver[`CsrfTokenArgumentResolver`].\nThe following is an example of `@ControllerAdvice` that applies to all controller endpoints in the application:\n\n[[controller-advice]]\n.CSRF Token in HTTP Response Header\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@ControllerAdvice\npublic class CsrfControllerAdvice {\n\n\t@ModelAttribute\n\tpublic void getCsrfToken(HttpServletResponse response, CsrfToken csrfToken) {\n response.setHeader(csrfToken.getHeaderName(), csrfToken.getToken());\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@ControllerAdvice\nclass CsrfControllerAdvice {\n\n\t@ModelAttribute\n\tfun getCsrfToken(response: HttpServletResponse, csrfToken: CsrfToken) {\n response.setHeader(csrfToken.headerName, csrfToken.token)\n\t}\n\n}\n----\n======\n\n[NOTE]\n====\nBecause this `@ControllerAdvice` applies to all endpoints in the application, it will cause the CSRF token to be loaded on every request, which can negate the benefits of <<deferred-csrf-token,deferred tokens>> when using the <<csrf-token-repository-httpsession,`HttpSessionCsrfTokenRepository`>>.\nHowever, this is not usually an issue when using the <<csrf-token-repository-cookie,`CookieCsrfTokenRepository`>>.\n====\n\n[NOTE]\n====\nIt is important to remember that controller endpoints and controller advice are called _after_ the Spring Security filter chain.\nThis means that this `@ControllerAdvice` will only be applied if the request passes through the filter chain to your application.\nSee the configuration for <<csrf-integration-javascript-spa-configuration,single-page applications>> for an example of adding a filter to the filter chain for earlier access to the `HttpServletResponse`.\n====\n\nThe CSRF token will now be available in a response header (<<csrf-token-repository-httpsession,`X-CSRF-TOKEN`>> or <<csrf-token-repository-cookie,`X-XSRF-TOKEN`>> by default) for any custom endpoints the controller advice applies to.\nAny request to the backend can be used to obtain the token from the response, and a subsequent request can include the token in a request header with the same name.\n\n[[csrf-integration-mobile]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Other JavaScript Applications", "heading_level": 4, "file_order": 121, "section_index": 17, "content_hash": "c052cc9b52b12a3862eec6ab413b81eb677462f37b88353a1abf3df12a10234e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:fe142c8dc5237b49134094e734a465410500673b6fa4f05d8e73fc58ddb2c73f", "content": "Like <<csrf-integration-javascript,JavaScript applications>>, mobile applications typically use JSON instead of HTML.\nA backend application that _does not_ serve browser traffic may choose to <<disable-csrf,disable CSRF>>.\nIn that case, no additional work is required.\n\nHowever, a backend application that also serves browser traffic and therefore _still requires_ CSRF protection may continue to store the `CsrfToken` <<csrf-token-repository-httpsession,in the session>> instead of <<csrf-token-repository-cookie,in a cookie>>.\n\nIn this case, a typical pattern for integrating with the backend is to expose a `/csrf` endpoint to allow the frontend (mobile or browser client) to request a CSRF token on demand.\nThe benefit of using this pattern is that the CSRF token <<deferred-csrf-token,can continue to be deferred>> and only needs to be loaded from the session when a request requires CSRF protection.\nThe use of a custom endpoint also means the client application can request that a new token be generated on demand (if necessary) by issuing an explicit request.\n\n[TIP]\n====\nThis pattern can be used for any type of application that requires CSRF protection, not just mobile applications.\nWhile this approach isn't typically required in those cases, it is another option for integrating with a CSRF-protected backend.\n====\n\nThe following is an example of the `/csrf` endpoint that makes use of the xref:servlet/integrations/mvc.adoc#mvc-csrf-resolver[`CsrfTokenArgumentResolver`]:\n\n[[csrf-endpoint]]\n.The `/csrf` endpoint\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic class CsrfController {\n\n @GetMapping(\"/csrf\")\n public CsrfToken csrf(CsrfToken csrfToken) {\n return csrfToken;\n }\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RestController\nclass CsrfController {\n\n @GetMapping(\"/csrf\")\n fun csrf(csrfToken: CsrfToken): CsrfToken {\n return csrfToken\n }\n\n}\n----\n======\n\n[NOTE]\n====\nYou may consider adding `.requestMatchers(\"/csrf\").permitAll()` if the endpoint above is required prior to authenticating with the server.\n====\n\nThis endpoint should be called to obtain a CSRF token when the application is launched or initialized (e.g. at load time), and also after authentication success and logout success.\n\n[NOTE]\n====\nRefreshing the token after authentication success and logout success is required because the javadoc:org.springframework.security.web.csrf.CsrfAuthenticationStrategy[] and javadoc:org.springframework.security.web.csrf.CsrfLogoutHandler[] will clear the previous token.\nThe client application will not be able to perform an unsafe HTTP request, such as a POST, without obtaining a fresh token.\n====\n\nOnce you've obtained the CSRF token, you will need to include it as an HTTP request header (one of <<csrf-token-repository-httpsession,`X-CSRF-TOKEN`>> or <<csrf-token-repository-cookie,`X-XSRF-TOKEN`>> by default) yourself.\n\n[[csrf-access-denied-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Mobile Applications", "heading_level": 3, "file_order": 121, "section_index": 18, "content_hash": "fe142c8dc5237b49134094e734a465410500673b6fa4f05d8e73fc58ddb2c73f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:63a4cf71fcd0f38913126f5792853fa09ac2a787f2578d40cddda08066430c70", "content": "To handle an `AccessDeniedException` such as `InvalidCsrfTokenException`, you can configure Spring Security to handle these exceptions in any way you like.\nFor example, you can configure a custom access denied page using the following configuration:\n\n[[csrf-access-denied-handler-configuration]]\n.Configure `AccessDeniedHandler`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .exceptionHandling((exceptionHandling) -> exceptionHandling\n .accessDeniedPage(\"/access-denied\")\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n exceptionHandling {\n accessDeniedPage = \"/access-denied\"\n }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<access-denied-handler error-page=\"/access-denied\"/>\n</http>\n----\n======\n\n[[csrf-testing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Handle `AccessDeniedException`", "heading_level": 2, "file_order": 121, "section_index": 19, "content_hash": "63a4cf71fcd0f38913126f5792853fa09ac2a787f2578d40cddda08066430c70", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:0f48283eb972f05b2b0277e32b6e024a05dbceb69a4bc9671b39896b36ea8f0c", "content": "You can use Spring Security's xref:servlet/test/mockmvc/setup.adoc[testing support] and xref:servlet/test/mockmvc/csrf.adoc[`CsrfRequestPostProcessor`] to test CSRF protection, like this:\n\n[[csrf-testing-example]]\n.Test CSRF Protection\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*;\nimport static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;\n\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = SecurityConfig.class)\n@WebAppConfiguration\npublic class CsrfTests {\n\n\tprivate MockMvc mockMvc;\n\n\t@BeforeEach\n\tpublic void setUp(WebApplicationContext applicationContext) {\n this.mockMvc = MockMvcBuilders.webAppContextSetup(applicationContext)\n .apply(springSecurity())\n .build();\n\t}\n\n\t@Test\n\tpublic void loginWhenValidCsrfTokenThenSuccess() throws Exception {\n this.mockMvc.perform(post(\"/login\").with(csrf())\n .accept(MediaType.TEXT_HTML)\n .param(\"username\", \"user\")\n .param(\"password\", \"password\"))\n .andExpect(status().is3xxRedirection())\n .andExpect(header().string(HttpHeaders.LOCATION, \"/\"));\n\t}\n\n\t@Test\n\tpublic void loginWhenInvalidCsrfTokenThenForbidden() throws Exception {\n this.mockMvc.perform(post(\"/login\").with(csrf().useInvalidToken())\n .accept(MediaType.TEXT_HTML)\n .param(\"username\", \"user\")\n .param(\"password\", \"password\"))\n .andExpect(status().isForbidden());\n\t}\n\n\t@Test\n\tpublic void loginWhenMissingCsrfTokenThenForbidden() throws Exception {\n this.mockMvc.perform(post(\"/login\")\n .accept(MediaType.TEXT_HTML)\n .param(\"username\", \"user\")\n .param(\"password\", \"password\"))\n .andExpect(status().isForbidden());\n\t}\n\n\t@Test\n\t@WithMockUser\n\tpublic void logoutWhenValidCsrfTokenThenSuccess() throws Exception {\n this.mockMvc.perform(post(\"/logout\").with(csrf())\n .accept(MediaType.TEXT_HTML))\n .andExpect(status().is3xxRedirection())\n .andExpect(header().string(HttpHeaders.LOCATION, \"/login?logout\"));\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*\nimport org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*\nimport org.springframework.test.web.servlet.result.MockMvcResultMatchers.*\n\n@ExtendWith(SpringExtension::class)\n@ContextConfiguration(classes = [SecurityConfig::class])\n@WebAppConfiguration\nclass CsrfTests {\n\tprivate lateinit var mockMvc: MockMvc\n\n\t@BeforeEach\n\tfun setUp(applicationContext: WebApplicationContext) {\n mockMvc = MockMvcBuilders.webAppContextSetup(applicationContext)\n .apply<DefaultMockMvcBuilder>(springSecurity())\n .build()\n\t}\n\n\t@Test\n\tfun loginWhenValidCsrfTokenThenSuccess() {\n mockMvc.perform(post(\"/login\").with(csrf())\n .accept(MediaType.TEXT_HTML)\n .param(\"username\", \"user\")\n .param(\"password\", \"password\"))\n .andExpect(status().is3xxRedirection)\n .andExpect(header().string(HttpHeaders.LOCATION, \"/\"))\n\t}\n\n\t@Test\n\tfun loginWhenInvalidCsrfTokenThenForbidden() {\n mockMvc.perform(post(\"/login\").with(csrf().useInvalidToken())\n .accept(MediaType.TEXT_HTML)\n .param(\"username\", \"user\")\n .param(\"password\", \"password\"))\n .andExpect(status().isForbidden)\n\t}\n\n\t@Test\n\tfun loginWhenMissingCsrfTokenThenForbidden() {\n mockMvc.perform(post(\"/login\")\n .accept(MediaType.TEXT_HTML)\n .param(\"username\", \"user\")\n .param(\"password\", \"password\"))\n .andExpect(status().isForbidden)\n\t}\n\n\t@Test\n\t@WithMockUser\n\t@Throws(Exception::class)\n\tfun logoutWhenValidCsrfTokenThenSuccess() {\n mockMvc.perform(post(\"/logout\").with(csrf())\n .accept(MediaType.TEXT_HTML))\n .andExpect(status().is3xxRedirection)\n .andExpect(header().string(HttpHeaders.LOCATION, \"/login?logout\"))\n\t}\n}\n----\n======\n\n[[disable-csrf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "CSRF Testing", "heading_level": 2, "file_order": 121, "section_index": 20, "content_hash": "0f48283eb972f05b2b0277e32b6e024a05dbceb69a4bc9671b39896b36ea8f0c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:adc76424e86dfa96a5470e3da0c84275dd69e54fa89e732d188cf60f414e140c", "content": "By default, CSRF protection is enabled, which affects <<csrf-integration,integrating with the backend>> and <<csrf-testing,testing>> your application.\nBefore disabling CSRF protection, consider whether it xref:features/exploits/csrf.adoc#csrf-when[makes sense for your application].\n\nYou can also consider whether only certain endpoints do not require CSRF protection and configure an ignoring rule, as in the following example:\n\n[[disable-csrf-ignoring-configuration]]\n.Ignoring Requests\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .csrf((csrf) -> csrf\n .ignoringRequestMatchers(\"/api/*\")\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n csrf {\n ignoringRequestMatchers(\"/api/*\")\n }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<csrf request-matcher-ref=\"csrfMatcher\"/>\n</http>\n<b:bean id=\"csrfMatcher\"\n class=\"org.springframework.security.web.util.matcher.AndRequestMatcher\">\n <b:constructor-arg value=\"#{T(org.springframework.security.web.csrf.CsrfFilter).DEFAULT_CSRF_MATCHER}\"/>\n <b:constructor-arg>\n <b:bean class=\"org.springframework.security.web.util.matcher.NegatedRequestMatcher\">\n <b:bean class=\"org.springframework.security.config.http.PathPatternRequestMatcherFactoryBean\">\n <b:constructor-arg value=\"/api/*\"/>\n </b:bean>\n </b:bean>\n </b:constructor-arg>\n</b:bean>\n----\n======\n\nIf you need to disable CSRF protection, you can do so using the following configuration:\n\n[[disable-csrf-configuration]]\n.Disable CSRF\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .csrf((csrf) -> csrf.disable());\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n csrf {\n disable()\n }\n }\n return http.build()\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\t<csrf disabled=\"true\"/>\n</http>\n----\n======\n\n[[csrf-considerations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Disable CSRF Protection", "heading_level": 2, "file_order": 121, "section_index": 21, "content_hash": "adc76424e86dfa96a5470e3da0c84275dd69e54fa89e732d188cf60f414e140c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:548af709d5d01033d00f688153f7dd16c327142b20e320330c92210ef27cd3b2", "content": "There are a few special considerations when implementing protection against CSRF attacks.\nThis section discusses those considerations as they pertain to servlet environments.\nSee xref:features/exploits/csrf.adoc#csrf-considerations[CSRF Considerations] for a more general discussion.\n\n[[csrf-considerations-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "CSRF Considerations", "heading_level": 2, "file_order": 121, "section_index": 22, "content_hash": "548af709d5d01033d00f688153f7dd16c327142b20e320330c92210ef27cd3b2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:5414bdce956d98141f08a4b9fd9fedf13403ac298727d5b24e15101a8c1b85df", "content": "It is important to xref:features/exploits/csrf.adoc#csrf-considerations-login[require CSRF for log in] requests to protect against forging log in attempts.\nSpring Security's servlet support does this out of the box.\n\n[[csrf-considerations-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Logging In", "heading_level": 3, "file_order": 121, "section_index": 23, "content_hash": "5414bdce956d98141f08a4b9fd9fedf13403ac298727d5b24e15101a8c1b85df", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:7f9b82115d5290e07ac761db2b2104aa711a46970ff6bce3448769939fd393e3", "content": "It is important to xref:features/exploits/csrf.adoc#csrf-considerations-logout[require CSRF for log out] requests to protect against forging logout attempts.\nIf CSRF protection is enabled (the default), Spring Security's `LogoutFilter` will only process HTTP POST requests.\nThis ensures that logging out requires a CSRF token and that a malicious user cannot forcibly log your users out.\n\nThe easiest approach is to use a form to log the user out.\nIf you really want a link, you can use JavaScript to have the link perform a POST (maybe on a hidden form).\nFor browsers with JavaScript that is disabled, you can optionally have the link take the user to a log out confirmation page that performs the POST.\n\nIf you really want to use HTTP GET with logout, you can do so.\nHowever, remember that this is generally not recommended.\nFor example, the following logs out when the `/logout` URL is requested with any HTTP method:\n\n.Log Out with Any HTTP Method\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .logout((logout) -> logout\n .logoutRequestMatcher(PathPatternRequestMatcher.withDefaults().matcher(\"/logout\"))\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n logout {\n logoutRequestMatcher = PathPatternRequestMatcher.withDefaults().matcher(\"/logout\")\n }\n }\n return http.build()\n }\n}\n----\n======\n\nSee the xref:servlet/authentication/logout.adoc[Logout] chapter for more information.\n\n[[considerations-csrf-timeouts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Logging Out", "heading_level": 3, "file_order": 121, "section_index": 24, "content_hash": "7f9b82115d5290e07ac761db2b2104aa711a46970ff6bce3448769939fd393e3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:26e4d03779cdc81fac2923a96d0ab7be77a37dc35c0407b8b16cfb396998764b", "content": "By default, Spring Security stores the CSRF token in the `HttpSession` using the <<csrf-token-repository-httpsession,`HttpSessionCsrfTokenRepository`>>.\nThis can lead to a situation where the session expires, leaving no CSRF token to validate against.\n\nWe have already discussed xref:features/exploits/csrf.adoc#csrf-considerations-timeouts[general solutions] to session timeouts.\nThis section discusses the specifics of CSRF timeouts as it pertains to the servlet support.\n\nYou can change the storage of the CSRF token to be in a cookie.\nFor details, see the <<csrf-token-repository-cookie>> section.\n\nIf a token does expire, you might want to customize how it is handled by specifying a <<csrf-access-denied-handler,custom `AccessDeniedHandler`>>.\nThe custom `AccessDeniedHandler` can process the `InvalidCsrfTokenException` any way you like.\n\n[[csrf-considerations-multipart]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "CSRF and Session Timeouts", "heading_level": 3, "file_order": 121, "section_index": 25, "content_hash": "26e4d03779cdc81fac2923a96d0ab7be77a37dc35c0407b8b16cfb396998764b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:129fdc0c6a0c40db611bf68c071a9dff6dff9d27ea1a6785256dccbffcb00d37", "content": "We have xref:features/exploits/csrf.adoc#csrf-considerations-multipart[already discussed] how protecting multipart requests (file uploads) from CSRF attacks causes a https://en.wikipedia.org/wiki/Chicken_or_the_egg[chicken and the egg] problem.\nWhen JavaScript is available, we _recommend_ <<csrf-integration-javascript-other,including the CSRF token in an HTTP request header>> to side-step the issue.\n\nIf JavaScript is not available, the following sections discuss options for placing the CSRF token in the <<csrf-considerations-multipart-body,body>> and <<csrf-considerations-multipart-url,url>> within a servlet application.\n\n[NOTE]\n====\nYou can find more information about using multipart forms with Spring in the https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart[Multipart Resolver] section of the Spring reference and the {spring-framework-api-url}org/springframework/web/multipart/support/MultipartFilter.html[`MultipartFilter` javadoc].\n====\n\n[[csrf-considerations-multipart-body]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Multipart (file upload)", "heading_level": 3, "file_order": 121, "section_index": 26, "content_hash": "129fdc0c6a0c40db611bf68c071a9dff6dff9d27ea1a6785256dccbffcb00d37", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:ec17b2fbf03514740c6a424cf1d2c9a42a6ee0fdce25245a6a880312c99cc0e7", "content": "We have xref:features/exploits/csrf.adoc#csrf-considerations-multipart-body[already discussed] the tradeoffs of placing the CSRF token in the body.\nIn this section, we discuss how to configure Spring Security to read the CSRF from the body.\n\nTo read the CSRF token from the body, the `MultipartFilter` is specified before the Spring Security filter.\nSpecifying the `MultipartFilter` before the Spring Security filter means that there is no authorization for invoking the `MultipartFilter`, which means anyone can place temporary files on your server.\nHowever, only authorized users can submit a file that is processed by your application.\nIn general, this is the recommended approach because the temporary file upload should have a negligible impact on most servers.\n\n.Configure `MultipartFilter`\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class SecurityApplicationInitializer extends AbstractSecurityWebApplicationInitializer {\n\n\t@Override\n\tprotected void beforeSpringSecurityFilterChain(ServletContext servletContext) {\n insertFilters(servletContext, new MultipartFilter());\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass SecurityApplicationInitializer : AbstractSecurityWebApplicationInitializer() {\n override fun beforeSpringSecurityFilterChain(servletContext: ServletContext?) {\n insertFilters(servletContext, MultipartFilter())\n }\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<filter>\n\t<filter-name>MultipartFilter</filter-name>\n\t<filter-class>org.springframework.web.multipart.support.MultipartFilter</filter-class>\n</filter>\n<filter>\n\t<filter-name>springSecurityFilterChain</filter-name>\n\t<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n</filter>\n<filter-mapping>\n\t<filter-name>MultipartFilter</filter-name>\n\t<url-pattern>/*</url-pattern>\n</filter-mapping>\n<filter-mapping>\n\t<filter-name>springSecurityFilterChain</filter-name>\n\t<url-pattern>/*</url-pattern>\n</filter-mapping>\n----\n======\n\n[NOTE]\n====\nTo ensure that `MultipartFilter` is specified before the Spring Security filter with XML configuration, you can ensure the `<filter-mapping>` element of the `MultipartFilter` is placed before the `springSecurityFilterChain` within the `web.xml` file.\n====\n\n[[csrf-considerations-multipart-url]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Place CSRF Token in the Body", "heading_level": 4, "file_order": 121, "section_index": 27, "content_hash": "ec17b2fbf03514740c6a424cf1d2c9a42a6ee0fdce25245a6a880312c99cc0e7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:eda5c47c3cb2f5b40907f32967d6eebd283cb42641b78a4cab6fa6811fc1edcf", "content": "If letting unauthorized users upload temporary files is not acceptable, an alternative is to place the `MultipartFilter` after the Spring Security filter and include the CSRF as a query parameter in the action attribute of the form.\nSince the `CsrfToken` is exposed as an <<csrf-token-request-handler,`HttpServletRequest` attribute named `_csrf`>>, we can use that to create an `action` with the CSRF token in it.\nThe following example does this with a JSP:\n\n.CSRF Token in Action\n[source,html]\n----\n<form method=\"post\"\n\taction=\"./upload?${_csrf.parameterName}=${_csrf.token}\"\n\tenctype=\"multipart/form-data\">\n----\n\n[[csrf-considerations-override-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Include a CSRF Token in a URL", "heading_level": 4, "file_order": 121, "section_index": 28, "content_hash": "eda5c47c3cb2f5b40907f32967d6eebd283cb42641b78a4cab6fa6811fc1edcf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:aeebb6360de4abf8dd1071f9527f481c69812f4c2f6e48524497b32421975c81", "content": "We have xref:features/exploits/csrf.adoc#csrf-considerations-multipart-body[already discussed] the trade-offs of placing the CSRF token in the body.\n\nIn Spring's Servlet support, overriding the HTTP method is done by using {spring-framework-api-url}org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html[`HiddenHttpMethodFilter`].\nYou can find more information in the https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-rest-method-conversion[HTTP Method Conversion] section of the reference documentation.\n\n[[csrf-further-reading]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "HiddenHttpMethodFilter", "heading_level": 3, "file_order": 121, "section_index": 29, "content_hash": "aeebb6360de4abf8dd1071f9527f481c69812f4c2f6e48524497b32421975c81", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:6e384b1d0790def6ac006dd227d3bf8f58503785f21ca8eec27935489cddc615", "content": "Now that you have reviewed CSRF protection, consider learning more about xref:servlet/exploits/index.adoc[exploit protection] including xref:servlet/exploits/headers.adoc[secure headers] and the xref:servlet/exploits/firewall.adoc[HTTP firewall] or move on to learning how to xref:servlet/test/index.adoc[test] your application.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/csrf.adoc", "title": "csrf", "heading": "Further Reading", "heading_level": 2, "file_order": 121, "section_index": 30, "content_hash": "6e384b1d0790def6ac006dd227d3bf8f58503785f21ca8eec27935489cddc615", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/csrf.adoc"}}
{"id": "sha256:e8ac428fed67c6afbe3c8dc0b0325fd789a8c2ae237cd366b92fbf8bdde45dfa", "content": "[[servlet-httpfirewall]]\nSpring Security has several areas where patterns you have defined are tested against incoming requests to decide how the request should be handled.\nThis occurs when the `FilterChainProxy` decides which filter chain a request should be passed through and when the `FilterSecurityInterceptor` decides which security constraints apply to a request.\nIt is important to understand what the mechanism is and what URL value is used when testing against the patterns that you define.\n\nThe servlet specification defines several properties for the `HttpServletRequest` that are accessible via getter methods and that we might want to match against.\nThese are the `contextPath`, `servletPath`, `pathInfo`, and `queryString`.\nSpring Security is only interested in securing paths within the application, so the `contextPath` is ignored.\nUnfortunately, the servlet spec does not define exactly what the values of `servletPath` and `pathInfo` contain for a particular request URI.\nFor example, each path segment of a URL may contain parameters, as defined in https://www.ietf.org/rfc/rfc2396.txt[RFC 2396]\n(You have probably seen this when a browser does not support cookies and the `jsessionid` parameter is appended to the URL after a semicolon.\nHowever, the RFC allows the presence of these parameters in any path segment of the URL.)\nThe Specification does not clearly state whether these should be included in the `servletPath` and `pathInfo` values and the behavior varies between different servlet containers.\nThere is a danger that, when an application is deployed in a container that does not strip path parameters from these values, an attacker could add them to the requested URL to cause a pattern match to succeed or fail unexpectedly.\n(The original values will be returned once the request leaves the `FilterChainProxy`, so will still be available to the application.)\nOther variations in the incoming URL are also possible.\nFor example, it could contain path-traversal sequences (such as `/../`) or multiple forward slashes (`//`) that could also cause pattern-matches to fail.\nSome containers normalize these out before performing the servlet mapping, but others do not.\nTo protect against issues like these, `FilterChainProxy` uses an `HttpFirewall` strategy to check and wrap the request.\nBy default, un-normalized requests are automatically rejected, and path parameters and duplicate slashes are removed for matching purposes.\n(So, for example, an original request path of `/secure;hack=1/somefile.html;hack=2` is returned as `/secure/somefile.html`.)\nIt is, therefore, essential that a `FilterChainProxy` is used to manage the security filter chain.\nNote that the `servletPath` and `pathInfo` values are decoded by the container, so your application should not have any valid paths that contain semi-colons, as these parts are removed for matching purposes.\n\nAs mentioned earlier, the default strategy is to use Ant-style paths for matching, and this is likely to be the best choice for most users.\nThe strategy is implemented in the class `PathPatternRequestMatcher`, which uses Spring's `PathPattern` to perform a case-insensitive match of the pattern against the concatenated `servletPath` and `pathInfo`, ignoring the `queryString`.\n\nIf you need a more powerful matching strategy, you can use regular expressions.\nThe strategy implementation is then `RegexRequestMatcher`.\nSee the javadoc:org.springframework.security.web.util.matcher.RegexRequestMatcher[] Javadoc for more information.\n\nIn practice, we recommend that you use method security at your service layer, to control access to your application, rather than rely entirely on the use of security constraints defined at the web-application level.\nURLs change, and it is difficult to take into account all the possible URLs that an application might support and how requests might be manipulated.\nYou should restrict yourself to using a few simple Ant paths that are simple to understand.\nAlways try to use a \"`deny-by-default`\" approach, where you have a catch-all wildcard (`/**` or `**`) defined last to deny access.\n\nSecurity defined at the service layer is much more robust and harder to bypass, so you should always take advantage of Spring Security's method security options.\n\nThe `HttpFirewall` also prevents https://www.owasp.org/index.php/HTTP_Response_Splitting[HTTP Response Splitting] by rejecting new line characters in the HTTP Response headers.\n\nBy default, the `StrictHttpFirewall` implementation is used.\nThis implementation rejects requests that appear to be malicious.\nIf it is too strict for your needs, you can customize what types of requests are rejected.\nHowever, it is important that you do so knowing that this can open your application up to attacks.\nFor example, if you wish to use Spring MVC's matrix variables, you could use the following configuration:\n\n.Allow Matrix Variables\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic StrictHttpFirewall httpFirewall() {\n StrictHttpFirewall firewall = new StrictHttpFirewall();\n firewall.setAllowSemicolon(true);\n return firewall;\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<b:bean id=\"httpFirewall\"\n class=\"org.springframework.security.web.firewall.StrictHttpFirewall\"\n p:allowSemicolon=\"true\"/>\n\n<http-firewall ref=\"httpFirewall\"/>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun httpFirewall(): StrictHttpFirewall {\n val firewall = StrictHttpFirewall()\n firewall.setAllowSemicolon(true)\n return firewall\n}\n----\n======\n\nTo protect against https://www.owasp.org/index.php/Cross_Site_Tracing[Cross Site Tracing (XST)] and https://www.owasp.org/index.php/Test_HTTP_Methods_(OTG-CONFIG-006)[HTTP Verb Tampering], the `StrictHttpFirewall` provides an allowed list of valid HTTP methods that are allowed.\nThe default valid methods are `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, and `PUT`.\nIf your application needs to modify the valid methods, you can configure a custom `StrictHttpFirewall` bean.\nThe following example allows only HTTP `GET` and `POST` methods:\n\n.Allow Only GET & POST\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic StrictHttpFirewall httpFirewall() {\n StrictHttpFirewall firewall = new StrictHttpFirewall();\n firewall.setAllowedHttpMethods(Arrays.asList(\"GET\", \"POST\"));\n return firewall;\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<b:bean id=\"httpFirewall\"\n class=\"org.springframework.security.web.firewall.StrictHttpFirewall\"\n p:allowedHttpMethods=\"GET,POST\"/>\n\n<http-firewall ref=\"httpFirewall\"/>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun httpFirewall(): StrictHttpFirewall {\n val firewall = StrictHttpFirewall()\n firewall.setAllowedHttpMethods(listOf(\"GET\", \"POST\"))\n return firewall\n}\n----\n======\n\n[TIP]\n====\nIf you use `new MockHttpServletRequest()`, it currently creates an HTTP method as an empty String (`\"\"`).\nThis is an invalid HTTP method and is rejected by Spring Security.\nYou can resolve this by replacing it with `new MockHttpServletRequest(\"GET\", \"\")`.\nSee https://jira.spring.io/browse/SPR-16851[SPR_16851] for an issue that requests improving this.\n====\n\nIf you must allow any HTTP method (not recommended), you can use `StrictHttpFirewall.setUnsafeAllowAnyHttpMethod(true)`.\nDoing so entirely disables validation of the HTTP method.\n\n[[servlet-httpfirewall-headers-parameters]]\n`StrictHttpFirewall` also checks header names and values and parameter names.\nIt requires that each character have a defined code point and not be a control character.\n\nThis requirement can be relaxed or adjusted as necessary by using the following methods:\n\n* `StrictHttpFirewall#setAllowedHeaderNames(Predicate)`\n* `StrictHttpFirewall#setAllowedHeaderValues(Predicate)`\n* `StrictHttpFirewall#setAllowedParameterNames(Predicate)`\n\n[NOTE]\n====\nParameter values can be also controlled with `setAllowedParameterValues(Predicate)`.\n====\n\nFor example, to switch off this check, you can wire your `StrictHttpFirewall` with `Predicate` instances that always return `true`:\n\n.Allow Any Header Name, Header Value, and Parameter Name\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic StrictHttpFirewall httpFirewall() {\n StrictHttpFirewall firewall = new StrictHttpFirewall();\n firewall.setAllowedHeaderNames((header) -> true);\n firewall.setAllowedHeaderValues((header) -> true);\n firewall.setAllowedParameterNames((parameter) -> true);\n return firewall;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun httpFirewall(): StrictHttpFirewall {\n val firewall = StrictHttpFirewall()\n firewall.setAllowedHeaderNames { true }\n firewall.setAllowedHeaderValues { true }\n firewall.setAllowedParameterNames { true }\n return firewall\n}\n----\n======\n\nAlternatively, there might be a specific value that you need to allow.\n\nFor example, iPhone X uses a `User-Agent` that includes a character that is not in the ISO-8859-1 charset.\nDue to this fact, some application servers parse this value into two separate characters, the latter being an undefined character.\n\nYou can address this with the `setAllowedHeaderValues` method:\n\n.Allow Certain User Agents\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic StrictHttpFirewall httpFirewall() {\n StrictHttpFirewall firewall = new StrictHttpFirewall();\n Pattern allowed = Pattern.compile(\"[\\\\p{IsAssigned}&&[^\\\\p{IsControl}]]*\");\n Pattern userAgent = ...;\n firewall.setAllowedHeaderValues((header) -> allowed.matcher(header).matches() || userAgent.matcher(header).matches());\n return firewall;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun httpFirewall(): StrictHttpFirewall {\n val firewall = StrictHttpFirewall()\n val allowed = Pattern.compile(\"[\\\\p{IsAssigned}&&[^\\\\p{IsControl}]]*\")\n val userAgent = Pattern.compile(...)\n firewall.setAllowedHeaderValues { allowed.matcher(it).matches() || userAgent.matcher(it).matches() }\n return firewall\n}\n----\n======\n\nIn the case of header values, you may instead consider parsing them as UTF-8 at verification time:\n\n.Parse Headers As UTF-8\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nfirewall.setAllowedHeaderValues((header) -> {\n String parsed = new String(header.getBytes(ISO_8859_1), UTF_8);\n return allowed.matcher(parsed).matches();\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nfirewall.setAllowedHeaderValues {\n val parsed = String(header.getBytes(ISO_8859_1), UTF_8)\n return allowed.matcher(parsed).matches()\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/firewall.adoc", "title": "firewall", "heading": "firewall", "heading_level": 1, "file_order": 122, "section_index": 0, "content_hash": "e8ac428fed67c6afbe3c8dc0b0325fd789a8c2ae237cd366b92fbf8bdde45dfa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/firewall.adoc"}}
{"id": "sha256:946b93d0b4a62ba4c4c80b6331fd89df962b341a2910e038231757f80bbbeac2", "content": "[[servlet-headers]]\n\nYou can use xref:features/exploits/headers.adoc#headers[Security HTTP Response Headers] to increase the security of web applications.\nThis section is dedicated to servlet-based support for Security HTTP Response Headers.\n\n[[servlet-headers-default]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "headers", "heading_level": 1, "file_order": 123, "section_index": 0, "content_hash": "946b93d0b4a62ba4c4c80b6331fd89df962b341a2910e038231757f80bbbeac2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:7d6aed529d5e948c9492fa0d7e67cc16f57e9c61f849d85348c5d9296a044ea2", "content": "Spring Security provides a xref:features/exploits/headers.adoc#headers-default[default set of Security HTTP Response Headers] to provide secure defaults.\nWhile each of these headers are considered best practice, it should be noted that not all clients use the headers, so additional testing is encouraged.\n\nYou can customize specific headers.\nFor example, assume that you want the defaults but you wish to specify `SAMEORIGIN` for <<servlet-headers-frame-options,X-Frame-Options>>.\n\nYou can do so with the following configuration:\n\n.Customize Default Security Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .frameOptions((frameOptions) -> frameOptions\n .sameOrigin()\n )\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <frame-options policy=\"SAMEORIGIN\" />\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n headers {\n frameOptions {\n sameOrigin = true\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\nIf you do not want the defaults to be added and want explicit control over what should be used, you can disable the defaults.\nThe next code listing shows how to do so.\n\nIf you use Spring Security's configuration, the following adds only xref:features/exploits/headers.adoc#headers-cache-control[Cache Control]:\n\n.Customize Cache Control Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n // do not use any default headers unless explicitly listed\n .defaultsDisabled()\n .cacheControl(withDefaults())\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers defaults-disabled=\"true\">\n <cache-control/>\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n headers {\n // do not use any default headers unless explicitly listed\n defaultsDisabled = true\n cacheControl {\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\nIf necessary, you can disable all of the HTTP Security response headers with the following configuration:\n\n.Disable All HTTP Security Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers.disable());\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers disabled=\"true\" />\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n headers {\n disable()\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-cache-control]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "Default Security Headers", "heading_level": 2, "file_order": 123, "section_index": 1, "content_hash": "7d6aed529d5e948c9492fa0d7e67cc16f57e9c61f849d85348c5d9296a044ea2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:0ae264f9deb634685304cc9ea52f91707a0a514bcfef8afe5aefe238edb2b94a", "content": "Spring Security includes xref:features/exploits/headers.adoc#headers-cache-control[Cache Control] headers by default.\n\nHowever, if you actually want to cache specific responses, your application can selectively invoke https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String,java.lang.String)[`HttpServletResponse.setHeader(String,String)`] to override the header set by Spring Security.\nYou can use this to ensure that content (such as CSS, JavaScript, and images) is properly cached.\n\nWhen you use Spring Web MVC, this is typically done within your configuration.\nYou can find details on how to do this in the https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources[Static Resources] portion of the Spring Reference documentation\n\nIf necessary, you can also disable Spring Security's cache control HTTP response headers.\n\n.Cache Control Disabled\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .cacheControl((cache) -> cache.disable())\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <cache-control disabled=\"true\"/>\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n headers {\n cacheControl {\n disable()\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-content-type-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "Cache Control", "heading_level": 2, "file_order": 123, "section_index": 2, "content_hash": "0ae264f9deb634685304cc9ea52f91707a0a514bcfef8afe5aefe238edb2b94a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:7f340169095c7184c4efc680a6508542a85535bb01712f4e5814e5d3e20ef32a", "content": "Spring Security includes xref:features/exploits/headers.adoc#headers-content-type-options[Content-Type] headers by default.\nHowever, you can disable it:\n\n.Content Type Options Disabled\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .contentTypeOptions((contentTypeOptions) -> contentTypeOptions.disable())\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <content-type-options disabled=\"true\"/>\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n headers {\n contentTypeOptions {\n disable()\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-hsts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "Content Type Options", "heading_level": 2, "file_order": 123, "section_index": 3, "content_hash": "7f340169095c7184c4efc680a6508542a85535bb01712f4e5814e5d3e20ef32a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:1a052dbf426cf07a4a2fb28f7398df3196e23d1990e4295194cf5657cf37436d", "content": "By default, Spring Security provides the xref:features/exploits/headers.adoc#headers-hsts[Strict Transport Security] header.\nHowever, you can explicitly customize the results.\nThe following example explicitly provides HSTS:\n\n.Strict Transport Security\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .httpStrictTransportSecurity((hsts) -> hsts\n .includeSubDomains(true)\n .preload(true)\n .maxAgeInSeconds(31536000)\n )\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <hsts\n include-subdomains=\"true\"\n max-age-seconds=\"31536000\"\n preload=\"true\" />\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n headers {\n httpStrictTransportSecurity {\n includeSubDomains = true\n preload = true\n maxAgeInSeconds = 31536000\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-hpkp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "HTTP Strict Transport Security (HSTS)", "heading_level": 2, "file_order": 123, "section_index": 4, "content_hash": "1a052dbf426cf07a4a2fb28f7398df3196e23d1990e4295194cf5657cf37436d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:32a07adc0cf1528b4bf51f9ff189888507cd5279fcdae58d90bac9cfdfcfa2d0", "content": "Spring Security provides servlet support for xref:features/exploits/headers.adoc#headers-hpkp[HTTP Public Key Pinning], but it is xref:features/exploits/headers.adoc#headers-hpkp-deprecated[no longer recommended].\n\nYou can enable HPKP headers with the following configuration:\n\n.HTTP Public Key Pinning\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .httpPublicKeyPinning((hpkp) -> hpkp\n .includeSubDomains(true)\n .reportUri(\"https://example.net/pkp-report\")\n .addSha256Pins(\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\", \"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\")\n )\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <hpkp\n include-subdomains=\"true\"\n report-uri=\"https://example.net/pkp-report\">\n <pins>\n <pin algorithm=\"sha256\">d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=</pin>\n <pin algorithm=\"sha256\">E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=</pin>\n </pins>\n </hpkp>\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n headers {\n httpPublicKeyPinning {\n includeSubDomains = true\n reportUri = \"https://example.net/pkp-report\"\n pins = mapOf(\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\" to \"sha256\",\n \"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\" to \"sha256\")\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-frame-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "HTTP Public Key Pinning (HPKP)", "heading_level": 2, "file_order": 123, "section_index": 5, "content_hash": "32a07adc0cf1528b4bf51f9ff189888507cd5279fcdae58d90bac9cfdfcfa2d0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:847537bc424fc452d5d343233c62e43c8f1e69dcc708c898a6412cc3b99c2856", "content": "By default, Spring Security instructs browsers to block reflected XSS attacks by using the xref:features/exploits/headers.adoc#headers-frame-options[X-Frame-Options].\n\nFor example, the following configuration specifies that Spring Security should no longer instruct browsers to block the content:\n\n.X-Frame-Options: SAMEORIGIN\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .frameOptions((frameOptions) -> frameOptions\n .sameOrigin()\n )\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <frame-options\n policy=\"SAMEORIGIN\" />\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n headers {\n frameOptions {\n sameOrigin = true\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-xss-protection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "X-Frame-Options", "heading_level": 2, "file_order": 123, "section_index": 6, "content_hash": "847537bc424fc452d5d343233c62e43c8f1e69dcc708c898a6412cc3b99c2856", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:e045abb3918eacf447eec482dfc88e1c225dda78e30b2ea113e7b0b24a3cc284", "content": "By default, Spring Security instructs browsers to disable the XSS Auditor by using <<headers-xss-protection,X-XSS-Protection header>.\nHowever, you can change this default.\nFor example, the following configuration specifies that Spring Security instruct compatible browsers to enable filtering,\nand block the content:\n\n.X-XSS-Protection Customization\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .xssProtection((xss) -> xss\n .headerValue(XXssProtectionHeaderWriter.HeaderValue.ENABLED_MODE_BLOCK)\n )\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <xss-protection headerValue=\"1; mode=block\"/>\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n // ...\n http {\n headers {\n xssProtection {\n headerValue = XXssProtectionHeaderWriter.HeaderValue.ENABLED_MODE_BLOCK\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-csp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "X-XSS-Protection", "heading_level": 2, "file_order": 123, "section_index": 7, "content_hash": "e045abb3918eacf447eec482dfc88e1c225dda78e30b2ea113e7b0b24a3cc284", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:678d994d69e5c0a80003d7630b0d80c49094dc4ef27a6b989165b69b37a12661", "content": "Spring Security does not add xref:features/exploits/headers.adoc#headers-csp[Content Security Policy] by default, because a reasonable default is impossible to know without knowing the context of the application.\nThe web application author must declare the security policy (or policies) to enforce or monitor for the protected resources.\n\nConsider the following security policy:\n\n.Content Security Policy Example\n[source,http]\n----\nContent-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\n----\n\nGiven the preceding security policy, you can enable the CSP header:\n\n.Content Security Policy\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .contentSecurityPolicy((csp) -> csp\n .policyDirectives(\"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\")\n )\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <content-security-policy\n policy-directives=\"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\" />\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n headers {\n contentSecurityPolicy {\n policyDirectives = \"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\"\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\nTo enable the CSP `report-only` header, provide the following configuration:\n\n.Content Security Policy Report Only\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .contentSecurityPolicy((csp) -> csp\n .policyDirectives(\"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\")\n .reportOnly()\n )\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <content-security-policy\n policy-directives=\"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\"\n report-only=\"true\" />\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n headers {\n contentSecurityPolicy {\n policyDirectives = \"script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/\"\n reportOnly = true\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-referrer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "Content Security Policy (CSP)", "heading_level": 2, "file_order": 123, "section_index": 8, "content_hash": "678d994d69e5c0a80003d7630b0d80c49094dc4ef27a6b989165b69b37a12661", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:ce3a36e462cf7155f65da2c1c1527058acb061f4615df64a39cc83ab045624c0", "content": "Spring Security does not add xref:features/exploits/headers.adoc#headers-referrer[Referrer Policy] headers by default.\nYou can enable the Referrer Policy header by using the configuration:\n\n.Referrer Policy\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .referrerPolicy((referrer) -> referrer\n .policy(ReferrerPolicy.SAME_ORIGIN)\n )\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <referrer-policy policy=\"same-origin\" />\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n headers {\n referrerPolicy {\n policy = ReferrerPolicy.SAME_ORIGIN\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-feature]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "Referrer Policy", "heading_level": 2, "file_order": 123, "section_index": 9, "content_hash": "ce3a36e462cf7155f65da2c1c1527058acb061f4615df64a39cc83ab045624c0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:07fccf51297c0960bc459828b0d3d5d6aa4b9dabe13b0ba7dccb9e4dd9c4e8ad", "content": "Spring Security does not add xref:features/exploits/headers.adoc#headers-feature[Feature Policy] headers by default.\nConsider the following `Feature-Policy` header:\n\n.Feature-Policy Example\n[source]\n----\nFeature-Policy: geolocation 'self'\n----\n\nYou can enable the preceding feature policy header by using the following configuration:\n\n.Feature-Policy\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .featurePolicy(\"geolocation 'self'\")\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <feature-policy policy-directives=\"geolocation 'self'\" />\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n headers {\n featurePolicy(\"geolocation 'self'\")\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-permissions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "Feature Policy", "heading_level": 2, "file_order": 123, "section_index": 10, "content_hash": "07fccf51297c0960bc459828b0d3d5d6aa4b9dabe13b0ba7dccb9e4dd9c4e8ad", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:b07e3af07873c7247589161ef0070c26f05308c85f284a7cfe63f30f10f0b6e7", "content": "Spring Security does not add xref:features/exploits/headers.adoc#headers-permissions[Permissions Policy] headers by default.\nConsider the following `Permissions-Policy` header:\n\n.Permissions-Policy Example\n[source]\n----\nPermissions-Policy: geolocation=(self)\n----\n\nYou can enable the preceding permissions policy header using the following configuration:\n\n.Permissions-Policy\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .permissionsPolicy((permissions) -> permissions\n .policy(\"geolocation=(self)\")\n )\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <permissions-policy policy=\"geolocation=(self)\" />\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n headers {\n permissionPolicy {\n policy = \"geolocation=(self)\"\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-clear-site-data]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "Permissions Policy", "heading_level": 2, "file_order": 123, "section_index": 11, "content_hash": "b07e3af07873c7247589161ef0070c26f05308c85f284a7cfe63f30f10f0b6e7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:e376cc84e8a05e4ceca063a3c34225434947058ca72dcacbf98eb0a3fea79cc4", "content": "Spring Security does not add xref:features/exploits/headers.adoc#headers-clear-site-data[Clear-Site-Data] headers by default.\nConsider the following Clear-Site-Data header:\n\n.Clear-Site-Data Example\n----\nClear-Site-Data: \"cache\", \"cookies\"\n----\n\nYou can send the preceding header on log out with the following configuration:\n\n.Clear-Site-Data\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .logout((logout) -> logout\n .addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(CACHE, COOKIES)))\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n logout {\n addLogoutHandler(HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter(CACHE, COOKIES)))\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "Clear Site Data", "heading_level": 2, "file_order": 123, "section_index": 12, "content_hash": "e376cc84e8a05e4ceca063a3c34225434947058ca72dcacbf98eb0a3fea79cc4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:a4f930e2e75c9f323f9499a2adb2710f22fd42623852538c8487fadc4411cddc", "content": "Spring Security has mechanisms to make it convenient to add the more common security headers to your application.\nHowever, it also provides hooks to enable adding custom headers.\n\n[[servlet-headers-static]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "Custom Headers", "heading_level": 2, "file_order": 123, "section_index": 13, "content_hash": "a4f930e2e75c9f323f9499a2adb2710f22fd42623852538c8487fadc4411cddc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:b15e757e153db64da80efeaee3a9dc486d900755fe74eed20a19f718da81f1ec", "content": "There may be times when you wish to inject custom security headers that are not supported out of the box into your application.\nConsider the following custom security header:\n\n[source]\n----\nX-Custom-Security-Header: header-value\n----\n\nGiven the preceding header, you could add the headers to the response by using the following configuration:\n\n.StaticHeadersWriter\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .addHeaderWriter(new StaticHeadersWriter(\"X-Custom-Security-Header\",\"header-value\"))\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <header name=\"X-Custom-Security-Header\" value=\"header-value\"/>\n\t</headers>\n</http>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n headers {\n addHeaderWriter(StaticHeadersWriter(\"X-Custom-Security-Header\",\"header-value\"))\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-headers-writer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "Static Headers", "heading_level": 3, "file_order": 123, "section_index": 14, "content_hash": "b15e757e153db64da80efeaee3a9dc486d900755fe74eed20a19f718da81f1ec", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:c95fd9de78e36e579b45327dc64c54126ea244bef9cb11d324d5320623465cea", "content": "When the namespace or Java configuration does not support the headers you want, you can create a custom `HeadersWriter` instance or even provide a custom implementation of the `HeadersWriter`.\n\nThe next example use a custom instance of `XFrameOptionsHeaderWriter`.\nIf you wanted to explicitly configure <<servlet-headers-frame-options>>, you could do so with the following configuration:\n\n.Headers Writer\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .addHeaderWriter(new XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN))\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <header ref=\"frameOptionsWriter\"/>\n\t</headers>\n</http>\n<!-- Requires the c-namespace.\nSee https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-c-namespace\n-->\n<beans:bean id=\"frameOptionsWriter\"\n\tclass=\"org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter\"\n\tc:frameOptionsMode=\"SAMEORIGIN\"/>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n headers {\n addHeaderWriter(XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN))\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[headers-delegatingrequestmatcherheaderwriter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "Headers Writer", "heading_level": 3, "file_order": 123, "section_index": 15, "content_hash": "c95fd9de78e36e579b45327dc64c54126ea244bef9cb11d324d5320623465cea", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:a8c3147c7e0727e539d0d608a704761cbdb954f31011fde80218605db598c326", "content": "At times, you may want to write a header only for certain requests.\nFor example, perhaps you want to protect only your login page from being framed.\nYou could use the `DelegatingRequestMatcherHeaderWriter` to do so.\n\nThe following configuration example uses `DelegatingRequestMatcherHeaderWriter`:\n\n.DelegatingRequestMatcherHeaderWriter Java Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n RequestMatcher matcher = PathPatternRequestMatcher.withDefaults().matcher(\"/login\");\n DelegatingRequestMatcherHeaderWriter headerWriter =\n new DelegatingRequestMatcherHeaderWriter(matcher,new XFrameOptionsHeaderWriter());\n http\n // ...\n .headers((headers) -> headers\n .frameOptions((frameOptions) -> frameOptions.disable())\n .addHeaderWriter(headerWriter)\n );\n return http.build();\n\t}\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<!-- ... -->\n\n\t<headers>\n <frame-options disabled=\"true\"/>\n <header ref=\"headerWriter\"/>\n\t</headers>\n</http>\n\n<beans:bean id=\"headerWriter\"\n\tclass=\"org.springframework.security.web.header.writers.DelegatingRequestMatcherHeaderWriter\">\n\t<beans:constructor-arg>\n <bean class=\"org.springframework.security.config.http.PathPatternRequestMatcherFactoryBean\"\n c:pattern=\"/login\"/>\n\t</beans:constructor-arg>\n\t<beans:constructor-arg>\n <beans:bean\n class=\"org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter\"/>\n\t</beans:constructor-arg>\n</beans:bean>\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n val matcher: RequestMatcher = PathPatternRequestMatcher.withDefaults().matcher(\"/login\")\n val headerWriter = DelegatingRequestMatcherHeaderWriter(matcher, XFrameOptionsHeaderWriter())\n http {\n headers {\n frameOptions {\n disable()\n }\n addHeaderWriter(headerWriter)\n }\n }\n return http.build()\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/headers.adoc", "title": "headers", "heading": "DelegatingRequestMatcherHeaderWriter", "heading_level": 3, "file_order": 123, "section_index": 16, "content_hash": "a8c3147c7e0727e539d0d608a704761cbdb954f31011fde80218605db598c326", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/headers.adoc"}}
{"id": "sha256:91305fb04461ca3445a770339b0cbab138d6e2751a35fec99ab66ecdfbfa3b2d", "content": "[[servlet-http]]\n\nAll HTTP-based communication should be protected xref:features/exploits/http.adoc#http[using TLS].\n\nThis section discusses the details of servlet-specific features that assist with HTTPS usage.\n\n[[servlet-http-redirect]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/http.adoc", "title": "http", "heading": "http", "heading_level": 1, "file_order": 124, "section_index": 0, "content_hash": "91305fb04461ca3445a770339b0cbab138d6e2751a35fec99ab66ecdfbfa3b2d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/http.adoc"}}
{"id": "sha256:928a78d1fd42a17e0d6686d54383e672f8944beff0aab0cac16af263eef75315", "content": "If a client makes a request using HTTP rather than HTTPS, you can configure Spring Security to redirect to HTTPS.\n\nFor example, the following Java or Kotlin configuration redirects any HTTP requests to HTTPS:\n\n.Redirect to HTTPS\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .redirectToHttps(withDefaults());\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n redirectToHttps { }\n }\n return http.build()\n }\n}\n----\n======\n\nThe following XML configuration redirects all HTTP requests to HTTPS\n\n.Redirect to HTTPS with XML Configuration\n[source,xml]\n----\n<http>\n\t<intercept-url pattern=\"/**\" access=\"ROLE_USER\" requires-channel=\"https\"/>\n...\n</http>\n----\n\n[[servlet-hsts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/http.adoc", "title": "http", "heading": "Redirect to HTTPS", "heading_level": 2, "file_order": 124, "section_index": 1, "content_hash": "928a78d1fd42a17e0d6686d54383e672f8944beff0aab0cac16af263eef75315", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/http.adoc"}}
{"id": "sha256:b38678f044da67b9c1b2281836c5992b4b913379028a2d271e4b800c20ce4ab6", "content": "Spring Security provides support for xref:servlet/exploits/headers.adoc#servlet-headers-hsts[Strict Transport Security] and enables it by default.\n\n[[servlet-http-proxy-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/http.adoc", "title": "http", "heading": "Strict Transport Security", "heading_level": 2, "file_order": 124, "section_index": 2, "content_hash": "b38678f044da67b9c1b2281836c5992b4b913379028a2d271e4b800c20ce4ab6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/http.adoc"}}
{"id": "sha256:963b6ba3828e2973958a8382b493df0d3d4acfac79c35ad22214b83b81cf6645", "content": "Spring Security xref:features/exploits/http.adoc#http-proxy-server[integrates with proxy servers].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/http.adoc", "title": "http", "heading": "Proxy Server Configuration", "heading_level": 2, "file_order": 124, "section_index": 3, "content_hash": "963b6ba3828e2973958a8382b493df0d3d4acfac79c35ad22214b83b81cf6645", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/http.adoc"}}
{"id": "sha256:0ff29612913375fef5b48d606622918e041b00a7d6fd1305d21c221ae9725c2b", "content": "[[servlet-exploits]]\n\nThis section discusses Servlet specific support for xref:features/exploits/index.adoc#exploits[Spring Security's protection against common exploits].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/exploits/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 125, "section_index": 0, "content_hash": "0ff29612913375fef5b48d606622918e041b00a7d6fd1305d21c221ae9725c2b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/exploits/index.adoc"}}
{"id": "sha256:7d8ca0882e4ce5e91f77b2c64ee1e2ffe7d69cbeb32b7bce1c988e4fe0e14633", "content": "[[concurrency]]\n\nIn most environments, Security is stored on a per-`Thread` basis.\nThis means that when work is done on a new `Thread`, the `SecurityContext` is lost.\nSpring Security provides some infrastructure to help make this much easier to manage.\nSpring Security provides low-level abstractions for working with Spring Security in multi-threaded environments.\nIn fact, this is what Spring Security builds on to integrate with xref:servlet/integrations/servlet-api.adoc#servletapi-start-runnable[`AsyncContext.start(Runnable)`] and xref:servlet/integrations/mvc.adoc#mvc-async[Spring MVC Async Integration].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/concurrency.adoc", "title": "concurrency", "heading": "concurrency", "heading_level": 1, "file_order": 126, "section_index": 0, "content_hash": "7d8ca0882e4ce5e91f77b2c64ee1e2ffe7d69cbeb32b7bce1c988e4fe0e14633", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/concurrency.adoc"}}
{"id": "sha256:04fac75fd99784871811719ba7418a7f265bd62d03a6dce57f9b09d2f98603d9", "content": "One of the most fundamental building blocks within Spring Security's concurrency support is the `DelegatingSecurityContextRunnable`.\nIt wraps a delegate `Runnable` to initialize the `SecurityContextHolder` with a specified `SecurityContext` for the delegate.\nIt then invokes the delegate `Runnable`, ensuring to clear the `SecurityContextHolder` afterwards.\nThe `DelegatingSecurityContextRunnable` looks something like this:\n\n[source,java]\n----\npublic void run() {\ntry {\n\tSecurityContextHolder.setContext(securityContext);\n\tdelegate.run();\n} finally {\n\tSecurityContextHolder.clearContext();\n}\n}\n----\n\nWhile very simple, it makes it seamless to transfer the `SecurityContext` from one `Thread` to another.\nThis is important since, in most cases, the `SecurityContextHolder` acts on a per-`Thread` basis.\nFor example, you might have used Spring Security's xref:servlet/appendix/namespace/method-security.adoc#nsa-global-method-security[`<global-method-security>`] support to secure one of your services.\nYou can now transfer the `SecurityContext` of the current `Thread` to the `Thread` that invokes the secured service.\nThe following example show how you might do so:\n\n[source,java]\n----\nRunnable originalRunnable = new Runnable() {\npublic void run() {\n\t// invoke secured service\n}\n};\n\nSecurityContext context = SecurityContextHolder.getContext();\nDelegatingSecurityContextRunnable wrappedRunnable =\n\tnew DelegatingSecurityContextRunnable(originalRunnable, context);\n\nnew Thread(wrappedRunnable).start();\n----\n\nThe preceding code:\n\n* Creates a `Runnable` that invokes our secured service.\nNote that it is not aware of Spring Security.\n* Obtains the `SecurityContext` that we wish to use from the `SecurityContextHolder` and initializes the `DelegatingSecurityContextRunnable`.\n* Uses the `DelegatingSecurityContextRunnable` to create a `Thread`.\n* Starts the `Thread` we created.\n\nSince it is common to create a `DelegatingSecurityContextRunnable` with the `SecurityContext` from the `SecurityContextHolder`, there is a shortcut constructor for it.\nThe following code has the same effect as the preceding code:\n\n[source,java]\n----\nRunnable originalRunnable = new Runnable() {\npublic void run() {\n\t// invoke secured service\n}\n};\n\nDelegatingSecurityContextRunnable wrappedRunnable =\n\tnew DelegatingSecurityContextRunnable(originalRunnable);\n\nnew Thread(wrappedRunnable).start();\n----\n\nThe code we have is simple to use, but it still requires knowledge that we are using Spring Security.\nIn the next section we will take a look at how we can utilize `DelegatingSecurityContextExecutor` to hide the fact that we are using Spring Security.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/concurrency.adoc", "title": "concurrency", "heading": "DelegatingSecurityContextRunnable", "heading_level": 2, "file_order": 126, "section_index": 1, "content_hash": "04fac75fd99784871811719ba7418a7f265bd62d03a6dce57f9b09d2f98603d9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/concurrency.adoc"}}
{"id": "sha256:f953d71230105ba902f8d0a237326b6126c13a9fa9f0a8941ad92a1767ea95df", "content": "In the previous section, we found that it was easy to use the `DelegatingSecurityContextRunnable`, but it was not ideal since we had to be aware of Spring Security to use it.\nNow we look at how `DelegatingSecurityContextExecutor` can shield our code from any knowledge that we are using Spring Security.\n\nThe design of `DelegatingSecurityContextExecutor` is similar to that of `DelegatingSecurityContextRunnable`, except that it accepts a delegate `Executor` instead of a delegate `Runnable`.\nThe following example shows how to use it:\n\n[source,java]\n----\nSecurityContext context = SecurityContextHolder.createEmptyContext();\nAuthentication authentication =\n\tUsernamePasswordAuthenticationToken.authenticated(\"user\",\"doesnotmatter\", AuthorityUtils.createAuthorityList(\"ROLE_USER\"));\ncontext.setAuthentication(authentication);\n\nSimpleAsyncTaskExecutor delegateExecutor =\n\tnew SimpleAsyncTaskExecutor();\nDelegatingSecurityContextExecutor executor =\n\tnew DelegatingSecurityContextExecutor(delegateExecutor, context);\n\nRunnable originalRunnable = new Runnable() {\npublic void run() {\n\t// invoke secured service\n}\n};\n\nexecutor.execute(originalRunnable);\n----\n\nThis code:\n\nNote that, in this example, we create the `SecurityContext` by hand.\nHowever, it does not matter where or how we get the `SecurityContext` (for example, we could obtain it from the `SecurityContextHolder`).\n* Creates a `delegateExecutor` that is in charge of executing submitted `Runnable` objects.\n* Finally, we create a `DelegatingSecurityContextExecutor`, which is in charge of wrapping any `Runnable` that is passed into the `execute` method with a `DelegatingSecurityContextRunnable`.\nIt then passes the wrapped `Runnable` to the `delegateExecutor`.\nIn this case, the same `SecurityContext` is used for every `Runnable` submitted to our `DelegatingSecurityContextExecutor`.\nThis is nice if we run background tasks that need to be run by a user with elevated privileges.\n* At this point, you may ask yourself, \"`How does this shield my code of any knowledge of Spring Security?`\" Instead of creating the `SecurityContext` and the `DelegatingSecurityContextExecutor` in our own code, we can inject an already initialized instance of `DelegatingSecurityContextExecutor`.\n\nConsider the following example:\n\n[source,java]\n----\n@Autowired\nprivate Executor executor; // becomes an instance of our DelegatingSecurityContextExecutor\n\npublic void submitRunnable() {\nRunnable originalRunnable = new Runnable() {\n\tpublic void run() {\n\t// invoke secured service\n\t}\n};\nexecutor.execute(originalRunnable);\n}\n----\n\nNow our code is unaware that the `SecurityContext` is being propagated to the `Thread`, the `originalRunnable` is run, and the `SecurityContextHolder` is cleared out.\nIn this example, the same user is being used to run each thread.\nWhat if we wanted to use the user from `SecurityContextHolder` (that is, the currently logged in-user) at the time we invoked `executor.execute(Runnable)` to process `originalRunnable`?\nYou can do so by removing the `SecurityContext` argument from our `DelegatingSecurityContextExecutor` constructor:\n\n[source,java]\n----\nSimpleAsyncTaskExecutor delegateExecutor = new SimpleAsyncTaskExecutor();\nDelegatingSecurityContextExecutor executor =\n\tnew DelegatingSecurityContextExecutor(delegateExecutor);\n----\n\nNow, any time `executor.execute(Runnable)` is run, the `SecurityContext` is first obtained by the `SecurityContextHolder` and then that `SecurityContext` is used to create our `DelegatingSecurityContextRunnable`.\nThis means that we are running our `Runnable` with the same user that was used to invoke the `executor.execute(Runnable)` code.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/concurrency.adoc", "title": "concurrency", "heading": "DelegatingSecurityContextExecutor", "heading_level": 2, "file_order": 126, "section_index": 2, "content_hash": "f953d71230105ba902f8d0a237326b6126c13a9fa9f0a8941ad92a1767ea95df", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/concurrency.adoc"}}
{"id": "sha256:ae70791066b09babad3f7d151caa4696bb749c7871fa7a57507b1aa6657e2d9b", "content": "See the {security-api-url}index.html[Javadoc] for additional integrations with both the Java concurrent APIs and the Spring Task abstractions.\nThey are self-explanatory once you understand the previous code.\n\n* javadoc:org.springframework.security.concurrent.DelegatingSecurityContextCallable[]\n* javadoc:org.springframework.security.concurrent.DelegatingSecurityContextExecutor[]\n* javadoc:org.springframework.security.concurrent.DelegatingSecurityContextExecutorService[]\n* javadoc:org.springframework.security.concurrent.DelegatingSecurityContextRunnable[]\n* javadoc:org.springframework.security.concurrent.DelegatingSecurityContextScheduledExecutorService[]\n* javadoc:org.springframework.security.scheduling.DelegatingSecurityContextSchedulingTaskExecutor[]\n* javadoc:org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor[]\n* javadoc:org.springframework.security.task.DelegatingSecurityContextTaskExecutor[]\n* javadoc:org.springframework.security.scheduling.DelegatingSecurityContextTaskScheduler[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/concurrency.adoc", "title": "concurrency", "heading": "Spring Security Concurrency Classes", "heading_level": 2, "file_order": 126, "section_index": 3, "content_hash": "ae70791066b09babad3f7d151caa4696bb749c7871fa7a57507b1aa6657e2d9b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/concurrency.adoc"}}
{"id": "sha256:037fa3f80dc8fff6d3ef2efa8928b7182fd55dc0304137d5c725bb8b157b019e", "content": "[[cors]]\n\nSpring Framework provides https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-cors[first class support for CORS].\nCORS must be processed before Spring Security, because the pre-flight request does not contain any cookies (that is, the `JSESSIONID`).\nIf the request does not contain any cookies and Spring Security is first, the request determines that the user is not authenticated (since there are no cookies in the request) and rejects it.\n\nThe easiest way to ensure that CORS is handled first is to use the `CorsFilter`.\nUsers can integrate the `CorsFilter` with Spring Security by providing a `CorsConfigurationSource`. Note that Spring Security will automatically configure CORS only if a `UrlBasedCorsConfigurationSource` instance is present.\nFor example, the following will integrate CORS support within Spring Security:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nUrlBasedCorsConfigurationSource corsConfigurationSource() {\n CorsConfiguration configuration = new CorsConfiguration();\n configuration.setAllowedOrigins(Arrays.asList(\"https://example.com\"));\n configuration.setAllowedMethods(Arrays.asList(\"GET\",\"POST\"));\n UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n source.registerCorsConfiguration(\"/**\", configuration);\n return source;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun corsConfigurationSource(): UrlBasedCorsConfigurationSource {\n val configuration = CorsConfiguration()\n configuration.allowedOrigins = listOf(\"https://example.com\")\n configuration.allowedMethods = listOf(\"GET\", \"POST\")\n val source = UrlBasedCorsConfigurationSource()\n source.registerCorsConfiguration(\"/**\", configuration)\n return source\n}\n----\n======\n\nThe following listing does the same thing in XML:\n\n[source,xml]\n----\n<http>\n\t<cors configuration-source-ref=\"corsSource\"/>\n\t...\n</http>\n<b:bean id=\"corsSource\" class=\"org.springframework.web.cors.UrlBasedCorsConfigurationSource\">\n\t...\n</b:bean>\n----\n\nIf you use Spring MVC's CORS support, you can omit specifying the `CorsConfigurationSource` and Spring Security uses the CORS configuration provided to Spring MVC:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // if Spring MVC is on classpath and no CorsConfigurationSource is provided,\n // Spring Security will use CORS configuration provided to Spring MVC\n .cors(withDefaults())\n ...\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nopen class WebSecurityConfig {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // if Spring MVC is on classpath and no CorsConfigurationSource is provided,\n // Spring Security will use CORS configuration provided to Spring MVC\n cors { }\n // ...\n }\n return http.build()\n }\n}\n----\n======\n\nThe following listing does the same thing in XML:\n\n[source,xml]\n----\n<http>\n\t<!-- Default to Spring MVC's CORS configuration -->\n\t<cors />\n\t...\n</http>\n----\n\nIf you have more than one `CorsConfigurationSource` bean, Spring Security won't automatically configure CORS support for you, that is because it cannot decide which one to use.\nIf you want to specify different `CorsConfigurationSource` for each `SecurityFilterChain`, you can pass it directly into the `.cors()` DSL.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\t@Order(0)\n\tpublic SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception {\n http\n .securityMatcher(\"/api/**\")\n .cors((cors) -> cors\n .configurationSource(apiConfigurationSource())\n )\n ...\n return http.build();\n\t}\n\n\t@Bean\n\t@Order(1)\n\tpublic SecurityFilterChain myOtherFilterChain(HttpSecurity http) throws Exception {\n http\n .cors((cors) -> cors\n .configurationSource(myWebsiteConfigurationSource())\n )\n ...\n return http.build();\n\t}\n\n\tUrlBasedCorsConfigurationSource apiConfigurationSource() {\n CorsConfiguration configuration = new CorsConfiguration();\n configuration.setAllowedOrigins(Arrays.asList(\"https://api.example.com\"));\n configuration.setAllowedMethods(Arrays.asList(\"GET\",\"POST\"));\n UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n source.registerCorsConfiguration(\"/**\", configuration);\n return source;\n\t}\n\n\tUrlBasedCorsConfigurationSource myWebsiteConfigurationSource() {\n CorsConfiguration configuration = new CorsConfiguration();\n configuration.setAllowedOrigins(Arrays.asList(\"https://example.com\"));\n configuration.setAllowedMethods(Arrays.asList(\"GET\",\"POST\"));\n UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n source.registerCorsConfiguration(\"/**\", configuration);\n return source;\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun corsConfigurationSource(): UrlBasedCorsConfigurationSource {\n val configuration = CorsConfiguration()\n configuration.allowedOrigins = listOf(\"https://example.com\")\n configuration.allowedMethods = listOf(\"GET\", \"POST\")\n val source = UrlBasedCorsConfigurationSource()\n source.registerCorsConfiguration(\"/**\", configuration)\n return source\n}\n----\n======\n\n[WARNING]\n====\nCORS is a browser-based security feature.\nBy disabling CORS in Spring Security with `.cors(CorsConfigurer::disable)`, you are not removing CORS protection from your browser.\nInstead, you are removing CORS support from Spring Security, and users will not be able to interact with your Spring backend from a cross-origin browser application.\nTo fix CORS errors in your application, you must enable CORS support, and provide an appropriate configuration source.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/cors.adoc", "title": "cors", "heading": "cors", "heading_level": 1, "file_order": 127, "section_index": 0, "content_hash": "037fa3f80dc8fff6d3ef2efa8928b7182fd55dc0304137d5c725bb8b157b019e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/cors.adoc"}}
{"id": "sha256:1975777987a8e2140963b0699de3d7d28f8962f45b75a69a1a73fa59f586d952", "content": "[[data]]\n\nSpring Security provides Spring Data integration that allows referring to the current user within your queries.\nIt is not only useful but necessary to include the user in the queries to support paged results since filtering the results afterwards would not scale.\n\n[[data-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/data.adoc", "title": "data", "heading": "data", "heading_level": 1, "file_order": 128, "section_index": 0, "content_hash": "1975777987a8e2140963b0699de3d7d28f8962f45b75a69a1a73fa59f586d952", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/data.adoc"}}
{"id": "sha256:215c4dc5263b30cc0e6f5b2856ee4aa6250234f2c3a5b83df015445b7bbcd732", "content": "To use this support, add `org.springframework.security:spring-security-data` dependency and provide a bean of type `SecurityEvaluationContextExtension`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityEvaluationContextExtension securityEvaluationContextExtension() {\n\treturn new SecurityEvaluationContextExtension();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun securityEvaluationContextExtension(): SecurityEvaluationContextExtension {\n\treturn SecurityEvaluationContextExtension()\n}\n----\n======\n\nIn XML Configuration, this would look like:\n\n[source,xml]\n----\n<bean class=\"org.springframework.security.data.repository.query.SecurityEvaluationContextExtension\"/>\n----\n\n[[data-query]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/data.adoc", "title": "data", "heading": "Spring Data & Spring Security Configuration", "heading_level": 2, "file_order": 128, "section_index": 1, "content_hash": "215c4dc5263b30cc0e6f5b2856ee4aa6250234f2c3a5b83df015445b7bbcd732", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/data.adoc"}}
{"id": "sha256:4a068d4e05f43b746b08087c1dfbef59e4d166da3d047876148847861902474d", "content": "Now you can use Spring Security within your queries:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic interface MessageRepository extends PagingAndSortingRepository<Message,Long> {\n\t@Query(\"select m from Message m where m.to.id = ?#{ principal?.id }\")\n\tPage<Message> findInbox(Pageable pageable);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ninterface MessageRepository : PagingAndSortingRepository<Message,Long> {\n\t@Query(\"select m from Message m where m.to.id = ?#{ principal?.id }\")\n\tfun findInbox(pageable: Pageable): Page<Message>\n}\n----\n======\n\nThis checks to see if the `Authentication.getPrincipal().getId()` is equal to the recipient of the `Message`.\nNote that this example assumes you have customized the principal to be an Object that has an id property.\nBy exposing the `SecurityEvaluationContextExtension` bean, all of the xref:servlet/authorization/method-security.adoc#authorization-expressions[Common Security Expressions] are available within the Query.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/data.adoc", "title": "data", "heading": "Security Expressions within @Query", "heading_level": 2, "file_order": 128, "section_index": 2, "content_hash": "4a068d4e05f43b746b08087c1dfbef59e4d166da3d047876148847861902474d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/data.adoc"}}
{"id": "sha256:fa0467cf0b0f6603bceb530f1af6ab4522ec523d909b9245e8db5055c82e3b17", "content": "Spring Security integrates with numerous frameworks and APIs.\nThis section describes various integrations that Spring Security has with other technologies:", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/index.adoc", "title": "Integrations", "heading": "Integrations", "heading_level": 1, "file_order": 129, "section_index": 0, "content_hash": "fa0467cf0b0f6603bceb530f1af6ab4522ec523d909b9245e8db5055c82e3b17", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/index.adoc"}}
{"id": "sha256:8063056d2092a06846bd6655d54b3f37b5d64959f3d857d9d0ea0f3c6191755f", "content": "[[taglibs]]\nSpring Security has its own taglib, which provides basic support for accessing security information and applying security constraints in JSPs.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc", "title": "jsp-taglibs", "heading": "jsp-taglibs", "heading_level": 1, "file_order": 130, "section_index": 0, "content_hash": "8063056d2092a06846bd6655d54b3f37b5d64959f3d857d9d0ea0f3c6191755f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc"}}
{"id": "sha256:dc4528582689c829639e0c2f4e0d7db369fc7c06d990df9e747c708fb05c8861", "content": "To use any of the tags, you must have the security taglib declared in your JSP:\n\n[source,xml]\n----\n<%@ taglib prefix=\"sec\" uri=\"http://www.springframework.org/security/tags\" %>\n----\n\n[[taglibs-authorize]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc", "title": "jsp-taglibs", "heading": "Declaring the Taglib", "heading_level": 2, "file_order": 130, "section_index": 1, "content_hash": "dc4528582689c829639e0c2f4e0d7db369fc7c06d990df9e747c708fb05c8861", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc"}}
{"id": "sha256:4ce5344e4bfc029ad294de29c0feb880ab3e87297309a0050cbc58c6ee931a93", "content": "This tag is used to determine whether its contents should be evaluated or not.\nIn Spring Security 3.0, it can be used in two ways.\n\n[NOTE]\n====\nThe legacy options from Spring Security 2.0 are also supported, but discouraged.\n====\n\nThe first approach uses a xref:servlet/authorization/authorize-http-requests.adoc#authorization-expressions[web-security expression], which is specified in the `access` attribute of the tag.\nThe expression evaluation is delegated to the `SecurityExpressionHandler<FilterInvocation>` defined in the application context (you should have web expressions enabled in your `<http>` namespace configuration to make sure this service is available).\nSo, for example, you might have:\n\n[source,xml]\n----\n<sec:authorize access=\"hasRole('supervisor')\">\n\nThis content will only be visible to users who have the \"supervisor\" authority in their list of <tt>GrantedAuthority</tt>s.\n\n</sec:authorize>\n----\n\nWhen used in conjunction with Spring Security's `PermissionEvaluator`, the tag can also be used to check permissions:\n\n[source,xml]\n----\n<sec:authorize access=\"hasPermission(#domain,'read') or hasPermission(#domain,'write')\">\n\nThis content will only be visible to users who have read or write permission to the Object found as a request attribute named \"domain\".\n\n</sec:authorize>\n----\n\nA common requirement is to show only a particular link, assuming the user is actually allowed to click it.\nHow can we determine in advance whether something is allowed? This tag can also operate in an alternative mode that lets you define a particular URL as an attribute.\nIf the user is allowed to invoke that URL, the tag body is evaluated. Otherwise, it is skipped.\nSo you might have something like:\n\n[source,xml]\n----\n<sec:authorize url=\"/admin\">\n\nThis content will only be visible to users who are authorized to send requests to the \"/admin\" URL.\n\n</sec:authorize>\n----\n\nTo use this tag, you must also have an instance of `WebInvocationPrivilegeEvaluator` in your application context.\nIf you are using the namespace, one is automatically registered.\nThis is an instance of `DefaultWebInvocationPrivilegeEvaluator`, which creates a dummy web request for the supplied URL and invokes the security interceptor to see whether the request would succeed or fail.\nThis lets you delegate to the access-control setup you defined by using `intercept-url` declarations within the `<http>` namespace configuration and saves having to duplicate the information (such as the required roles) within your JSPs.\nYou can also combine this approach with a `method` attribute (supplying the HTTP method, such as `POST`) for a more specific match.\n\nYou can store the Boolean result of evaluating the tag (whether it grants or denies access) in a page context scope variable by setting the `var` attribute to the variable name, avoiding the need for duplicating and re-evaluating the condition at other points in the page.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc", "title": "jsp-taglibs", "heading": "The authorize Tag", "heading_level": 2, "file_order": 130, "section_index": 2, "content_hash": "4ce5344e4bfc029ad294de29c0feb880ab3e87297309a0050cbc58c6ee931a93", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc"}}
{"id": "sha256:972c8c4805a3d4e7e85481d5c96a01602db0b37b0523c64ae0ffbd40706b016c", "content": "Hiding a link in a page for unauthorized users does not prevent them from accessing the URL.\nThey could just type it into their browser directly, for example.\nAs part of your testing process, you may want to reveal the hidden areas, to check that links really are secured at the back end.\nIf you set the `spring.security.disableUISecurity` system property to `true`, the `authorize` tag still runs but does not hide its contents.\nBy default, it also surrounds the content with `<span class=\"securityHiddenUI\">...</span>` tags.\nThis lets you to display \"`hidden`\" content with a particular CSS style, such as a different background color.\nTry running the \"`tutorial`\" sample application, for example, with this property enabled.\n\nYou can also set the `spring.security.securedUIPrefix` and `spring.security.securedUISuffix` properties if you want to change surrounding text from the default `span` tags (or use empty strings to remove it completely).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc", "title": "jsp-taglibs", "heading": "Disabling Tag Authorization for Testing", "heading_level": 3, "file_order": 130, "section_index": 3, "content_hash": "972c8c4805a3d4e7e85481d5c96a01602db0b37b0523c64ae0ffbd40706b016c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc"}}
{"id": "sha256:bfd1037f20f064f3d0999e9c176882b5a005ce817ddc52a51a30600b7e71ce20", "content": "This tag allows access to the current `Authentication` object stored in the security context.\nIt renders a property of the object directly in the JSP.\nSo, for example, if the `principal` property of the `Authentication` is an instance of Spring Security's `UserDetails` object, then using `<sec:authentication property=\"principal.username\" />` renders the name of the current user.\n\nOf course, it is not necessary to use JSP tags for this kind of thing, and some people prefer to keep as little logic as possible in the view.\nYou can access the `Authentication` object in your MVC controller (by calling `SecurityContextHolder.getContext().getAuthentication()`) and add the data directly to your model for rendering by the view.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc", "title": "jsp-taglibs", "heading": "The authentication Tag", "heading_level": 2, "file_order": 130, "section_index": 4, "content_hash": "bfd1037f20f064f3d0999e9c176882b5a005ce817ddc52a51a30600b7e71ce20", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc"}}
{"id": "sha256:9dfb5014a6e4f02921b5087144e901a30f120d54afec18bbb168da9bb41a3d57", "content": "This tag is only valid when used with Spring Security's ACL module.\nIt checks a comma-separated list of required permissions for a specified domain object.\nIf the current user has all of those permissions, the tag body is evaluated.\nIf they do not, it is skipped.\n\n[CAUTION]\n====\nIn general, this tag should be considered deprecated.\nInstead, use the <<taglibs-authorize>>.\n====\n\nThe following listing shows an example:\n\n[source,xml]\n----\n<sec:accesscontrollist hasPermission=\"1,2\" domainObject=\"${someObject}\">\n\n<!-- This will be shown if the user has all of the permissions represented by the values \"1\" or \"2\" on the given object. -->\n\n</sec:accesscontrollist>\n----\n\nThe permissions are passed to the `PermissionFactory` defined in the application context, converting them to ACL `Permission` instances, so they may be any format that is supported by the factory. They do not have to be integers. They could be strings such as `READ` or `WRITE`.\nIf no `PermissionFactory` is found, an instance of `DefaultPermissionFactory` is used.\nThe `AclService` from the application context is used to load the `Acl` instance for the supplied object.\nThe `Acl` is invoked with the required permissions to check if all of them are granted.\n\nThis tag also supports the `var` attribute, in the same way as the `authorize` tag.\n\n[[taglibs-csrfinput]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc", "title": "jsp-taglibs", "heading": "The accesscontrollist Tag", "heading_level": 2, "file_order": 130, "section_index": 5, "content_hash": "9dfb5014a6e4f02921b5087144e901a30f120d54afec18bbb168da9bb41a3d57", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc"}}
{"id": "sha256:24686cb6755a02767a340387f4d34dcbd87ccb855f303ff3d1a20310d3694db8", "content": "If CSRF protection is enabled, this tag inserts a hidden form field with the correct name and value for the CSRF protection token.\nIf CSRF protection is not enabled, this tag outputs nothing.\n\nNormally, Spring Security automatically inserts a CSRF form field for any `<form:form>` tags you use, but if for some reason you cannot use `<form:form>`, `csrfInput` is a handy replacement.\n\nYou should place this tag within an HTML `<form></form>` block, where you would normally place other input fields.\nDo NOT place this tag within a Spring `<form:form></form:form>` block.\nSpring Security handles Spring forms automatically.\nThe following listing shows an example:\n\n[source,xml]\n----\n\t<form method=\"post\" action=\"/do/something\">\n <sec:csrfInput />\n Name:<br />\n <input type=\"text\" name=\"name\" />\n ...\n\t</form>\n----\n\n[[taglibs-csrfmeta]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc", "title": "jsp-taglibs", "heading": "The csrfInput Tag", "heading_level": 2, "file_order": 130, "section_index": 6, "content_hash": "24686cb6755a02767a340387f4d34dcbd87ccb855f303ff3d1a20310d3694db8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc"}}
{"id": "sha256:d3b10984c98f047b35ab399f1c8efe815581877c432779fd6c09501078e90152", "content": "If CSRF protection is enabled, this tag inserts meta tags that contain the CSRF protection token form field and header names and CSRF protection token value.\nThese meta tags are useful for employing CSRF protection within JavaScript in your applications.\n\nYou should place `csrfMetaTags` within an HTML `<head></head>` block, where you would normally place other meta tags.\nOnce you use this tag, you can access the form field name, header name, and token value by using JavaScript.\nJQuery is used in this example to make the task easier.\nThe following listing shows an example:\n\n[source,xml]\n----\n<!DOCTYPE html>\n<html>\n\t<head>\n <title>CSRF Protected JavaScript Page</title>\n <meta name=\"description\" content=\"This is the description for this page\" />\n <sec:csrfMetaTags />\n <script type=\"text/javascript\" language=\"javascript\">\n\n var csrfParameter = $(\"meta[name='_csrf_parameter']\").attr(\"content\");\n var csrfHeader = $(\"meta[name='_csrf_header']\").attr(\"content\");\n var csrfToken = $(\"meta[name='_csrf']\").attr(\"content\");\n\n // using XMLHttpRequest directly to send an x-www-form-urlencoded request\n var ajax = new XMLHttpRequest();\n ajax.open(\"POST\", \"https://www.example.org/do/something\", true);\n ajax.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded data\");\n ajax.send(csrfParameter + \"=\" + csrfToken + \"&name=John&...\");\n\n // using XMLHttpRequest directly to send a non-x-www-form-urlencoded request\n var ajax = new XMLHttpRequest();\n ajax.open(\"POST\", \"https://www.example.org/do/something\", true);\n ajax.setRequestHeader(csrfHeader, csrfToken);\n ajax.send(\"...\");\n\n // using JQuery to send an x-www-form-urlencoded request\n var data = {};\n data[csrfParameter] = csrfToken;\n data[\"name\"] = \"John\";\n ...\n $.ajax({\n url: \"https://www.example.org/do/something\",\n type: \"POST\",\n data: data,\n ...\n });\n\n // using JQuery to send a non-x-www-form-urlencoded request\n var headers = {};\n headers[csrfHeader] = csrfToken;\n $.ajax({\n url: \"https://www.example.org/do/something\",\n type: \"POST\",\n headers: headers,\n ...\n });\n\n <script>\n\t</head>\n\t<body>\n ...\n\t</body>\n</html>\n----\n\nIf CSRF protection is not enabled, `csrfMetaTags` outputs nothing.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc", "title": "jsp-taglibs", "heading": "The csrfMetaTags Tag", "heading_level": 2, "file_order": 130, "section_index": 7, "content_hash": "d3b10984c98f047b35ab399f1c8efe815581877c432779fd6c09501078e90152", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/jsp-taglibs.adoc"}}
{"id": "sha256:a795608e8ec8d72607450bb0f793dca9ef71ac946263d5f56251cd3b512eeed0", "content": "[[localization]]\nSpring Security supports localization of exception messages that end users are likely to see.\nIf your application is designed for English-speaking users, you need not do anything as, by default, all Security messages are in English.\nIf you need to support other locales, this section contains everything you need to know.\n\nAll exception messages, including messages related to authentication failures and access being denied (authorization failures), can be localized.\nExceptions and logging messages that are focused on developers or system deployers (including incorrect attributes, interface contract violations, using incorrect constructors, startup time validation, debug-level logging) are not localized and instead are hard-coded in English within Spring Security's code.\n\nIn the `spring-security-core-xx.jar`, you find an `org.springframework.security` package that, in turn, contains a `messages.properties` file as well as localized versions for some common languages.\nYour `ApplicationContext` should refer to this, as Spring Security classes implement Spring's `MessageSourceAware` interface and expect the message resolver to be dependency injected at application context startup time.\nUsually, all you need to do is register a bean inside your application context to refer to the messages.\nThe following listing shows an example:\n\n[source,xml]\n----\n<bean id=\"messageSource\"\n\tclass=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\">\n<property name=\"basename\" value=\"classpath:org/springframework/security/messages\"/>\n</bean>\n----\n\nThe `messages.properties` is named in accordance with standard resource bundles and represents the default language supported by Spring Security messages.\nThis default file is in English.\n\nTo customize the `messages.properties` file or support other languages, you should copy the file, rename it accordingly, and register it inside the preceding bean definition.\nThere are not a large number of message keys inside this file, so localization should not be considered a major initiative.\nIf you do perform localization of this file, consider sharing your work with the community by logging a JIRA task and attaching your appropriately-named localized version of `messages.properties`.\n\nSpring Security relies on Spring's localization support in order to actually look up the appropriate message.\nFor this to work, you have to make sure that the locale from the incoming request is stored in Spring's `org.springframework.context.i18n.LocaleContextHolder`.\nSpring MVC's `DispatcherServlet` does this for your application automatically. However, since Spring Security's filters are invoked before this, the `LocaleContextHolder` needs to be set up to contain the correct `Locale` before the filters are called.\nYou can either do this in a filter yourself (which must come before the Spring Security filters in `web.xml`) or you can use Spring's `RequestContextFilter`.\nSee the Spring Framework documentation for further details on using localization with Spring.\n\nThe `contacts` sample application is set up to use localized messages.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/localization.adoc", "title": "localization", "heading": "localization", "heading_level": 1, "file_order": 131, "section_index": 0, "content_hash": "a795608e8ec8d72607450bb0f793dca9ef71ac946263d5f56251cd3b512eeed0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/localization.adoc"}}
{"id": "sha256:2fdec0726a705118aa06b0d3c1295c2b2de43914803094f9661d4c92ed365a35", "content": "[[mvc]]\n\nSpring Security provides a number of optional integrations with Spring MVC.\nThis section covers the integration in further detail.\n\n[[mvc-enablewebmvcsecurity]]\n[[mvc-enablewebsecurity]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/mvc.adoc", "title": "mvc", "heading": "mvc", "heading_level": 1, "file_order": 132, "section_index": 0, "content_hash": "2fdec0726a705118aa06b0d3c1295c2b2de43914803094f9661d4c92ed365a35", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/mvc.adoc"}}
{"id": "sha256:9c03623d8e62fabc9a7a65f287184556d5399233b613beca209ea3682624d8d4", "content": "To enable Spring Security integration with Spring MVC, add the `@EnableWebSecurity` annotation to your configuration.\n\n[NOTE]\n====\nSpring Security provides the configuration by using Spring MVC's https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-customize[`WebMvcConfigurer`].\nThis means that, if you use more advanced options, such as integrating with `WebMvcConfigurationSupport` directly, you need to manually provide the Spring Security configuration.\n====\n\n[[mvc-requestmatcher]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/mvc.adoc", "title": "mvc", "heading": "@EnableWebSecurity", "heading_level": 2, "file_order": 132, "section_index": 1, "content_hash": "9c03623d8e62fabc9a7a65f287184556d5399233b613beca209ea3682624d8d4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/mvc.adoc"}}
{"id": "sha256:1f262da8399d98b6dd894273f9937505035f8f147e15e8d4103902fe8ccb5122", "content": "Spring Security provides deep integration with how Spring MVC matches on URLs with `PathPatternRequestMatcher`.\nThis is helpful to ensure that your Security rules match the logic used to handle your requests.\n\n`PathPatternRequestMatcher` must use the same `PathPatternParser` as Spring MVC.\nIf you are not customizing the `PathPatternParser`, then you can do:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nPathPatternRequestMatcherBuilderFactoryBean usePathPattern() {\n\treturn new PathPatternRequestMatcherBuilderFactoryBean();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun usePathPattern(): PathPatternRequestMatcherBuilderFactoryBean {\n return PathPatternRequestMatcherBuilderFactoryBean()\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<b:bean class=\"org.springframework.security.config.web.PathPatternRequestMatcherBuilderFactoryBean\"/>\n----\n======\n\nand Spring Security will find the appropriate Spring MVC configuration for you.\n\nIf you *are* customizing Spring MVC's `PathPatternParser` instance, you will need to <<security-mvc-same-application-context, configure Spring Security and Spring MVC in the same `ApplicationContext`>>.\n\n[NOTE]\n====\nWe always recommend that you provide authorization rules by matching on the `HttpServletRequest` and method security.\n\nProviding authorization rules by matching on `HttpServletRequest` is good, because it happens very early in the code path and helps reduce the https://en.wikipedia.org/wiki/Attack_surface[attack surface].\nMethod security ensures that, if someone has bypassed the web authorization rules, your application is still secured.\nThis is known as https://en.wikipedia.org/wiki/Defense_in_depth_(computing)[Defense in Depth]\n====\n\nNow that Spring MVC is integrated with Spring Security, you are ready to write some xref:servlet/authorization/authorize-http-requests.adoc[authorization rules] that will use `PathPatternRequestMatcher`.\n\n[[mvc-authentication-principal]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/mvc.adoc", "title": "mvc", "heading": "PathPatternRequestMatcher", "heading_level": 2, "file_order": 132, "section_index": 2, "content_hash": "1f262da8399d98b6dd894273f9937505035f8f147e15e8d4103902fe8ccb5122", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/mvc.adoc"}}
{"id": "sha256:6da2ae4349801a3403a20d7375e923b31a0a97009dced2aaa284977dd743afa1", "content": "Spring Security provides `AuthenticationPrincipalArgumentResolver`, which can automatically resolve the current `Authentication.getPrincipal()` for Spring MVC arguments.\nBy using `@EnableWebSecurity`, you automatically have this added to your Spring MVC configuration.\nIf you use XML-based configuration, you must add this yourself:\n\n[source,xml]\n----\n<mvc:annotation-driven>\n <mvc:argument-resolvers>\n <bean class=\"org.springframework.security.web.method.annotation.AuthenticationPrincipalArgumentResolver\" />\n </mvc:argument-resolvers>\n</mvc:annotation-driven>\n----\n\nOnce you have properly configured `AuthenticationPrincipalArgumentResolver`, you can entirely decouple from Spring Security in your Spring MVC layer.\n\nConsider a situation where a custom `UserDetailsService` returns an `Object` that implements `UserDetails` and your own `CustomUser` `Object`. The `CustomUser` of the currently authenticated user could be accessed by using the following code:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RequestMapping(\"/messages/inbox\")\npublic ModelAndView findMessagesForUser() {\n\tAuthentication authentication =\n\tSecurityContextHolder.getContext().getAuthentication();\n\tCustomUser custom = (CustomUser) authentication == null ? null : authentication.getPrincipal();\n\n\t// .. find messages for this user and return them ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RequestMapping(\"/messages/inbox\")\nopen fun findMessagesForUser(): ModelAndView {\n val authentication: Authentication = SecurityContextHolder.getContext().authentication\n val custom: CustomUser? = if (authentication as CustomUser == null) null else authentication.principal\n\n // .. find messages for this user and return them ...\n}\n----\n======\n\nAs of Spring Security 3.2, we can resolve the argument more directly by adding an annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport org.springframework.security.core.annotation.AuthenticationPrincipal;\n\n@RequestMapping(\"/messages/inbox\")\npublic ModelAndView findMessagesForUser(@AuthenticationPrincipal CustomUser customUser) {\n\n\t// .. find messages for this user and return them ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RequestMapping(\"/messages/inbox\")\nopen fun findMessagesForUser(@AuthenticationPrincipal customUser: CustomUser?): ModelAndView {\n\n // .. find messages for this user and return them ...\n}\n----\n======\n\nSometimes, you may need to transform the principal in some way.\nFor example, if `CustomUser` needed to be final, it could not be extended.\nIn this situation, the `UserDetailsService` might return an `Object` that implements `UserDetails` and provides a method named `getCustomUser` to access `CustomUser`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class CustomUserUserDetails extends User {\n // ...\n public CustomUser getCustomUser() {\n return customUser;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass CustomUserUserDetails(\n username: String?,\n password: String?,\n authorities: MutableCollection<out GrantedAuthority>?\n) : User(username, password, authorities) {\n // ...\n val customUser: CustomUser? = null\n}\n----\n======\n\nWe could then access the `CustomUser` by using a https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html[SpEL expression] that uses `Authentication.getPrincipal()` as the root object:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport org.springframework.security.core.annotation.AuthenticationPrincipal;\n\n@RequestMapping(\"/messages/inbox\")\npublic ModelAndView findMessagesForUser(@AuthenticationPrincipal(expression = \"customUser\") CustomUser customUser) {\n\n\t// .. find messages for this user and return them ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.core.annotation.AuthenticationPrincipal\n\n@RequestMapping(\"/messages/inbox\")\nopen fun findMessagesForUser(@AuthenticationPrincipal(expression = \"customUser\") customUser: CustomUser?): ModelAndView {\n\n // .. find messages for this user and return them ...\n}\n----\n======\n\nWe can also refer to beans in our SpEL expressions.\nFor example, we could use the following if we were using JPA to manage our users and if we wanted to modify and save a property on the current user:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport org.springframework.security.core.annotation.AuthenticationPrincipal;\n\n@PutMapping(\"/users/self\")\npublic ModelAndView updateName(@AuthenticationPrincipal(expression = \"@jpaEntityManager.merge(#this)\") CustomUser attachedCustomUser,\n @RequestParam String firstName) {\n\n\t// change the firstName on an attached instance which will be persisted to the database\n\tattachedCustomUser.setFirstName(firstName);\n\n\t// ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.core.annotation.AuthenticationPrincipal\n\n@PutMapping(\"/users/self\")\nopen fun updateName(\n @AuthenticationPrincipal(expression = \"@jpaEntityManager.merge(#this)\") attachedCustomUser: CustomUser,\n @RequestParam firstName: String?\n): ModelAndView {\n\n // change the firstName on an attached instance which will be persisted to the database\n attachedCustomUser.setFirstName(firstName)\n\n // ...\n}\n----\n======\n\nWe can further remove our dependency on Spring Security by making `@AuthenticationPrincipal` a meta-annotation on our own annotation.\nThe next example demonstrates how we could do so on an annotation named `@CurrentUser`.\n\n[NOTE]\n====\nTo remove the dependency on Spring Security, it is the consuming application that would create `@CurrentUser`.\nThis step is not strictly required but assists in isolating your dependency to Spring Security to a more central location.\n====\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Target({ElementType.PARAMETER, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@AuthenticationPrincipal\npublic @interface CurrentUser {}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Target(AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.TYPE)\n@Retention(AnnotationRetention.RUNTIME)\n@MustBeDocumented\n@AuthenticationPrincipal\nannotation class CurrentUser\n----\n======\n\nWe have isolated our dependency on Spring Security to a single file.\nNow that `@CurrentUser` has been specified, we can use it to signal to resolve our `CustomUser` of the currently authenticated user:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RequestMapping(\"/messages/inbox\")\npublic ModelAndView findMessagesForUser(@CurrentUser CustomUser customUser) {\n\n\t// .. find messages for this user and return them ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RequestMapping(\"/messages/inbox\")\nopen fun findMessagesForUser(@CurrentUser customUser: CustomUser?): ModelAndView {\n\n // .. find messages for this user and return them ...\n}\n----\n======\n\nOnce it is a meta-annotation, parameterization is also available to you.\n\nFor example, consider when you have a JWT as your principal and you want to say which claim to retrieve.\nAs a meta-annotation, you might do:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Target({ElementType.PARAMETER, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@AuthenticationPrincipal(expression = \"claims['sub']\")\npublic @interface CurrentUser {}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Target(AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.TYPE)\n@Retention(AnnotationRetention.RUNTIME)\n@MustBeDocumented\n@AuthenticationPrincipal(expression = \"claims['sub']\")\nannotation class CurrentUser\n----\n======\n\nwhich is already quite powerful.\nBut, it is also limited to retrieving the `sub` claim.\n\nTo make this more flexible, first publish the `AnnotationTemplateExpressionDefaults` bean like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic AnnotationTemplateExpressionDefaults templateDefaults() {\n\treturn new AnnotationTemplateExpressionDefaults();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun templateDefaults(): AnnotationTemplateExpressionDefaults {\n\treturn AnnotationTemplateExpressionDefaults()\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<b:bean name=\"annotationExpressionTemplateDefaults\" class=\"org.springframework.security.core.annotation.AnnotationTemplateExpressionDefaults\"/>\n----\n======\n\nand then you can supply a parameter to `@CurrentUser` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Target({ElementType.PARAMETER, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@AuthenticationPrincipal(expression = \"claims['{claim}']\")\npublic @interface CurrentUser {\n\tString claim() default 'sub';\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Target(AnnotationTarget.VALUE_PARAMETER, AnnotationTarget.TYPE)\n@Retention(AnnotationRetention.RUNTIME)\n@MustBeDocumented\n@AuthenticationPrincipal(expression = \"claims['{claim}']\")\nannotation class CurrentUser(val claim: String = \"sub\")\n----\n======\n\nThis will allow you more flexibility across your set of applications in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RequestMapping(\"/messages/inbox\")\npublic ModelAndView findMessagesForUser(@CurrentUser(\"user_id\") String userId) {\n\n\t// .. find messages for this user and return them ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RequestMapping(\"/messages/inbox\")\nopen fun findMessagesForUser(@CurrentUser(\"user_id\") userId: String?): ModelAndView {\n\n // .. find messages for this user and return them ...\n}\n----\n======\n\n[[mvc-current-security-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/mvc.adoc", "title": "mvc", "heading": "@AuthenticationPrincipal", "heading_level": 2, "file_order": 132, "section_index": 3, "content_hash": "6da2ae4349801a3403a20d7375e923b31a0a97009dced2aaa284977dd743afa1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/mvc.adoc"}}
{"id": "sha256:ae4d0dd506a208a52c738bca82a5810adb7a0f5594502cc498b82df61cec38eb", "content": "Spring Security provides `CurrentSecurityContextArgumentResolver`, which can automatically resolve the current `SecurityContext` for Spring MVC arguments.\nBy using `@EnableWebSecurity`, you automatically have this added to your Spring MVC configuration.\nIf you use XML-based configuration, you must add this yourself:\n\n[source,xml]\n----\n<mvc:annotation-driven>\n <mvc:argument-resolvers>\n <bean class=\"org.springframework.security.web.method.annotation.CurrentSecurityContextArgumentResolver\" />\n </mvc:argument-resolvers>\n</mvc:annotation-driven>\n----\n\nOnce `CurrentSecurityContextArgumentResolver` is configured, you can access the `SecurityContext` directly:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/me\")\npublic String me(@CurrentSecurityContext SecurityContext context) {\n\treturn context.getAuthentication().getName();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/me\")\nfun me(@CurrentSecurityContext context: SecurityContext): String {\n return context.authentication.name\n}\n----\n======\n\nYou can also use a SpEL expression that is rooted at the `SecurityContext`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/me\")\npublic String me(@CurrentSecurityContext(expression = \"authentication\") Authentication authentication) {\n\treturn authentication.getName();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/me\")\nfun me(@CurrentSecurityContext(expression = \"authentication\") authentication: Authentication): String {\n return authentication.name\n}\n----\n======\n\n[[mvc-async]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/mvc.adoc", "title": "mvc", "heading": "@CurrentSecurityContext", "heading_level": 2, "file_order": 132, "section_index": 4, "content_hash": "ae4d0dd506a208a52c738bca82a5810adb7a0f5594502cc498b82df61cec38eb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/mvc.adoc"}}
{"id": "sha256:8f24e5094fa4b6f894d83c9bc23c148d916cae8de53b50e07dead8a6dd29aa98", "content": "Spring Web MVC 3.2+ has excellent support for https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-ann-async[Asynchronous Request Processing].\nWith no additional configuration, Spring Security automatically sets up the `SecurityContext` to the `Thread` that invokes a `Callable` returned by your controllers.\nFor example, the following method automatically has its `Callable` invoked with the `SecurityContext` that was available when the `Callable` was created:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RequestMapping(method=RequestMethod.POST)\npublic Callable<String> processUpload(final MultipartFile file) {\n\nreturn new Callable<String>() {\n\tpublic Object call() throws Exception {\n\t// ...\n\treturn \"someView\";\n\t}\n};\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RequestMapping(method = [RequestMethod.POST])\nopen fun processUpload(file: MultipartFile?): Callable<String> {\n return Callable {\n // ...\n \"someView\"\n }\n}\n----\n======\n\n.Associating SecurityContext to Callable's\n[NOTE]\n====\nMore technically speaking, Spring Security integrates with `WebAsyncManager`.\nThe `SecurityContext` that is used to process the `Callable` is the `SecurityContext` that exists on the `SecurityContextHolder` when `startCallableProcessing` is invoked.\n====\n\nThere is no automatic integration with a `DeferredResult` that is returned by controllers.\nThis is because `DeferredResult` is processed by the users and, thus, there is no way of automatically integrating with it.\nHowever, you can still use xref:features/integrations/concurrency.adoc#concurrency[Concurrency Support] to provide transparent integration with Spring Security.\n\n[[mvc-csrf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/mvc.adoc", "title": "mvc", "heading": "Spring MVC Async Integration", "heading_level": 2, "file_order": 132, "section_index": 5, "content_hash": "8f24e5094fa4b6f894d83c9bc23c148d916cae8de53b50e07dead8a6dd29aa98", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/mvc.adoc"}}
{"id": "sha256:2f859c928e1815aed2cfb9108e6a4be741c3f7ed7aa19919ee451e0dadddd1c0", "content": "Spring Security integrates with Spring MVC to add CSRF protection.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/mvc.adoc", "title": "mvc", "heading": "Spring MVC and CSRF Integration", "heading_level": 2, "file_order": 132, "section_index": 6, "content_hash": "2f859c928e1815aed2cfb9108e6a4be741c3f7ed7aa19919ee451e0dadddd1c0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/mvc.adoc"}}
{"id": "sha256:0cbb3cbcddd9406e4f020c7ca78c2b0ec77af294fabe0419b5112f0b8f910488", "content": "Spring Security automatically xref:servlet/exploits/csrf.adoc#csrf-integration-form[include the CSRF Token] within forms that use the https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/view.html#view-jsp-formtaglib-formtag[Spring MVC form tag].\nConsider the following JSP:\n\n[source,xml]\n----\n<jsp:root xmlns:jsp=\"http://java.sun.com/JSP/Page\"\n\txmlns:c=\"http://java.sun.com/jsp/jstl/core\"\n\txmlns:form=\"http://www.springframework.org/tags/form\" version=\"2.0\">\n\t<jsp:directive.page language=\"java\" contentType=\"text/html\" />\n<html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">\n\t<!-- ... -->\n\n\t<c:url var=\"logoutUrl\" value=\"/logout\"/>\n\t<form:form action=\"${logoutUrl}\"\n method=\"post\">\n\t<input type=\"submit\"\n value=\"Log out\" />\n\t<input type=\"hidden\"\n name=\"${_csrf.parameterName}\"\n value=\"${_csrf.token}\"/>\n\t</form:form>\n\n\t<!-- ... -->\n</html>\n</jsp:root>\n----\n\nThe preceding example output HTMLs that is similar to the following:\n\n[source,xml]\n----\n<!-- ... -->\n\n<form action=\"/context/logout\" method=\"post\">\n<input type=\"submit\" value=\"Log out\"/>\n<input type=\"hidden\" name=\"_csrf\" value=\"f81d4fae-7dec-11d0-a765-00a0c91e6bf6\"/>\n</form>\n\n<!-- ... -->\n----\n\n[[mvc-csrf-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/mvc.adoc", "title": "mvc", "heading": "Automatic Token Inclusion", "heading_level": 3, "file_order": 132, "section_index": 7, "content_hash": "0cbb3cbcddd9406e4f020c7ca78c2b0ec77af294fabe0419b5112f0b8f910488", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/mvc.adoc"}}
{"id": "sha256:55bdcae6fd278b9ed3c0d309a573e4092b35fbcdf51f7176cd5c125da8a1801b", "content": "Spring Security provides `CsrfTokenArgumentResolver`, which can automatically resolve the current `CsrfToken` for Spring MVC arguments.\nBy using xref:servlet/configuration/java.adoc#jc-hello-wsca[@EnableWebSecurity], you automatically have this added to your Spring MVC configuration.\nIf you use XML-based configuration, you must add this yourself.\n\nOnce `CsrfTokenArgumentResolver` is properly configured, you can expose the `CsrfToken` to your static HTML based application:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic class CsrfController {\n\n\t@RequestMapping(\"/csrf\")\n\tpublic CsrfToken csrf(CsrfToken token) {\n return token;\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RestController\nclass CsrfController {\n @RequestMapping(\"/csrf\")\n fun csrf(token: CsrfToken): CsrfToken {\n return token\n }\n}\n----\n======\n\nIt is important to keep the `CsrfToken` a secret from other domains.\nThis means that, if you use https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS[Cross Origin Sharing (CORS)], you should *NOT* expose the `CsrfToken` to any external domains.\n\n[[security-mvc-same-application-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/mvc.adoc", "title": "mvc", "heading": "Resolving the CsrfToken", "heading_level": 3, "file_order": 132, "section_index": 8, "content_hash": "55bdcae6fd278b9ed3c0d309a573e4092b35fbcdf51f7176cd5c125da8a1801b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/mvc.adoc"}}
{"id": "sha256:d776237a4f844a8ecb043556010bd0bc07a8c436882cfc19d5562a8363e95083", "content": "If you are using Boot, Spring MVC and Spring Security are in the same application context by default.\n\nOtherwise, for Java Config, including both `@EnableWebMvc` and `@EnableWebSecurity` will construct Spring Security and Spring MVC components in the same context.\n\nOf, if you are using ``ServletListener``s you can do:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class SecurityInitializer extends\n AbstractAnnotationConfigDispatcherServletInitializer {\n\n @Override\n protected Class<?>[] getRootConfigClasses() {\n return null;\n }\n\n @Override\n protected Class<?>[] getServletConfigClasses() {\n return new Class[] { RootConfiguration.class,\n WebMvcConfiguration.class };\n }\n\n @Override\n protected String[] getServletMappings() {\n return new String[] { \"/\" };\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass SecurityInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {\n override fun getRootConfigClasses(): Array<Class<*>>? {\n return null\n }\n\n override fun getServletConfigClasses(): Array<Class<*>> {\n return arrayOf(\n RootConfiguration::class.java,\n WebMvcConfiguration::class.java\n )\n }\n\n override fun getServletMappings(): Array<String> {\n return arrayOf(\"/\")\n }\n}\n----\n======\n\nAnd finally for a `web.xml` file, you configure the `DispatcherServlet` like so:\n\n[source,xml]\n----\n<listener>\n <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n\n<!-- All Spring Configuration (both MVC and Security) are in /WEB-INF/spring/ -->\n<context-param>\n <param-name>contextConfigLocation</param-name>\n <param-value>/WEB-INF/spring/*.xml</param-value>\n</context-param>\n\n<servlet>\n <servlet-name>spring</servlet-name>\n <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n <!-- Load from the ContextLoaderListener -->\n <init-param>\n <param-name>contextConfigLocation</param-name>\n <param-value></param-value>\n </init-param>\n</servlet>\n\n<servlet-mapping>\n <servlet-name>spring</servlet-name>\n <url-pattern>/</url-pattern>\n</servlet-mapping>\n----\n\nThe following `WebSecurityConfiguration` in placed in the `ApplicationContext` of the `DispatcherServlet`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/mvc.adoc", "title": "mvc", "heading": "Configuring Spring MVC and Spring Security in the Same Application Context", "heading_level": 2, "file_order": 132, "section_index": 9, "content_hash": "d776237a4f844a8ecb043556010bd0bc07a8c436882cfc19d5562a8363e95083", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/mvc.adoc"}}
{"id": "sha256:3322bc998829b952f9fe8556be4a82df539c6534aa43f35a306a85e3ceb5af3f", "content": "[[observability]]\n\nSpring Security integrates with Spring Observability out-of-the-box for tracing; though it's also quite simple to configure for gathering metrics.\n\n[[observability-tracing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/observability.adoc", "title": "observability", "heading": "observability", "heading_level": 1, "file_order": 133, "section_index": 0, "content_hash": "3322bc998829b952f9fe8556be4a82df539c6534aa43f35a306a85e3ceb5af3f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/observability.adoc"}}
{"id": "sha256:db0fa969902ed86ba249cb73351240ed5f86077cef2d6c357746938a07448d6d", "content": "When an `ObservationRegistry` bean is present, Spring Security creates traces for:\n\n* the filter chain\n* the `AuthenticationManager`, and\n* the `AuthorizationManager`\n\n[[observability-tracing-boot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/observability.adoc", "title": "observability", "heading": "Tracing", "heading_level": 2, "file_order": 133, "section_index": 1, "content_hash": "db0fa969902ed86ba249cb73351240ed5f86077cef2d6c357746938a07448d6d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/observability.adoc"}}
{"id": "sha256:ef6ae491e999bcffc8315a3f8d30cfb70e71792e03e8605660d376ecbec184e3", "content": "For example, consider a simple Boot application:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@SpringBootApplication\npublic class MyApplication {\n\t@Bean\n\tpublic UserDetailsService userDetailsService() {\n return new InMemoryUserDetailsManager(\n User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .authorities(\"app\")\n .build()\n );\n\t}\n\n\t@Bean\n\tObservationRegistryCustomizer<ObservationRegistry> addTextHandler() {\n return (registry) -> registry.observationConfig().observationHandler(new ObservationTextPublisher());\n\t}\n\n\tpublic static void main(String[] args) {\n SpringApplication.run(ListenerSamplesApplication.class, args);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@SpringBootApplication\nclass MyApplication {\n\t@Bean\n\tfun userDetailsService(): UserDetailsService {\n InMemoryUserDetailsManager(\n User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .authorities(\"app\")\n .build()\n );\n\t}\n\n\t@Bean\n\tfun addTextHandler(): ObservationRegistryCustomizer<ObservationRegistry> {\n return registry: ObservationRegistry -> registry.observationConfig()\n .observationHandler(ObservationTextPublisher());\n\t}\n\n\tfun main(args: Array<String>) {\n runApplication<MyApplication>(*args)\n\t}\n}\n----\n======\n\nAnd a corresponding request:\n\n[source,bash]\n----\n?> http -a user:password :8080\n----\n\nWill produce the following output (indentation added for clarity):\n\n[source,bash]\n----\nSTART - name='http.server.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@687e16d1', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.001779024, duration(nanos)=1779024.0, startTimeNanos=91695917264958}']\n\tSTART - name='spring.security.http.chains', contextualName='spring.security.http.chains.before', error='null', lowCardinalityKeyValues=[chain.position='0', chain.size='17', filter.section='before'], highCardinalityKeyValues=[request.line='GET /'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@79f554a5', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=7.42147E-4, duration(nanos)=742147.0, startTimeNanos=91695947182029}']\n\t... skipped for brevity ...\n\tSTOP - name='spring.security.http.chains', contextualName='spring.security.http.chains.before', error='null', lowCardinalityKeyValues=[chain.position='0', chain.size='17', filter.section='before'], highCardinalityKeyValues=[request.line='GET /'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@79f554a5', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.014771848, duration(nanos)=1.4771848E7, startTimeNanos=91695947182029}']\n START - name='spring.security.authentications', contextualName='null', error='null', lowCardinalityKeyValues=[authentication.failure.type='Optional', authentication.method='ProviderManager', authentication.request.type='UsernamePasswordAuthenticationToken'], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@4d4b2b56', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=7.09759E-4, duration(nanos)=709759.0, startTimeNanos=91696094477504}']\n ... skipped for brevity ...\n STOP - name='spring.security.authentications', contextualName='null', error='null', lowCardinalityKeyValues=[authentication.failure.type='Optional', authentication.method='ProviderManager', authentication.request.type='UsernamePasswordAuthenticationToken', authentication.result.type='UsernamePasswordAuthenticationToken'], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@4d4b2b56', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.895141386, duration(nanos)=8.95141386E8, startTimeNanos=91696094477504}']\n START - name='spring.security.authorizations', contextualName='null', error='null', lowCardinalityKeyValues=[object.type='Servlet3SecurityContextHolderAwareRequestWrapper'], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@6d834cc7', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=3.0965E-4, duration(nanos)=309650.0, startTimeNanos=91697034893983}']\n ... skipped for brevity ...\n STOP - name='spring.security.authorizations', contextualName='null', error='null', lowCardinalityKeyValues=[authorization.decision='true', object.type='Servlet3SecurityContextHolderAwareRequestWrapper'], highCardinalityKeyValues=[authentication.authorities='[app]', authorization.decision.details='AuthorizationDecision [granted=true]'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@6d834cc7', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.02084809, duration(nanos)=2.084809E7, startTimeNanos=91697034893983}']\n START - name='spring.security.http.secured.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@649c5ec3', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=2.67878E-4, duration(nanos)=267878.0, startTimeNanos=91697059819304}']\n ... skipped for brevity ...\n STOP - name='spring.security.http.secured.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@649c5ec3', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.090753322, duration(nanos)=9.0753322E7, startTimeNanos=91697059819304}']\n\tSTART - name='spring.security.http.chains', contextualName='spring.security.http.chains.after', error='null', lowCardinalityKeyValues=[chain.position='0', chain.size='17', filter.section='after'], highCardinalityKeyValues=[request.line='GET /'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@47af8207', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=5.31832E-4, duration(nanos)=531832.0, startTimeNanos=91697152857268}']\n\t... skipped for brevity ...\n\tSTOP - name='spring.security.http.chains', contextualName='spring.security.http.chains.after', error='null', lowCardinalityKeyValues=[chain.position='17', chain.size='17', current.filter.name='DisableEncodeUrlFilter', filter.section='after'], highCardinalityKeyValues=[request.line='GET /'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@47af8207', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=0.007689382, duration(nanos)=7689382.0, startTimeNanos=91697152857268}']\nSTOP - name='http.server.requests', contextualName='null', error='null', lowCardinalityKeyValues=[], highCardinalityKeyValues=[request.line='GET /'], map=[class io.micrometer.core.instrument.Timer$Sample='io.micrometer.core.instrument.Timer$Sample@687e16d1', class io.micrometer.core.instrument.LongTaskTimer$Sample='SampleImpl{duration(seconds)=1.245858319, duration(nanos)=1.245858319E9, startTimeNanos=91695917264958}']\n----\n\n[[observability-tracing-manual-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/observability.adoc", "title": "observability", "heading": "Boot Integration", "heading_level": 3, "file_order": 133, "section_index": 2, "content_hash": "ef6ae491e999bcffc8315a3f8d30cfb70e71792e03e8605660d376ecbec184e3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/observability.adoc"}}
{"id": "sha256:0c7817e1028a3af49d1c5401b1dec810dd91d0b77ed6c26cd28b770c15d2c426", "content": "For a non-Spring Boot application, or to override the existing Boot configuration, you can publish your own `ObservationRegistry` and Spring Security will still pick it up.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@SpringBootApplication\npublic class MyApplication {\n\t@Bean\n\tpublic UserDetailsService userDetailsService() {\n return new InMemoryUserDetailsManager(\n User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .authorities(\"app\")\n .build()\n );\n\t}\n\n\t@Bean\n\tObservationRegistry observationRegistry() {\n ObservationRegistry registry = ObservationRegistry.create();\n registry.observationConfig().observationHandler(new ObservationTextPublisher());\n return registry;\n\t}\n\n\tpublic static void main(String[] args) {\n SpringApplication.run(ListenerSamplesApplication.class, args);\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@SpringBootApplication\nclass MyApplication {\n\t@Bean\n\tfun userDetailsService(): UserDetailsService {\n InMemoryUserDetailsManager(\n User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .authorities(\"app\")\n .build()\n );\n\t}\n\n\t@Bean\n\tfun observationRegistry(): ObservationRegistry {\n ObservationRegistry registry = ObservationRegistry.create()\n registry.observationConfig().observationHandler(ObservationTextPublisher())\n return registry\n\t}\n\n\tfun main(args: Array<String>) {\n runApplication<MyApplication>(*args)\n\t}\n}\n----\n\nXml::\n+\n[source,kotlin,role=\"secondary\"]\n----\n<sec:http auto-config=\"true\" observation-registry-ref=\"ref\">\n\t<sec:intercept-url pattern=\"/**\" access=\"authenticated\"/>\n</sec:http>\n\n<!-- define and configure ObservationRegistry bean -->\n----\n======\n\n[[observability-tracing-disable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/observability.adoc", "title": "observability", "heading": "Manual Configuration", "heading_level": 3, "file_order": 133, "section_index": 3, "content_hash": "0c7817e1028a3af49d1c5401b1dec810dd91d0b77ed6c26cd28b770c15d2c426", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/observability.adoc"}}
{"id": "sha256:177df75b0d65a0d4675ee3afab4ec3026f8ad132c07eef005149dff2833c19fb", "content": "If you don't want any Spring Security observations, in a Spring Boot application you can publish a `ObservationRegistry.NOOP` `@Bean`.\nHowever, this may turn off observations for more than just Spring Security.\n\nInstead, you can publish a `SecurityObservationSettings` like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityObservationSettings noSpringSecurityObservations() {\n\treturn SecurityObservationSettings.noObservations();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun noSpringSecurityObservations(): SecurityObservationSettings {\n\treturn SecurityObservationSettings.noObservations()\n}\n----\n======\n\nand then Spring Security will not wrap any filter chains, authentications, or authorizations in their `ObservationXXX` counterparts.\n\n[TIP]\nThere is no facility for disabling observations with XML support.\nInstead, simply do not set the `observation-registry-ref` attribute.\n\nYou can also disable security for only a subset of Security's observations.\nFor example, the `SecurityObservationSettings` bean excludes the filter chain observations by default.\nSo, you can also do:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityObservationSettings defaultSpringSecurityObservations() {\n\treturn SecurityObservationSettings.withDefaults().build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun defaultSpringSecurityObservations(): SecurityObservationSettings {\n\treturn SecurityObservationSettings.withDefaults().build()\n}\n----\n======\n\nOr you can turn on and off observations individually, based on the defaults:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityObservationSettings allSpringSecurityObservations() {\n\treturn SecurityObservationSettings.withDefaults()\n .shouldObserveFilterChains(true).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun allSpringSecurityObservations(): SecurityObservationSettings {\n return SecurityObservationSettings.builder()\n .shouldObserveFilterChains(true).build()\n}\n----\n======\n\n[NOTE]\n=====\nFor backward compatibility, the all Spring Security observations are made unless a `SecurityObservationSettings` is published.\n=====\n\n[[observability-tracing-listing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/observability.adoc", "title": "observability", "heading": "Disabling Observability", "heading_level": 4, "file_order": 133, "section_index": 4, "content_hash": "177df75b0d65a0d4675ee3afab4ec3026f8ad132c07eef005149dff2833c19fb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/observability.adoc"}}
{"id": "sha256:978657a9efeeb0597f667757c45b90e5c9ac0297f7d7c48eaed2971f0ac430f8", "content": "Spring Security tracks the following spans on each request:\n\n1. `spring.security.http.requests` - a span that wraps the entire filter chain, including the request\n2. `spring.security.http.chains.before` - a span that wraps the receiving part of the security filters\n3. `spring.security.http.chains.after` - a span that wraps the returning part of the security filters\n4. `spring.security.http.secured.requests` - a span that wraps the now-secured application request\n5. `spring.security.http.unsecured.requests` - a span that wraps requests that Spring Security does not secure\n6. `spring.security.authentications` - a span that wraps authentication attempts\n7. `spring.security.authorizations` - a span that wraps authorization attempts\n\n[TIP]\n`spring.security.http.chains.before` + `spring.security.http.secured.requests` + `spring.security.http.chains.after` = `spring.security.http.requests` +\n`spring.security.http.chains.before` + `spring.security.http.chains.after` = Spring Security's part of the request", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/observability.adoc", "title": "observability", "heading": "Trace Listing", "heading_level": 3, "file_order": 133, "section_index": 5, "content_hash": "978657a9efeeb0597f667757c45b90e5c9ac0297f7d7c48eaed2971f0ac430f8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/observability.adoc"}}
{"id": "sha256:3eabea2611f4f6b1489539a64454b680870d8b76cf7aec5e2286fef852fc4d91", "content": "[[servletapi]]\nThis section describes how Spring Security is integrated with the Servlet API.\n\n[[servletapi-25]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "servlet-api", "heading_level": 1, "file_order": 134, "section_index": 0, "content_hash": "3eabea2611f4f6b1489539a64454b680870d8b76cf7aec5e2286fef852fc4d91", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:4ff0a5e827ef5628340bee4253b496ea9091cf9792956b2c87cbe247e5b65205", "content": "This section describes how Spring Security integrates with the Servlet 2.5 specification.\n\n[[servletapi-remote-user]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "Servlet 2.5+ Integration", "heading_level": 2, "file_order": 134, "section_index": 1, "content_hash": "4ff0a5e827ef5628340bee4253b496ea9091cf9792956b2c87cbe247e5b65205", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:9956cabf0ff0bf4a6e1680e8a39cc1c54242736d22fe10c16c41cda66f8199b7", "content": "https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()[`HttpServletRequest.getRemoteUser()`] returns the result of `SecurityContextHolder.getContext().getAuthentication().getName()`, which is typically the current username.This can be useful if you want to display the current username in your application.\nAdditionally, you can check this for null to determine whether a user has authenticated or is anonymous.\nKnowing whether the user is authenticated or not can be useful for determining if certain UI elements should be shown or not (for example, a logout link that should be displayed only if the user is authenticated).\n\n[[servletapi-user-principal]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "HttpServletRequest.getRemoteUser()", "heading_level": 3, "file_order": 134, "section_index": 2, "content_hash": "9956cabf0ff0bf4a6e1680e8a39cc1c54242736d22fe10c16c41cda66f8199b7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:d148f737fdacc29bc2cbfe18b8b79c5d598d63fc59db884840a9d246c0be93e7", "content": "https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()[`HttpServletRequest.getUserPrincipal()`] returns the result of `SecurityContextHolder.getContext().getAuthentication()`.\nThis means that it is an `Authentication`, which is typically an instance of `UsernamePasswordAuthenticationToken` when using username- and password-based authentication.\nThis can be useful if you need additional information about your user.\nFor example, you might have created a custom `UserDetailsService` that returns a custom `UserDetails` containing a first and last name for your user.\nYou could obtain this information with the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nAuthentication auth = httpServletRequest.getUserPrincipal();\nMyCustomUserDetails userDetails = (MyCustomUserDetails) auth.getPrincipal();\nString firstName = userDetails.getFirstName();\nString lastName = userDetails.getLastName();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval auth: Authentication = httpServletRequest.getUserPrincipal()\nval userDetails: MyCustomUserDetails = auth.principal as MyCustomUserDetails\nval firstName: String = userDetails.firstName\nval lastName: String = userDetails.lastName\n----\n======\n\n[NOTE]\n====\nIt should be noted that it is typically bad practice to perform so much logic throughout your application.\nInstead, one should centralize it to reduce any coupling of Spring Security and the Servlet API's.\n====\n\n[[servletapi-user-in-role]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "HttpServletRequest.getUserPrincipal()", "heading_level": 3, "file_order": 134, "section_index": 3, "content_hash": "d148f737fdacc29bc2cbfe18b8b79c5d598d63fc59db884840a9d246c0be93e7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:d5b13d72d01ffabf25824618255dfac6f1beeaa68cecea99104f65ced4c22edc", "content": "https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)[`HttpServletRequest.isUserInRole(String)`] determines if `SecurityContextHolder.getContext().getAuthentication().getAuthorities()` contains a `GrantedAuthority` with the role passed into `isUserInRole(String)`.\nTypically, users should not pass the `ROLE_` prefix to this method, since it is added automatically.\nFor example, if you want to determine if the current user has the authority \"ROLE_ADMIN\", you could use the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nboolean isAdmin = httpServletRequest.isUserInRole(\"ADMIN\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval isAdmin: Boolean = httpServletRequest.isUserInRole(\"ADMIN\")\n----\n======\n\nThis might be useful to determine if certain UI components should be displayed.\nFor example, you might display admin links only if the current user is an admin.\n\n[[servletapi-3]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "HttpServletRequest.isUserInRole(String)", "heading_level": 3, "file_order": 134, "section_index": 4, "content_hash": "d5b13d72d01ffabf25824618255dfac6f1beeaa68cecea99104f65ced4c22edc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:72649f9d9b7713b790735d341329dc554c8d051f9d1ec551f130f837bcbbe347", "content": "The following section describes the Servlet 3 methods with which Spring Security integrates.\n\n[[servletapi-authenticate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "Servlet 3+ Integration", "heading_level": 2, "file_order": 134, "section_index": 5, "content_hash": "72649f9d9b7713b790735d341329dc554c8d051f9d1ec551f130f837bcbbe347", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:1edca148538435c495dbd084debb49e8f8bf4c41f82e28945e5ec79906211b01", "content": "You can use the https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#authenticate%28javax.servlet.http.HttpServletResponse%29[`HttpServletRequest.authenticate(HttpServletResponse)`] method to ensure that a user is authenticated.\nIf they are not authenticated, the configured `AuthenticationEntryPoint` is used to request the user to authenticate (redirect to the login page).\n\n[[servletapi-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "HttpServletRequest.authenticate(HttpServletResponse)", "heading_level": 3, "file_order": 134, "section_index": 6, "content_hash": "1edca148538435c495dbd084debb49e8f8bf4c41f82e28945e5ec79906211b01", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:02c11f391e31129b71fa0bec5a5d7d0fd869161cd3bcc0f3d02361203150cbcd", "content": "You can use the https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login%28java.lang.String,%20java.lang.String%29[`HttpServletRequest.login(String,String)`] method to authenticate the user with the current `AuthenticationManager`.\nFor example, the following would attempt to authenticate with a username of `user` and a password of `password`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\ntry {\nhttpServletRequest.login(\"user\",\"password\");\n} catch(ServletException ex) {\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ntry {\n httpServletRequest.login(\"user\", \"password\")\n} catch (ex: ServletException) {\n // fail to authenticate\n}\n----\n======\n\n[NOTE]\n====\nYou need not catch the `ServletException` if you want Spring Security to process the failed authentication attempt.\n====\n\n[[servletapi-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "HttpServletRequest.login(String,String)", "heading_level": 3, "file_order": 134, "section_index": 7, "content_hash": "02c11f391e31129b71fa0bec5a5d7d0fd869161cd3bcc0f3d02361203150cbcd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:465308c537bc301138fdc4b7b39b112c8c53ee0ef6316d796731eae72f32c232", "content": "You can use the https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout%28%29[`HttpServletRequest.logout()`] method to log out the current user.\n\nTypically, this means that the `SecurityContextHolder` is cleared out, the `HttpSession` is invalidated, any \"`Remember Me`\" authentication is cleaned up, and so on.\nHowever, the configured `LogoutHandler` implementations vary, depending on your Spring Security configuration.\nNote that, after `HttpServletRequest.logout()` has been invoked, you are still in charge of writing out a response.\nTypically, this would involve a redirect to the welcome page.\n\n[[servletapi-start-runnable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "HttpServletRequest.logout()", "heading_level": 3, "file_order": 134, "section_index": 8, "content_hash": "465308c537bc301138fdc4b7b39b112c8c53ee0ef6316d796731eae72f32c232", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:20863dae21815602e5dcbd6cadf6cb89fb574a8f028a86d7c5e78c745bde27b8", "content": "The https://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html#start%28java.lang.Runnable%29[`AsyncContext.start(Runnable)`] method ensures your credentials are propagated to the new `Thread`.\nBy using Spring Security's concurrency support, Spring Security overrides `AsyncContext.start(Runnable)` to ensure that the current `SecurityContext` is used when processing the Runnable.\nThe following example outputs the current user's Authentication:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nfinal AsyncContext async = httpServletRequest.startAsync();\nasync.start(new Runnable() {\n\tpublic void run() {\n Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n try {\n final HttpServletResponse asyncResponse = (HttpServletResponse) async.getResponse();\n asyncResponse.setStatus(HttpServletResponse.SC_OK);\n asyncResponse.getWriter().write(String.valueOf(authentication));\n async.complete();\n } catch(Exception ex) {\n throw new RuntimeException(ex);\n }\n\t}\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval async: AsyncContext = httpServletRequest.startAsync()\nasync.start {\n val authentication: Authentication = SecurityContextHolder.getContext().authentication\n try {\n val asyncResponse = async.response as HttpServletResponse\n asyncResponse.status = HttpServletResponse.SC_OK\n asyncResponse.writer.write(String.valueOf(authentication))\n async.complete()\n } catch (ex: Exception) {\n throw RuntimeException(ex)\n }\n}\n----\n======\n\n[[servletapi-async]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "AsyncContext.start(Runnable)", "heading_level": 3, "file_order": 134, "section_index": 9, "content_hash": "20863dae21815602e5dcbd6cadf6cb89fb574a8f028a86d7c5e78c745bde27b8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:dbd498740d627350ca47609e620874e0f2a4d78450970172f515e2d95da0d54c", "content": "If you use Java-based configuration, you are ready to go.\nIf you use XML configuration, a few updates are necessary.\nThe first step is to ensure that you have updated your `web.xml` file to use at least the 3.0 schema:\n\n[source,xml]\n----\n<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\nversion=\"3.0\">\n\n</web-app>\n----\n\nNext, you need to ensure that your `springSecurityFilterChain` is set up for processing asynchronous requests:\n\n[source,xml]\n----\n<filter>\n<filter-name>springSecurityFilterChain</filter-name>\n<filter-class>\n\torg.springframework.web.filter.DelegatingFilterProxy\n</filter-class>\n<async-supported>true</async-supported>\n</filter>\n<filter-mapping>\n<filter-name>springSecurityFilterChain</filter-name>\n<url-pattern>/*</url-pattern>\n<dispatcher>REQUEST</dispatcher>\n<dispatcher>ASYNC</dispatcher>\n</filter-mapping>\n----\n\nNow Spring Security ensures that your `SecurityContext` is propagated on asynchronous requests, too.\n\nSo how does it work? If you are not really interested, feel free to skip the remainder of this section\nMost of this is built into the Servlet specification, but there is a little bit of tweaking that Spring Security does to ensure things work properly with asynchronous requests.\nPrior to Spring Security 3.2, the `SecurityContext` from the `SecurityContextHolder` was automatically saved as soon as the `HttpServletResponse` was committed.\nThis can cause issues in an asynchronous environment.\nConsider the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttpServletRequest.startAsync();\nnew Thread(\"AsyncThread\") {\n\t@Override\n\tpublic void run() {\n try {\n // Do work\n TimeUnit.SECONDS.sleep(1);\n\n // Write to and commit the httpServletResponse\n httpServletResponse.getOutputStream().flush();\n } catch (Exception ex) {\n ex.printStackTrace();\n }\n\t}\n}.start();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttpServletRequest.startAsync()\nobject : Thread(\"AsyncThread\") {\n override fun run() {\n try {\n // Do work\n TimeUnit.SECONDS.sleep(1)\n\n // Write to and commit the httpServletResponse\n httpServletResponse.outputStream.flush()\n } catch (ex: java.lang.Exception) {\n ex.printStackTrace()\n }\n }\n}.start()\n----\n======\n\nThe issue is that this `Thread` is not known to Spring Security, so the `SecurityContext` is not propagated to it.\nThis means that, when we commit the `HttpServletResponse`, there is no `SecurityContext`.\nWhen Spring Security automatically saved the `SecurityContext` on committing the `HttpServletResponse`, it would lose a logged in user.\n\nSince version 3.2, Spring Security is smart enough to no longer automatically save the `SecurityContext` on committing the `HttpServletResponse` as soon as `HttpServletRequest.startAsync()` is invoked.\n\n[[servletapi-31]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "Async Servlet Support", "heading_level": 3, "file_order": 134, "section_index": 10, "content_hash": "dbd498740d627350ca47609e620874e0f2a4d78450970172f515e2d95da0d54c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:bed7c037a27a0a0b9c6af9a06cf66b2a5f7747a4aa7cca13a803375f16f57def", "content": "The following section describes the Servlet 3.1 methods that Spring Security integrates with.\n\n[[servletapi-change-session-id]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "Servlet 3.1+ Integration", "heading_level": 2, "file_order": 134, "section_index": 11, "content_hash": "bed7c037a27a0a0b9c6af9a06cf66b2a5f7747a4aa7cca13a803375f16f57def", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:bf15be6791b7c12e141a4ae70e95bead8579737bbaafae92f6b802e743e61c2b", "content": "https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html#changeSessionId()[HttpServletRequest.changeSessionId()] is the default method for protecting against xref:servlet/authentication/session-management.adoc#ns-session-fixation[Session Fixation] attacks in Servlet 3.1 and higher.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc", "title": "servlet-api", "heading": "HttpServletRequest#changeSessionId()", "heading_level": 3, "file_order": 134, "section_index": 12, "content_hash": "bf15be6791b7c12e141a4ae70e95bead8579737bbaafae92f6b802e743e61c2b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/servlet-api.adoc"}}
{"id": "sha256:434ff37597dcdc701b5f70e2f76a2d7695aa0543969e135c6ec094755d8a1444", "content": "[[websocket]]\n\nSpring Security 4 added support for securing https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html[Spring's WebSocket support].\nThis section describes how to use Spring Security's WebSocket support.\n\n.Direct JSR-356 Support\n****\nSpring Security does not provide direct JSR-356 support, because doing so would provide little value.\nThis is because the format is unknown, and there is https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-intro-sub-protocol[little Spring can do to secure an unknown format].\nAdditionally, JSR-356 does not provide a way to intercept messages, so security would be invasive.\n****\n\n[[websocket-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "websocket", "heading_level": 1, "file_order": 135, "section_index": 0, "content_hash": "434ff37597dcdc701b5f70e2f76a2d7695aa0543969e135c6ec094755d8a1444", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:ea6c8a9ec5ba4b37259f6c41e4b89a60a662d01def4f6e3f8a4b51229abcfa9d", "content": "WebSockets reuse the same authentication information that is found in the HTTP request when the WebSocket connection was made.\nThis means that the `Principal` on the `HttpServletRequest` will be handed off to WebSockets.\nIf you are using Spring Security, the `Principal` on the `HttpServletRequest` is overridden automatically.\n\nMore concretely, to ensure a user has authenticated to your WebSocket application, all that is necessary is to ensure that you setup Spring Security to authenticate your HTTP based web application.\n\n[[websocket-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "WebSocket Authentication", "heading_level": 2, "file_order": 135, "section_index": 1, "content_hash": "ea6c8a9ec5ba4b37259f6c41e4b89a60a662d01def4f6e3f8a4b51229abcfa9d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:8789fd5d9f5a377625b008860deb95e724c0e0924ea4133e7e64a24b81535e88", "content": "Spring Security 4.0 has introduced authorization support for WebSockets through the Spring Messaging abstraction.\n\nIn Spring Security 5.8, this support has been refreshed to use the `AuthorizationManager` API.\n\nTo configure authorization using Java Configuration, simply include the `@EnableWebSocketSecurity` annotation and publish an `AuthorizationManager<Message<?>>` bean or in xref:servlet/appendix/namespace/websocket.adoc#nsa-websocket-security[XML] use the `use-authorization-manager` attribute.\nOne way to do this is by using the `AuthorizationManagerMessageMatcherRegistry` to specify endpoint patterns like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSocketSecurity // <1> <2>\npublic class WebSocketSecurityConfig {\n\n @Bean\n AuthorizationManager<Message<?>> messageAuthorizationManager(MessageMatcherDelegatingAuthorizationManager.Builder messages) {\n messages\n .simpDestMatchers(\"/user/**\").hasRole(\"USER\") // <3>\n\n return messages.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSocketSecurity // <1> <2>\nopen class WebSocketSecurityConfig { // <1> <2>\n @Bean\n fun messageAuthorizationManager(messages: MessageMatcherDelegatingAuthorizationManager.Builder): AuthorizationManager<Message<*>> {\n messages.simpDestMatchers(\"/user/**\").hasRole(\"USER\") // <3>\n return messages.build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<websocket-message-broker use-authorization-manager=\"true\"> <1> <2>\n <intercept-message pattern=\"/user/**\" access=\"hasRole('USER')\"/> <3>\n</websocket-message-broker>\n----\n======\n<1> Any inbound CONNECT message requires a valid CSRF token to enforce the <<websocket-sameorigin,Same Origin Policy>>.\n<2> The `SecurityContextHolder` is populated with the user within the `simpUser` header attribute for any inbound request.\n<3> Our messages require the proper authorization. Specifically, any inbound message that starts with `/user/` will require `ROLE_USER`. You can find additional details on authorization in <<websocket-authorization>>", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "WebSocket Authorization", "heading_level": 2, "file_order": 135, "section_index": 2, "content_hash": "8789fd5d9f5a377625b008860deb95e724c0e0924ea4133e7e64a24b81535e88", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:3b2e56257150ffb10f139d54628bddb4b109281e41cc6e82ee7275b553b8ca70", "content": "When using `AuthorizationManager`, customization is quite simple.\nFor example, you can publish an `AuthorizationManager` that requires that all messages have a role of \"USER\" using `AuthorityAuthorizationManager`, as seen below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSocketSecurity // <1> <2>\npublic class WebSocketSecurityConfig {\n\n @Bean\n AuthorizationManager<Message<?>> messageAuthorizationManager(MessageMatcherDelegatingAuthorizationManager.Builder messages) {\n return AuthorityAuthorizationManager.hasRole(\"USER\");\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSocketSecurity // <1> <2>\nopen class WebSocketSecurityConfig {\n @Bean\n fun messageAuthorizationManager(messages: MessageMatcherDelegatingAuthorizationManager.Builder): AuthorizationManager<Message<*>> {\n return AuthorityAuthorizationManager.hasRole(\"USER\") // <3>\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<bean id=\"authorizationManager\" class=\"org.example.MyAuthorizationManager\"/>\n\n<websocket-message-broker authorization-manager-ref=\"myAuthorizationManager\"/>\n----\n======\n\nThere are several ways to further match messages, as can be seen in a more advanced example below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class WebSocketSecurityConfig {\n\n @Bean\n public AuthorizationManager<Message<?>> messageAuthorizationManager(MessageMatcherDelegatingAuthorizationManager.Builder messages) {\n messages\n .nullDestMatcher().authenticated() // <1>\n .simpSubscribeDestMatchers(\"/user/queue/errors\").permitAll() // <2>\n .simpDestMatchers(\"/app/**\").hasRole(\"USER\") // <3>\n .simpSubscribeDestMatchers(\"/user/**\", \"/topic/friends/*\").hasRole(\"USER\") // <4>\n .simpTypeMatchers(MESSAGE, SUBSCRIBE).denyAll() // <5>\n .anyMessage().denyAll(); // <6>\n\n return messages.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nopen class WebSocketSecurityConfig {\n fun messageAuthorizationManager(messages: MessageMatcherDelegatingAuthorizationManager.Builder): AuthorizationManager<Message<*>> {\n messages\n .nullDestMatcher().authenticated() // <1>\n .simpSubscribeDestMatchers(\"/user/queue/errors\").permitAll() // <2>\n .simpDestMatchers(\"/app/**\").hasRole(\"USER\") // <3>\n .simpSubscribeDestMatchers(\"/user/**\", \"/topic/friends/*\").hasRole(\"USER\") // <4>\n .simpTypeMatchers(MESSAGE, SUBSCRIBE).denyAll() // <5>\n .anyMessage().denyAll() // <6>\n\n return messages.build();\n }\n}\n----\n\nXml::\n+\n[source,kotlin,role=\"secondary\"]\n----\n<websocket-message-broker use-authorization-manager=\"true\">\n <!--1-->\n <intercept-message type=\"CONNECT\" access=\"permitAll\" />\n <intercept-message type=\"UNSUBSCRIBE\" access=\"permitAll\" />\n <intercept-message type=\"DISCONNECT\" access=\"permitAll\" />\n\n <intercept-message pattern=\"/user/queue/errors\" type=\"SUBSCRIBE\" access=\"permitAll\" /> <!--2-->\n <intercept-message pattern=\"/app/**\" access=\"hasRole('USER')\" /> <!--3-->\n\n <!--4-->\n <intercept-message pattern=\"/user/**\" type=\"SUBSCRIBE\" access=\"hasRole('USER')\" />\n <intercept-message pattern=\"/topic/friends/*\" type=\"SUBSCRIBE\" access=\"hasRole('USER')\" />\n\n <!--5-->\n <intercept-message type=\"MESSAGE\" access=\"denyAll\" />\n <intercept-message type=\"SUBSCRIBE\" access=\"denyAll\" />\n\n <intercept-message pattern=\"/**\" access=\"denyAll\" /> <!--6-->\n</websocket-message-broker>\n----\n======\n\nThis will ensure that:\n\n<1> Any message without a destination (i.e. anything other than Message type of MESSAGE or SUBSCRIBE) will require the user to be authenticated\n<2> Anyone can subscribe to /user/queue/errors\n<3> Any message that has a destination starting with \"/app/\" will be require the user to have the role ROLE_USER\n<4> Any message that starts with \"/user/\" or \"/topic/friends/\" that is of type SUBSCRIBE will require ROLE_USER\n<5> Any other message of type MESSAGE or SUBSCRIBE is rejected. Due to 6 we do not need this step, but it illustrates how one can match on specific message types.\n<6> Any other Message is rejected. This is a good idea to ensure that you do not miss any messages.\n\n[[migrating-spel-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "Custom Authorization", "heading_level": 3, "file_order": 135, "section_index": 3, "content_hash": "3b2e56257150ffb10f139d54628bddb4b109281e41cc6e82ee7275b553b8ca70", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:86c063301a4a6a8d030d1e470fe9dc0a73a90ce8b51fe6cb30e568c977e3d87a", "content": "If you are migrating from an older version of Spring Security, your destination matchers may include SpEL expressions.\nIt's recommended that these be changed to using concrete implementations of `AuthorizationManager` since this is independently testable.\n\nHowever, to ease migration, you can also use a class like the following:\n\n[source,java]\n----\npublic final class MessageExpressionAuthorizationManager implements AuthorizationManager<MessageAuthorizationContext<?>> {\n\n\tprivate SecurityExpressionHandler<Message<?>> expressionHandler = new DefaultMessageSecurityExpressionHandler();\n\n\tprivate Expression expression;\n\n\tpublic MessageExpressionAuthorizationManager(String expressionString) {\n Assert.hasText(expressionString, \"expressionString cannot be empty\");\n this.expression = this.expressionHandler.getExpressionParser().parseExpression(expressionString);\n\t}\n\n\t@Override\n\tpublic AuthorizationResult authorize(Supplier<Authentication> authentication, MessageAuthorizationContext<?> context) {\n EvaluationContext ctx = this.expressionHandler.createEvaluationContext(authentication, context.getMessage());\n boolean granted = ExpressionUtils.evaluateAsBoolean(this.expression, ctx);\n return new ExpressionAuthorizationDecision(granted, this.expression);\n\t}\n\n}\n----\n\nAnd specify an instance for each matcher that you cannot get migrate:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class WebSocketSecurityConfig {\n\n @Bean\n public AuthorizationManager<Message<?>> messageAuthorizationManager(MessageMatcherDelegatingAuthorizationManager.Builder messages) {\n messages\n // ...\n .simpSubscribeDestMatchers(\"/topic/friends/{friend}\").access(new MessageExpressionAuthorizationManager(\"#friends == 'john\"));\n // ...\n\n return messages.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nopen class WebSocketSecurityConfig {\n fun messageAuthorizationManager(messages: MessageMatcherDelegatingAuthorizationManager.Builder): AuthorizationManager<Message<?> {\n messages\n // ..\n .simpSubscribeDestMatchers(\"/topic/friends/{friends}\").access(MessageExpressionAuthorizationManager(\"#friends == 'john\"))\n // ...\n\n return messages.build()\n }\n}\n----\n======\n\n[[websocket-authorization-notes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "Migrating SpEL Expressions", "heading_level": 3, "file_order": 135, "section_index": 4, "content_hash": "86c063301a4a6a8d030d1e470fe9dc0a73a90ce8b51fe6cb30e568c977e3d87a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:1812979dfd370d3a7369deed85862040cc82df4df8a6cb8ca12b44839b424f93", "content": "To properly secure your application, you need to understand Spring's WebSocket support.\n\n[[websocket-authorization-notes-messagetypes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "WebSocket Authorization Notes", "heading_level": 3, "file_order": 135, "section_index": 5, "content_hash": "1812979dfd370d3a7369deed85862040cc82df4df8a6cb8ca12b44839b424f93", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:e759c81a6b9aa4e83ac8acc786eb3f24525c77afd61c10a28d511d7e168241b2", "content": "You need to understand the distinction between `SUBSCRIBE` and `MESSAGE` types of messages and how they work within Spring.\n\nConsider a chat application:\n\n* The system can send a notification `MESSAGE` to all users through a destination of `/topic/system/notifications`.\n* Clients can receive notifications by `SUBSCRIBE` to the `/topic/system/notifications`.\n\nWhile we want clients to be able to `SUBSCRIBE` to `/topic/system/notifications`, we do not want to enable them to send a `MESSAGE` to that destination.\nIf we allowed sending a `MESSAGE` to `/topic/system/notifications`, clients could send a message directly to that endpoint and impersonate the system.\n\nIn general, it is common for applications to deny any `MESSAGE` sent to a destination that starts with the https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp[broker prefix] (`/topic/` or `/queue/`).\n\n[[websocket-authorization-notes-destinations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "WebSocket Authorization on Message Types", "heading_level": 4, "file_order": 135, "section_index": 6, "content_hash": "e759c81a6b9aa4e83ac8acc786eb3f24525c77afd61c10a28d511d7e168241b2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:60ae6b986313e90942db16a6f3fd0e4293551ffb33d6dfd11ec452999c6e3085", "content": "You should also understand how destinations are transformed.\n\nConsider a chat application:\n\n* Users can send messages to a specific user by sending a message to the `/app/chat` destination.\n* The application sees the message, ensures that the `from` attribute is specified as the current user (we cannot trust the client).\n* The application then sends the message to the recipient by using `SimpMessageSendingOperations.convertAndSendToUser(\"toUser\", \"/queue/messages\", message)`.\n* The message gets turned into the destination of `/queue/user/messages-<sessionid>`.\n\nWith this chat application, we want to let our client to listen `/user/queue`, which is transformed into `/queue/user/messages-<sessionid>`.\nHowever, we do not want the client to be able to listen to `/queue/*`, because that would let the client see messages for every user.\n\nIn general, it is common for applications to deny any `SUBSCRIBE` sent to a message that starts with the https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp[broker prefix] (`/topic/` or `/queue/`).\nWe may provide exceptions to account for things like\n\n[[websocket-authorization-notes-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "WebSocket Authorization on Destinations", "heading_level": 4, "file_order": 135, "section_index": 7, "content_hash": "60ae6b986313e90942db16a6f3fd0e4293551ffb33d6dfd11ec452999c6e3085", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:b73eafb55d03e08034e003940e53358f28d805e407b50a6934d40be4097aad56", "content": "The Spring Framework reference documentation contains a section titled https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp-message-flow[\"`Flow of Messages`\"] that describes how messages flow through the system.\nNote that Spring Security secures only the `clientInboundChannel`.\nSpring Security does not attempt to secure the `clientOutboundChannel`.\n\nThe most important reason for this is performance.\nFor every message that goes in, typically many more go out.\nInstead of securing the outbound messages, we encourage securing the subscription to the endpoints.\n\n[[websocket-sameorigin]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "Outbound Messages", "heading_level": 3, "file_order": 135, "section_index": 8, "content_hash": "b73eafb55d03e08034e003940e53358f28d805e407b50a6934d40be4097aad56", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:47c1cd11571af79fe179e38daceb5c304d3f83855e9cd9a6cd64405c4119f1f6", "content": "Note that the browser does not enforce the https://en.wikipedia.org/wiki/Same-origin_policy[Same Origin Policy] for WebSocket connections.\nThis is an extremely important consideration.\n\n[[websocket-sameorigin-why]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "Enforcing Same Origin Policy", "heading_level": 2, "file_order": 135, "section_index": 9, "content_hash": "47c1cd11571af79fe179e38daceb5c304d3f83855e9cd9a6cd64405c4119f1f6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:2aa4d91e1c2411f0b96aa829c250d757cdd1c359e64024621e23274c9b9a77c2", "content": "Consider the following scenario.\nA user visits `bank.com` and authenticates to their account.\nThe same user opens another tab in their browser and visits `evil.com`.\nThe Same Origin Policy ensures that `evil.com` cannot read data from or write data to `bank.com`.\n\nWith WebSockets, the Same Origin Policy does not apply.\nIn fact, unless `bank.com` explicitly forbids it, `evil.com` can read and write data on behalf of the user.\nThis means that anything the user can do over the webSocket (such as transferring money), `evil.com` can do on that user's behalf.\n\nSince SockJS tries to emulate WebSockets, it also bypasses the Same Origin Policy.\nThis means that developers need to explicitly protect their applications from external domains when they use SockJS.\n\n[[websocket-sameorigin-spring]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "Why Same Origin?", "heading_level": 3, "file_order": 135, "section_index": 10, "content_hash": "2aa4d91e1c2411f0b96aa829c250d757cdd1c359e64024621e23274c9b9a77c2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:d6df0a85dcf7385a1e92466e8d4ea2fe936ca81ad513843b141a54293349ec61", "content": "Fortunately, since Spring 4.1.5 Spring's WebSocket and SockJS support restricts access to the https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-server-allowed-origins[current domain].\nSpring Security adds an additional layer of protection to provide https://en.wikipedia.org/wiki/Defence_in_depth_(non-military)#Information_security[defense in depth].\n\n[[websocket-sameorigin-csrf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "Spring WebSocket Allowed Origin", "heading_level": 3, "file_order": 135, "section_index": 11, "content_hash": "d6df0a85dcf7385a1e92466e8d4ea2fe936ca81ad513843b141a54293349ec61", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:3a371a4e4bca02543c1877e3e37c53e8e9df43d90b466e087a1d1209df3ffe50", "content": "By default, Spring Security requires the xref:features/exploits/csrf.adoc#csrf[CSRF token] in any `CONNECT` message type.\nThis ensures that only a site that has access to the CSRF token can connect.\nSince only the *same origin* can access the CSRF token, external domains are not allowed to make a connection.\n\nTypically we need to include the CSRF token in an HTTP header or an HTTP parameter.\nHowever, SockJS does not allow for these options.\nInstead, we must include the token in the Stomp headers.\n\nApplications can xref:servlet/exploits/csrf.adoc#csrf-integration[obtain a CSRF token] by accessing the request attribute named `_csrf`.\nFor example, the following allows accessing the `CsrfToken` in a JSP:\n\n[source,javascript]\n----\nvar headerName = \"${_csrf.headerName}\";\nvar token = \"${_csrf.token}\";\n----\n\nIf you use static HTML, you can expose the `CsrfToken` on a REST endpoint.\nFor example, the following would expose the `CsrfToken` on the `/csrf` URL:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic class CsrfController {\n\n @RequestMapping(\"/csrf\")\n public CsrfToken csrf(CsrfToken token) {\n return token;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@RestController\nclass CsrfController {\n @RequestMapping(\"/csrf\")\n fun csrf(token: CsrfToken): CsrfToken {\n return token\n }\n}\n----\n======\n\nThe JavaScript can make a REST call to the endpoint and use the response to populate the `headerName` and the token.\n\nWe can now include the token in our Stomp client:\n\n[source,javascript]\n----\n...\nvar headers = {};\nheaders[headerName] = token;\nstompClient.connect(headers, function(frame) {\n ...\n\n})\n----\n\n[[websocket-sameorigin-disable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "Adding CSRF to Stomp Headers", "heading_level": 3, "file_order": 135, "section_index": 12, "content_hash": "3a371a4e4bca02543c1877e3e37c53e8e9df43d90b466e087a1d1209df3ffe50", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:61df80bce273f751e8ee7f44552c979be63bc7278fa2a148f9ad7b813bd436f2", "content": "NOTE: At this point, CSRF is not configurable when using `@EnableWebSocketSecurity`, though this will likely be added in a future release.\n\nTo disable CSRF, instead of using `@EnableWebSocketSecurity`, you can use XML support or add the Spring Security components yourself, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class WebSocketSecurityConfig implements WebSocketMessageBrokerConfigurer {\n\n private final ApplicationContext applicationContext;\n\n private final AuthorizationManager<Message<?>> authorizationManager;\n\n public WebSocketSecurityConfig(ApplicationContext applicationContext, AuthorizationManager<Message<?>> authorizationManager) {\n this.applicationContext = applicationContext;\n this.authorizationManager = authorizationManager;\n }\n\n @Override\n public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n argumentResolvers.add(new AuthenticationPrincipalArgumentResolver());\n }\n\n @Override\n public void configureClientInboundChannel(ChannelRegistration registration) {\n AuthorizationChannelInterceptor authz = new AuthorizationChannelInterceptor(authorizationManager);\n AuthorizationEventPublisher publisher = new SpringAuthorizationEventPublisher(applicationContext);\n authz.setAuthorizationEventPublisher(publisher);\n registration.interceptors(new SecurityContextChannelInterceptor(), authz);\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nopen class WebSocketSecurityConfig(val applicationContext: ApplicationContext, val authorizationManager: AuthorizationManager<Message<*>>) : WebSocketMessageBrokerConfigurer {\n @Override\n override fun addArgumentResolvers(argumentResolvers: List<HandlerMethodArgumentResolver>) {\n argumentResolvers.add(AuthenticationPrincipalArgumentResolver())\n }\n\n @Override\n override fun configureClientInboundChannel(registration: ChannelRegistration) {\n var authz: AuthorizationChannelInterceptor = AuthorizationChannelInterceptor(authorizationManager)\n var publisher: AuthorizationEventPublisher = SpringAuthorizationEventPublisher(applicationContext)\n authz.setAuthorizationEventPublisher(publisher)\n registration.interceptors(SecurityContextChannelInterceptor(), authz)\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<websocket-message-broker use-authorization-manager=\"true\" same-origin-disabled=\"true\">\n <intercept-message pattern=\"/**\" access=\"authenticated\"/>\n</websocket-message-broker>\n----\n======\n\n[[websocket-expression-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "Disable CSRF within WebSockets", "heading_level": 3, "file_order": 135, "section_index": 13, "content_hash": "61df80bce273f751e8ee7f44552c979be63bc7278fa2a148f9ad7b813bd436f2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:45ee26fd2e75b3f670331a2fdf86741577929ca53c37b5d29b3f1022dc32b019", "content": "At times, there may be value in customizing how the `access` expressions are handled defined in your `intercept-message` XML elements.\nTo do this, you can create a class of type `SecurityExpressionHandler<MessageAuthorizationContext<?>>` and refer to it in your XML definition like so:\n\n[source,xml]\n----\n<websocket-message-broker use-authorization-manager=\"true\">\n <expression-handler ref=\"myRef\"/>\n ...\n</websocket-message-broker>\n\n<b:bean ref=\"myRef\" class=\"org.springframework.security.messaging.access.expression.MessageAuthorizationContextSecurityExpressionHandler\"/>\n----\n\nIf you are migrating from a legacy usage of `websocket-message-broker` that implements a `SecurityExpressionHandler<Message<?>>`, you can:\n 1. Additionally implement the `createEvaluationContext(Supplier, Message)` method and then\n 2. Wrap that value in a `MessageAuthorizationContextSecurityExpressionHandler` like so:\n\n[source,xml]\n----\n<websocket-message-broker use-authorization-manager=\"true\">\n <expression-handler ref=\"myRef\"/>\n ...\n</websocket-message-broker>\n\n<b:bean ref=\"myRef\" class=\"org.springframework.security.messaging.access.expression.MessageAuthorizationContextSecurityExpressionHandler\">\n <b:constructor-arg>\n <b:bean class=\"org.example.MyLegacyExpressionHandler\"/>\n </b:constructor-arg>\n</b:bean>\n----\n\n[[websocket-sockjs]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "Custom Expression Handler", "heading_level": 3, "file_order": 135, "section_index": 14, "content_hash": "45ee26fd2e75b3f670331a2fdf86741577929ca53c37b5d29b3f1022dc32b019", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:16e53140254a4baa3632586aa09f6505ecb0b70683e843ef87a5adee821807f5", "content": "https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-fallback[SockJS] provides fallback transports to support older browsers.\nWhen using the fallback options, we need to relax a few security constraints to allow SockJS to work with Spring Security.\n\n[[websocket-sockjs-sameorigin]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "Working with SockJS", "heading_level": 2, "file_order": 135, "section_index": 15, "content_hash": "16e53140254a4baa3632586aa09f6505ecb0b70683e843ef87a5adee821807f5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:e757094db9ccfbd55b2243350238716e738464ec99910cbeb143fda3bc5e58cb", "content": "SockJS may use a https://github.com/sockjs/sockjs-client/tree/v0.3.4[transport that leverages an iframe].\nBy default, Spring Security xref:features/exploits/headers.adoc#headers-frame-options[denies] the site from being framed to prevent clickjacking attacks.\nTo allow SockJS frame-based transports to work, we need to configure Spring Security to let the same origin frame the content.\n\nYou can customize `X-Frame-Options` with the xref:servlet/appendix/namespace/http.adoc#nsa-frame-options[frame-options] element.\nFor example, the following instructs Spring Security to use `X-Frame-Options: SAMEORIGIN`, which allows iframes within the same domain:\n\n[source,xml]\n----\n<http>\n <!-- ... -->\n\n <headers>\n <frame-options\n policy=\"SAMEORIGIN\" />\n </headers>\n</http>\n----\n\nSimilarly, you can customize frame options to use the same origin within Java Configuration by using the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .headers((headers) -> headers\n .frameOptions((frameOptions) -> frameOptions\n .sameOrigin()\n )\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nopen class WebSecurityConfig {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n headers {\n frameOptions {\n sameOrigin = true\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[websocket-sockjs-csrf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "SockJS & frame-options", "heading_level": 3, "file_order": 135, "section_index": 16, "content_hash": "e757094db9ccfbd55b2243350238716e738464ec99910cbeb143fda3bc5e58cb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:e812bda060e014fd9b1fd8faf678668518fe60e9379b3966bffb9e262fdb4e0f", "content": "SockJS uses a POST on the CONNECT messages for any HTTP-based transport.\nTypically, we need to include the CSRF token in an HTTP header or an HTTP parameter.\nHowever, SockJS does not allow for these options.\nInstead, we must include the token in the Stomp headers as described in <<websocket-sameorigin-csrf>>.\n\nIt also means that we need to relax our CSRF protection with the web layer.\nSpecifically, we want to disable CSRF protection for our connect URLs.\nWe do NOT want to disable CSRF protection for every URL.\nOtherwise, our site is vulnerable to CSRF attacks.\n\nWe can easily achieve this by providing a CSRF `RequestMatcher`.\nOur Java configuration makes this easy.\nFor example, if our stomp endpoint is `/chat`, we can disable CSRF protection only for URLs that start with `/chat/` by using the following configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .csrf((csrf) -> csrf\n // ignore our stomp endpoints since they are protected using Stomp headers\n .ignoringRequestMatchers(\"/chat/**\")\n )\n .headers((headers) -> headers\n // allow same origin to frame our site to support iframe SockJS\n .frameOptions((frameOptions) -> frameOptions\n .sameOrigin()\n )\n )\n .authorizeHttpRequests((authorize) -> authorize\n ...\n )\n ...\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nopen class WebSecurityConfig {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n csrf {\n ignoringRequestMatchers(\"/chat/**\")\n }\n headers {\n frameOptions {\n sameOrigin = true\n }\n }\n authorizeHttpRequests {\n // ...\n }\n // ...\n }\n }\n}\n----\n======\n\nIf we use XML-based configuration, we can use thexref:servlet/appendix/namespace/http.adoc#nsa-csrf-request-matcher-ref[csrf@request-matcher-ref].\n\n[source,xml]\n----\n<http ...>\n <csrf request-matcher-ref=\"csrfMatcher\"/>\n\n <headers>\n <frame-options policy=\"SAMEORIGIN\"/>\n </headers>\n\n ...\n</http>\n\n<b:bean id=\"csrfMatcher\"\n class=\"AndRequestMatcher\">\n <b:constructor-arg value=\"#{T(org.springframework.security.web.csrf.CsrfFilter).DEFAULT_CSRF_MATCHER}\"/>\n <b:constructor-arg>\n <b:bean class=\"org.springframework.security.web.util.matcher.NegatedRequestMatcher\">\n <b:bean class=\"org.springframework.security.config.http.PathPatternRequestMatcherFactoryBean\">\n <b:constructor-arg value=\"/chat/**\"/>\n </b:bean>\n </b:bean>\n </b:constructor-arg>\n</b:bean>\n----\n\n[[legacy-websocket-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "SockJS & Relaxing CSRF", "heading_level": 3, "file_order": 135, "section_index": 17, "content_hash": "e812bda060e014fd9b1fd8faf678668518fe60e9379b3966bffb9e262fdb4e0f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:42c89e1398a7a496c0496731f232ddb93c7c12950b0440ea18261804bd8c0d5f", "content": "`AbstractSecurityWebSocketMessageBrokerConfigurer` and `MessageSecurityMetadataSourceRegistry` are removed as of Spring Security 7.\nPlease see https://docs.spring.io/spring-security/reference/5.8/migration/servlet/authorization.html#_use_authorizationmanager_for_message_security[the 5.8 migration guide] for guidance.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/integrations/websocket.adoc", "title": "websocket", "heading": "Legacy WebSocket Configuration", "heading_level": 2, "file_order": 135, "section_index": 18, "content_hash": "42c89e1398a7a496c0496731f232ddb93c7c12950b0440ea18261804bd8c0d5f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/integrations/websocket.adoc"}}
{"id": "sha256:8943b49c0eb8e9eaf5a50a07d6a9401b17490ae894f3729412429614fcc7fb24", "content": "[[oauth2AuthorizationServer-configuration-model]]\n\n[[oauth2AuthorizationServer-default-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc", "title": "configuration-model", "heading": "configuration-model", "heading_level": 1, "file_order": 136, "section_index": 0, "content_hash": "8943b49c0eb8e9eaf5a50a07d6a9401b17490ae894f3729412429614fcc7fb24", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc"}}
{"id": "sha256:6d668898c66220b90f4c0b46aae87358dccfc22ff42abdfc8b3fe06021a45565", "content": "`OAuth2AuthorizationServerConfiguration` is a `@Configuration` that provides the minimal default configuration for an OAuth2 authorization server.\n\n`OAuth2AuthorizationServerConfiguration` uses xref:servlet/oauth2/authorization-server/configuration-model.adoc#oauth2AuthorizationServer-customizing-the-configuration[`OAuth2AuthorizationServerConfigurer`] to apply the default configuration and registers a `SecurityFilterChain` `@Bean` composed of all the infrastructure components supporting an OAuth2 authorization server.\n\nThe OAuth2 authorization server `SecurityFilterChain` `@Bean` is configured with the following default protocol endpoints:\n\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-authorization-endpoint[OAuth2 Authorization endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-endpoint[OAuth2 Token endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-introspection-endpoint[OAuth2 Token Introspection endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-revocation-endpoint[OAuth2 Token Revocation endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-authorization-server-metadata-endpoint[OAuth2 Authorization Server Metadata endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-jwk-set-endpoint[JWK Set endpoint]\n\n[NOTE]\nThe JWK Set endpoint is configured *only* if a `JWKSource<SecurityContext>` `@Bean` is registered.\n\n[NOTE]\n====\nThe following protocol endpoints are disabled by default:\n\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-device-authorization-endpoint[OAuth2 Device Authorization Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-device-verification-endpoint[OAuth2 Device Verification Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-client-registration-endpoint[OAuth2 Client Registration endpoint]\n====\n\nThe following example shows how to use `OAuth2AuthorizationServerConfiguration` to apply the minimal default configuration:\n\n[source,java]\n----\n@Configuration\n@Import(OAuth2AuthorizationServerConfiguration.class)\npublic class AuthorizationServerConfig {\n\n\t@Bean\n\tpublic RegisteredClientRepository registeredClientRepository() {\n List<RegisteredClient> registrations = ...\n return new InMemoryRegisteredClientRepository(registrations);\n\t}\n\n\t@Bean\n\tpublic JWKSource<SecurityContext> jwkSource() {\n RSAKey rsaKey = ...\n JWKSet jwkSet = new JWKSet(rsaKey);\n return (jwkSelector, securityContext) -> jwkSelector.select(jwkSet);\n\t}\n\n}\n----\n\n[IMPORTANT]\nThe https://datatracker.ietf.org/doc/html/rfc6749#section-4.1[authorization_code grant] requires the resource owner to be authenticated. Therefore, a user authentication mechanism *must* be configured in addition to the default OAuth2 security configuration.\n\nhttps://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect 1.0] is disabled in the default configuration. The following example shows how to enable OpenID Connect 1.0 by initializing the `OidcConfigurer`:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .oidc(Customizer.withDefaults())\t// Initialize `OidcConfigurer`\n );\n\treturn http.build();\n}\n----\n\nIn addition to the default protocol endpoints, the OAuth2 authorization server `SecurityFilterChain` `@Bean` is configured with the following OpenID Connect 1.0 protocol endpoints:\n\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-provider-configuration-endpoint[OpenID Connect 1.0 Provider Configuration endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-logout-endpoint[OpenID Connect 1.0 Logout endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-user-info-endpoint[OpenID Connect 1.0 UserInfo endpoint]\n\n[NOTE]\nThe xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-client-registration-endpoint[OpenID Connect 1.0 Client Registration endpoint] is disabled by default.\n\n[TIP]\n`OAuth2AuthorizationServerConfiguration.jwtDecoder(JWKSource<SecurityContext>)` is a convenience (`static`) utility method that can be used to register a `JwtDecoder` `@Bean`, which is *REQUIRED* for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-user-info-endpoint[OpenID Connect 1.0 UserInfo endpoint] and the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-client-registration-endpoint[OpenID Connect 1.0 Client Registration endpoint].\n\nThe following example shows how to register a `JwtDecoder` `@Bean`:\n\n[source,java]\n----\n@Bean\npublic JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {\n\treturn OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);\n}\n----\n\nThe main intent of `OAuth2AuthorizationServerConfiguration` is to provide a convenient method to apply the minimal default configuration for an OAuth2 authorization server. However, in most cases, customizing the configuration will be required.\n\n[[oauth2AuthorizationServer-customizing-the-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc", "title": "configuration-model", "heading": "Default configuration", "heading_level": 2, "file_order": 136, "section_index": 1, "content_hash": "6d668898c66220b90f4c0b46aae87358dccfc22ff42abdfc8b3fe06021a45565", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc"}}
{"id": "sha256:72db779db2867e7eecfa1de3d74c388873401831667984dd8980e221ef8d2bac", "content": "`OAuth2AuthorizationServerConfigurer` provides the ability to fully customize the security configuration for an OAuth2 authorization server.\nIt lets you specify the core components to use - for example, xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-registered-client-repository[`RegisteredClientRepository`], xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-authorization-service[`OAuth2AuthorizationService`], xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-token-generator[`OAuth2TokenGenerator`], and others.\nFurthermore, it lets you customize the request processing logic for the protocol endpoints  for example, xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-authorization-endpoint[authorization endpoint], xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-device-authorization-endpoint[device authorization endpoint], xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-device-verification-endpoint[device verification endpoint], xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-endpoint[token endpoint], xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-introspection-endpoint[token introspection endpoint], and others.\n\n`OAuth2AuthorizationServerConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .registeredClientRepository(registeredClientRepository)\t<1>\n .authorizationService(authorizationService)\t<2>\n .authorizationConsentService(authorizationConsentService)\t<3>\n .authorizationServerSettings(authorizationServerSettings)\t<4>\n .tokenGenerator(tokenGenerator)\t<5>\n .clientAuthentication(clientAuthentication -> { })\t<6>\n .authorizationEndpoint(authorizationEndpoint -> { })\t<7>\n .pushedAuthorizationRequestEndpoint(pushedAuthorizationRequestEndpoint -> { }) <8>\n .deviceAuthorizationEndpoint(deviceAuthorizationEndpoint -> { })\t<9>\n .deviceVerificationEndpoint(deviceVerificationEndpoint -> { })\t<10>\n .tokenEndpoint(tokenEndpoint -> { })\t<11>\n .tokenIntrospectionEndpoint(tokenIntrospectionEndpoint -> { })\t<12>\n .tokenRevocationEndpoint(tokenRevocationEndpoint -> { })\t<13>\n .clientRegistrationEndpoint(clientRegistrationEndpoint -> { }) <14>\n .authorizationServerMetadataEndpoint(authorizationServerMetadataEndpoint -> { })\t<15>\n .oidc(oidc -> oidc\n .providerConfigurationEndpoint(providerConfigurationEndpoint -> { })\t<16>\n .logoutEndpoint(logoutEndpoint -> { })\t<17>\n .userInfoEndpoint(userInfoEndpoint -> { })\t<18>\n .clientRegistrationEndpoint(clientRegistrationEndpoint -> { })\t<19>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `registeredClientRepository()`: The xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-registered-client-repository[`RegisteredClientRepository`] (*REQUIRED*) for managing new and existing clients.\n<2> `authorizationService()`: The xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-authorization-service[`OAuth2AuthorizationService`] for managing new and existing authorizations.\n<3> `authorizationConsentService()`: The xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-authorization-consent-service[`OAuth2AuthorizationConsentService`] for managing new and existing authorization consents.\n<4> `authorizationServerSettings()`: The xref:servlet/oauth2/authorization-server/configuration-model.adoc#oauth2AuthorizationServer-configuring-authorization-server-settings[`AuthorizationServerSettings`] (*REQUIRED*) for customizing configuration settings for the OAuth2 authorization server.\n<5> `tokenGenerator()`: The xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-token-generator[`OAuth2TokenGenerator`] for generating tokens supported by the OAuth2 authorization server.\n<6> `clientAuthentication()`: The configurer for xref:servlet/oauth2/authorization-server/configuration-model.adoc#oauth2AuthorizationServer-configuring-client-authentication[OAuth2 Client Authentication].\n<7> `authorizationEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-authorization-endpoint[OAuth2 Authorization endpoint].\n<8> `pushedAuthorizationRequestEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-pushed-authorization-request-endpoint[OAuth2 Pushed Authorization Request endpoint].\n<9> `deviceAuthorizationEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-device-authorization-endpoint[OAuth2 Device Authorization endpoint].\n<10> `deviceVerificationEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-device-verification-endpoint[OAuth2 Device Verification endpoint].\n<11> `tokenEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-endpoint[OAuth2 Token endpoint].\n<12> `tokenIntrospectionEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-introspection-endpoint[OAuth2 Token Introspection endpoint].\n<13> `tokenRevocationEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-revocation-endpoint[OAuth2 Token Revocation endpoint].\n<14> `clientRegistrationEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-client-registration-endpoint[OAuth2 Client Registration endpoint].\n<15> `authorizationServerMetadataEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-authorization-server-metadata-endpoint[OAuth2 Authorization Server Metadata endpoint].\n<16> `providerConfigurationEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-provider-configuration-endpoint[OpenID Connect 1.0 Provider Configuration endpoint].\n<17> `logoutEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-logout-endpoint[OpenID Connect 1.0 Logout endpoint].\n<18> `userInfoEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-user-info-endpoint[OpenID Connect 1.0 UserInfo endpoint].\n<19> `clientRegistrationEndpoint()`: The configurer for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-client-registration-endpoint[OpenID Connect 1.0 Client Registration endpoint].\n\n[[oauth2AuthorizationServer-configuring-authorization-server-settings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc", "title": "configuration-model", "heading": "Customizing the configuration", "heading_level": 2, "file_order": 136, "section_index": 2, "content_hash": "72db779db2867e7eecfa1de3d74c388873401831667984dd8980e221ef8d2bac", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc"}}
{"id": "sha256:21ea25ff3ea137a8df692ad8e3abf7c38a8876aab50f18d653b0f55956c2fb0d", "content": "`AuthorizationServerSettings` contains the configuration settings for the OAuth2 authorization server.\nIt specifies the `URI` for the protocol endpoints as well as the https://datatracker.ietf.org/doc/html/rfc8414#section-2[issuer identifier].\nThe default `URI` for the protocol endpoints are as follows:\n\n[source,java]\n----\npublic final class AuthorizationServerSettings extends AbstractSettings {\n\n\t...\n\n\tpublic static Builder builder() {\n return new Builder()\n .authorizationEndpoint(\"/oauth2/authorize\")\n .pushedAuthorizationRequestEndpoint(\"/oauth2/par\")\n .deviceAuthorizationEndpoint(\"/oauth2/device_authorization\")\n .deviceVerificationEndpoint(\"/oauth2/device_verification\")\n .tokenEndpoint(\"/oauth2/token\")\n .tokenIntrospectionEndpoint(\"/oauth2/introspect\")\n .tokenRevocationEndpoint(\"/oauth2/revoke\")\n .clientRegistrationEndpoint(\"/oauth2/register\")\n .jwkSetEndpoint(\"/oauth2/jwks\")\n .oidcLogoutEndpoint(\"/connect/logout\")\n .oidcUserInfoEndpoint(\"/userinfo\")\n .oidcClientRegistrationEndpoint(\"/connect/register\");\n\t}\n\n\t...\n\n}\n----\n\n[NOTE]\n`AuthorizationServerSettings` is a *REQUIRED* component.\n\n[TIP]\nxref:servlet/oauth2/authorization-server/configuration-model.adoc#oauth2AuthorizationServer-default-configuration[`@Import(OAuth2AuthorizationServerConfiguration.class)`] automatically registers an `AuthorizationServerSettings` `@Bean`, if not already provided.\n\nThe following example shows how to customize the configuration settings and register an `AuthorizationServerSettings` `@Bean`:\n\n[source,java]\n----\n@Bean\npublic AuthorizationServerSettings authorizationServerSettings() {\n\treturn AuthorizationServerSettings.builder()\n .issuer(\"https://example.com\")\n .authorizationEndpoint(\"/oauth2/v1/authorize\")\n .pushedAuthorizationRequestEndpoint(\"/oauth2/v1/par\")\n .deviceAuthorizationEndpoint(\"/oauth2/v1/device_authorization\")\n .deviceVerificationEndpoint(\"/oauth2/v1/device_verification\")\n .tokenEndpoint(\"/oauth2/v1/token\")\n .tokenIntrospectionEndpoint(\"/oauth2/v1/introspect\")\n .tokenRevocationEndpoint(\"/oauth2/v1/revoke\")\n .clientRegistrationEndpoint(\"/oauth2/v1/register\")\n .jwkSetEndpoint(\"/oauth2/v1/jwks\")\n .oidcLogoutEndpoint(\"/connect/v1/logout\")\n .oidcUserInfoEndpoint(\"/connect/v1/userinfo\")\n .oidcClientRegistrationEndpoint(\"/connect/v1/register\")\n .build();\n}\n----\n\nThe `AuthorizationServerContext` is a context object that holds information of the Authorization Server runtime environment.\nIt provides access to the `AuthorizationServerSettings` and the \"`current`\" issuer identifier.\n\n[NOTE]\nIf the issuer identifier is not configured in `AuthorizationServerSettings.builder().issuer(String)`, it is resolved from the current request.\n\n[NOTE]\nThe `AuthorizationServerContext` is accessible through the `AuthorizationServerContextHolder`, which associates it with the current request thread by using a `ThreadLocal`.\n\n[[oauth2AuthorizationServer-configuring-client-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc", "title": "configuration-model", "heading": "Configuring Authorization Server Settings", "heading_level": 2, "file_order": 136, "section_index": 3, "content_hash": "21ea25ff3ea137a8df692ad8e3abf7c38a8876aab50f18d653b0f55956c2fb0d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc"}}
{"id": "sha256:cd003cbed8dc394adfc4933d693386e0f865ab20e6439816a8cfe89c1a193fd0", "content": "`OAuth2ClientAuthenticationConfigurer` provides the ability to customize https://datatracker.ietf.org/doc/html/rfc6749#section-2.3[OAuth2 client authentication].\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for client authentication requests.\n\n`OAuth2ClientAuthenticationConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .clientAuthentication(clientAuthentication ->\n clientAuthentication\n .authenticationConverter(authenticationConverter)\t<1>\n .authenticationConverters(authenticationConvertersConsumer)\t<2>\n .authenticationProvider(authenticationProvider)\t<3>\n .authenticationProviders(authenticationProvidersConsumer)\t<4>\n .authenticationSuccessHandler(authenticationSuccessHandler)\t<5>\n .errorResponseHandler(errorResponseHandler)\t<6>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `authenticationConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract client credentials from `HttpServletRequest` to an instance of `OAuth2ClientAuthenticationToken`.\n<2> `authenticationConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OAuth2ClientAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `authenticationSuccessHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling a successful client authentication and associating the `OAuth2ClientAuthenticationToken` to the `SecurityContext`.\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling a failed client authentication and returning the https://datatracker.ietf.org/doc/html/rfc6749#section-5.2[`OAuth2Error` response].\n\n`OAuth2ClientAuthenticationConfigurer` configures the `OAuth2ClientAuthenticationFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OAuth2ClientAuthenticationFilter` is the `Filter` that processes client authentication requests.\n\nBy default, client authentication is required for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-endpoint[OAuth2 Token endpoint], the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-introspection-endpoint[OAuth2 Token Introspection endpoint], and the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-revocation-endpoint[OAuth2 Token Revocation endpoint].\nThe supported client authentication methods are `client_secret_basic`, `client_secret_post`, `private_key_jwt`, `client_secret_jwt`, `tls_client_auth`, `self_signed_tls_client_auth`, and `none` (public clients).\n\n`OAuth2ClientAuthenticationFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- A `DelegatingAuthenticationConverter` composed of `JwtClientAssertionAuthenticationConverter`, `X509ClientCertificateAuthenticationConverter`, `ClientSecretBasicAuthenticationConverter`, `ClientSecretPostAuthenticationConverter`, and `PublicClientAuthenticationConverter`.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `JwtClientAssertionAuthenticationProvider`, `X509ClientCertificateAuthenticationProvider`, `ClientSecretAuthenticationProvider`, and `PublicClientAuthenticationProvider`.\n* `*AuthenticationSuccessHandler*` -- An internal implementation that associates the \"`authenticated`\" `OAuth2ClientAuthenticationToken` (current `Authentication`) to the `SecurityContext`.\n* `*AuthenticationFailureHandler*` -- An internal implementation that uses the `OAuth2Error` associated with the `OAuth2AuthenticationException` to return the OAuth2 error response.\n\n[[oauth2AuthorizationServer-customizing-jwt-client-assertion-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc", "title": "configuration-model", "heading": "Configuring Client Authentication", "heading_level": 2, "file_order": 136, "section_index": 4, "content_hash": "cd003cbed8dc394adfc4933d693386e0f865ab20e6439816a8cfe89c1a193fd0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc"}}
{"id": "sha256:25941ac4e7cee266e66142857c21382c9eb3627f91018855d686f4aa46bccbd3", "content": "`JwtClientAssertionDecoderFactory.DEFAULT_JWT_VALIDATOR_FACTORY` is the default factory that provides an `OAuth2TokenValidator<Jwt>` for the specified `RegisteredClient` and is used for validating the `iss`, `sub`, `aud`, `exp` and `nbf` claims of the `Jwt` client assertion.\n\n`JwtClientAssertionDecoderFactory` provides the ability to override the default `Jwt` client assertion validation by supplying a custom factory of type `Function<RegisteredClient, OAuth2TokenValidator<Jwt>>` to `setJwtValidatorFactory()`.\n\n[NOTE]\n`JwtClientAssertionDecoderFactory` is the default `JwtDecoderFactory` used by `JwtClientAssertionAuthenticationProvider` that provides a `JwtDecoder` for the specified `RegisteredClient` and is used for authenticating a `Jwt` Bearer Token during OAuth2 client authentication.\n\nA common use case for customizing `JwtClientAssertionDecoderFactory` is to validate additional claims in the `Jwt` client assertion.\n\nThe following example shows how to configure `JwtClientAssertionAuthenticationProvider` with a customized `JwtClientAssertionDecoderFactory` that validates an additional claim in the `Jwt` client assertion:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .clientAuthentication(clientAuthentication ->\n clientAuthentication\n .authenticationProviders(configureJwtClientAssertionValidator())\n )\n );\n\n\treturn http.build();\n}\n\nprivate Consumer<List<AuthenticationProvider>> configureJwtClientAssertionValidator() {\n\treturn (authenticationProviders) ->\n authenticationProviders.forEach((authenticationProvider) -> {\n if (authenticationProvider instanceof JwtClientAssertionAuthenticationProvider) {\n // Customize JwtClientAssertionDecoderFactory\n JwtClientAssertionDecoderFactory jwtDecoderFactory = new JwtClientAssertionDecoderFactory();\n Function<RegisteredClient, OAuth2TokenValidator<Jwt>> jwtValidatorFactory = (registeredClient) ->\n new DelegatingOAuth2TokenValidator<>(\n // Use default validators\n JwtClientAssertionDecoderFactory.DEFAULT_JWT_VALIDATOR_FACTORY.apply(registeredClient),\n // Add custom validator\n new JwtClaimValidator<>(\"claim\", \"value\"::equals));\n jwtDecoderFactory.setJwtValidatorFactory(jwtValidatorFactory);\n\n ((JwtClientAssertionAuthenticationProvider) authenticationProvider)\n .setJwtDecoderFactory(jwtDecoderFactory);\n }\n });\n}\n----\n\n[[oauth2AuthorizationServer-customizing-mutual-tls-client-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc", "title": "configuration-model", "heading": "Customizing Jwt Client Assertion Validation", "heading_level": 3, "file_order": 136, "section_index": 5, "content_hash": "25941ac4e7cee266e66142857c21382c9eb3627f91018855d686f4aa46bccbd3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc"}}
{"id": "sha256:321069bf0e8b07cb14484953f38d3ebce9d993db2bc299e3919a547eba6455c4", "content": "`X509ClientCertificateAuthenticationProvider` is used for authenticating the client `X509Certificate` chain received when `ClientAuthenticationMethod.TLS_CLIENT_AUTH` or `ClientAuthenticationMethod.SELF_SIGNED_TLS_CLIENT_AUTH` method is used during OAuth2 client authentication.\nIt is also composed with a _\"Certificate Verifier\"_, which is used to verify the contents of the client `X509Certificate` after the TLS handshake has successfully completed.\n\n[[oauth2AuthorizationServer-customizing-mutual-tls-client-authentication-pki-mutual-tls-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc", "title": "configuration-model", "heading": "Customizing Mutual-TLS Client Authentication", "heading_level": 3, "file_order": 136, "section_index": 6, "content_hash": "321069bf0e8b07cb14484953f38d3ebce9d993db2bc299e3919a547eba6455c4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc"}}
{"id": "sha256:741fa39c32d409e33f55541b4b22fd502a948de3001c14dee3fa027f74f26f95", "content": "For the PKI Mutual-TLS (`ClientAuthenticationMethod.TLS_CLIENT_AUTH`) method, the default implementation of the certificate verifier verifies the subject distinguished name of the client `X509Certificate` against the setting `RegisteredClient.getClientSettings.getX509CertificateSubjectDN()`.\n\nIf you need to verify another attribute of the client `X509Certificate`, for example, a Subject Alternative Name (SAN) entry, the following example shows how to configure `X509ClientCertificateAuthenticationProvider` with a custom implementation of a certificate verifier:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .clientAuthentication(clientAuthentication ->\n clientAuthentication\n .authenticationProviders(configureX509ClientCertificateVerifier())\n )\n );\n\n\treturn http.build();\n}\n\nprivate Consumer<List<AuthenticationProvider>> configureX509ClientCertificateVerifier() {\n\treturn (authenticationProviders) ->\n authenticationProviders.forEach((authenticationProvider) -> {\n if (authenticationProvider instanceof X509ClientCertificateAuthenticationProvider) {\n Consumer<OAuth2ClientAuthenticationContext> certificateVerifier = (clientAuthenticationContext) -> {\n OAuth2ClientAuthenticationToken clientAuthentication = clientAuthenticationContext.getAuthentication();\n RegisteredClient registeredClient = clientAuthenticationContext.getRegisteredClient();\n X509Certificate[] clientCertificateChain = (X509Certificate[]) clientAuthentication.getCredentials();\n X509Certificate clientCertificate = clientCertificateChain[0];\n\n // TODO Verify Subject Alternative Name (SAN) entry\n\n };\n\n ((X509ClientCertificateAuthenticationProvider) authenticationProvider)\n .setCertificateVerifier(certificateVerifier);\n }\n });\n}\n----\n\n[[oauth2AuthorizationServer-customizing-mutual-tls-client-authentication-self-signed-certificate-mutual-tls-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc", "title": "configuration-model", "heading": "PKI Mutual-TLS Method", "heading_level": 4, "file_order": 136, "section_index": 7, "content_hash": "741fa39c32d409e33f55541b4b22fd502a948de3001c14dee3fa027f74f26f95", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc"}}
{"id": "sha256:1569df275f7696113b2658bf21b076303afc18b09e2c6237fd45a3005605a48f", "content": "For the Self-Signed Certificate Mutual-TLS (`ClientAuthenticationMethod.SELF_SIGNED_TLS_CLIENT_AUTH`) method, the default implementation of the certificate verifier will retrieve the client's JSON Web Key Set using the setting `RegisteredClient.getClientSettings.getJwkSetUrl()` and expect to find a match against the client `X509Certificate` received during the TLS handshake.\n\n[NOTE]\nThe `RegisteredClient.getClientSettings.getJwkSetUrl()` setting is used to retrieve the client's certificates via a JSON Web Key (JWK) Set.\nA certificate is represented with the `x5c` parameter of an individual JWK within the set.\n\n[[oauth2AuthorizationServer-customizing-mutual-tls-client-authentication-client-certificate-bound-access-tokens]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc", "title": "configuration-model", "heading": "Self-Signed Certificate Mutual-TLS Method", "heading_level": 4, "file_order": 136, "section_index": 8, "content_hash": "1569df275f7696113b2658bf21b076303afc18b09e2c6237fd45a3005605a48f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc"}}
{"id": "sha256:73c4d4172d115525b46bd0efb7296639a86867167e52082ef76b393ff0436cc6", "content": "When Mutual-TLS client authentication is used at the token endpoint, the authorization server is able to bind the issued access token to the client's `X509Certificate`.\nThe binding is accomplished by computing the SHA-256 thumbprint of the client's `X509Certificate` and associating the thumbprint with the access token.\nFor example, a JWT access token would include a `x5t#S256` claim, containing the `X509Certificate` thumbprint, within the top-level `cnf` (confirmation method) claim.\n\nBinding the access token to the client's `X509Certificate` provides the ability to implement a proof-of-possession mechanism during protected resource access.\nFor example, the protected resource would obtain the client's `X509Certificate` used during Mutual-TLS authentication and then verify that the certificate thumbprint matches the `x5t#S256` claim associated with the access token.\n\nThe following example shows how to enable certificate-bound access tokens for a client:\n\n[source,java]\n----\nRegisteredClient mtlsClient = RegisteredClient.withId(UUID.randomUUID().toString())\n .clientId(\"mtls-client\")\n .clientAuthenticationMethod(ClientAuthenticationMethod.TLS_CLIENT_AUTH)\n .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)\n .scope(\"scope-a\")\n .clientSettings(\n ClientSettings.builder()\n .x509CertificateSubjectDN(\"CN=mtls-client,OU=Spring Samples,O=Spring,C=US\")\n .build()\n )\n .tokenSettings(\n TokenSettings.builder()\n .x509CertificateBoundAccessTokens(true)\n .build()\n )\n .build();\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc", "title": "configuration-model", "heading": "Client Certificate-Bound Access Tokens", "heading_level": 4, "file_order": 136, "section_index": 9, "content_hash": "73c4d4172d115525b46bd0efb7296639a86867167e52082ef76b393ff0436cc6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/configuration-model.adoc"}}
{"id": "sha256:4795c64cad46352fd847405f9b5fddbc03afd837790f380a8aa71abfc38e7031", "content": "[[oauth2AuthorizationServer-core-model-components]]\n\n[[oauth2AuthorizationServer-registered-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "core-model-components", "heading_level": 1, "file_order": 137, "section_index": 0, "content_hash": "4795c64cad46352fd847405f9b5fddbc03afd837790f380a8aa71abfc38e7031", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:6318faf44fcccc7c64e72df597c9eed7222deeca11c7c7c78305265b37dc8e1b", "content": "A `RegisteredClient` is a representation of a client that is https://datatracker.ietf.org/doc/html/rfc6749#section-2[registered] with the authorization server.\nA client must be registered with the authorization server before it can initiate an authorization grant flow, such as `authorization_code` or `client_credentials`.\n\nDuring client registration, the client is assigned a unique https://datatracker.ietf.org/doc/html/rfc6749#section-2.2[client identifier], (optionally) a client secret (depending on https://datatracker.ietf.org/doc/html/rfc6749#section-2.1[client type]), and metadata associated with its unique client identifier.\nThe client's metadata can range from human-facing display strings (such as client name) to items specific to a protocol flow (such as the list of valid redirect URIs).\n\n[TIP]\nThe corresponding client registration model in Spring Security's OAuth2 Client support is xref:servlet/oauth2/client/core.adoc#oauth2Client-client-registration[ClientRegistration].\n\nThe primary purpose of a client is to request access to protected resources.\nThe client first requests an access token by authenticating with the authorization server and presenting the authorization grant.\nThe authorization server authenticates the client and authorization grant, and, if they are valid, issues an access token.\nThe client can now request the protected resource from the resource server by presenting the access token.\n\nThe following example shows how to configure a `RegisteredClient` that is allowed to perform the https://datatracker.ietf.org/doc/html/rfc6749#section-4.1[authorization_code grant] flow to request an access token:\n\n[source,java]\n----\nRegisteredClient registeredClient = RegisteredClient.withId(UUID.randomUUID().toString())\n\t.clientId(\"client-a\")\n\t.clientSecret(\"{noop}secret\") <1>\n\t.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n\t.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n\t.redirectUri(\"http://127.0.0.1:8080/authorized\")\n\t.scope(\"scope-a\")\n\t.clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())\n\t.build();\n----\n<1> `\\{noop\\}` represents the `PasswordEncoder` id for Spring Security's xref:features/authentication/password-storage.adoc#authentication-password-storage-dpe[NoOpPasswordEncoder].\n\nThe corresponding configuration in Spring Security's xref:servlet/oauth2/client/index.adoc[OAuth2 Client support] is:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n client-a:\n provider: spring\n client-id: client-a\n client-secret: secret\n authorization-grant-type: authorization_code\n redirect-uri: \"http://127.0.0.1:8080/authorized\"\n scope: scope-a\n provider:\n spring:\n issuer-uri: http://localhost:9000\n----\n\nA `RegisteredClient` has metadata (attributes) associated with its unique Client Identifier and is defined as follows:\n\n[source,java]\n----\npublic class RegisteredClient implements Serializable {\n\tprivate String id; <1>\n\tprivate String clientId; <2>\n\tprivate Instant clientIdIssuedAt; <3>\n\tprivate String clientSecret; <4>\n\tprivate Instant clientSecretExpiresAt; <5>\n\tprivate String clientName; <6>\n\tprivate Set<ClientAuthenticationMethod> clientAuthenticationMethods; <7>\n\tprivate Set<AuthorizationGrantType> authorizationGrantTypes; <8>\n\tprivate Set<String> redirectUris; <9>\n\tprivate Set<String> postLogoutRedirectUris; <10>\n\tprivate Set<String> scopes; <11>\n\tprivate ClientSettings clientSettings; <12>\n\tprivate TokenSettings tokenSettings; <13>\n\n\t...\n\n}\n----\n<1> `id`: The ID that uniquely identifies the `RegisteredClient`.\n<2> `clientId`: The client identifier.\n<3> `clientIdIssuedAt`: The time at which the client identifier was issued.\n<4> `clientSecret`: The client's secret. The value should be encoded using Spring Security's xref:features/authentication/password-storage.adoc#authentication-password-storage-dpe[PasswordEncoder].\n<5> `clientSecretExpiresAt`: The time at which the client secret expires.\n<6> `clientName`: A descriptive name used for the client. The name may be used in certain scenarios, such as when displaying the client name in the consent page.\n<7> `clientAuthenticationMethods`: The authentication method(s) that the client may use. The supported values are `client_secret_basic`, `client_secret_post`, https://datatracker.ietf.org/doc/html/rfc7523[`private_key_jwt`], `client_secret_jwt`, and `none` https://datatracker.ietf.org/doc/html/rfc7636[(public clients)].\n<8> `authorizationGrantTypes`: The https://datatracker.ietf.org/doc/html/rfc6749#section-1.3[authorization grant type(s)] that the client can use. The supported values are `authorization_code`, `client_credentials`, `refresh_token`, `urn:ietf:params:oauth:grant-type:device_code`, and `urn:ietf:params:oauth:grant-type:token-exchange`.\n<9> `redirectUris`: The registered https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2[redirect URI(s)] that the client may use in redirect-based flows  for example, `authorization_code` grant.\n<10> `postLogoutRedirectUris`: The post logout redirect URI(s) that the client may use for logout.\n<11> `scopes`: The scope(s) that the client is allowed to request.\n<12> `clientSettings`: The custom settings for the client  for example, require https://datatracker.ietf.org/doc/html/rfc7636[PKCE], require authorization consent, and others.\n<13> `tokenSettings`: The custom settings for the OAuth2 tokens issued to the client  for example, access/refresh token time-to-live, reuse refresh tokens, and others.\n\n[[oauth2AuthorizationServer-client-settings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "RegisteredClient", "heading_level": 2, "file_order": 137, "section_index": 1, "content_hash": "6318faf44fcccc7c64e72df597c9eed7222deeca11c7c7c78305265b37dc8e1b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:fdb6549c95ee78a7dd0b8195b44a1c50690a9d826cdafa0b4861859663fada2a", "content": "`ClientSettings` contains the configuration settings associated to a `RegisteredClient`.\n\n`ClientSettings` provides the following accessors:\n\n[source,java]\n----\npublic final class ClientSettings extends AbstractSettings {\n\n public boolean isRequireProofKey() ... <1>\n\n public boolean isRequireAuthorizationConsent() ... <2>\n\n public String getJwkSetUrl() ... <3>\n\n public JwsAlgorithm getTokenEndpointAuthenticationSigningAlgorithm() ... <4>\n\n public String getX509CertificateSubjectDN() ... <5>\n\n\t...\n\n}\n----\n<1> `isRequireProofKey()`: If `true`, the client is required to provide a proof key challenge and verifier when performing the Authorization Code Grant flow (PKCE). The default is `true`.\n<2> `isRequireAuthorizationConsent()`: If `true`, authorization consent is required when the client requests access. The default is `false`.\n<3> `getJwkSetUrl()`: The `URL` for the client's JSON Web Key Set. Used for `private_key_jwt`, `self_signed_tls_client_auth` and `client_secret_jwt` client authentication methods.\n<4> `getTokenEndpointAuthenticationSigningAlgorithm()`: The `JwsAlgorithm` that must be used for signing the JWT used to authenticate the client at the Token Endpoint for `private_key_jwt` and `client_secret_jwt` authentication methods.\n<5> `getX509CertificateSubjectDN()`: The expected subject distinguished name associated to the client `X509Certificate` received during client authentication when using the `tls_client_auth` method.\n\n[NOTE]\nhttps://datatracker.ietf.org/doc/html/rfc7636[Proof Key for Code Exchange (PKCE)] is enabled by default for all clients using the Authorization Code grant. To disable PKCE, set `requireProofKey` to `false`.\n\n[[oauth2AuthorizationServer-registered-client-repository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "ClientSettings", "heading_level": 2, "file_order": 137, "section_index": 2, "content_hash": "fdb6549c95ee78a7dd0b8195b44a1c50690a9d826cdafa0b4861859663fada2a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:96dbdf80bffda1d7f26c31d40e85d835963b200f7a0d2529107070bd76ad6fcd", "content": "The `RegisteredClientRepository` is the central component where new clients can be registered and existing clients can be queried.\nIt is used by other components when following a specific protocol flow, such as client authentication, authorization grant processing, token introspection, dynamic client registration, and others.\n\nThe provided implementations of `RegisteredClientRepository` are `InMemoryRegisteredClientRepository` and `JdbcRegisteredClientRepository`.\nThe `InMemoryRegisteredClientRepository` implementation stores `RegisteredClient` instances in-memory and is recommended *ONLY* to be used during development and testing.\n`JdbcRegisteredClientRepository` is a JDBC implementation that persists `RegisteredClient` instances by using `JdbcOperations`.\n\n[NOTE]\nThe `RegisteredClientRepository` is a *REQUIRED* component.\n\nThe following example shows how to register a `RegisteredClientRepository` `@Bean`:\n\n[source,java]\n----\n@Bean\npublic RegisteredClientRepository registeredClientRepository() {\n\tList<RegisteredClient> registrations = ...\n\treturn new InMemoryRegisteredClientRepository(registrations);\n}\n----\n\nAlternatively, you can configure the `RegisteredClientRepository` through the xref:servlet/oauth2/authorization-server/configuration-model.adoc#oauth2AuthorizationServer-customizing-the-configuration[`OAuth2AuthorizationServerConfigurer`]:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .registeredClientRepository(registeredClientRepository)\n )\n ...\n\n\treturn http.build();\n}\n----\n\n[NOTE]\nThe `OAuth2AuthorizationServerConfigurer` is useful when applying multiple configuration options simultaneously.\n\n[[oauth2AuthorizationServer-oauth2-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "RegisteredClientRepository", "heading_level": 2, "file_order": 137, "section_index": 3, "content_hash": "96dbdf80bffda1d7f26c31d40e85d835963b200f7a0d2529107070bd76ad6fcd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:7c1b4ca69f8c6592ed549fc15664209b1d843b22633e79ba64ab083aff7a6083", "content": "An `OAuth2Authorization` is a representation of an OAuth2 authorization, which holds state related to the authorization granted to a xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-registered-client[client], by the resource owner or itself in the case of the `client_credentials` authorization grant type.\n\n[TIP]\nThe corresponding authorization model in Spring Security's OAuth2 Client support is xref:servlet/oauth2/client/core.adoc#oauth2Client-authorized-client[OAuth2AuthorizedClient].\n\nAfter the successful completion of an authorization grant flow, an `OAuth2Authorization` is created and associates an {security-api-url}/org/springframework/security/oauth2/core/OAuth2AccessToken.html[`OAuth2AccessToken`], an (optional) {security-api-url}/org/springframework/security/oauth2/core/OAuth2RefreshToken.html[`OAuth2RefreshToken`], and additional state specific to the executed authorization grant type.\n\nThe {security-api-url}/org/springframework/security/oauth2/core/OAuth2Token.html[`OAuth2Token`] instances associated with an `OAuth2Authorization` vary, depending on the authorization grant type.\n\nFor the OAuth2 https://datatracker.ietf.org/doc/html/rfc6749#section-4.1[authorization_code grant], an `OAuth2AuthorizationCode`, an `OAuth2AccessToken`, and an (optional) `OAuth2RefreshToken` are associated.\n\nFor the OpenID Connect 1.0 https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth[authorization_code grant], an `OAuth2AuthorizationCode`, an {security-api-url}/org/springframework/security/oauth2/core/oidc/OidcIdToken.html[`OidcIdToken`], an `OAuth2AccessToken`, and an (optional) `OAuth2RefreshToken` are associated.\n\nFor the OAuth2 https://datatracker.ietf.org/doc/html/rfc6749#section-4.4[client_credentials grant], only an `OAuth2AccessToken` is associated.\n\n`OAuth2Authorization` and its attributes are defined as follows:\n\n[source,java]\n----\npublic class OAuth2Authorization implements Serializable {\n\tprivate String id; <1>\n\tprivate String registeredClientId; <2>\n\tprivate String principalName; <3>\n\tprivate AuthorizationGrantType authorizationGrantType; <4>\n\tprivate Set<String> authorizedScopes; <5>\n\tprivate Map<Class<? extends OAuth2Token>, Token<?>> tokens; <6>\n\tprivate Map<String, Object> attributes; <7>\n\n\t...\n\n}\n----\n<1> `id`: The ID that uniquely identifies the `OAuth2Authorization`.\n<2> `registeredClientId`: The ID that uniquely identifies the xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-registered-client[RegisteredClient].\n<3> `principalName`: The principal name of the resource owner (or client).\n<4> `authorizationGrantType`: The `AuthorizationGrantType` used.\n<5> `authorizedScopes`: The `Set` of scope(s) authorized for the client.\n<6> `tokens`: The `OAuth2Token` instances (and associated metadata) specific to the executed authorization grant type.\n<7> `attributes`: The additional attributes specific to the executed authorization grant type  for example, the authenticated `Principal`, `OAuth2AuthorizationRequest`, and others.\n\n`OAuth2Authorization` and its associated `OAuth2Token` instances have a set lifespan.\nA newly issued `OAuth2Token` is active and becomes inactive when it either expires or is invalidated (revoked).\nThe `OAuth2Authorization` is (implicitly) inactive when all associated `OAuth2Token` instances are inactive.\nEach `OAuth2Token` is held in an `OAuth2Authorization.Token`, which provides accessors for `isExpired()`, `isInvalidated()`, and `isActive()`.\n\n`OAuth2Authorization.Token` also provides `getClaims()`, which returns the claims (if any) associated with the `OAuth2Token`.\n\n[[oauth2AuthorizationServer-oauth2-authorization-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "OAuth2Authorization", "heading_level": 2, "file_order": 137, "section_index": 4, "content_hash": "7c1b4ca69f8c6592ed549fc15664209b1d843b22633e79ba64ab083aff7a6083", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:cfc72ac418595ebe6b4076c28808f68f68e2239ae66abf0c1d4265e7ea66765e", "content": "The `OAuth2AuthorizationService` is the central component where new authorizations are stored and existing authorizations are queried.\nIt is used by other components when following a specific protocol flow  for example, client authentication, authorization grant processing, token introspection, token revocation, dynamic client registration, and others.\n\nThe provided implementations of `OAuth2AuthorizationService` are `InMemoryOAuth2AuthorizationService` and `JdbcOAuth2AuthorizationService`.\nThe `InMemoryOAuth2AuthorizationService` implementation stores `OAuth2Authorization` instances in-memory and is recommended *ONLY* to be used during development and testing.\n`JdbcOAuth2AuthorizationService` is a JDBC implementation that persists `OAuth2Authorization` instances by using `JdbcOperations`.\n\n[NOTE]\nThe `OAuth2AuthorizationService` is an *OPTIONAL* component and defaults to `InMemoryOAuth2AuthorizationService`.\n\nThe following example shows how to register an `OAuth2AuthorizationService` `@Bean`:\n\n[source,java]\n----\n@Bean\npublic OAuth2AuthorizationService authorizationService() {\n\treturn new InMemoryOAuth2AuthorizationService();\n}\n----\n\nAlternatively, you can configure the `OAuth2AuthorizationService` through the xref:servlet/oauth2/authorization-server/configuration-model.adoc#oauth2AuthorizationServer-customizing-the-configuration[`OAuth2AuthorizationServerConfigurer`]:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .authorizationService(authorizationService)\n )\n ...\n\n\treturn http.build();\n}\n----\n\n[NOTE]\nThe `OAuth2AuthorizationServerConfigurer` is useful when applying multiple configuration options simultaneously.\n\n[[oauth2AuthorizationServer-oauth2-authorization-consent]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "OAuth2AuthorizationService", "heading_level": 2, "file_order": 137, "section_index": 5, "content_hash": "cfc72ac418595ebe6b4076c28808f68f68e2239ae66abf0c1d4265e7ea66765e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:ffe2f4992f6fc57794bb56a6d945d5554c188064380132427346b4bce4bd71d9", "content": "An `OAuth2AuthorizationConsent` is a representation of an authorization \"consent\" (decision) from an https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1[OAuth2 authorization request flow]  for example, the `authorization_code` grant, which holds the authorities granted to a xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-registered-client[client] by the resource owner.\n\nWhen authorizing access to a client, the resource owner may grant only a subset of the authorities requested by the client.\nThe typical use case is the `authorization_code` grant flow, in which the client requests scope(s) and the resource owner grants (or denies) access to the requested scope(s).\n\nAfter the completion of an OAuth2 authorization request flow, an `OAuth2AuthorizationConsent` is created (or updated) and associates the granted authorities with the client and resource owner.\n\n`OAuth2AuthorizationConsent` and its attributes are defined as follows:\n\n[source,java]\n----\npublic final class OAuth2AuthorizationConsent implements Serializable {\n\tprivate final String registeredClientId; <1>\n\tprivate final String principalName; <2>\n\tprivate final Set<GrantedAuthority> authorities; <3>\n\n\t...\n\n}\n----\n<1> `registeredClientId`: The ID that uniquely identifies the xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-registered-client[RegisteredClient].\n<2> `principalName`: The principal name of the resource owner.\n<3> `authorities`: The authorities granted to the client by the resource owner. An authority can represent a scope, a claim, a permission, a role, and others.\n\n[[oauth2AuthorizationServer-oauth2-authorization-consent-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "OAuth2AuthorizationConsent", "heading_level": 2, "file_order": 137, "section_index": 6, "content_hash": "ffe2f4992f6fc57794bb56a6d945d5554c188064380132427346b4bce4bd71d9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:6280ca4e0446e02f6898d054d2a30bc3ae2715f927df13e022a568db2b93598d", "content": "The `OAuth2AuthorizationConsentService` is the central component where new authorization consents are stored and existing authorization consents are queried.\nIt is primarily used by components that implement an OAuth2 authorization request flow  for example, the `authorization_code` grant.\n\nThe provided implementations of `OAuth2AuthorizationConsentService` are `InMemoryOAuth2AuthorizationConsentService` and `JdbcOAuth2AuthorizationConsentService`.\nThe `InMemoryOAuth2AuthorizationConsentService` implementation stores `OAuth2AuthorizationConsent` instances in-memory and is recommended *ONLY* for development and testing.\n`JdbcOAuth2AuthorizationConsentService` is a JDBC implementation that persists `OAuth2AuthorizationConsent` instances by using `JdbcOperations`.\n\n[NOTE]\nThe `OAuth2AuthorizationConsentService` is an *OPTIONAL* component and defaults to `InMemoryOAuth2AuthorizationConsentService`.\n\nThe following example shows how to register an `OAuth2AuthorizationConsentService` `@Bean`:\n\n[source,java]\n----\n@Bean\npublic OAuth2AuthorizationConsentService authorizationConsentService() {\n\treturn new InMemoryOAuth2AuthorizationConsentService();\n}\n----\n\nAlternatively, you can configure the `OAuth2AuthorizationConsentService` through the xref:servlet/oauth2/authorization-server/configuration-model.adoc#oauth2AuthorizationServer-customizing-the-configuration[`OAuth2AuthorizationServerConfigurer`]:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .authorizationConsentService(authorizationConsentService)\n )\n ...\n\n\treturn http.build();\n}\n----\n\n[NOTE]\nThe `OAuth2AuthorizationServerConfigurer` is useful when applying multiple configuration options simultaneously.\n\n[[oauth2AuthorizationServer-oauth2-token-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "OAuth2AuthorizationConsentService", "heading_level": 2, "file_order": 137, "section_index": 7, "content_hash": "6280ca4e0446e02f6898d054d2a30bc3ae2715f927df13e022a568db2b93598d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:e6b496c97a0e90ae4b5d3ba7a6fa2abcda3ec96d0ece572672e3c245f34f156f", "content": "An `OAuth2TokenContext` is a context object that holds information associated with an `OAuth2Token` and is used by an xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-token-generator[OAuth2TokenGenerator] and xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-token-customizer[OAuth2TokenCustomizer].\n\n`OAuth2TokenContext` provides the following accessors:\n\n[source,java]\n----\npublic interface OAuth2TokenContext extends Context {\n\n\tdefault RegisteredClient getRegisteredClient() ... <1>\n\n\tdefault <T extends Authentication> T getPrincipal() ... <2>\n\n\tdefault AuthorizationServerContext getAuthorizationServerContext() ... <3>\n\n\t@Nullable\n\tdefault OAuth2Authorization getAuthorization() ... <4>\n\n\tdefault Set<String> getAuthorizedScopes() ... <5>\n\n\tdefault OAuth2TokenType getTokenType() ... <6>\n\n\tdefault AuthorizationGrantType getAuthorizationGrantType() ... <7>\n\n\tdefault <T extends Authentication> T getAuthorizationGrant() ... <8>\n\n\t...\n\n}\n----\n<1> `getRegisteredClient()`: The xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-registered-client[RegisteredClient] associated with the authorization grant.\n<2> `getPrincipal()`: The `Authentication` instance of the resource owner (or client).\n<3> `getAuthorizationServerContext()`: The xref:servlet/oauth2/authorization-server/configuration-model.adoc#oauth2AuthorizationServer-configuring-authorization-server-settings[`AuthorizationServerContext`] object that holds information of the Authorization Server runtime environment.\n<4> `getAuthorization()`: The xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-authorization[OAuth2Authorization] associated with the authorization grant.\n<5> `getAuthorizedScopes()`: The scope(s) authorized for the client.\n<6> `getTokenType()`: The `OAuth2TokenType` to generate. The supported values are `code`, `access_token`, `refresh_token`, and `id_token`.\n<7> `getAuthorizationGrantType()`: The `AuthorizationGrantType` associated with the authorization grant.\n<8> `getAuthorizationGrant()`: The `Authentication` instance used by the `AuthenticationProvider` that processes the authorization grant.\n\n[[oauth2AuthorizationServer-oauth2-token-generator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "OAuth2TokenContext", "heading_level": 2, "file_order": 137, "section_index": 8, "content_hash": "e6b496c97a0e90ae4b5d3ba7a6fa2abcda3ec96d0ece572672e3c245f34f156f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:00cb9b07ca8de7e77a3b69846545bd1d0547b8b710da30bdc1ddefd85cf3b7be", "content": "An `OAuth2TokenGenerator` is responsible for generating an `OAuth2Token` from the information contained in the provided xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-token-context[OAuth2TokenContext].\n\nThe `OAuth2Token` generated primarily depends on the type of `OAuth2TokenType` specified in the `OAuth2TokenContext`.\n\nFor example, when the `value` for `OAuth2TokenType` is:\n\n* `code`, then `OAuth2AuthorizationCode` is generated.\n* `access_token`, then `OAuth2AccessToken` is generated.\n* `refresh_token`, then `OAuth2RefreshToken` is generated.\n* `id_token`, then `OidcIdToken` is generated.\n\nFurthermore, the format of the generated `OAuth2AccessToken` varies, depending on the `TokenSettings.getAccessTokenFormat()` configured for the xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-registered-client[RegisteredClient].\nIf the format is `OAuth2TokenFormat.SELF_CONTAINED` (the default), then a `Jwt` is generated.\nIf the format is `OAuth2TokenFormat.REFERENCE`, then an \"opaque\" token is generated.\n\nFinally, if the generated `OAuth2Token` has a set of claims and implements `ClaimAccessor`, the claims are made accessible from xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-authorization[OAuth2Authorization.Token.getClaims()].\n\nThe `OAuth2TokenGenerator` is primarily used by components that implement authorization grant processing  for example, `authorization_code`, `client_credentials`, and `refresh_token`.\n\nThe provided implementations are `OAuth2AccessTokenGenerator`, `OAuth2RefreshTokenGenerator`, and `JwtGenerator`.\nThe `OAuth2AccessTokenGenerator` generates an \"opaque\" (`OAuth2TokenFormat.REFERENCE`) access token, and the `JwtGenerator` generates a `Jwt` (`OAuth2TokenFormat.SELF_CONTAINED`).\n\n[NOTE]\nThe `OAuth2TokenGenerator` is an *OPTIONAL* component and defaults to a `DelegatingOAuth2TokenGenerator` composed of an `OAuth2AccessTokenGenerator` and `OAuth2RefreshTokenGenerator`.\n\n[NOTE]\nIf a `JwtEncoder` `@Bean` or `JWKSource<SecurityContext>` `@Bean` is registered, then a `JwtGenerator` is additionally composed in the `DelegatingOAuth2TokenGenerator`.\n\nThe `OAuth2TokenGenerator` provides great flexibility, as it can support any custom token format for `access_token` and `refresh_token`.\n\nThe following example shows how to register an `OAuth2TokenGenerator` `@Bean`:\n\n[source,java]\n----\n@Bean\npublic OAuth2TokenGenerator<?> tokenGenerator() {\n\tJwtEncoder jwtEncoder = ...\n\tJwtGenerator jwtGenerator = new JwtGenerator(jwtEncoder);\n\tOAuth2AccessTokenGenerator accessTokenGenerator = new OAuth2AccessTokenGenerator();\n\tOAuth2RefreshTokenGenerator refreshTokenGenerator = new OAuth2RefreshTokenGenerator();\n\treturn new DelegatingOAuth2TokenGenerator(\n jwtGenerator, accessTokenGenerator, refreshTokenGenerator);\n}\n----\n\nAlternatively, you can configure the `OAuth2TokenGenerator` through the xref:servlet/oauth2/authorization-server/configuration-model.adoc#oauth2AuthorizationServer-customizing-the-configuration[`OAuth2AuthorizationServerConfigurer`]:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .tokenGenerator(tokenGenerator)\n )\n ...\n\n\treturn http.build();\n}\n----\n\n[NOTE]\nThe `OAuth2AuthorizationServerConfigurer` is useful when applying multiple configuration options simultaneously.\n\n[[oauth2AuthorizationServer-oauth2-token-customizer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "OAuth2TokenGenerator", "heading_level": 2, "file_order": 137, "section_index": 9, "content_hash": "00cb9b07ca8de7e77a3b69846545bd1d0547b8b710da30bdc1ddefd85cf3b7be", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:4c40baad3e24a323e564539fc821fb4de95a16a477c41a7476430bb1114ef37a", "content": "An `OAuth2TokenCustomizer` provides the ability to customize the attributes of an `OAuth2Token`, which are accessible in the provided xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-token-context[OAuth2TokenContext].\nIt is used by an xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-token-generator[OAuth2TokenGenerator] to let it customize the attributes of the `OAuth2Token` before it is generated.\n\nAn `OAuth2TokenCustomizer<OAuth2TokenClaimsContext>` declared with a generic type of `OAuth2TokenClaimsContext` (`implements OAuth2TokenContext`) provides the ability to customize the claims of an \"opaque\" `OAuth2AccessToken`.\n`OAuth2TokenClaimsContext.getClaims()` provides access to the `OAuth2TokenClaimsSet.Builder`, allowing the ability to add, replace, and remove claims.\n\nThe following example shows how to implement an `OAuth2TokenCustomizer<OAuth2TokenClaimsContext>` and configure it with an `OAuth2AccessTokenGenerator`:\n\n[source,java]\n----\n@Bean\npublic OAuth2TokenGenerator<?> tokenGenerator() {\n\tJwtEncoder jwtEncoder = ...\n\tJwtGenerator jwtGenerator = new JwtGenerator(jwtEncoder);\n\tOAuth2AccessTokenGenerator accessTokenGenerator = new OAuth2AccessTokenGenerator();\n\taccessTokenGenerator.setAccessTokenCustomizer(accessTokenCustomizer());\n\tOAuth2RefreshTokenGenerator refreshTokenGenerator = new OAuth2RefreshTokenGenerator();\n\treturn new DelegatingOAuth2TokenGenerator(\n jwtGenerator, accessTokenGenerator, refreshTokenGenerator);\n}\n\n@Bean\npublic OAuth2TokenCustomizer<OAuth2TokenClaimsContext> accessTokenCustomizer() {\n\treturn context -> {\n OAuth2TokenClaimsSet.Builder claims = context.getClaims();\n // Customize claims\n\n\t};\n}\n----\n\n[NOTE]\nIf the `OAuth2TokenGenerator` is not provided as a `@Bean` or is not configured through the `OAuth2AuthorizationServerConfigurer`, an `OAuth2TokenCustomizer<OAuth2TokenClaimsContext>` `@Bean` will automatically be configured with an `OAuth2AccessTokenGenerator`.\n\nAn `OAuth2TokenCustomizer<JwtEncodingContext>` declared with a generic type of `JwtEncodingContext` (`implements OAuth2TokenContext`) provides the ability to customize the headers and claims of a `Jwt`.\n`JwtEncodingContext.getJwsHeader()` provides access to the `JwsHeader.Builder`, allowing the ability to add, replace, and remove headers.\n`JwtEncodingContext.getClaims()` provides access to the `JwtClaimsSet.Builder`, allowing the ability to add, replace, and remove claims.\n\nThe following example shows how to implement an `OAuth2TokenCustomizer<JwtEncodingContext>` and configure it with a `JwtGenerator`:\n\n[source,java]\n----\n@Bean\npublic OAuth2TokenGenerator<?> tokenGenerator() {\n\tJwtEncoder jwtEncoder = ...\n\tJwtGenerator jwtGenerator = new JwtGenerator(jwtEncoder);\n\tjwtGenerator.setJwtCustomizer(jwtCustomizer());\n\tOAuth2AccessTokenGenerator accessTokenGenerator = new OAuth2AccessTokenGenerator();\n\tOAuth2RefreshTokenGenerator refreshTokenGenerator = new OAuth2RefreshTokenGenerator();\n\treturn new DelegatingOAuth2TokenGenerator(\n jwtGenerator, accessTokenGenerator, refreshTokenGenerator);\n}\n\n@Bean\npublic OAuth2TokenCustomizer<JwtEncodingContext> jwtCustomizer() {\n\treturn context -> {\n JwsHeader.Builder headers = context.getJwsHeader();\n JwtClaimsSet.Builder claims = context.getClaims();\n if (context.getTokenType().equals(OAuth2TokenType.ACCESS_TOKEN)) {\n // Customize headers/claims for access_token\n\n } else if (context.getTokenType().getValue().equals(OidcParameterNames.ID_TOKEN)) {\n // Customize headers/claims for id_token\n\n }\n\t};\n}\n----\n\n[NOTE]\nIf the `OAuth2TokenGenerator` is not provided as a `@Bean` or is not configured through the `OAuth2AuthorizationServerConfigurer`, an `OAuth2TokenCustomizer<JwtEncodingContext>` `@Bean` will automatically be configured with a `JwtGenerator`.\n\n[[oauth2AuthorizationServer-session-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "OAuth2TokenCustomizer", "heading_level": 2, "file_order": 137, "section_index": 10, "content_hash": "4c40baad3e24a323e564539fc821fb4de95a16a477c41a7476430bb1114ef37a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:2597ff462d6315b7cdc4d605c62a725977d9847cb90a560d15ec5878f4c6867c", "content": "If OpenID Connect 1.0 is enabled, a `SessionRegistry` instance is used to track authenticated sessions.\nThe `SessionRegistry` is used by the default implementation of `SessionAuthenticationStrategy` associated to the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-authorization-endpoint[OAuth2 Authorization Endpoint] for registering new authenticated sessions.\n\n[NOTE]\nIf a `SessionRegistry` `@Bean` is not registered, the default implementation `SessionRegistryImpl` will be used.\n\n[IMPORTANT]\nIf a `SessionRegistry` `@Bean` is registered and is an instance of `SessionRegistryImpl`, a `HttpSessionEventPublisher` `@Bean` *SHOULD* also be registered as it's responsible for notifying `SessionRegistryImpl` of session lifecycle events, for example, `SessionDestroyedEvent`, to provide the ability to remove the `SessionInformation` instance.\n\nWhen a logout is requested by an End-User, the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-logout-endpoint[OpenID Connect 1.0 Logout Endpoint] uses the `SessionRegistry` to lookup the `SessionInformation` associated to the authenticated End-User to perform the logout.\n\nIf Spring Security's xref:servlet/authentication/session-management.adoc#ns-concurrent-sessions[Concurrent Session Control] feature is being used, it is *RECOMMENDED* to register a `SessionRegistry` `@Bean` to ensure it's shared between Spring Security's Concurrent Session Control and Spring Security Authorization Server's Logout feature.\n\nThe following example shows how to register a `SessionRegistry` `@Bean` and `HttpSessionEventPublisher` `@Bean` (required by `SessionRegistryImpl`):\n\n[source,java]\n----\n@Bean\npublic SessionRegistry sessionRegistry() {\n\treturn new SessionRegistryImpl();\n}\n\n@Bean\npublic HttpSessionEventPublisher httpSessionEventPublisher() {\n\treturn new HttpSessionEventPublisher();\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc", "title": "core-model-components", "heading": "SessionRegistry", "heading_level": 2, "file_order": 137, "section_index": 11, "content_hash": "2597ff462d6315b7cdc4d605c62a725977d9847cb90a560d15ec5878f4c6867c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/core-model-components.adoc"}}
{"id": "sha256:b03733f50314ac51f269892c1b1c05b0bb8950a5207b3cfb9bbbfaf42e61416f", "content": "[[oauth2AuthorizationServer-getting-started]]\n\nIf you are just getting started with Spring Security Authorization Server, the following sections walk you through creating your first application.\n\n[[oauth2AuthorizationServer-system-requirements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/getting-started.adoc", "title": "getting-started", "heading": "getting-started", "heading_level": 1, "file_order": 138, "section_index": 0, "content_hash": "b03733f50314ac51f269892c1b1c05b0bb8950a5207b3cfb9bbbfaf42e61416f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/getting-started.adoc"}}
{"id": "sha256:1a672d2c775112b9a91110d98545dedb5294e01f07efdb603146e490ab64f05c", "content": "Spring Security Authorization Server requires a Java 17 or higher Runtime Environment.\n\n[[oauth2AuthorizationServer-installing-spring-security-authorization-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/getting-started.adoc", "title": "getting-started", "heading": "System Requirements", "heading_level": 2, "file_order": 138, "section_index": 1, "content_hash": "1a672d2c775112b9a91110d98545dedb5294e01f07efdb603146e490ab64f05c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/getting-started.adoc"}}
{"id": "sha256:2b2064220551b7372110dbab97ecff8440d14221768d47ba7c56e506992d85c7", "content": "The easiest way to begin using Spring Security Authorization Server is by creating a https://spring.io/projects/spring-boot[Spring Boot]-based application.\nYou can use https://start.spring.io[start.spring.io] to generate a basic project or use the https://github.com/spring-projects/spring-authorization-server/tree/main/samples/default-authorizationserver[default authorization server sample] as a guide.\nThen add Spring Boot's starter for Spring Security Authorization Server as a dependency:\n\n[tabs]\n======\nMaven::\n+\n[[oauth2AuthorizationServer-spring-boot-maven-dependency]]\n[source,xml,role=\"primary\",subs=\"attributes,verbatim\"]\n----\n<dependency>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-oauth2-authorization-server</artifactId>\n</dependency>\n----\n\nGradle::\n+\n[[oauth2AuthorizationServer-spring-boot-gradle-dependency]]\n[source,gradle,role=\"secondary\",subs=\"attributes,verbatim\"]\n----\nimplementation \"org.springframework.boot:spring-boot-starter-oauth2-authorization-server\"\n----\n======\n\nTIP: See https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.installing[Installing Spring Boot] for more information on using Spring Boot with Maven or Gradle.\n\nAlternatively, you can add Spring Security Authorization Server without Spring Boot using the following example:\n\n[tabs]\n======\nMaven::\n+\n[[oauth2AuthorizationServer-maven-dependency]]\n[source,xml,role=\"primary\",subs=\"attributes,verbatim\"]\n----\n<dependency>\n <groupId>org.springframework.security</groupId>\n <artifactId>spring-security-oauth2-authorization-server</artifactId>\n <version>{spring-security-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[[oauth2AuthorizationServer-gradle-dependency]]\n[source,gradle,role=\"secondary\",subs=\"attributes,verbatim\"]\n----\nimplementation \"org.springframework.security:spring-security-oauth2-authorization-server:{spring-security-version}\"\n----\n======\n\n[[oauth2AuthorizationServer-developing-your-first-application]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/getting-started.adoc", "title": "getting-started", "heading": "Installing Spring Security Authorization Server", "heading_level": 2, "file_order": 138, "section_index": 2, "content_hash": "2b2064220551b7372110dbab97ecff8440d14221768d47ba7c56e506992d85c7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/getting-started.adoc"}}
{"id": "sha256:0b601799a4c7a8b60038b93cd44c932a67bae8d7f7e9aba5f9b4cbca0a2db7aa", "content": "To get started, you need the minimum required components defined as a `@Bean`. When using the `spring-boot-starter-oauth2-authorization-server` dependency, define the following properties and Spring Boot will provide the necessary `@Bean` definitions for you:\n\n[[oauth2AuthorizationServer-application-yml]]\n.application.yml\n[source,yaml]\n----\nserver:\n port: 9000\n\nlogging:\n level:\n org.springframework.security: trace\n\nspring:\n security:\n user:\n name: user\n password: password\n oauth2:\n authorizationserver:\n client:\n oidc-client:\n registration:\n client-id: \"oidc-client\"\n client-secret: \"{noop}secret\"\n client-authentication-methods:\n - \"client_secret_basic\"\n authorization-grant-types:\n - \"authorization_code\"\n - \"refresh_token\"\n redirect-uris:\n - \"http://127.0.0.1:8080/login/oauth2/code/oidc-client\"\n post-logout-redirect-uris:\n - \"http://127.0.0.1:8080/\"\n scopes:\n - \"openid\"\n - \"profile\"\n require-authorization-consent: true\n----\n\nIf you want to customize the default `HttpSecurity` configuration, you may override Spring Boot's auto-configuration with the following example:\n\n[[oauth2AuthorizationServer-minimal-sample-gettingstarted]]\n.SecurityConfig.java\n[source,java]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) {\n http\n .authorizeHttpRequests((authorize) ->\n authorize\n .anyRequest().authenticated()\n )\n .formLogin(Customizer.withDefaults())\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .oidc(Customizer.withDefaults())\t// Enable OpenID Connect 1.0\n );\n return http.build();\n\t}\n\n}\n----\n\nTIP: Beyond the Getting Started experience, most users will want to customize the default configuration. The xref:servlet/oauth2/authorization-server/getting-started.adoc#oauth2AuthorizationServer-defining-required-components[next section] demonstrates providing all of the necessary beans yourself.\n\n[[oauth2AuthorizationServer-defining-required-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/getting-started.adoc", "title": "getting-started", "heading": "Developing Your First Application", "heading_level": 2, "file_order": 138, "section_index": 3, "content_hash": "0b601799a4c7a8b60038b93cd44c932a67bae8d7f7e9aba5f9b4cbca0a2db7aa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/getting-started.adoc"}}
{"id": "sha256:2fe9b72d2bc82d182398d18d32579a319a6f70e1fae521265fec3e7e3afb2bd3", "content": "If you want to customize the default configuration (regardless of whether you're using Spring Boot), you can define the minimum required components as a `@Bean` in a Spring `@Configuration`.\n\nThese components can be defined as follows:\n\n[[oauth2AuthorizationServer-sample-gettingstarted]]\n.SecurityConfig.java\n[source,java]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean // <1>\n\t@Order(1)\n\tpublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http)\n throws Exception {\n\n // @formatter:off\n http\n .oauth2AuthorizationServer((authorizationServer) -> {\n http.securityMatcher(authorizationServer.getEndpointsMatcher());\n authorizationServer\n .oidc(Customizer.withDefaults());\t// Enable OpenID Connect 1.0\n })\n .authorizeHttpRequests((authorize) ->\n authorize\n .anyRequest().authenticated()\n )\n // Redirect to the login page when not authenticated from the\n // authorization endpoint\n .exceptionHandling((exceptions) -> exceptions\n .defaultAuthenticationEntryPointFor(\n new LoginUrlAuthenticationEntryPoint(\"/login\"),\n new MediaTypeRequestMatcher(MediaType.TEXT_HTML)\n )\n );\n // @formatter:on\n\n return http.build();\n\t}\n\n\t@Bean // <2>\n\t@Order(2)\n\tpublic SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http)\n throws Exception {\n // @formatter:off\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n // Form login handles the redirect to the login page from the\n // authorization server filter chain\n .formLogin(Customizer.withDefaults());\n // @formatter:on\n\n return http.build();\n\t}\n\n\t@Bean // <3>\n\tpublic UserDetailsService userDetailsService() {\n // @formatter:off\n UserDetails userDetails = User.withDefaultPasswordEncoder()\n .username(\"user\")\n .password(\"password\")\n .roles(\"USER\")\n .build();\n // @formatter:on\n\n return new InMemoryUserDetailsManager(userDetails);\n\t}\n\n\t@Bean // <4>\n\tpublic RegisteredClientRepository registeredClientRepository() {\n // @formatter:off\n RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString())\n .clientId(\"oidc-client\")\n .clientSecret(\"{noop}secret\")\n .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)\n .redirectUri(\"http://127.0.0.1:8080/login/oauth2/code/oidc-client\")\n .postLogoutRedirectUri(\"http://127.0.0.1:8080/\")\n .scope(OidcScopes.OPENID)\n .scope(OidcScopes.PROFILE)\n .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build())\n .build();\n // @formatter:on\n\n return new InMemoryRegisteredClientRepository(oidcClient);\n\t}\n\n\t@Bean // <5>\n\tpublic JWKSource<SecurityContext> jwkSource() {\n KeyPair keyPair = generateRsaKey();\n RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();\n // @formatter:off\n RSAKey rsaKey = new RSAKey.Builder(publicKey)\n .privateKey(privateKey)\n .keyID(UUID.randomUUID().toString())\n .build();\n // @formatter:on\n JWKSet jwkSet = new JWKSet(rsaKey);\n return new ImmutableJWKSet<>(jwkSet);\n\t}\n\n\tprivate static KeyPair generateRsaKey() { // <6>\n KeyPair keyPair;\n try {\n KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n keyPairGenerator.initialize(2048);\n keyPair = keyPairGenerator.generateKeyPair();\n }\n catch (Exception ex) {\n throw new IllegalStateException(ex);\n }\n return keyPair;\n\t}\n\n\t@Bean // <7>\n\tpublic JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {\n return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);\n\t}\n\n\t@Bean // <8>\n\tpublic AuthorizationServerSettings authorizationServerSettings() {\n return AuthorizationServerSettings.builder().build();\n\t}\n\n}\n----\n\nThis is a minimal configuration for getting started quickly. To understand what each component is used for, see the following descriptions:\n\n<1> A Spring Security filter chain for the xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc[Protocol Endpoints].\n<2> A Spring Security filter chain for xref:servlet/authentication/index.adoc#servlet-authentication[authentication].\n<3> An instance of {security-api-url}/org/springframework/security/core/userdetails/UserDetailsService.html[`UserDetailsService`] for retrieving users to authenticate.\n<4> An instance of xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-registered-client-repository[`RegisteredClientRepository`] for managing clients.\n<5> An instance of `com.nimbusds.jose.jwk.source.JWKSource` for signing access tokens.\n<6> An instance of `java.security.KeyPair` with keys generated on startup used to create the `JWKSource` above.\n<7> An instance of {security-api-url}/org/springframework/security/oauth2/jwt/JwtDecoder.html[`JwtDecoder`] for decoding signed access tokens.\n<8> An instance of xref:servlet/oauth2/authorization-server/configuration-model.adoc#oauth2AuthorizationServer-configuring-authorization-server-settings[`AuthorizationServerSettings`] to configure Spring Security Authorization Server.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/getting-started.adoc", "title": "getting-started", "heading": "Defining Required Components", "heading_level": 2, "file_order": 138, "section_index": 4, "content_hash": "2fe9b72d2bc82d182398d18d32579a319a6f70e1fae521265fec3e7e3afb2bd3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/getting-started.adoc"}}
{"id": "sha256:2d5670db406ebea0921137ded3ce400a440b7ac281f34a59b874ef2e2e9b3f7b", "content": "[[oauth2AuthorizationServer]]\n\nThe OAuth 2.1 Authorization Server features provide support for the Authorization Server role as defined in the https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-1.1[OAuth 2.1 Authorization Framework].\n\nThe Authorization Server features provide implementations of the https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07[OAuth 2.1] and https://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect 1.0] specifications and other related specifications.\nIt provides a secure, light-weight, and customizable foundation for building OpenID Connect 1.0 Identity Providers and OAuth 2.1 Authorization Server products.\n\n[[oauth2AuthorizationServer-use-cases]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 139, "section_index": 0, "content_hash": "2d5670db406ebea0921137ded3ce400a440b7ac281f34a59b874ef2e2e9b3f7b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/index.adoc"}}
{"id": "sha256:43b2e925cffa06fb4a0412e0cd31c0cb669854593e65632bc86d191090a4b817", "content": "The following list provides some use cases for using Spring Security Authorization Server compared to using an open source or commercial OAuth2 or OpenID Connect 1.0 Provider product.\n\n* Provides full control of configuration and customization when advanced customization scenarios are required.\n* Preference for a light-weight authorization server compared to a commercial product that includes all the \"bells and whistles\".\n* Potential savings in software licensing and/or hosting costs.\n* Quick startup and ease of use during development using the familiar Spring programming model.\n\n[[oauth2AuthorizationServer-feature-list]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/index.adoc", "title": "index", "heading": "Use Cases", "heading_level": 2, "file_order": 139, "section_index": 1, "content_hash": "43b2e925cffa06fb4a0412e0cd31c0cb669854593e65632bc86d191090a4b817", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/index.adoc"}}
{"id": "sha256:fa0f69ff173436a2d4dd35e1e71e28af99acd521a0cabf815f738e9f10773870", "content": "Spring Security Authorization Server supports the following features:\n\n[cols=\"2a,4a,6a\"]\n|===\n|Category |Feature |Related specifications\n\n|xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-endpoint[Authorization Grant]\n|\n* Authorization Code\n** xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-authorization-endpoint[User Consent]\n* Client Credentials\n* Refresh Token\n* Device Code\n** xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-device-verification-endpoint[User Consent]\n* Token Exchange\n|\n* The OAuth 2.1 Authorization Framework (https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07[draft])\n** https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-4.1[Authorization Code Grant]\n** https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-4.2[Client Credentials Grant]\n** https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-4.3[Refresh Token Grant]\n* OpenID Connect Core 1.0 (https://openid.net/specs/openid-connect-core-1_0.html[spec])\n** https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth[Authorization Code Flow]\n* OAuth 2.0 Device Authorization Grant\n(https://tools.ietf.org/html/rfc8628[spec])\n** https://tools.ietf.org/html/rfc8628#section-3[Device Flow]\n* OAuth 2.0 Token Exchange (https://datatracker.ietf.org/doc/html/rfc8693[spec])\n** https://datatracker.ietf.org/doc/html/rfc8693#section-2[Token Exchange Flow]\n\n|xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-token-generator[Token Formats]\n|\n* Self-contained (JWT)\n* Reference (Opaque)\n|\n* JSON Web Token (JWT) (https://tools.ietf.org/html/rfc7519[RFC 7519])\n* JSON Web Signature (JWS) (https://tools.ietf.org/html/rfc7515[RFC 7515])\n\n|Token Types\n|\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-endpoint-dpop-bound-access-tokens[DPoP-bound Access Tokens]\n|\n* OAuth 2.0 Demonstrating Proof of Possession (DPoP) (https://datatracker.ietf.org/doc/html/rfc9449[RFC 9449])\n\n|xref:servlet/oauth2/authorization-server/configuration-model.adoc#oauth2AuthorizationServer-configuring-client-authentication[Client Authentication]\n|\n* `client_secret_basic`\n* `client_secret_post`\n* `client_secret_jwt`\n* `private_key_jwt`\n* `tls_client_auth`\n* `self_signed_tls_client_auth`\n* `none` (public clients)\n|\n* The OAuth 2.1 Authorization Framework (https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-2.4[Client Authentication])\n* JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication (https://tools.ietf.org/html/rfc7523[RFC 7523])\n* OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens (https://datatracker.ietf.org/doc/html/rfc8705[RFC 8705])\n* Proof Key for Code Exchange by OAuth Public Clients (PKCE) (https://tools.ietf.org/html/rfc7636[RFC 7636])\n\n|xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc[Protocol Endpoints]\n|\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-authorization-endpoint[OAuth2 Authorization Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-pushed-authorization-request-endpoint[OAuth2 Pushed Authorization Request Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-device-authorization-endpoint[OAuth2 Device Authorization Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-device-verification-endpoint[OAuth2 Device Verification Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-endpoint[OAuth2 Token Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-introspection-endpoint[OAuth2 Token Introspection Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-token-revocation-endpoint[OAuth2 Token Revocation Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-client-registration-endpoint[OAuth2 Client Registration Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oauth2-authorization-server-metadata-endpoint[OAuth2 Authorization Server Metadata Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-jwk-set-endpoint[JWK Set Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-provider-configuration-endpoint[OpenID Connect 1.0 Provider Configuration Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-logout-endpoint[OpenID Connect 1.0 Logout Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-user-info-endpoint[OpenID Connect 1.0 UserInfo Endpoint]\n* xref:servlet/oauth2/authorization-server/protocol-endpoints.adoc#oauth2AuthorizationServer-oidc-client-registration-endpoint[OpenID Connect 1.0 Client Registration Endpoint]\n|\n* The OAuth 2.1 Authorization Framework (https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07[draft])\n** https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-3.1[Authorization Endpoint]\n** https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-3.2[Token Endpoint]\n* OAuth 2.0 Pushed Authorization Requests (https://datatracker.ietf.org/doc/html/rfc9126[RFC 9126])\n** https://datatracker.ietf.org/doc/html/rfc9126#section-2[Pushed Authorization Request Endpoint]\n* OAuth 2.0 Device Authorization Grant (https://tools.ietf.org/html/rfc8628[RFC 8628])\n** https://tools.ietf.org/html/rfc8628#section-3.1[Device Authorization Endpoint]\n** https://tools.ietf.org/html/rfc8628#section-3.3[Device Verification Endpoint]\n* OAuth 2.0 Token Introspection (https://tools.ietf.org/html/rfc7662[RFC 7662])\n* OAuth 2.0 Token Revocation (https://tools.ietf.org/html/rfc7009[RFC 7009])\n* OAuth 2.0 Dynamic Client Registration Protocol (https://datatracker.ietf.org/doc/html/rfc7591[RFC 7591])\n* OAuth 2.0 Authorization Server Metadata (https://tools.ietf.org/html/rfc8414[RFC 8414])\n* JSON Web Key (JWK) (https://tools.ietf.org/html/rfc7517[RFC 7517])\n* OpenID Connect Discovery 1.0 (https://openid.net/specs/openid-connect-discovery-1_0.html[spec])\n** https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[Provider Configuration Endpoint]\n* OpenID Connect RP-Initiated Logout 1.0 (https://openid.net/specs/openid-connect-rpinitiated-1_0.html[spec])\n** https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout[Logout Endpoint]\n* OpenID Connect Core 1.0 (https://openid.net/specs/openid-connect-core-1_0.html[spec])\n** https://openid.net/specs/openid-connect-core-1_0.html#UserInfo[UserInfo Endpoint]\n* OpenID Connect Dynamic Client Registration 1.0 (https://openid.net/specs/openid-connect-registration-1_0.html[spec])\n** https://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration[Client Registration Endpoint]\n** https://openid.net/specs/openid-connect-registration-1_0.html#ClientConfigurationEndpoint[Client Configuration Endpoint]\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/index.adoc", "title": "index", "heading": "Feature List", "heading_level": 2, "file_order": 139, "section_index": 2, "content_hash": "fa0f69ff173436a2d4dd35e1e71e28af99acd521a0cabf815f738e9f10773870", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/index.adoc"}}
{"id": "sha256:861f5ed08a0f40ff7f83a34ccf4bcc7a9d413bbb2a9055c25cad5fccc029977a", "content": "[[oauth2AuthorizationServer-protocol-endpoints]]\n\n[[oauth2AuthorizationServer-oauth2-authorization-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "protocol-endpoints", "heading_level": 1, "file_order": 140, "section_index": 0, "content_hash": "861f5ed08a0f40ff7f83a34ccf4bcc7a9d413bbb2a9055c25cad5fccc029977a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:fe153a916683510a2900a888fb85117f5494a63e543648b953e57c9758421cf9", "content": "`OAuth2AuthorizationEndpointConfigurer` provides the ability to customize the https://datatracker.ietf.org/doc/html/rfc6749#section-3.1[OAuth2 Authorization endpoint].\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1[OAuth2 authorization requests].\n\n`OAuth2AuthorizationEndpointConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .authorizationEndpoint(authorizationEndpoint ->\n authorizationEndpoint\n .authorizationRequestConverter(authorizationRequestConverter) <1>\n .authorizationRequestConverters(authorizationRequestConvertersConsumer) <2>\n .authenticationProvider(authenticationProvider) <3>\n .authenticationProviders(authenticationProvidersConsumer) <4>\n .authorizationResponseHandler(authorizationResponseHandler) <5>\n .errorResponseHandler(errorResponseHandler) <6>\n .consentPage(\"/oauth2/v1/authorize\") <7>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `authorizationRequestConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract an https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1[OAuth2 authorization request] (or consent) from `HttpServletRequest` to an instance of `OAuth2AuthorizationCodeRequestAuthenticationToken` or `OAuth2AuthorizationConsentAuthenticationToken`.\n<2> `authorizationRequestConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OAuth2AuthorizationCodeRequestAuthenticationToken` or `OAuth2AuthorizationConsentAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `authorizationResponseHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling an \"`authenticated`\" `OAuth2AuthorizationCodeRequestAuthenticationToken` and returning the https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2[OAuth2AuthorizationResponse].\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling an `OAuth2AuthorizationCodeRequestAuthenticationException` and returning the https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.2.1[OAuth2Error response].\n<7> `consentPage()`: The `URI` of the custom consent page to redirect resource owners to if consent is required during the authorization request flow.\n\n`OAuth2AuthorizationEndpointConfigurer` configures the `OAuth2AuthorizationEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OAuth2AuthorizationEndpointFilter` is the `Filter` that processes OAuth2 authorization requests (and consents).\n\n`OAuth2AuthorizationEndpointFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- A `DelegatingAuthenticationConverter` composed of `OAuth2AuthorizationCodeRequestAuthenticationConverter` and `OAuth2AuthorizationConsentAuthenticationConverter`.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `OAuth2AuthorizationCodeRequestAuthenticationProvider` and `OAuth2AuthorizationConsentAuthenticationProvider`.\n* `*AuthenticationSuccessHandler*` -- An internal implementation that handles an \"`authenticated`\" `OAuth2AuthorizationCodeRequestAuthenticationToken` and returns the `OAuth2AuthorizationResponse`.\n* `*AuthenticationFailureHandler*` -- An internal implementation that uses the `OAuth2Error` associated with the `OAuth2AuthorizationCodeRequestAuthenticationException` and returns the `OAuth2Error` response.\n\n[[oauth2AuthorizationServer-oauth2-authorization-endpoint-customizing-authorization-request-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OAuth2 Authorization Endpoint", "heading_level": 2, "file_order": 140, "section_index": 1, "content_hash": "fe153a916683510a2900a888fb85117f5494a63e543648b953e57c9758421cf9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:43f1de27246a4a2582ce4f49d4cd122c64e4c17a0d73b277d64d4210a0454539", "content": "`OAuth2AuthorizationCodeRequestAuthenticationValidator` is the default validator used for validating specific OAuth2 authorization request parameters used in the Authorization Code Grant.\nThe default implementation validates the `redirect_uri` and `scope` parameters.\nIf validation fails, an `OAuth2AuthorizationCodeRequestAuthenticationException` is thrown.\n\n`OAuth2AuthorizationCodeRequestAuthenticationProvider` provides the ability to override the default authorization request validation by supplying a custom authentication validator of type `Consumer<OAuth2AuthorizationCodeRequestAuthenticationContext>` to `setAuthenticationValidator()`.\n\n[TIP]\n`OAuth2AuthorizationCodeRequestAuthenticationContext` holds the `OAuth2AuthorizationCodeRequestAuthenticationToken`, which contains the OAuth2 authorization request parameters.\n\n[IMPORTANT]\nIf validation fails, the authentication validator *MUST* throw `OAuth2AuthorizationCodeRequestAuthenticationException`.\n\nA common use case during the development life cycle phase is to allow for `localhost` in the `redirect_uri` parameter.\n\nThe following example shows how to configure `OAuth2AuthorizationCodeRequestAuthenticationProvider` with a custom authentication validator that allows for `localhost` in the `redirect_uri` parameter:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .authorizationEndpoint(authorizationEndpoint ->\n authorizationEndpoint\n .authenticationProviders(configureAuthenticationValidator())\n )\n );\n\n\treturn http.build();\n}\n\nprivate Consumer<List<AuthenticationProvider>> configureAuthenticationValidator() {\n\treturn (authenticationProviders) ->\n authenticationProviders.forEach((authenticationProvider) -> {\n if (authenticationProvider instanceof OAuth2AuthorizationCodeRequestAuthenticationProvider) {\n Consumer<OAuth2AuthorizationCodeRequestAuthenticationContext> authenticationValidator =\n // Override default redirect_uri validator\n new CustomRedirectUriValidator()\n // Reuse default scope validator\n .andThen(OAuth2AuthorizationCodeRequestAuthenticationValidator.DEFAULT_SCOPE_VALIDATOR);\n\n ((OAuth2AuthorizationCodeRequestAuthenticationProvider) authenticationProvider)\n .setAuthenticationValidator(authenticationValidator);\n }\n });\n}\n\nstatic class CustomRedirectUriValidator implements Consumer<OAuth2AuthorizationCodeRequestAuthenticationContext> {\n\n\t@Override\n\tpublic void accept(OAuth2AuthorizationCodeRequestAuthenticationContext authenticationContext) {\n OAuth2AuthorizationCodeRequestAuthenticationToken authorizationCodeRequestAuthentication =\n authenticationContext.getAuthentication();\n RegisteredClient registeredClient = authenticationContext.getRegisteredClient();\n String requestedRedirectUri = authorizationCodeRequestAuthentication.getRedirectUri();\n\n // Use exact string matching when comparing client redirect URIs against pre-registered URIs\n if (!registeredClient.getRedirectUris().contains(requestedRedirectUri)) {\n OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.INVALID_REQUEST);\n throw new OAuth2AuthorizationCodeRequestAuthenticationException(error, null);\n }\n\t}\n}\n----\n\n[[oauth2AuthorizationServer-oauth2-pushed-authorization-request-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "Customizing Authorization Request Validation", "heading_level": 3, "file_order": 140, "section_index": 2, "content_hash": "43f1de27246a4a2582ce4f49d4cd122c64e4c17a0d73b277d64d4210a0454539", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:ed763694818c9336ed1e1e9fe703b98a165de7020312bd1aee64ab328f8a770f", "content": "`OAuth2PushedAuthorizationRequestEndpointConfigurer` provides the ability to customize the https://datatracker.ietf.org/doc/html/rfc9126#section-2[OAuth2 Pushed Authorization Request endpoint].\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for https://datatracker.ietf.org/doc/html/rfc9126#section-2.1[OAuth2 Pushed Authorization requests].\n\n`OAuth2PushedAuthorizationRequestEndpointConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .pushedAuthorizationRequestEndpoint(pushedAuthorizationRequestEndpoint ->\n pushedAuthorizationRequestEndpoint\n .pushedAuthorizationRequestConverter(pushedAuthorizationRequestConverter) <1>\n .pushedAuthorizationRequestConverters(pushedAuthorizationRequestConvertersConsumer) <2>\n .authenticationProvider(authenticationProvider) <3>\n .authenticationProviders(authenticationProvidersConsumer) <4>\n .pushedAuthorizationResponseHandler(pushedAuthorizationResponseHandler) <5>\n .errorResponseHandler(errorResponseHandler) <6>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `pushedAuthorizationRequestConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract an https://datatracker.ietf.org/doc/html/rfc9126#section-2.1[OAuth2 pushed authorization request] from `HttpServletRequest` to an instance of `OAuth2PushedAuthorizationRequestAuthenticationToken`.\n<2> `pushedAuthorizationRequestConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OAuth2PushedAuthorizationRequestAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `pushedAuthorizationResponseHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling an \"`authenticated`\" `OAuth2PushedAuthorizationRequestAuthenticationToken` and returning the https://datatracker.ietf.org/doc/html/rfc9126#section-2.2[OAuth2 pushed authorization response].\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling an `OAuth2AuthenticationException` and returning the https://datatracker.ietf.org/doc/html/rfc9126#section-2.3[OAuth2Error response].\n\n`OAuth2PushedAuthorizationRequestEndpointConfigurer` configures the `OAuth2PushedAuthorizationRequestEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OAuth2PushedAuthorizationRequestEndpointFilter` is the `Filter` that processes OAuth2 pushed authorization requests.\n\n`OAuth2PushedAuthorizationRequestEndpointFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- A `DelegatingAuthenticationConverter` composed of `OAuth2AuthorizationCodeRequestAuthenticationConverter`.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `OAuth2PushedAuthorizationRequestAuthenticationProvider`.\n* `*AuthenticationSuccessHandler*` -- An internal implementation that handles an \"`authenticated`\" `OAuth2PushedAuthorizationRequestAuthenticationToken` and returns the OAuth2 pushed authorization response.\n* `*AuthenticationFailureHandler*` -- An `OAuth2ErrorAuthenticationFailureHandler`.\n\n[[oauth2AuthorizationServer-oauth2-pushed-authorization-request-endpoint-customizing-pushed-authorization-request-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OAuth2 Pushed Authorization Request Endpoint", "heading_level": 2, "file_order": 140, "section_index": 3, "content_hash": "ed763694818c9336ed1e1e9fe703b98a165de7020312bd1aee64ab328f8a770f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:17f4f1eb29e131a412856b4518e580684589fd82686d45938eda932a82d07d0a", "content": "`OAuth2AuthorizationCodeRequestAuthenticationValidator` is the default validator used for validating specific OAuth2 pushed authorization request parameters used in the Authorization Code Grant.\nThe default implementation validates the `redirect_uri` and `scope` parameters.\nIf validation fails, an `OAuth2AuthorizationCodeRequestAuthenticationException` is thrown.\n\n`OAuth2PushedAuthorizationRequestAuthenticationProvider` provides the ability to override the default pushed authorization request validation by supplying a custom authentication validator of type `Consumer<OAuth2AuthorizationCodeRequestAuthenticationContext>` to `setAuthenticationValidator()`.\n\n[TIP]\n`OAuth2AuthorizationCodeRequestAuthenticationContext` holds the `OAuth2AuthorizationCodeRequestAuthenticationToken`, which contains the OAuth2 pushed authorization request parameters.\n\n[IMPORTANT]\nIf validation fails, the authentication validator *MUST* throw `OAuth2AuthorizationCodeRequestAuthenticationException`.\n\nA common use case during the development life cycle phase is to allow for `localhost` in the `redirect_uri` parameter.\n\nThe following example shows how to configure `OAuth2PushedAuthorizationRequestAuthenticationProvider` with a custom authentication validator that allows for `localhost` in the `redirect_uri` parameter:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .pushedAuthorizationRequestEndpoint(pushedAuthorizationRequestEndpoint ->\n pushedAuthorizationRequestEndpoint\n .authenticationProviders(configureAuthenticationValidator())\n )\n );\n\n\treturn http.build();\n}\n\nprivate Consumer<List<AuthenticationProvider>> configureAuthenticationValidator() {\n\treturn (authenticationProviders) ->\n authenticationProviders.forEach((authenticationProvider) -> {\n if (authenticationProvider instanceof OAuth2PushedAuthorizationRequestAuthenticationProvider) {\n Consumer<OAuth2AuthorizationCodeRequestAuthenticationContext> authenticationValidator =\n // Override default redirect_uri validator\n new CustomRedirectUriValidator()\n // Reuse default scope validator\n .andThen(OAuth2AuthorizationCodeRequestAuthenticationValidator.DEFAULT_SCOPE_VALIDATOR);\n\n ((OAuth2PushedAuthorizationRequestAuthenticationProvider) authenticationProvider)\n .setAuthenticationValidator(authenticationValidator);\n }\n });\n}\n\nstatic class CustomRedirectUriValidator implements Consumer<OAuth2AuthorizationCodeRequestAuthenticationContext> {\n\n\t@Override\n\tpublic void accept(OAuth2AuthorizationCodeRequestAuthenticationContext authenticationContext) {\n OAuth2AuthorizationCodeRequestAuthenticationToken authorizationCodeRequestAuthentication =\n authenticationContext.getAuthentication();\n RegisteredClient registeredClient = authenticationContext.getRegisteredClient();\n String requestedRedirectUri = authorizationCodeRequestAuthentication.getRedirectUri();\n\n // Use exact string matching when comparing client redirect URIs against pre-registered URIs\n if (!registeredClient.getRedirectUris().contains(requestedRedirectUri)) {\n OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.INVALID_REQUEST);\n throw new OAuth2AuthorizationCodeRequestAuthenticationException(error, null);\n }\n\t}\n}\n----\n\n[[oauth2AuthorizationServer-oauth2-device-authorization-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "Customizing Pushed Authorization Request Validation", "heading_level": 3, "file_order": 140, "section_index": 4, "content_hash": "17f4f1eb29e131a412856b4518e580684589fd82686d45938eda932a82d07d0a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:0157b7fbe3cb2608fe728383d9c81a2d9351995fd712bc61715c984bb400887e", "content": "`OAuth2DeviceAuthorizationEndpointConfigurer` provides the ability to customize the https://datatracker.ietf.org/doc/html/rfc8628#section-3.1[OAuth2 Device Authorization endpoint].\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for OAuth2 device authorization requests.\n\n`OAuth2DeviceAuthorizationEndpointConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .deviceAuthorizationEndpoint(deviceAuthorizationEndpoint ->\n deviceAuthorizationEndpoint\n .deviceAuthorizationRequestConverter(deviceAuthorizationRequestConverter) <1>\n .deviceAuthorizationRequestConverters(deviceAuthorizationRequestConvertersConsumer) <2>\n .authenticationProvider(authenticationProvider) <3>\n .authenticationProviders(authenticationProvidersConsumer) <4>\n .deviceAuthorizationResponseHandler(deviceAuthorizationResponseHandler) <5>\n .errorResponseHandler(errorResponseHandler) <6>\n .verificationUri(\"/oauth2/v1/device_verification\") <7>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `deviceAuthorizationRequestConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract an https://datatracker.ietf.org/doc/html/rfc8628#section-3.1[OAuth2 device authorization request] from `HttpServletRequest` to an instance of `OAuth2DeviceAuthorizationRequestAuthenticationToken`.\n<2> `deviceAuthorizationRequestConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OAuth2DeviceAuthorizationRequestAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `deviceAuthorizationResponseHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling an \"`authenticated`\" `OAuth2DeviceAuthorizationRequestAuthenticationToken` and returning the https://datatracker.ietf.org/doc/html/rfc8628#section-3.2[OAuth2DeviceAuthorizationResponse].\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling an `OAuth2AuthenticationException` and returning the https://datatracker.ietf.org/doc/html/rfc6749#section-5.2[OAuth2Error response].\n<7> `verificationUri()`: The `URI` of the custom end-user verification page to direct resource owners to on a secondary device.\n\n[NOTE]\nThe OAuth2 Device Authorization endpoint is disabled by default.\n\n`OAuth2DeviceAuthorizationEndpointConfigurer` configures the `OAuth2DeviceAuthorizationEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OAuth2DeviceAuthorizationEndpointFilter` is the `Filter` that processes OAuth2 device authorization requests.\n\n`OAuth2DeviceAuthorizationEndpointFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- An `OAuth2DeviceAuthorizationRequestAuthenticationConverter`.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `OAuth2DeviceAuthorizationRequestAuthenticationProvider`.\n* `*AuthenticationSuccessHandler*` -- An internal implementation that handles an \"`authenticated`\" `OAuth2DeviceAuthorizationRequestAuthenticationToken` and returns the `OAuth2DeviceAuthorizationResponse`.\n* `*AuthenticationFailureHandler*` -- An `OAuth2ErrorAuthenticationFailureHandler`.\n\n[[oauth2AuthorizationServer-oauth2-device-verification-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OAuth2 Device Authorization Endpoint", "heading_level": 2, "file_order": 140, "section_index": 5, "content_hash": "0157b7fbe3cb2608fe728383d9c81a2d9351995fd712bc61715c984bb400887e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:d1c3ff8c9951118cbe3730ec1f1c9e9a83ebd61d760453789bc40a5f102aa6fc", "content": "`OAuth2DeviceVerificationEndpointConfigurer` provides the ability to customize the https://datatracker.ietf.org/doc/html/rfc8628#section-3.3[OAuth2 Device Verification endpoint] (or \"User Interaction\").\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for OAuth2 device verification requests.\n\n`OAuth2DeviceVerificationEndpointConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .deviceVerificationEndpoint(deviceVerificationEndpoint ->\n deviceVerificationEndpoint\n .deviceVerificationRequestConverter(deviceVerificationRequestConverter) <1>\n .deviceVerificationRequestConverters(deviceVerificationRequestConvertersConsumer) <2>\n .authenticationProvider(authenticationProvider) <3>\n .authenticationProviders(authenticationProvidersConsumer) <4>\n .deviceVerificationResponseHandler(deviceVerificationResponseHandler) <5>\n .errorResponseHandler(errorResponseHandler) <6>\n .consentPage(\"/oauth2/v1/consent\") <7>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `deviceVerificationRequestConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract an https://datatracker.ietf.org/doc/html/rfc8628#section-3.3[OAuth2 device verification request] (or consent) from `HttpServletRequest` to an instance of `OAuth2DeviceVerificationAuthenticationToken` or `OAuth2DeviceAuthorizationConsentAuthenticationToken`.\n<2> `deviceVerificationRequestConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OAuth2DeviceVerificationAuthenticationToken` or `OAuth2DeviceAuthorizationConsentAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `deviceVerificationResponseHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling an \"`authenticated`\" `OAuth2DeviceVerificationAuthenticationToken` and directing the resource owner to return to their device.\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling an `OAuth2AuthenticationException` and returning the error response.\n<7> `consentPage()`: The `URI` of the custom consent page to redirect resource owners to if consent is required during the device verification request flow.\n\n[NOTE]\nThe OAuth2 Device Verification endpoint is disabled by default.\n\n`OAuth2DeviceVerificationEndpointConfigurer` configures the `OAuth2DeviceVerificationEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OAuth2DeviceVerificationEndpointFilter` is the `Filter` that processes OAuth2 device verification requests (and consents).\n\n`OAuth2DeviceVerificationEndpointFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- A `DelegatingAuthenticationConverter` composed of `OAuth2DeviceVerificationAuthenticationConverter` and `OAuth2DeviceAuthorizationConsentAuthenticationConverter`.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `OAuth2DeviceVerificationAuthenticationProvider` and `OAuth2DeviceAuthorizationConsentAuthenticationProvider`.\n* `*AuthenticationSuccessHandler*` -- A `SimpleUrlAuthenticationSuccessHandler` that handles an \"`authenticated`\" `OAuth2DeviceVerificationAuthenticationToken` and redirects the user to a success page (`/?success`).\n* `*AuthenticationFailureHandler*` -- An internal implementation that uses the `OAuth2Error` associated with the `OAuth2AuthenticationException` and returns the `OAuth2Error` response.\n\n[[oauth2AuthorizationServer-oauth2-token-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OAuth2 Device Verification Endpoint", "heading_level": 2, "file_order": 140, "section_index": 6, "content_hash": "d1c3ff8c9951118cbe3730ec1f1c9e9a83ebd61d760453789bc40a5f102aa6fc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:68cb24c7c02408fffff940dcdc8bf3dbf791109b057f5187744da93633a8ea18", "content": "`OAuth2TokenEndpointConfigurer` provides the ability to customize the https://datatracker.ietf.org/doc/html/rfc6749#section-3.2[OAuth2 Token endpoint].\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3[OAuth2 access token requests].\n\n`OAuth2TokenEndpointConfigurer` provides the following configuration options:\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .tokenEndpoint(tokenEndpoint ->\n tokenEndpoint\n .accessTokenRequestConverter(accessTokenRequestConverter) <1>\n .accessTokenRequestConverters(accessTokenRequestConvertersConsumer) <2>\n .authenticationProvider(authenticationProvider) <3>\n .authenticationProviders(authenticationProvidersConsumer) <4>\n .accessTokenResponseHandler(accessTokenResponseHandler) <5>\n .errorResponseHandler(errorResponseHandler) <6>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `accessTokenRequestConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract an https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3[OAuth2 access token request] from `HttpServletRequest` to an instance of `OAuth2AuthorizationGrantAuthenticationToken`.\n<2> `accessTokenRequestConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OAuth2AuthorizationGrantAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `accessTokenResponseHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling an `OAuth2AccessTokenAuthenticationToken` and returning the https://datatracker.ietf.org/doc/html/rfc6749#section-5.1[`OAuth2AccessTokenResponse`].\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling an `OAuth2AuthenticationException` and returning the https://datatracker.ietf.org/doc/html/rfc6749#section-5.2[OAuth2Error response].\n\n`OAuth2TokenEndpointConfigurer` configures the `OAuth2TokenEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OAuth2TokenEndpointFilter` is the `Filter` that processes OAuth2 access token requests.\n\nThe supported https://datatracker.ietf.org/doc/html/rfc6749#section-1.3[authorization grant types] are `authorization_code`, `refresh_token`, `client_credentials`, `urn:ietf:params:oauth:grant-type:device_code`, and `urn:ietf:params:oauth:grant-type:token-exchange`.\n\n`OAuth2TokenEndpointFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- A `DelegatingAuthenticationConverter` composed of `OAuth2AuthorizationCodeAuthenticationConverter`, `OAuth2RefreshTokenAuthenticationConverter`, `OAuth2ClientCredentialsAuthenticationConverter`, `OAuth2DeviceCodeAuthenticationConverter`, and `OAuth2TokenExchangeAuthenticationConverter`.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `OAuth2AuthorizationCodeAuthenticationProvider`, `OAuth2RefreshTokenAuthenticationProvider`, `OAuth2ClientCredentialsAuthenticationProvider`, `OAuth2DeviceCodeAuthenticationProvider`, and `OAuth2TokenExchangeAuthenticationProvider`.\n* `*AuthenticationSuccessHandler*` -- An `OAuth2AccessTokenResponseAuthenticationSuccessHandler`.\n* `*AuthenticationFailureHandler*` -- An `OAuth2ErrorAuthenticationFailureHandler`.\n\n[[oauth2AuthorizationServer-oauth2-token-endpoint-customizing-client-credentials-grant-request-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OAuth2 Token Endpoint", "heading_level": 2, "file_order": 140, "section_index": 7, "content_hash": "68cb24c7c02408fffff940dcdc8bf3dbf791109b057f5187744da93633a8ea18", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:cca6b84fe1fb25018a4c375b2042f8143612375ca38d7b0c8a7e199d87b1c6e0", "content": "`OAuth2ClientCredentialsAuthenticationValidator` is the default validator used for validating specific OAuth2 Client Credentials Grant request parameters.\nThe default implementation validates the `scope` parameter.\nIf validation fails, an `OAuth2AuthenticationException` is thrown.\n\n`OAuth2ClientCredentialsAuthenticationProvider` provides the ability to override the default request validation by supplying a custom authentication validator of type `Consumer<OAuth2ClientCredentialsAuthenticationContext>` to `setAuthenticationValidator()`.\n\n[TIP]\n`OAuth2ClientCredentialsAuthenticationContext` holds the `OAuth2ClientCredentialsAuthenticationToken`, which contains the OAuth2 Client Credentials Grant request parameters.\n\n[IMPORTANT]\nIf validation fails, the authentication validator *MUST* throw `OAuth2AuthenticationException`.\n\nThe following example shows how to configure `OAuth2ClientCredentialsAuthenticationProvider` with a custom authentication validator that overrides the default `scope` validation:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .tokenEndpoint(tokenEndpoint ->\n tokenEndpoint\n .authenticationProviders(configureAuthenticationValidator())\n )\n );\n\n\treturn http.build();\n}\n\nprivate Consumer<List<AuthenticationProvider>> configureAuthenticationValidator() {\n\treturn (authenticationProviders) ->\n authenticationProviders.forEach((authenticationProvider) -> {\n if (authenticationProvider instanceof OAuth2ClientCredentialsAuthenticationProvider) {\n Consumer<OAuth2ClientCredentialsAuthenticationContext> authenticationValidator =\n new CustomScopeValidator();\n\n // Override default scope validation\n ((OAuth2ClientCredentialsAuthenticationProvider) authenticationProvider)\n .setAuthenticationValidator(authenticationValidator);\n }\n });\n}\n\nstatic class CustomScopeValidator implements Consumer<OAuth2ClientCredentialsAuthenticationContext> {\n\n\t@Override\n\tpublic void accept(OAuth2ClientCredentialsAuthenticationContext authenticationContext) {\n OAuth2ClientCredentialsAuthenticationToken clientCredentialsAuthentication =\n authenticationContext.getAuthentication();\n\n Set<String> requestedScopes = clientCredentialsAuthentication.getScopes();\n RegisteredClient registeredClient = authenticationContext.getRegisteredClient();\n Set<String> allowedScopes = registeredClient.getScopes();\n\n // TODO Implement scope validation\n\n\t}\n}\n----\n\n[[oauth2AuthorizationServer-oauth2-token-endpoint-dpop-bound-access-tokens]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "Customizing Client Credentials Grant Request Validation", "heading_level": 3, "file_order": 140, "section_index": 8, "content_hash": "cca6b84fe1fb25018a4c375b2042f8143612375ca38d7b0c8a7e199d87b1c6e0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:05a097fff1cab3b685f4f174bdb8c6754d7af035c6a1a0b6ee941413498ae03e", "content": "https://datatracker.ietf.org/doc/html/rfc9449[RFC 9449 OAuth 2.0 Demonstrating Proof of Possession (DPoP)] is an application-level mechanism for sender-constraining an access token.\n\nThe primary goal of DPoP is to prevent unauthorized or illegitimate clients from using leaked or stolen access tokens, by binding an access token to a public key upon issuance by the authorization server and requiring that the client proves possession of the corresponding private key when using the access token at the resource server.\n\nAccess tokens that are sender-constrained via DPoP stand in contrast to the typical bearer token, which can be used by any client in possession of the access token.\n\nDPoP introduces the concept of a https://datatracker.ietf.org/doc/html/rfc9449#name-dpop-proof-jwts[DPoP Proof], which is a JWT created by the client and sent as a header in an HTTP request.\nA client uses a DPoP proof to prove the possession of a private key corresponding to a certain public key.\n\nWhen the client initiates an access token request, it attaches a DPoP proof to the request in an HTTP header.\nThe authorization server binds (sender-constrains) the access token to the public key associated in the DPoP proof.\n\nWhen the client initiates a protected resource request, it again attaches a DPoP proof to the request in an HTTP header.\n\nThe resource server obtains information about the public key bound to the access token, either directly in the access token (JWT) or via the <<oauth2AuthorizationServer-oauth2-token-introspection-endpoint,OAuth2 Token Introspection endpoint>>.\nThe resource server then verifies that the public key bound to the access token matches the public key in the DPoP proof.\nIt also verifies that the access token hash in the DPoP proof matches the access token in the request.\n\n[[oauth2AuthorizationServer-oauth2-token-endpoint-dpop-access-token-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "DPoP-bound Access Tokens", "heading_level": 3, "file_order": 140, "section_index": 9, "content_hash": "05a097fff1cab3b685f4f174bdb8c6754d7af035c6a1a0b6ee941413498ae03e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:0b8b99fedb42a02f5844d5aab9892b596ca75b5d1d3b1cf9f68048b2bae62d7d", "content": "To request an access token that is bound to a public key using DPoP, the client MUST provide a valid DPoP proof in the `DPoP` header when making an access token request to the OAuth2 Token endpoint.\nThis is applicable for all access token requests regardless of authorization grant type (e.g. `authorization_code`, `refresh_token`, `client_credentials`, etc).\n\nThe following HTTP request shows an `authorization_code` access token request with a DPoP proof in the `DPoP` header:\n\n[source,shell]\n----\nPOST /oauth2/token HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\nDPoP: eyJraWQiOiJyc2EtandrLWtpZCIsInR5cCI6ImRwb3Arand0IiwiYWxnIjoiUlMyNTYiLCJqd2siOnsia3R5IjoiUlNBIiwiZSI6IkFRQUIiLCJraWQiOiJyc2EtandrLWtpZCIsIm4iOiIzRmxxSnI1VFJza0lRSWdkRTNEZDdEOWxib1dkY1RVVDhhLWZKUjdNQXZRbTdYWE5vWWttM3Y3TVFMMU5ZdER2TDJsOENBbmMwV2RTVElOVTZJUnZjNUtxbzJRNGNzTlg5U0hPbUVmem9ST2pRcWFoRWN2ZTFqQlhsdW9DWGRZdVlweDRfMXRmUmdHNmlpNFVoeGg2aUk4cU5NSlFYLWZMZnFoYmZZZnhCUVZSUHl3QmtBYklQNHgxRUFzYkM2RlNObWtoQ3hpTU5xRWd4YUlwWThDMmtKZEpfWklWLVdXNG5vRGR6cEtxSGN3bUI4RnNydW1sVllfRE5WdlVTRElpcGlxOVBiUDRIOTlUWE4xbzc0Nm9SYU5hMDdycTFob0NnTVNTeS04NVNhZ0NveGxteUUtRC1vZjlTc01ZOE9sOXQwcmR6cG9iQnVoeUpfbzVkZnZqS3cifX0.eyJodG0iOiJQT1NUIiwiaHR1IjoiaHR0cHM6Ly9zZXJ2ZXIuZXhhbXBsZS5jb20vb2F1dGgyL3Rva2VuIiwiaWF0IjoxNzQ2ODA2MzA1LCJqdGkiOiI0YjIzNDBkMi1hOTFmLTQwYTUtYmFhOS1kZDRlNWRlYWM4NjcifQ.wq8gJ_G6vpiEinfaY3WhereqCCLoeJOG8tnWBBAzRWx9F1KU5yAAWq-ZVCk_k07-h6DIqz2wgv6y9dVbNpRYwNwDUeik9qLRsC60M8YW7EFVyI3n_NpujLwzZeub_nDYMVnyn4ii0NaZrYHtoGXOlswQfS_-ET-jpC0XWm5nBZsCdUEXjOYtwaACC6Js-pyNwKmSLp5SKIk11jZUR5xIIopaQy521y9qJHhGRwzj8DQGsP7wMZ98UFL0E--1c-hh4rTy8PMeWCqRHdwjj_ry_eTe0DJFcxxYQdeL7-0_0CIO4Ayx5WHEpcUOIzBRoN32RsNpDZc-5slDNj9ku004DA\n\ngrant_type=authorization_code\\\n&client_id=s6BhdRkqt\\\n&code=SplxlOBeZQQYbYS6WxSbIA\\\n&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\\\n&code_verifier=bEaL42izcC-o-xBk0K2vuJ6U-y1p9r_wW2dFWIWgjz-\n----\n\nThe following shows a representation of the DPoP Proof JWT header and claims:\n\n[source,json]\n----\n{\n \"typ\": \"dpop+jwt\",\n \"alg\": \"RS256\",\n \"jwk\": {\n \"kty\": \"RSA\",\n \"e\": \"AQAB\",\n \"n\": \"3FlqJr5TRskIQIgdE3Dd7D9lboWdcTUT8a-fJR7MAvQm7XXNoYkm3v7MQL1NYtDvL2l8CAnc0WdSTINU6IRvc5Kqo2Q4csNX9SHOmEfzoROjQqahEcve1jBXluoCXdYuYpx4_1tfRgG6ii4Uhxh6iI8qNMJQX-fLfqhbfYfxBQVRPywBkAbIP4x1EAsbC6FSNmkhCxiMNqEgxaIpY8C2kJdJ_ZIV-WW4noDdzpKqHcwmB8FsrumlVY_DNVvUSDIipiq9PbP4H99TXN1o746oRaNa07rq1hoCgMSSy-85SagCoxlmyE-D-of9SsMY8Ol9t0rdzpobBuhyJ_o5dfvjKw\"\n }\n}\n----\n\n[source,json]\n----\n{\n \"htm\": \"POST\",\n \"htu\": \"https://server.example.com/oauth2/token\",\n \"iat\": 1746806305,\n \"jti\": \"4b2340d2-a91f-40a5-baa9-dd4e5deac867\"\n}\n----\n\nThe following code shows an example of how to generate the DPoP Proof JWT:\n\n[source,java]\n----\nRSAKey rsaKey = ...\nJWKSource<SecurityContext> jwkSource = (jwkSelector, securityContext) -> jwkSelector\n .select(new JWKSet(rsaKey));\nNimbusJwtEncoder jwtEncoder = new NimbusJwtEncoder(jwkSource);\n\nJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n .type(\"dpop+jwt\")\n .jwk(rsaKey.toPublicJWK().toJSONObject())\n .build();\nJwtClaimsSet claims = JwtClaimsSet.builder()\n .issuedAt(Instant.now())\n .claim(\"htm\", \"POST\")\n .claim(\"htu\", \"https://server.example.com/oauth2/token\")\n .id(UUID.randomUUID().toString())\n .build();\n\nJwt dPoPProof = jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n----\n\nAfter the authorization server successfully validates the DPoP proof, the public key from the DPoP proof will be bound (sender-constrained) to the issued access token.\n\nThe following access token response shows the `token_type` parameter as `DPoP` to signal to the client that the access token was bound to its DPoP proof public key:\n\n[source,shell]\n----\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\n\n{\n \"access_token\": \"Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU\",\n \"token_type\": \"DPoP\",\n \"expires_in\": 2677\n}\n----\n\n[[oauth2AuthorizationServer-oauth2-token-endpoint-dpop-public-key-confirmation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "DPoP Access Token Request", "heading_level": 4, "file_order": 140, "section_index": 10, "content_hash": "0b8b99fedb42a02f5844d5aab9892b596ca75b5d1d3b1cf9f68048b2bae62d7d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:64f1d6014504b5930b3b853ab6b733aa677b5c2db073e8aea9db15e7e3649118", "content": "Resource servers MUST be able to identify whether an access token is DPoP-bound and verify the binding to the public key of the DPoP proof.\nThe binding is accomplished by associating the public key with the access token in a way that can be accessed by the resource server, such as embedding the public key hash in the access token directly (JWT) or through token introspection.\n\nWhen an access token is represented as a JWT, the public key hash is contained in the `jkt` claim under the confirmation method (`cnf`) claim.\n\nThe following example shows the claims of a JWT access token containing a `cnf` claim with a `jkt` claim, which is the JWK SHA-256 Thumbprint of the DPoP proof public key:\n\n[source,json]\n----\n{\n \"sub\":\"user@example.com\",\n \"iss\":\"https://server.example.com\",\n \"nbf\":1562262611,\n \"exp\":1562266216,\n \"cnf\":\n {\n \"jkt\":\"CQMknzRoZ5YUi7vS58jck1q8TmZT8wiIiXrCN1Ny4VU\"\n }\n}\n----\n\n[[oauth2AuthorizationServer-oauth2-token-introspection-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "Public Key Confirmation", "heading_level": 4, "file_order": 140, "section_index": 11, "content_hash": "64f1d6014504b5930b3b853ab6b733aa677b5c2db073e8aea9db15e7e3649118", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:994b9cc220449c6532d616ba3d43aac86fcb61333aa7ae82e0b9cebf2ca775fa", "content": "`OAuth2TokenIntrospectionEndpointConfigurer` provides the ability to customize the https://datatracker.ietf.org/doc/html/rfc7662#section-2[OAuth2 Token Introspection endpoint].\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for https://datatracker.ietf.org/doc/html/rfc7662#section-2.1[OAuth2 introspection requests].\n\n`OAuth2TokenIntrospectionEndpointConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .tokenIntrospectionEndpoint(tokenIntrospectionEndpoint ->\n tokenIntrospectionEndpoint\n .introspectionRequestConverter(introspectionRequestConverter) <1>\n .introspectionRequestConverters(introspectionRequestConvertersConsumer) <2>\n .authenticationProvider(authenticationProvider) <3>\n .authenticationProviders(authenticationProvidersConsumer) <4>\n .introspectionResponseHandler(introspectionResponseHandler) <5>\n .errorResponseHandler(errorResponseHandler) <6>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `introspectionRequestConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract an https://datatracker.ietf.org/doc/html/rfc7662#section-2.1[OAuth2 introspection request] from `HttpServletRequest` to an instance of `OAuth2TokenIntrospectionAuthenticationToken`.\n<2> `introspectionRequestConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OAuth2TokenIntrospectionAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `introspectionResponseHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling an \"`authenticated`\" `OAuth2TokenIntrospectionAuthenticationToken` and returning the https://datatracker.ietf.org/doc/html/rfc7662#section-2.2[OAuth2TokenIntrospection response].\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling an `OAuth2AuthenticationException` and returning the https://datatracker.ietf.org/doc/html/rfc7662#section-2.3[OAuth2Error response].\n\n`OAuth2TokenIntrospectionEndpointConfigurer` configures the `OAuth2TokenIntrospectionEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OAuth2TokenIntrospectionEndpointFilter` is the `Filter` that processes OAuth2 introspection requests.\n\n`OAuth2TokenIntrospectionEndpointFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- An `OAuth2TokenIntrospectionAuthenticationConverter`.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `OAuth2TokenIntrospectionAuthenticationProvider`.\n* `*AuthenticationSuccessHandler*` -- An internal implementation that handles an \"`authenticated`\" `OAuth2TokenIntrospectionAuthenticationToken` and returns the `OAuth2TokenIntrospection` response.\n* `*AuthenticationFailureHandler*` -- An `OAuth2ErrorAuthenticationFailureHandler`.\n\n[[oauth2AuthorizationServer-oauth2-token-revocation-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OAuth2 Token Introspection Endpoint", "heading_level": 2, "file_order": 140, "section_index": 12, "content_hash": "994b9cc220449c6532d616ba3d43aac86fcb61333aa7ae82e0b9cebf2ca775fa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:62db49797f5922186d6af26b751ad416918e1e816dfe65f472f223483c7943aa", "content": "`OAuth2TokenRevocationEndpointConfigurer` provides the ability to customize the https://datatracker.ietf.org/doc/html/rfc7009#section-2[OAuth2 Token Revocation endpoint].\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for https://datatracker.ietf.org/doc/html/rfc7009#section-2.1[OAuth2 revocation requests].\n\n`OAuth2TokenRevocationEndpointConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .tokenRevocationEndpoint(tokenRevocationEndpoint ->\n tokenRevocationEndpoint\n .revocationRequestConverter(revocationRequestConverter) <1>\n .revocationRequestConverters(revocationRequestConvertersConsumer) <2>\n .authenticationProvider(authenticationProvider) <3>\n .authenticationProviders(authenticationProvidersConsumer) <4>\n .revocationResponseHandler(revocationResponseHandler) <5>\n .errorResponseHandler(errorResponseHandler) <6>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `revocationRequestConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract an https://datatracker.ietf.org/doc/html/rfc7009#section-2.1[OAuth2 revocation request] from `HttpServletRequest` to an instance of `OAuth2TokenRevocationAuthenticationToken`.\n<2> `revocationRequestConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OAuth2TokenRevocationAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `revocationResponseHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling an \"`authenticated`\" `OAuth2TokenRevocationAuthenticationToken` and returning the https://datatracker.ietf.org/doc/html/rfc7009#section-2.2[OAuth2 revocation response].\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling an `OAuth2AuthenticationException` and returning the https://datatracker.ietf.org/doc/html/rfc7009#section-2.2.1[OAuth2Error response].\n\n`OAuth2TokenRevocationEndpointConfigurer` configures the `OAuth2TokenRevocationEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OAuth2TokenRevocationEndpointFilter` is the `Filter` that processes OAuth2 revocation requests.\n\n`OAuth2TokenRevocationEndpointFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- An `OAuth2TokenRevocationAuthenticationConverter`.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `OAuth2TokenRevocationAuthenticationProvider`.\n* `*AuthenticationSuccessHandler*` -- An internal implementation that handles an \"`authenticated`\" `OAuth2TokenRevocationAuthenticationToken` and returns the OAuth2 revocation response.\n* `*AuthenticationFailureHandler*` -- An `OAuth2ErrorAuthenticationFailureHandler`.\n\n[[oauth2AuthorizationServer-oauth2-client-registration-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OAuth2 Token Revocation Endpoint", "heading_level": 2, "file_order": 140, "section_index": 13, "content_hash": "62db49797f5922186d6af26b751ad416918e1e816dfe65f472f223483c7943aa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:c29e4ec588233d3146c7952bc6cd3d7fdb2daf72197392a892483e5c5b31c3f6", "content": "`OAuth2ClientRegistrationEndpointConfigurer` provides the ability to customize the https://datatracker.ietf.org/doc/html/rfc7591#section-3[OAuth2 Client Registration endpoint].\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for https://datatracker.ietf.org/doc/html/rfc7591#section-3.1[Client Registration requests].\n\n`OAuth2ClientRegistrationEndpointConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .clientRegistrationEndpoint(clientRegistrationEndpoint ->\n clientRegistrationEndpoint\n .clientRegistrationRequestConverter(clientRegistrationRequestConverter) <1>\n .clientRegistrationRequestConverters(clientRegistrationRequestConvertersConsumer) <2>\n .authenticationProvider(authenticationProvider) <3>\n .authenticationProviders(authenticationProvidersConsumer) <4>\n .clientRegistrationResponseHandler(clientRegistrationResponseHandler) <5>\n .errorResponseHandler(errorResponseHandler) <6>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `clientRegistrationRequestConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract a https://datatracker.ietf.org/doc/html/rfc7591#section-3.1[Client Registration request] from `HttpServletRequest` to an instance of `OAuth2ClientRegistrationAuthenticationToken`.\n<2> `clientRegistrationRequestConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OAuth2ClientRegistrationAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `clientRegistrationResponseHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling an \"`authenticated`\" `OAuth2ClientRegistrationAuthenticationToken` and returning the https://datatracker.ietf.org/doc/html/rfc7591#section-3.2.1[Client Registration response].\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling an `OAuth2AuthenticationException` and returning the https://datatracker.ietf.org/doc/html/rfc7591#section-3.2.2[Client Registration Error response].\n\n[NOTE]\nThe OAuth2 Client Registration endpoint is disabled by default.\n\n`OAuth2ClientRegistrationEndpointConfigurer` configures the `OAuth2ClientRegistrationEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OAuth2ClientRegistrationEndpointFilter` is the `Filter` that processes https://datatracker.ietf.org/doc/html/rfc7591#section-3.1[Client Registration requests] and returns the https://datatracker.ietf.org/doc/html/rfc7591#section-3.2.1[OAuth2ClientRegistration response].\n\n`OAuth2ClientRegistrationEndpointFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- An `OAuth2ClientRegistrationAuthenticationConverter`.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `OAuth2ClientRegistrationAuthenticationProvider`.\n* `*AuthenticationSuccessHandler*` -- An internal implementation that handles an \"`authenticated`\" `OAuth2ClientRegistrationAuthenticationToken` and returns the `OAuth2ClientRegistration` response.\n* `*AuthenticationFailureHandler*` -- An internal implementation that uses the `OAuth2Error` associated with the `OAuth2AuthenticationException` and returns the `OAuth2Error` response.\n\nThe OAuth2 Client Registration endpoint is an https://datatracker.ietf.org/doc/html/rfc7591#section-3[OAuth2 protected resource], which *REQUIRES* an access token to be sent as a bearer token in the Client Registration request.\n\n[NOTE]\nOAuth2 resource server support is autoconfigured, however, a `JwtDecoder` `@Bean` is *REQUIRED* for the OAuth2 Client Registration endpoint.\n\n[IMPORTANT]\nThe access token in a Client Registration request *REQUIRES* the OAuth2 scope `client.create`.\n\n[TIP]\nTo allow open client registration (no access token in request), configure `OAuth2ClientRegistrationAuthenticationProvider.setOpenRegistrationAllowed(true)`.\n\n[[oauth2AuthorizationServer-oauth2-authorization-server-metadata-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OAuth2 Client Registration Endpoint", "heading_level": 2, "file_order": 140, "section_index": 14, "content_hash": "c29e4ec588233d3146c7952bc6cd3d7fdb2daf72197392a892483e5c5b31c3f6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:612af698bb187b6ff1ccc05a4d417159c36326ccdc6858996a1bf6bce744b80b", "content": "`OAuth2AuthorizationServerMetadataEndpointConfigurer` provides the ability to customize the https://datatracker.ietf.org/doc/html/rfc8414#section-3[OAuth2 Authorization Server Metadata endpoint].\nIt defines an extension point that lets you customize the https://datatracker.ietf.org/doc/html/rfc8414#section-3.2[OAuth2 Authorization Server Metadata response].\n\n`OAuth2AuthorizationServerMetadataEndpointConfigurer` provides the following configuration option:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .authorizationServerMetadataEndpoint(authorizationServerMetadataEndpoint ->\n authorizationServerMetadataEndpoint\n .authorizationServerMetadataCustomizer(authorizationServerMetadataCustomizer) <1>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `authorizationServerMetadataCustomizer()`: The `Consumer` providing access to the `OAuth2AuthorizationServerMetadata.Builder` allowing the ability to customize the claims of the Authorization Server's configuration.\n\n`OAuth2AuthorizationServerMetadataEndpointConfigurer` configures the `OAuth2AuthorizationServerMetadataEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OAuth2AuthorizationServerMetadataEndpointFilter` is the `Filter` that returns the https://datatracker.ietf.org/doc/html/rfc8414#section-3.2[OAuth2AuthorizationServerMetadata response].\n\n[[oauth2AuthorizationServer-jwk-set-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OAuth2 Authorization Server Metadata Endpoint", "heading_level": 2, "file_order": 140, "section_index": 15, "content_hash": "612af698bb187b6ff1ccc05a4d417159c36326ccdc6858996a1bf6bce744b80b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:c4b025bada33bcdc00b96facfd2458b194effff7aa6e27a970fae7333a352d99", "content": "`OAuth2AuthorizationServerConfigurer` provides support for the https://datatracker.ietf.org/doc/html/rfc7517[JWK Set endpoint].\n\n`OAuth2AuthorizationServerConfigurer` configures the `NimbusJwkSetEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`NimbusJwkSetEndpointFilter` is the `Filter` that returns the https://datatracker.ietf.org/doc/html/rfc7517#section-5[JWK Set].\n\n[NOTE]\nThe JWK Set endpoint is configured *only* if a `JWKSource<SecurityContext>` `@Bean` is registered.\n\n[[oauth2AuthorizationServer-oidc-provider-configuration-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "JWK Set Endpoint", "heading_level": 2, "file_order": 140, "section_index": 16, "content_hash": "c4b025bada33bcdc00b96facfd2458b194effff7aa6e27a970fae7333a352d99", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:99376837453721b46fb7e6b88c6fe4db3e470b6d618f2aaea7138fe2729c56d2", "content": "`OidcProviderConfigurationEndpointConfigurer` provides the ability to customize the https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[OpenID Connect 1.0 Provider Configuration endpoint].\nIt defines an extension point that lets you customize the https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse[OpenID Provider Configuration response].\n\n`OidcProviderConfigurationEndpointConfigurer` provides the following configuration option:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .oidc(oidc ->\n oidc\n .providerConfigurationEndpoint(providerConfigurationEndpoint ->\n providerConfigurationEndpoint\n .providerConfigurationCustomizer(providerConfigurationCustomizer) <1>\n )\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `providerConfigurationCustomizer()`: The `Consumer` providing access to the `OidcProviderConfiguration.Builder` allowing the ability to customize the claims of the OpenID Provider's configuration.\n\n`OidcProviderConfigurationEndpointConfigurer` configures the `OidcProviderConfigurationEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OidcProviderConfigurationEndpointFilter` is the `Filter` that returns the https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse[OidcProviderConfiguration response].\n\n[[oauth2AuthorizationServer-oidc-logout-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OpenID Connect 1.0 Provider Configuration Endpoint", "heading_level": 2, "file_order": 140, "section_index": 17, "content_hash": "99376837453721b46fb7e6b88c6fe4db3e470b6d618f2aaea7138fe2729c56d2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:4358f68b1f57fb5ac7202b027be85882f790ee441ba60401e6bf1ccd1e03cd48", "content": "`OidcLogoutEndpointConfigurer` provides the ability to customize the https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout[OpenID Connect 1.0 Logout endpoint].\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for RP-Initiated Logout requests.\n\n`OidcLogoutEndpointConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .oidc(oidc ->\n oidc\n .logoutEndpoint(logoutEndpoint ->\n logoutEndpoint\n .logoutRequestConverter(logoutRequestConverter) <1>\n .logoutRequestConverters(logoutRequestConvertersConsumer) <2>\n .authenticationProvider(authenticationProvider) <3>\n .authenticationProviders(authenticationProvidersConsumer) <4>\n .logoutResponseHandler(logoutResponseHandler) <5>\n .errorResponseHandler(errorResponseHandler) <6>\n )\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `logoutRequestConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract a https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout[Logout request] from `HttpServletRequest` to an instance of `OidcLogoutAuthenticationToken`.\n<2> `logoutRequestConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OidcLogoutAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `logoutResponseHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling an \"`authenticated`\" `OidcLogoutAuthenticationToken` and performing the logout.\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling an `OAuth2AuthenticationException` and returning the error response.\n\n`OidcLogoutEndpointConfigurer` configures the `OidcLogoutEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OidcLogoutEndpointFilter` is the `Filter` that processes https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout[RP-Initiated Logout requests] and performs the logout of the End-User.\n\n`OidcLogoutEndpointFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- An `OidcLogoutAuthenticationConverter`.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `OidcLogoutAuthenticationProvider`.\n* `*AuthenticationSuccessHandler*` -- An `OidcLogoutAuthenticationSuccessHandler`.\n* `*AuthenticationFailureHandler*` -- An internal implementation that uses the `OAuth2Error` associated with the `OAuth2AuthenticationException` and returns the `OAuth2Error` response.\n\n[NOTE]\n`OidcLogoutAuthenticationProvider` uses a xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-session-registry[`SessionRegistry`] to look up the `SessionInformation` instance associated to the End-User requesting to be logged out.\n\n[TIP]\n`OidcClientInitiatedLogoutSuccessHandler` is the corresponding configuration in Spring Securitys OAuth2 Client support for configuring xref:servlet/oauth2/login/advanced.adoc#oauth2login-advanced-oidc-logout[OpenID Connect 1.0 RP-Initiated Logout].\n\n[[oauth2AuthorizationServer-oidc-logout-endpoint-customizing-logout-request-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OpenID Connect 1.0 Logout Endpoint", "heading_level": 2, "file_order": 140, "section_index": 18, "content_hash": "4358f68b1f57fb5ac7202b027be85882f790ee441ba60401e6bf1ccd1e03cd48", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:37842e110640efd55826f783d223cbbb2c207206c5ddadc9ef7e0b0fe040ac6c", "content": "`OidcLogoutAuthenticationValidator` is the default validator used for validating specific OpenID Connect RP-Initiated Logout Request parameters.\nThe default implementation validates the `post_logout_redirect_uri` parameter.\nIf validation fails, an `OAuth2AuthenticationException` is thrown.\n\n`OidcLogoutAuthenticationProvider` provides the ability to override the default logout request validation by supplying a custom authentication validator of type `Consumer<OidcLogoutAuthenticationContext>` to `setAuthenticationValidator()`.\n\n[TIP]\n`OidcLogoutAuthenticationContext` holds the `OidcLogoutAuthenticationToken`, which contains the logout request parameters.\n\n[IMPORTANT]\nIf validation fails, the authentication validator *MUST* throw `OAuth2AuthenticationException`.\n\nThe following example shows how to configure `OidcLogoutAuthenticationProvider` with a custom authentication validator:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .oidc(oidc ->\n oidc\n .logoutEndpoint(logoutEndpoint ->\n logoutEndpoint\n .authenticationProviders(configureAuthenticationValidator())\n )\n )\n );\n\n\treturn http.build();\n}\n\nprivate Consumer<List<AuthenticationProvider>> configureAuthenticationValidator() {\n\treturn (authenticationProviders) ->\n authenticationProviders.forEach((authenticationProvider) -> {\n if (authenticationProvider instanceof OidcLogoutAuthenticationProvider oidcLogoutAuthenticationProvider) {\n Consumer<OidcLogoutAuthenticationContext> authenticationValidator = new CustomPostLogoutRedirectUriValidator();\n oidcLogoutAuthenticationProvider.setAuthenticationValidator(authenticationValidator);\n }\n });\n}\n\nstatic class CustomPostLogoutRedirectUriValidator implements Consumer<OidcLogoutAuthenticationContext> {\n\n\t@Override\n\tpublic void accept(OidcLogoutAuthenticationContext authenticationContext) {\n OidcLogoutAuthenticationToken oidcLogoutAuthentication =\n authenticationContext.getAuthentication();\n RegisteredClient registeredClient = authenticationContext.getRegisteredClient();\n\n // TODO\n\n\t}\n}\n----\n\n[[oauth2AuthorizationServer-oidc-user-info-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "Customizing Logout Request Validation", "heading_level": 3, "file_order": 140, "section_index": 19, "content_hash": "37842e110640efd55826f783d223cbbb2c207206c5ddadc9ef7e0b0fe040ac6c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:5ca940ed3fe1c27d24a78029c84a9ba9bc3feb8a8e3df5de90c6dba3c4f66243", "content": "`OidcUserInfoEndpointConfigurer` provides the ability to customize the https://openid.net/specs/openid-connect-core-1_0.html#UserInfo[OpenID Connect 1.0 UserInfo endpoint].\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for https://openid.net/specs/openid-connect-core-1_0.html#UserInfoRequest[UserInfo requests].\n\n`OidcUserInfoEndpointConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .oidc(oidc ->\n oidc\n .userInfoEndpoint(userInfoEndpoint ->\n userInfoEndpoint\n .userInfoRequestConverter(userInfoRequestConverter) <1>\n .userInfoRequestConverters(userInfoRequestConvertersConsumer) <2>\n .authenticationProvider(authenticationProvider) <3>\n .authenticationProviders(authenticationProvidersConsumer) <4>\n .userInfoResponseHandler(userInfoResponseHandler) <5>\n .errorResponseHandler(errorResponseHandler) <6>\n .userInfoMapper(userInfoMapper) <7>\n )\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `userInfoRequestConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract an https://openid.net/specs/openid-connect-core-1_0.html#UserInfoRequest[UserInfo request] from `HttpServletRequest` to an instance of `OidcUserInfoAuthenticationToken`.\n<2> `userInfoRequestConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OidcUserInfoAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `userInfoResponseHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling an \"`authenticated`\" `OidcUserInfoAuthenticationToken` and returning the https://openid.net/specs/openid-connect-core-1_0.html#UserInfoResponse[UserInfo response].\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling an `OAuth2AuthenticationException` and returning the https://openid.net/specs/openid-connect-core-1_0.html#UserInfoError[UserInfo Error response].\n<7> `userInfoMapper()`: The `Function` used to extract claims from `OidcUserInfoAuthenticationContext` to an instance of `OidcUserInfo`.\n\n`OidcUserInfoEndpointConfigurer` configures the `OidcUserInfoEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OidcUserInfoEndpointFilter` is the `Filter` that processes https://openid.net/specs/openid-connect-core-1_0.html#UserInfoRequest[UserInfo requests] and returns the https://openid.net/specs/openid-connect-core-1_0.html#UserInfoResponse[OidcUserInfo response].\n\n`OidcUserInfoEndpointFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- An internal implementation that obtains the `Authentication` from the `SecurityContext` and creates an `OidcUserInfoAuthenticationToken` with the principal.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `OidcUserInfoAuthenticationProvider`, which is associated with an internal implementation of `userInfoMapper` that extracts https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims[standard claims] from the https://openid.net/specs/openid-connect-core-1_0.html#IDToken[ID Token] based on the https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims[scopes requested] during authorization.\n* `*AuthenticationSuccessHandler*` -- An internal implementation that handles an \"`authenticated`\" `OidcUserInfoAuthenticationToken` and returns the `OidcUserInfo` response.\n* `*AuthenticationFailureHandler*` -- An internal implementation that uses the `OAuth2Error` associated with the `OAuth2AuthenticationException` and returns the `OAuth2Error` response.\n\n[TIP]\nYou can customize the ID Token by providing an xref:servlet/oauth2/authorization-server/core-model-components.adoc#oauth2AuthorizationServer-oauth2-token-customizer[`OAuth2TokenCustomizer<JwtEncodingContext>`] `@Bean`.\n\nThe OpenID Connect 1.0 UserInfo endpoint is an OAuth2 protected resource, which *REQUIRES* an access token to be sent as a bearer token in the https://openid.net/specs/openid-connect-core-1_0.html#UserInfoRequest[UserInfo request].\n\n[NOTE]\nOAuth2 resource server support is autoconfigured, however, a `JwtDecoder` `@Bean` is *REQUIRED* for the OpenID Connect 1.0 UserInfo endpoint.\n\n[[oauth2AuthorizationServer-oidc-client-registration-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OpenID Connect 1.0 UserInfo Endpoint", "heading_level": 2, "file_order": 140, "section_index": 20, "content_hash": "5ca940ed3fe1c27d24a78029c84a9ba9bc3feb8a8e3df5de90c6dba3c4f66243", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:798f037745280076aa5c8efbdda75caf56e56cc7dd3b1e5cc8a5cb84a613f4b3", "content": "`OidcClientRegistrationEndpointConfigurer` provides the ability to customize the https://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration[OpenID Connect 1.0 Client Registration endpoint].\nIt defines extension points that let you customize the pre-processing, main processing, and post-processing logic for https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationRequest[Client Registration requests] or https://openid.net/specs/openid-connect-registration-1_0.html#ReadRequest[Client Read requests].\n\n`OidcClientRegistrationEndpointConfigurer` provides the following configuration options:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2AuthorizationServer((authorizationServer) ->\n authorizationServer\n .oidc(oidc ->\n oidc\n .clientRegistrationEndpoint(clientRegistrationEndpoint ->\n clientRegistrationEndpoint\n .clientRegistrationRequestConverter(clientRegistrationRequestConverter) <1>\n .clientRegistrationRequestConverters(clientRegistrationRequestConvertersConsumers) <2>\n .authenticationProvider(authenticationProvider) <3>\n .authenticationProviders(authenticationProvidersConsumer) <4>\n .clientRegistrationResponseHandler(clientRegistrationResponseHandler) <5>\n .errorResponseHandler(errorResponseHandler) <6>\n )\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `clientRegistrationRequestConverter()`: Adds an `AuthenticationConverter` (_pre-processor_) used when attempting to extract a https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationRequest[Client Registration request] or https://openid.net/specs/openid-connect-registration-1_0.html#ReadRequest[Client Read request] from `HttpServletRequest` to an instance of `OidcClientRegistrationAuthenticationToken`.\n<2> `clientRegistrationRequestConverters()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationConverter``'s allowing the ability to add, remove, or customize a specific `AuthenticationConverter`.\n<3> `authenticationProvider()`: Adds an `AuthenticationProvider` (_main processor_) used for authenticating the `OidcClientRegistrationAuthenticationToken`.\n<4> `authenticationProviders()`: Sets the `Consumer` providing access to the `List` of default and (optionally) added ``AuthenticationProvider``'s allowing the ability to add, remove, or customize a specific `AuthenticationProvider`.\n<5> `clientRegistrationResponseHandler()`: The `AuthenticationSuccessHandler` (_post-processor_) used for handling an \"`authenticated`\" `OidcClientRegistrationAuthenticationToken` and returning the https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationResponse[Client Registration response] or https://openid.net/specs/openid-connect-registration-1_0.html#ReadResponse[Client Read response].\n<6> `errorResponseHandler()`: The `AuthenticationFailureHandler` (_post-processor_) used for handling an `OAuth2AuthenticationException` and returning the https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationError[Client Registration Error response] or https://openid.net/specs/openid-connect-registration-1_0.html#ReadError[Client Read Error response].\n\n[NOTE]\nThe OpenID Connect 1.0 Client Registration endpoint is disabled by default.\n\n`OidcClientRegistrationEndpointConfigurer` configures the `OidcClientRegistrationEndpointFilter` and registers it with the OAuth2 authorization server `SecurityFilterChain` `@Bean`.\n`OidcClientRegistrationEndpointFilter` is the `Filter` that processes https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationRequest[Client Registration requests] and returns the https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationResponse[OidcClientRegistration response].\n\n[TIP]\n`OidcClientRegistrationEndpointFilter` also processes https://openid.net/specs/openid-connect-registration-1_0.html#ReadRequest[Client Read requests] and returns the https://openid.net/specs/openid-connect-registration-1_0.html#ReadResponse[OidcClientRegistration response].\n\n`OidcClientRegistrationEndpointFilter` is configured with the following defaults:\n\n* `*AuthenticationConverter*` -- An `OidcClientRegistrationAuthenticationConverter`.\n* `*AuthenticationManager*` -- An `AuthenticationManager` composed of `OidcClientRegistrationAuthenticationProvider` and `OidcClientConfigurationAuthenticationProvider`.\n* `*AuthenticationSuccessHandler*` -- An internal implementation that handles an \"`authenticated`\" `OidcClientRegistrationAuthenticationToken` and returns the `OidcClientRegistration` response.\n* `*AuthenticationFailureHandler*` -- An internal implementation that uses the `OAuth2Error` associated with the `OAuth2AuthenticationException` and returns the `OAuth2Error` response.\n\nThe OpenID Connect 1.0 Client Registration endpoint is an https://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration[OAuth2 protected resource], which *REQUIRES* an access token to be sent as a bearer token in the Client Registration (or Client Read) request.\n\n[NOTE]\nOAuth2 resource server support is autoconfigured, however, a `JwtDecoder` `@Bean` is *REQUIRED* for the OpenID Connect 1.0 Client Registration endpoint.\n\n[IMPORTANT]\nThe access token in a Client Registration request *REQUIRES* the OAuth2 scope `client.create`.\n\n[IMPORTANT]\nThe access token in a Client Read request *REQUIRES* the OAuth2 scope `client.read`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc", "title": "protocol-endpoints", "heading": "OpenID Connect 1.0 Client Registration Endpoint", "heading_level": 2, "file_order": 140, "section_index": 21, "content_hash": "798f037745280076aa5c8efbdda75caf56e56cc7dd3b1e5cc8a5cb84a613f4b3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/authorization-server/protocol-endpoints.adoc"}}
{"id": "sha256:62022b1ecb1fe7903cd93ff8302825e5606d74ce262ed35ce2cf7e770406e118", "content": "[[oauth2-client-authorization-grants]]\n\nThis section describes Spring Security's support for authorization grants.\n\n[[oauth2-client-authorization-code]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "authorization-grants", "heading_level": 1, "file_order": 141, "section_index": 0, "content_hash": "62022b1ecb1fe7903cd93ff8302825e5606d74ce262ed35ce2cf7e770406e118", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:85580e6a8b5108a80cdaafb6d7f712ff1d8e31f5dd31a2c940486e7ea6828bea", "content": "[NOTE]\n====\nSee the OAuth 2.0 Authorization Framework for further details on the https://tools.ietf.org/html/rfc6749#section-1.3.1[Authorization Code] grant.\n====\n\n[[oauth2-client-authorization-code-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "[[oauth2Client-auth-code-grant]]Authorization Code", "heading_level": 2, "file_order": 141, "section_index": 1, "content_hash": "85580e6a8b5108a80cdaafb6d7f712ff1d8e31f5dd31a2c940486e7ea6828bea", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:78c9c41b5210f4a10d9a0c0d2367a7ef02fcb61e432efc007bd030b23970eedc", "content": "[NOTE]\n====\nSee the https://tools.ietf.org/html/rfc6749#section-4.1.1[Authorization Request/Response] protocol flow for the Authorization Code grant.\n====\n\n[[oauth2-client-authorization-code-authorization-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Obtaining Authorization", "heading_level": 3, "file_order": 141, "section_index": 2, "content_hash": "78c9c41b5210f4a10d9a0c0d2367a7ef02fcb61e432efc007bd030b23970eedc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:c58d6295c59e8eab13101fdd34a42768a66797b1c97d47027c4748ee6efd043b", "content": "The `OAuth2AuthorizationRequestRedirectFilter` uses an `OAuth2AuthorizationRequestResolver` to resolve an `OAuth2AuthorizationRequest` and initiate the Authorization Code grant flow by redirecting the end-user's user-agent to the Authorization Server's Authorization Endpoint.\n\nThe primary role of the `OAuth2AuthorizationRequestResolver` is to resolve an `OAuth2AuthorizationRequest` from the provided web request.\nThe default implementation `DefaultOAuth2AuthorizationRequestResolver` matches on the (default) path `+/oauth2/authorization/{registrationId}+`, extracting the `registrationId`, and using it to build the `OAuth2AuthorizationRequest` for the associated `ClientRegistration`.\n\nConsider the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml,attrs=\"-attributes\"]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n authorization-grant-type: authorization_code\n redirect-uri: \"{baseUrl}/authorized/okta\"\n scope: read, write\n provider:\n okta:\n authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize\n token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token\n----\n\nGiven the preceding properties, a request with the base path `/oauth2/authorization/okta` initiates the Authorization Request redirect by the `OAuth2AuthorizationRequestRedirectFilter` and ultimately starts the Authorization Code grant flow.\n\n[NOTE]\n====\nThe `AuthorizationCodeOAuth2AuthorizedClientProvider` is an implementation of `OAuth2AuthorizedClientProvider` for the Authorization Code grant,\nwhich also initiates the Authorization Request redirect by the `OAuth2AuthorizationRequestRedirectFilter`.\n====\n\nIf the OAuth 2.0 Client is a https://tools.ietf.org/html/rfc6749#section-2.1[Public Client], configure the OAuth 2.0 Client registration as follows:\n\n[source,yaml,attrs=\"-attributes\"]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-authentication-method: none\n authorization-grant-type: authorization_code\n redirect-uri: \"{baseUrl}/authorized/okta\"\n # ...\n----\n\nPublic Clients are supported by using https://tools.ietf.org/html/rfc7636[Proof Key for Code Exchange] (PKCE).\nIf the client is running in an untrusted environment (such as a native application or web browser-based application) and is therefore incapable of maintaining the confidentiality of its credentials, PKCE is automatically used when the following conditions are true:\n\n. `client-secret` is omitted (or empty)\n. `client-authentication-method` is set to `none` (`ClientAuthenticationMethod.NONE`)\n\nor\n\n. When `ClientRegistration.clientSettings.requireProofKey` is `true` (in this case `ClientRegistration.authorizationGrantType` must be `authorization_code`)\n\n[TIP]\n====\nIf the OAuth 2.0 Provider doesn't support PKCE for https://tools.ietf.org/html/rfc6749#section-2.1[Confidential Clients], you need to disable it by setting `ClientRegistration.clientSettings.requireProofKey` to `false`.\n====\n\n[[oauth2-client-authorization-code-redirect-uri]]\n[[oauth2Client-auth-code-redirect-uri]]The `DefaultOAuth2AuthorizationRequestResolver` also supports `URI` template variables for the `redirect-uri` by using `UriComponentsBuilder`.\n\nThe following configuration uses all the supported `URI` template variables:\n\n[source,yaml,attrs=\"-attributes\"]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n # ...\n redirect-uri: \"{baseScheme}://{baseHost}{basePort}{basePath}/authorized/{registrationId}\"\n # ...\n----\n\n[NOTE]\n====\n`+{baseUrl}+` resolves to `+{baseScheme}://{baseHost}{basePort}{basePath}+`\n====\n\nConfiguring the `redirect-uri` with `URI` template variables is especially useful when the OAuth 2.0 Client is running behind a xref:features/exploits/http.adoc#http-proxy-server[Proxy Server].\nDoing so ensures that the `X-Forwarded-*` headers are used when expanding the `redirect-uri`.\n\n[[oauth2-client-authorization-code-authorization-request-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Initiating the Authorization Request", "heading_level": 3, "file_order": 141, "section_index": 3, "content_hash": "c58d6295c59e8eab13101fdd34a42768a66797b1c97d47027c4748ee6efd043b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:1caa95f95a5f0586b272105be4edbb0c3c216d24909b8a7d8df4d3264dc06df8", "content": "One of the primary use cases an `OAuth2AuthorizationRequestResolver` can realize is the ability to customize the Authorization Request with additional parameters above the standard parameters defined in the OAuth 2.0 Authorization Framework.\n\nFor example, OpenID Connect defines additional OAuth 2.0 request parameters for the https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest[Authorization Code Flow] extending from the standard parameters defined in the https://tools.ietf.org/html/rfc6749#section-4.1.1[OAuth 2.0 Authorization Framework].\nOne of those extended parameters is the `prompt` parameter.\n\n[NOTE]\n====\nThe `prompt` parameter is optional. Space delimited, case sensitive list of ASCII string values that specifies whether the Authorization Server prompts the End-User for re-authentication and consent. The defined values are: `none`, `login`, `consent`, and `select_account`.\n====\n\nThe following example shows how to configure the `DefaultOAuth2AuthorizationRequestResolver` with a `Consumer<OAuth2AuthorizationRequest.Builder>` that customizes the Authorization Request for `oauth2Login()`, by including the request parameter `prompt=consent`.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Autowired\n\tprivate ClientRegistrationRepository clientRegistrationRepository;\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2Login((oauth2) -> oauth2\n .authorizationEndpoint((authorization) -> authorization\n .authorizationRequestResolver(\n authorizationRequestResolver(this.clientRegistrationRepository)\n )\n )\n );\n return http.build();\n\t}\n\n\tprivate OAuth2AuthorizationRequestResolver authorizationRequestResolver(\n ClientRegistrationRepository clientRegistrationRepository) {\n\n DefaultOAuth2AuthorizationRequestResolver authorizationRequestResolver =\n new DefaultOAuth2AuthorizationRequestResolver(\n clientRegistrationRepository, \"/oauth2/authorization\");\n authorizationRequestResolver.setAuthorizationRequestCustomizer(\n authorizationRequestCustomizer());\n\n return authorizationRequestResolver;\n\t}\n\n\tprivate Consumer<OAuth2AuthorizationRequest.Builder> authorizationRequestCustomizer() {\n return customizer -> customizer\n .additionalParameters((params) -> params.put(\"prompt\", \"consent\"));\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Autowired\n private lateinit var customClientRegistrationRepository: ClientRegistrationRepository\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2Login {\n authorizationEndpoint {\n authorizationRequestResolver = authorizationRequestResolver(customClientRegistrationRepository)\n }\n }\n }\n return http.build()\n }\n\n private fun authorizationRequestResolver(\n clientRegistrationRepository: ClientRegistrationRepository?): OAuth2AuthorizationRequestResolver {\n val authorizationRequestResolver = DefaultOAuth2AuthorizationRequestResolver(\n clientRegistrationRepository, \"/oauth2/authorization\")\n authorizationRequestResolver.setAuthorizationRequestCustomizer(\n authorizationRequestCustomizer())\n return authorizationRequestResolver\n }\n\n private fun authorizationRequestCustomizer(): Consumer<OAuth2AuthorizationRequest.Builder> {\n return Consumer { customizer ->\n customizer\n .additionalParameters { params -> params[\"prompt\"] = \"consent\" }\n }\n }\n}\n----\n======\n\nFor the simple use case where the additional request parameter is always the same for a specific provider, you can add it directly in the `authorization-uri` property.\n\nFor example, if the value for the request parameter `prompt` is always `consent` for the provider `okta`, you can configure it as follows:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n provider:\n okta:\n authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize?prompt=consent\n----\n\nThe preceding example shows the common use case of adding a custom parameter on top of the standard parameters.\nAlternatively, if your requirements are more advanced, you can take full control in building the Authorization Request URI by overriding the `OAuth2AuthorizationRequest.authorizationRequestUri` property.\n\n[TIP]\n====\n`OAuth2AuthorizationRequest.Builder.build()` constructs the `OAuth2AuthorizationRequest.authorizationRequestUri`, which represents the Authorization Request URI including all query parameters using the `application/x-www-form-urlencoded` format.\n====\n\nThe following example shows a variation of `authorizationRequestCustomizer()` from the preceding example and instead overrides the `OAuth2AuthorizationRequest.authorizationRequestUri` property:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nprivate Consumer<OAuth2AuthorizationRequest.Builder> authorizationRequestCustomizer() {\n\treturn customizer -> customizer\n .authorizationRequestUri((uriBuilder) -> uriBuilder\n .queryParam(\"prompt\", \"consent\").build());\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nprivate fun authorizationRequestCustomizer(): Consumer<OAuth2AuthorizationRequest.Builder> {\n return Consumer { customizer: OAuth2AuthorizationRequest.Builder ->\n customizer\n .authorizationRequestUri { uriBuilder: UriBuilder ->\n uriBuilder\n .queryParam(\"prompt\", \"consent\").build()\n }\n }\n}\n----\n======\n\n[[oauth2-client-authorization-code-authorization-request-repository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customizing the Authorization Request", "heading_level": 3, "file_order": 141, "section_index": 4, "content_hash": "1caa95f95a5f0586b272105be4edbb0c3c216d24909b8a7d8df4d3264dc06df8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:87f6d171e91af648343b9f21ed93b72b2f95740b36289f38728de2bb1b9dad41", "content": "The `AuthorizationRequestRepository` is responsible for the persistence of the `OAuth2AuthorizationRequest` from the time the Authorization Request is initiated to the time the Authorization Response is received (the callback).\n\n[TIP]\n====\nThe `OAuth2AuthorizationRequest` is used to correlate and validate the Authorization Response.\n====\n\nThe default implementation of `AuthorizationRequestRepository` is `HttpSessionOAuth2AuthorizationRequestRepository`, which stores the `OAuth2AuthorizationRequest` in the `HttpSession`.\n\nIf you have a custom implementation of `AuthorizationRequestRepository`, you can configure it as follows:\n\n.AuthorizationRequestRepository Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2ClientSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Client((oauth2) -> oauth2\n .authorizationCodeGrant((codeGrant) -> codeGrant\n .authorizationRequestRepository(this.authorizationRequestRepository())\n // ...\n )\n )\n .oauth2Login((oauth2) -> oauth2\n .authorizationEndpoint((endpoint) -> endpoint\n .authorizationRequestRepository(this.authorizationRequestRepository())\n // ...\n )\n );\n return http.build();\n\t}\n\n @Bean\n public AuthorizationRequestRepository<OAuth2AuthorizationRequest> authorizationRequestRepository() {\n return new CustomOAuth2AuthorizationRequestRepository();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2ClientSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Client {\n authorizationCodeGrant {\n authorizationRequestRepository = authorizationRequestRepository()\n }\n }\n }\n return http.build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<oauth2-client>\n <authorization-code-grant authorization-request-repository-ref=\"authorizationRequestRepository\"/>\n\t</oauth2-client>\n</http>\n----\n======\n\n[[oauth2-client-authorization-code-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Storing the Authorization Request", "heading_level": 3, "file_order": 141, "section_index": 5, "content_hash": "87f6d171e91af648343b9f21ed93b72b2f95740b36289f38728de2bb1b9dad41", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:e4aa71f337720ad833b415b66237c6787ee222684cb9cca1584565ae5400eb91", "content": "[NOTE]\n====\nSee the https://tools.ietf.org/html/rfc6749#section-4.1.3[Access Token Request/Response] protocol flow for the Authorization Code grant.\n====\n\nThe default implementation of `OAuth2AccessTokenResponseClient` for the Authorization Code grant is `RestClientAuthorizationCodeTokenResponseClient`, which uses a `RestClient` instance to exchange an authorization code for an access token at the Authorization Servers Token Endpoint.\n\n`{class-name}` is very flexible and provides several options for customizing the OAuth 2.0 Access Token request and response for the {grant-type} grant.\nChoose from the following use cases to learn more:\n\n* I want to <<oauth2-client-{section-id}-access-token-request-headers,customize headers of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-request-parameters,customize parameters of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-response-rest-client,customize the instance of `RestClient` that is used>>\n* I want to <<oauth2-client-{section-id}-access-token-response-parameters,customize parameters of the Access Token response>>\n* I want to <<oauth2-client-{section-id}-access-token-response-errors,customize error handling of the Access Token response>>\n\n[#oauth2-client-{section-id}-access-token-request]\n== Customizing the Access Token Request\n\n`{class-name}` provides hooks for customizing HTTP headers and request parameters of the OAuth 2.0 Access Token Request.\n\n[#oauth2-client-{section-id}-access-token-request-headers]\n=== Customizing Request Headers\n\nThere are two options for customizing HTTP headers:\n\n* Add additional headers by calling `addHeadersConverter()`\n* Fully customize headers by calling `setHeadersConverter()`\n\nYou can include additional headers without affecting the default headers added to every request using `addHeadersConverter()`.\nThe following example adds a `User-Agent` header to the request when the `registrationId` is `spring`:\n\n.Include Additional HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addHeadersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tHttpHeaders headers = new HttpHeaders();\n\tif (clientRegistration.getRegistrationId().equals(\"spring\")) {\n\t\theaders.set(HttpHeaders.USER_AGENT, \"my-user-agent\");\n\t}\n\treturn headers;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addHeadersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval headers = HttpHeaders()\n\tif (clientRegistration.getRegistrationId() == \"spring\") {\n        headers[HttpHeaders.USER_AGENT] = \"my-user-agent\"\n\t}\n\theaders\n}\n----\n======\n\nYou can fully customize headers by re-using `DefaultOAuth2TokenRequestHeadersConverter` or providing a custom implementation using `setHeadersConverter()`.\nThe following example re-uses `DefaultOAuth2TokenRequestHeadersConverter` and disables `encodeClientCredentials` so that HTTP Basic credentials are no longer encoded with `application/x-www-form-urlencoded`:\n\n.Customize HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter headersConverter =\n\tnew DefaultOAuth2TokenRequestHeadersConverter();\nheadersConverter.setEncodeClientCredentials(false);\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter()\nheadersConverter.setEncodeClientCredentials(false)\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[#oauth2-client-{section-id}-access-token-request-parameters]\n=== Customizing Request Parameters\n\nThere are three options for customizing request parameters:\n\n* Add additional parameters by calling `addParametersConverter()`\n* Override parameters by calling `setParametersConverter()`\n* Fully customize parameters by calling `setParametersCustomizer()`\n\n[NOTE]\n====\nUsing `setParametersConverter()` does not fully customize parameters because it would require the user to provide all default parameters themselves.\nDefault parameters are always provided, but can be fully customized or omitted by calling `setParametersCustomizer()`.\n====\n\nYou can include additional parameters without affecting the default parameters added to every request using `addParametersConverter()`.\nThe following example adds an `audience` parameter to the request when the `registrationId` is `keycloak`:\n\n.Include Additional Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tMultiValueMap<String, String> parameters = new LinkedMultiValueMap<String, String>();\n\tif (clientRegistration.getRegistrationId().equals(\"keycloak\")) {\n\t\tparameters.set(OAuth2ParameterNames.AUDIENCE, \"my-audience\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addParametersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"keycloak\") {\n        parameters[OAuth2ParameterNames.AUDIENCE] = \"my-audience\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can override default parameters using `setParametersConverter()`.\nThe following example overrides the `client_id` parameter when the `registrationId` is `okta`:\n\n.Override Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tLinkedMultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n\tif (clientRegistration.getRegistrationId().equals(\"okta\")) {\n\t\tparameters.set(OAuth2ParameterNames.CLIENT_ID, \"my-client\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval parametersConverter = DefaultOAuth2TokenRequestParametersConverter<{grant-request}>()\nparametersConverter.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersConverter { grantRequest ->\n    val clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"okta\") {\n        parameters[OAuth2ParameterNames.CLIENT_ID] = \"my-client\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can fully customize parameters (including omitting default parameters) using `setParametersCustomizer()`.\nThe following example omits the `client_id` parameter when the `client_assertion` parameter is present in the request:\n\n.Omit Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersCustomizer(parameters -> {\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID);\n\t}\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response]\n== Customizing the Access Token Response\n\n`{class-name}` provides hooks for customizing response parameters and error handling of the OAuth 2.0 Access Token Response.\n\n[#oauth2-client-{section-id}-access-token-response-rest-client]\n=== Customizing the `RestClient`\n\nYou can customize the Token Response by providing a pre-configured `RestClient` to `setRestClient()`.\nThe default `RestClient` is configured as follows:\n\n.Default `RestClient` Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nRestClient restClient = RestClient.builder()\n\t.messageConverters(messageConverters -> {\n\t\tmessageConverters.clear();\n\t\tmessageConverters.add(new FormHttpMessageConverter());\n\t\tmessageConverters.add(new OAuth2AccessTokenResponseHttpMessageConverter());\n\t})\n\t.defaultStatusHandler(new OAuth2ErrorResponseErrorHandler())\n\t.build();\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setRestClient(restClient);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval restClient = RestClient.builder()\n\t.messageConverters { messageConverters ->\n\t\tmessageConverters.clear()\n\t\tmessageConverters.add(FormHttpMessageConverter())\n\t\tmessageConverters.add(OAuth2AccessTokenResponseHttpMessageConverter())\n\t}\n\t.defaultStatusHandler(OAuth2ErrorResponseErrorHandler())\n\t.build()\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setRestClient(restClient)\n----\n======\n\n`OAuth2AccessTokenResponseHttpMessageConverter` is an `HttpMessageConverter` for an OAuth 2.0 Access Token Response.\nYou can customize the conversion of Token Response parameters to an `OAuth2AccessTokenResponse` by calling `setAccessTokenResponseConverter()`.\nThe default implementation is `DefaultMapOAuth2AccessTokenResponseConverter`.\n\n`OAuth2ErrorResponseErrorHandler` is a `ResponseErrorHandler` that can handle an OAuth 2.0 Error, such as `400 Bad Request`.\nIt uses an `OAuth2ErrorHttpMessageConverter` for converting the OAuth 2.0 Error parameters to an `OAuth2Error`.\nYou can customize the conversion of Token Response parameters to an `OAuth2Error` by calling `setErrorConverter()`.\n\n[TIP]\n====\nSpring MVC `FormHttpMessageConverter` is required, as it is used when sending the OAuth 2.0 Access Token Request.\n====\n\n[#oauth2-client-{section-id}-access-token-response-parameters]\n=== Customizing Response Parameters\n\nThe following example provides a starting point for customizing the conversion of Token Response parameters to an `OAuth2AccessTokenResponse`:\n\n.Customize Access Token Response Converter\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2AccessTokenResponseHttpMessageConverter accessTokenResponseMessageConverter =\n\tnew OAuth2AccessTokenResponseHttpMessageConverter();\naccessTokenResponseMessageConverter.setAccessTokenResponseConverter(parameters -> {\n\t// ...\n\treturn OAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t// ...\n\t\t.build();\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval accessTokenResponseMessageConverter = OAuth2AccessTokenResponseHttpMessageConverter()\naccessTokenResponseMessageConverter.setAccessTokenResponseConverter { parameters ->\n\t// ...\n\treturn OAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t// ...\n\t\t.build()\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response-errors]\n=== Customizing Error Handling\n\nThe following example provides a starting point for customizing the conversion of Error parameters to an `OAuth2Error`:\n\n.Customize Access Token Error Handler\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2ErrorHttpMessageConverter errorConverter =\n\tnew OAuth2ErrorHttpMessageConverter();\nerrorConverter.setErrorConverter(parameters -> {\n\t// ...\n\treturn new OAuth2Error(\"custom-error\", \"custom description\", \"custom-uri\");\n});\n\nOAuth2ErrorResponseErrorHandler errorHandler =\n\tnew OAuth2ErrorResponseErrorHandler();\nerrorHandler.setErrorConverter(errorConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval errorConverter = OAuth2ErrorHttpMessageConverter()\nerrorConverter.setErrorConverter { parameters ->\n\t// ...\n\treturn OAuth2Error(\"custom-error\", \"custom description\", \"custom-uri\")\n}\n\nval errorHandler = OAuth2ErrorResponseErrorHandler()\nerrorHandler.setErrorConverter(errorConverter)\n----\n======\n\n[[oauth2-client-authorization-code-access-token-response-client-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Requesting an Access Token", "heading_level": 3, "file_order": 141, "section_index": 6, "content_hash": "e4aa71f337720ad833b415b66237c6787ee222684cb9cca1584565ae5400eb91", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:24ef14a630cfa58e15da058c60f75983eac8391edcbdb355bc1ca3086f5aa96f", "content": "Whether you customize `{class-name}` or provide your own implementation of `OAuth2AccessTokenResponseClient`, you can configure it using the DSL (as an alternative to <<oauth2-client-authorization-code-access-token-response-client-bean,publishing a bean>>) as follows:\n\n.Access Token Response Configuration via DSL\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2ClientSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Client((oauth2) -> oauth2\n .authorizationCodeGrant((codeGrant) -> codeGrant\n .accessTokenResponseClient(this.accessTokenResponseClient())\n // ...\n )\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2ClientSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Client {\n authorizationCodeGrant {\n accessTokenResponseClient = accessTokenResponseClient()\n }\n }\n }\n return http.build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<oauth2-client>\n <authorization-code-grant access-token-response-client-ref=\"accessTokenResponseClient\"/>\n\t</oauth2-client>\n</http>\n----\n======\n\n[[oauth2-client-refresh-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customize using the DSL", "heading_level": 3, "file_order": 141, "section_index": 7, "content_hash": "24ef14a630cfa58e15da058c60f75983eac8391edcbdb355bc1ca3086f5aa96f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:3b167e292abc67c0595368650fe3fa9e50844f158145021b36fdd5c3d1f8d77d", "content": "[NOTE]\n====\nSee the OAuth 2.0 Authorization Framework for further details on the https://tools.ietf.org/html/rfc6749#section-1.5[Refresh Token].\n====\n\n[[oauth2-client-refresh-token-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "[[oauth2Client-refresh-token-grant]]Refresh Token", "heading_level": 2, "file_order": 141, "section_index": 8, "content_hash": "3b167e292abc67c0595368650fe3fa9e50844f158145021b36fdd5c3d1f8d77d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:11ffddf1f73a38529e8313589737e7487a4691202ca1b7464119a19738eaa907", "content": "[NOTE]\n====\nSee the https://tools.ietf.org/html/rfc6749#section-6[Access Token Request/Response] protocol flow for the Refresh Token grant.\n====\n\nThe default implementation of `OAuth2AccessTokenResponseClient` for the Refresh Token grant is `RestClientRefreshTokenTokenResponseClient`, which uses a `RestClient` instance to obtain an access token at the Authorization Servers Token Endpoint.\n\n`{class-name}` is very flexible and provides several options for customizing the OAuth 2.0 Access Token request and response for the {grant-type} grant.\nChoose from the following use cases to learn more:\n\n* I want to <<oauth2-client-{section-id}-access-token-request-headers,customize headers of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-request-parameters,customize parameters of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-response-rest-client,customize the instance of `RestClient` that is used>>\n* I want to <<oauth2-client-{section-id}-access-token-response-parameters,customize parameters of the Access Token response>>\n* I want to <<oauth2-client-{section-id}-access-token-response-errors,customize error handling of the Access Token response>>\n\n[#oauth2-client-{section-id}-access-token-request]\n== Customizing the Access Token Request\n\n`{class-name}` provides hooks for customizing HTTP headers and request parameters of the OAuth 2.0 Access Token Request.\n\n[#oauth2-client-{section-id}-access-token-request-headers]\n=== Customizing Request Headers\n\nThere are two options for customizing HTTP headers:\n\n* Add additional headers by calling `addHeadersConverter()`\n* Fully customize headers by calling `setHeadersConverter()`\n\nYou can include additional headers without affecting the default headers added to every request using `addHeadersConverter()`.\nThe following example adds a `User-Agent` header to the request when the `registrationId` is `spring`:\n\n.Include Additional HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addHeadersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tHttpHeaders headers = new HttpHeaders();\n\tif (clientRegistration.getRegistrationId().equals(\"spring\")) {\n\t\theaders.set(HttpHeaders.USER_AGENT, \"my-user-agent\");\n\t}\n\treturn headers;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addHeadersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval headers = HttpHeaders()\n\tif (clientRegistration.getRegistrationId() == \"spring\") {\n        headers[HttpHeaders.USER_AGENT] = \"my-user-agent\"\n\t}\n\theaders\n}\n----\n======\n\nYou can fully customize headers by re-using `DefaultOAuth2TokenRequestHeadersConverter` or providing a custom implementation using `setHeadersConverter()`.\nThe following example re-uses `DefaultOAuth2TokenRequestHeadersConverter` and disables `encodeClientCredentials` so that HTTP Basic credentials are no longer encoded with `application/x-www-form-urlencoded`:\n\n.Customize HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter headersConverter =\n\tnew DefaultOAuth2TokenRequestHeadersConverter();\nheadersConverter.setEncodeClientCredentials(false);\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter()\nheadersConverter.setEncodeClientCredentials(false)\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[#oauth2-client-{section-id}-access-token-request-parameters]\n=== Customizing Request Parameters\n\nThere are three options for customizing request parameters:\n\n* Add additional parameters by calling `addParametersConverter()`\n* Override parameters by calling `setParametersConverter()`\n* Fully customize parameters by calling `setParametersCustomizer()`\n\n[NOTE]\n====\nUsing `setParametersConverter()` does not fully customize parameters because it would require the user to provide all default parameters themselves.\nDefault parameters are always provided, but can be fully customized or omitted by calling `setParametersCustomizer()`.\n====\n\nYou can include additional parameters without affecting the default parameters added to every request using `addParametersConverter()`.\nThe following example adds an `audience` parameter to the request when the `registrationId` is `keycloak`:\n\n.Include Additional Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tMultiValueMap<String, String> parameters = new LinkedMultiValueMap<String, String>();\n\tif (clientRegistration.getRegistrationId().equals(\"keycloak\")) {\n\t\tparameters.set(OAuth2ParameterNames.AUDIENCE, \"my-audience\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addParametersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"keycloak\") {\n        parameters[OAuth2ParameterNames.AUDIENCE] = \"my-audience\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can override default parameters using `setParametersConverter()`.\nThe following example overrides the `client_id` parameter when the `registrationId` is `okta`:\n\n.Override Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tLinkedMultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n\tif (clientRegistration.getRegistrationId().equals(\"okta\")) {\n\t\tparameters.set(OAuth2ParameterNames.CLIENT_ID, \"my-client\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval parametersConverter = DefaultOAuth2TokenRequestParametersConverter<{grant-request}>()\nparametersConverter.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersConverter { grantRequest ->\n    val clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"okta\") {\n        parameters[OAuth2ParameterNames.CLIENT_ID] = \"my-client\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can fully customize parameters (including omitting default parameters) using `setParametersCustomizer()`.\nThe following example omits the `client_id` parameter when the `client_assertion` parameter is present in the request:\n\n.Omit Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersCustomizer(parameters -> {\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID);\n\t}\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response]\n== Customizing the Access Token Response\n\n`{class-name}` provides hooks for customizing response parameters and error handling of the OAuth 2.0 Access Token Response.\n\n[#oauth2-client-{section-id}-access-token-response-rest-client]\n=== Customizing the `RestClient`\n\nYou can customize the Token Response by providing a pre-configured `RestClient` to `setRestClient()`.\nThe default `RestClient` is configured as follows:\n\n.Default `RestClient` Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nRestClient restClient = RestClient.builder()\n\t.messageConverters(messageConverters -> {\n\t\tmessageConverters.clear();\n\t\tmessageConverters.add(new FormHttpMessageConverter());\n\t\tmessageConverters.add(new OAuth2AccessTokenResponseHttpMessageConverter());\n\t})\n\t.defaultStatusHandler(new OAuth2ErrorResponseErrorHandler())\n\t.build();\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setRestClient(restClient);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval restClient = RestClient.builder()\n\t.messageConverters { messageConverters ->\n\t\tmessageConverters.clear()\n\t\tmessageConverters.add(FormHttpMessageConverter())\n\t\tmessageConverters.add(OAuth2AccessTokenResponseHttpMessageConverter())\n\t}\n\t.defaultStatusHandler(OAuth2ErrorResponseErrorHandler())\n\t.build()\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setRestClient(restClient)\n----\n======\n\n`OAuth2AccessTokenResponseHttpMessageConverter` is an `HttpMessageConverter` for an OAuth 2.0 Access Token Response.\nYou can customize the conversion of Token Response parameters to an `OAuth2AccessTokenResponse` by calling `setAccessTokenResponseConverter()`.\nThe default implementation is `DefaultMapOAuth2AccessTokenResponseConverter`.\n\n`OAuth2ErrorResponseErrorHandler` is a `ResponseErrorHandler` that can handle an OAuth 2.0 Error, such as `400 Bad Request`.\nIt uses an `OAuth2ErrorHttpMessageConverter` for converting the OAuth 2.0 Error parameters to an `OAuth2Error`.\nYou can customize the conversion of Token Response parameters to an `OAuth2Error` by calling `setErrorConverter()`.\n\n[TIP]\n====\nSpring MVC `FormHttpMessageConverter` is required, as it is used when sending the OAuth 2.0 Access Token Request.\n====\n\n[#oauth2-client-{section-id}-access-token-response-parameters]\n=== Customizing Response Parameters\n\nThe following example provides a starting point for customizing the conversion of Token Response parameters to an `OAuth2AccessTokenResponse`:\n\n.Customize Access Token Response Converter\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2AccessTokenResponseHttpMessageConverter accessTokenResponseMessageConverter =\n\tnew OAuth2AccessTokenResponseHttpMessageConverter();\naccessTokenResponseMessageConverter.setAccessTokenResponseConverter(parameters -> {\n\t// ...\n\treturn OAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t// ...\n\t\t.build();\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval accessTokenResponseMessageConverter = OAuth2AccessTokenResponseHttpMessageConverter()\naccessTokenResponseMessageConverter.setAccessTokenResponseConverter { parameters ->\n\t// ...\n\treturn OAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t// ...\n\t\t.build()\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response-errors]\n=== Customizing Error Handling\n\nThe following example provides a starting point for customizing the conversion of Error parameters to an `OAuth2Error`:\n\n.Customize Access Token Error Handler\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2ErrorHttpMessageConverter errorConverter =\n\tnew OAuth2ErrorHttpMessageConverter();\nerrorConverter.setErrorConverter(parameters -> {\n\t// ...\n\treturn new OAuth2Error(\"custom-error\", \"custom description\", \"custom-uri\");\n});\n\nOAuth2ErrorResponseErrorHandler errorHandler =\n\tnew OAuth2ErrorResponseErrorHandler();\nerrorHandler.setErrorConverter(errorConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval errorConverter = OAuth2ErrorHttpMessageConverter()\nerrorConverter.setErrorConverter { parameters ->\n\t// ...\n\treturn OAuth2Error(\"custom-error\", \"custom description\", \"custom-uri\")\n}\n\nval errorHandler = OAuth2ErrorResponseErrorHandler()\nerrorHandler.setErrorConverter(errorConverter)\n----\n======\n\n[[oauth2-client-refresh-token-authorized-client-provider-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Refreshing an Access Token", "heading_level": 3, "file_order": 141, "section_index": 9, "content_hash": "11ffddf1f73a38529e8313589737e7487a4691202ca1b7464119a19738eaa907", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:ca582fb9593afbd39575e6d585f408013bff36e785c39488ab7ff5f811a3fdd8", "content": "Whether you customize `RestClientRefreshTokenTokenResponseClient` or provide your own implementation of `OAuth2AccessTokenResponseClient`, you can configure it using the `OAuth2AuthorizedClientProviderBuilder` (as an alternative to <<oauth2-client-refresh-token-access-token-response-client-bean,publishing a bean>>) as follows:\n\n.Access Token Response Configuration via Builder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> refreshTokenTokenResponseClient = ...\n\nOAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken((configurer) -> configurer.accessTokenResponseClient(refreshTokenTokenResponseClient))\n .build();\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval refreshTokenTokenResponseClient: OAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> = ...\n\nval authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken { it.accessTokenResponseClient(refreshTokenTokenResponseClient) }\n .build()\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n----\n======\n\n[NOTE]\n====\n`OAuth2AuthorizedClientProviderBuilder.builder().refreshToken()` configures a `RefreshTokenOAuth2AuthorizedClientProvider`,\nwhich is an implementation of an `OAuth2AuthorizedClientProvider` for the Refresh Token grant.\n====\n\nThe `OAuth2RefreshToken` can optionally be returned in the Access Token Response for the `authorization_code` grant type.\nIf the `OAuth2AuthorizedClient.getRefreshToken()` is available and the `OAuth2AuthorizedClient.getAccessToken()` is expired, it is automatically refreshed by the `RefreshTokenOAuth2AuthorizedClientProvider`.\n\n[[oauth2-client-client-credentials]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customize using the Builder", "heading_level": 3, "file_order": 141, "section_index": 10, "content_hash": "ca582fb9593afbd39575e6d585f408013bff36e785c39488ab7ff5f811a3fdd8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:75355b15d8da3c1b0640cc3873c66bb8ee8149f27564652187ec71670432a058", "content": "[NOTE]\n====\nPlease refer to the OAuth 2.0 Authorization Framework for further details on the https://tools.ietf.org/html/rfc6749#section-1.3.4[Client Credentials] grant.\n====\n\n[[oauth2-client-client-credentials-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "[[oauth2Client-client-creds-grant]]Client Credentials", "heading_level": 2, "file_order": 141, "section_index": 11, "content_hash": "75355b15d8da3c1b0640cc3873c66bb8ee8149f27564652187ec71670432a058", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:c4b84dfc98ab997b090d7738e7a70782076492cc8840c13c9ff8aaea94e773b2", "content": "[NOTE]\n====\nSee the https://tools.ietf.org/html/rfc6749#section-4.4.2[Access Token Request/Response] protocol flow for the Client Credentials grant.\n====\n\nThe default implementation of `OAuth2AccessTokenResponseClient` for the Client Credentials grant is `RestClientClientCredentialsTokenResponseClient`, which uses a `RestClient` instance to obtain an access token at the Authorization Servers Token Endpoint.\n\n`{class-name}` is very flexible and provides several options for customizing the OAuth 2.0 Access Token request and response for the {grant-type} grant.\nChoose from the following use cases to learn more:\n\n* I want to <<oauth2-client-{section-id}-access-token-request-headers,customize headers of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-request-parameters,customize parameters of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-response-rest-client,customize the instance of `RestClient` that is used>>\n* I want to <<oauth2-client-{section-id}-access-token-response-parameters,customize parameters of the Access Token response>>\n* I want to <<oauth2-client-{section-id}-access-token-response-errors,customize error handling of the Access Token response>>\n\n[#oauth2-client-{section-id}-access-token-request]\n== Customizing the Access Token Request\n\n`{class-name}` provides hooks for customizing HTTP headers and request parameters of the OAuth 2.0 Access Token Request.\n\n[#oauth2-client-{section-id}-access-token-request-headers]\n=== Customizing Request Headers\n\nThere are two options for customizing HTTP headers:\n\n* Add additional headers by calling `addHeadersConverter()`\n* Fully customize headers by calling `setHeadersConverter()`\n\nYou can include additional headers without affecting the default headers added to every request using `addHeadersConverter()`.\nThe following example adds a `User-Agent` header to the request when the `registrationId` is `spring`:\n\n.Include Additional HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addHeadersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tHttpHeaders headers = new HttpHeaders();\n\tif (clientRegistration.getRegistrationId().equals(\"spring\")) {\n\t\theaders.set(HttpHeaders.USER_AGENT, \"my-user-agent\");\n\t}\n\treturn headers;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addHeadersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval headers = HttpHeaders()\n\tif (clientRegistration.getRegistrationId() == \"spring\") {\n        headers[HttpHeaders.USER_AGENT] = \"my-user-agent\"\n\t}\n\theaders\n}\n----\n======\n\nYou can fully customize headers by re-using `DefaultOAuth2TokenRequestHeadersConverter` or providing a custom implementation using `setHeadersConverter()`.\nThe following example re-uses `DefaultOAuth2TokenRequestHeadersConverter` and disables `encodeClientCredentials` so that HTTP Basic credentials are no longer encoded with `application/x-www-form-urlencoded`:\n\n.Customize HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter headersConverter =\n\tnew DefaultOAuth2TokenRequestHeadersConverter();\nheadersConverter.setEncodeClientCredentials(false);\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter()\nheadersConverter.setEncodeClientCredentials(false)\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[#oauth2-client-{section-id}-access-token-request-parameters]\n=== Customizing Request Parameters\n\nThere are three options for customizing request parameters:\n\n* Add additional parameters by calling `addParametersConverter()`\n* Override parameters by calling `setParametersConverter()`\n* Fully customize parameters by calling `setParametersCustomizer()`\n\n[NOTE]\n====\nUsing `setParametersConverter()` does not fully customize parameters because it would require the user to provide all default parameters themselves.\nDefault parameters are always provided, but can be fully customized or omitted by calling `setParametersCustomizer()`.\n====\n\nYou can include additional parameters without affecting the default parameters added to every request using `addParametersConverter()`.\nThe following example adds an `audience` parameter to the request when the `registrationId` is `keycloak`:\n\n.Include Additional Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tMultiValueMap<String, String> parameters = new LinkedMultiValueMap<String, String>();\n\tif (clientRegistration.getRegistrationId().equals(\"keycloak\")) {\n\t\tparameters.set(OAuth2ParameterNames.AUDIENCE, \"my-audience\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addParametersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"keycloak\") {\n        parameters[OAuth2ParameterNames.AUDIENCE] = \"my-audience\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can override default parameters using `setParametersConverter()`.\nThe following example overrides the `client_id` parameter when the `registrationId` is `okta`:\n\n.Override Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tLinkedMultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n\tif (clientRegistration.getRegistrationId().equals(\"okta\")) {\n\t\tparameters.set(OAuth2ParameterNames.CLIENT_ID, \"my-client\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval parametersConverter = DefaultOAuth2TokenRequestParametersConverter<{grant-request}>()\nparametersConverter.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersConverter { grantRequest ->\n    val clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"okta\") {\n        parameters[OAuth2ParameterNames.CLIENT_ID] = \"my-client\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can fully customize parameters (including omitting default parameters) using `setParametersCustomizer()`.\nThe following example omits the `client_id` parameter when the `client_assertion` parameter is present in the request:\n\n.Omit Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersCustomizer(parameters -> {\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID);\n\t}\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response]\n== Customizing the Access Token Response\n\n`{class-name}` provides hooks for customizing response parameters and error handling of the OAuth 2.0 Access Token Response.\n\n[#oauth2-client-{section-id}-access-token-response-rest-client]\n=== Customizing the `RestClient`\n\nYou can customize the Token Response by providing a pre-configured `RestClient` to `setRestClient()`.\nThe default `RestClient` is configured as follows:\n\n.Default `RestClient` Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nRestClient restClient = RestClient.builder()\n\t.messageConverters(messageConverters -> {\n\t\tmessageConverters.clear();\n\t\tmessageConverters.add(new FormHttpMessageConverter());\n\t\tmessageConverters.add(new OAuth2AccessTokenResponseHttpMessageConverter());\n\t})\n\t.defaultStatusHandler(new OAuth2ErrorResponseErrorHandler())\n\t.build();\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setRestClient(restClient);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval restClient = RestClient.builder()\n\t.messageConverters { messageConverters ->\n\t\tmessageConverters.clear()\n\t\tmessageConverters.add(FormHttpMessageConverter())\n\t\tmessageConverters.add(OAuth2AccessTokenResponseHttpMessageConverter())\n\t}\n\t.defaultStatusHandler(OAuth2ErrorResponseErrorHandler())\n\t.build()\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setRestClient(restClient)\n----\n======\n\n`OAuth2AccessTokenResponseHttpMessageConverter` is an `HttpMessageConverter` for an OAuth 2.0 Access Token Response.\nYou can customize the conversion of Token Response parameters to an `OAuth2AccessTokenResponse` by calling `setAccessTokenResponseConverter()`.\nThe default implementation is `DefaultMapOAuth2AccessTokenResponseConverter`.\n\n`OAuth2ErrorResponseErrorHandler` is a `ResponseErrorHandler` that can handle an OAuth 2.0 Error, such as `400 Bad Request`.\nIt uses an `OAuth2ErrorHttpMessageConverter` for converting the OAuth 2.0 Error parameters to an `OAuth2Error`.\nYou can customize the conversion of Token Response parameters to an `OAuth2Error` by calling `setErrorConverter()`.\n\n[TIP]\n====\nSpring MVC `FormHttpMessageConverter` is required, as it is used when sending the OAuth 2.0 Access Token Request.\n====\n\n[#oauth2-client-{section-id}-access-token-response-parameters]\n=== Customizing Response Parameters\n\nThe following example provides a starting point for customizing the conversion of Token Response parameters to an `OAuth2AccessTokenResponse`:\n\n.Customize Access Token Response Converter\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2AccessTokenResponseHttpMessageConverter accessTokenResponseMessageConverter =\n\tnew OAuth2AccessTokenResponseHttpMessageConverter();\naccessTokenResponseMessageConverter.setAccessTokenResponseConverter(parameters -> {\n\t// ...\n\treturn OAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t// ...\n\t\t.build();\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval accessTokenResponseMessageConverter = OAuth2AccessTokenResponseHttpMessageConverter()\naccessTokenResponseMessageConverter.setAccessTokenResponseConverter { parameters ->\n\t// ...\n\treturn OAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t// ...\n\t\t.build()\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response-errors]\n=== Customizing Error Handling\n\nThe following example provides a starting point for customizing the conversion of Error parameters to an `OAuth2Error`:\n\n.Customize Access Token Error Handler\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2ErrorHttpMessageConverter errorConverter =\n\tnew OAuth2ErrorHttpMessageConverter();\nerrorConverter.setErrorConverter(parameters -> {\n\t// ...\n\treturn new OAuth2Error(\"custom-error\", \"custom description\", \"custom-uri\");\n});\n\nOAuth2ErrorResponseErrorHandler errorHandler =\n\tnew OAuth2ErrorResponseErrorHandler();\nerrorHandler.setErrorConverter(errorConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval errorConverter = OAuth2ErrorHttpMessageConverter()\nerrorConverter.setErrorConverter { parameters ->\n\t// ...\n\treturn OAuth2Error(\"custom-error\", \"custom description\", \"custom-uri\")\n}\n\nval errorHandler = OAuth2ErrorResponseErrorHandler()\nerrorHandler.setErrorConverter(errorConverter)\n----\n======\n\n[[oauth2-client-client-credentials-authorized-client-provider-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Requesting an Access Token", "heading_level": 3, "file_order": 141, "section_index": 12, "content_hash": "c4b84dfc98ab997b090d7738e7a70782076492cc8840c13c9ff8aaea94e773b2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:0698375345315507f6720c1aa55032913a4990ba586f6ff568fc86a2c58c6293", "content": "Whether you customize `RestClientClientCredentialsTokenResponseClient` or provide your own implementation of `OAuth2AccessTokenResponseClient`, you can configure it using the `OAuth2AuthorizedClientProviderBuilder` (as an alternative to <<oauth2-client-client-credentials-access-token-response-client-bean,publishing a bean>>) as follows:\n\n.Access Token Response Configuration via Builder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsTokenResponseClient = ...\n\nOAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials((configurer) -> configurer.accessTokenResponseClient(clientCredentialsTokenResponseClient))\n .build();\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval clientCredentialsTokenResponseClient: OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> = ...\n\nval authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials { it.accessTokenResponseClient(clientCredentialsTokenResponseClient) }\n .build()\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n----\n======\n\n[NOTE]\n====\n`OAuth2AuthorizedClientProviderBuilder.builder().clientCredentials()` configures a `ClientCredentialsOAuth2AuthorizedClientProvider`,\nwhich is an implementation of an `OAuth2AuthorizedClientProvider` for the Client Credentials grant.\n====\n\n[[oauth2-client-client-credentials-authorized-client-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customize using the Builder", "heading_level": 3, "file_order": 141, "section_index": 13, "content_hash": "0698375345315507f6720c1aa55032913a4990ba586f6ff568fc86a2c58c6293", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:67ac2fa6dd71b7389cdd7adc9bb530c5203dec553ae55627dda22587df7b580e", "content": "Consider the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n authorization-grant-type: client_credentials\n scope: read, write\n provider:\n okta:\n token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token\n----\n\nFurther consider the following `OAuth2AuthorizedClientManager` `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic OAuth2AuthorizedClientManager authorizedClientManager(\n ClientRegistrationRepository clientRegistrationRepository,\n OAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tOAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials()\n .build();\n\n\tDefaultOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ClientRegistrationRepository,\n authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {\n val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials()\n .build()\n val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======\n\nGiven the preceding properties and bean, you can obtain the `OAuth2AccessToken` as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class OAuth2ClientController {\n\n\t@Autowired\n\tprivate OAuth2AuthorizedClientManager authorizedClientManager;\n\n\t@GetMapping(\"/\")\n\tpublic String index(Authentication authentication,\n HttpServletRequest servletRequest,\n HttpServletResponse servletResponse) {\n\n OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(authentication)\n .attributes(attrs -> {\n attrs.put(HttpServletRequest.class.getName(), servletRequest);\n attrs.put(HttpServletResponse.class.getName(), servletResponse);\n })\n .build();\n OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);\n\n OAuth2AccessToken accessToken = authorizedClient.getAccessToken();\n\n // ...\n\n return \"index\";\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass OAuth2ClientController {\n\n @Autowired\n private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager\n\n @GetMapping(\"/\")\n fun index(authentication: Authentication?,\n servletRequest: HttpServletRequest,\n servletResponse: HttpServletResponse): String {\n val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(authentication)\n .attributes(Consumer { attrs: MutableMap<String, Any> ->\n attrs[HttpServletRequest::class.java.name] = servletRequest\n attrs[HttpServletResponse::class.java.name] = servletResponse\n })\n .build()\n val authorizedClient = authorizedClientManager.authorize(authorizeRequest)\n val accessToken: OAuth2AccessToken = authorizedClient.accessToken\n\n // ...\n\n return \"index\"\n }\n}\n----\n======\n\n[NOTE]\n====\n`HttpServletRequest` and `HttpServletResponse` are both OPTIONAL attributes.\nIf not provided, they default to `ServletRequestAttributes` by using `RequestContextHolder.getRequestAttributes()`.\n====\n\n[[oauth2-client-jwt-bearer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Using the Access Token", "heading_level": 3, "file_order": 141, "section_index": 14, "content_hash": "67ac2fa6dd71b7389cdd7adc9bb530c5203dec553ae55627dda22587df7b580e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:2c49523e6801d5a59e9d72dc737e08f5d4ec94723b4b31deed39fede8b77cd50", "content": "[NOTE]\n====\nPlease refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on the https://datatracker.ietf.org/doc/html/rfc7523[JWT Bearer] grant.\n====\n\n[[oauth2-client-jwt-bearer-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "JWT Bearer", "heading_level": 2, "file_order": 141, "section_index": 15, "content_hash": "2c49523e6801d5a59e9d72dc737e08f5d4ec94723b4b31deed39fede8b77cd50", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:bd8bddf2d51e37b7b4635cc38db7dc56129a9fc5b586b7d2298250e86c24d9bc", "content": "[NOTE]\n====\nPlease refer to the https://datatracker.ietf.org/doc/html/rfc7523#section-2.1[Access Token Request/Response] protocol flow for the JWT Bearer grant.\n====\n\nThe default implementation of `OAuth2AccessTokenResponseClient` for the JWT Bearer grant is `RestClientJwtBearerTokenResponseClient`, which uses a `RestClient` instance to obtain an access token at the Authorization Servers Token Endpoint.\n\n`{class-name}` is very flexible and provides several options for customizing the OAuth 2.0 Access Token request and response for the {grant-type} grant.\nChoose from the following use cases to learn more:\n\n* I want to <<oauth2-client-{section-id}-access-token-request-headers,customize headers of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-request-parameters,customize parameters of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-response-rest-client,customize the instance of `RestClient` that is used>>\n* I want to <<oauth2-client-{section-id}-access-token-response-parameters,customize parameters of the Access Token response>>\n* I want to <<oauth2-client-{section-id}-access-token-response-errors,customize error handling of the Access Token response>>\n\n[#oauth2-client-{section-id}-access-token-request]\n== Customizing the Access Token Request\n\n`{class-name}` provides hooks for customizing HTTP headers and request parameters of the OAuth 2.0 Access Token Request.\n\n[#oauth2-client-{section-id}-access-token-request-headers]\n=== Customizing Request Headers\n\nThere are two options for customizing HTTP headers:\n\n* Add additional headers by calling `addHeadersConverter()`\n* Fully customize headers by calling `setHeadersConverter()`\n\nYou can include additional headers without affecting the default headers added to every request using `addHeadersConverter()`.\nThe following example adds a `User-Agent` header to the request when the `registrationId` is `spring`:\n\n.Include Additional HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addHeadersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tHttpHeaders headers = new HttpHeaders();\n\tif (clientRegistration.getRegistrationId().equals(\"spring\")) {\n\t\theaders.set(HttpHeaders.USER_AGENT, \"my-user-agent\");\n\t}\n\treturn headers;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addHeadersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval headers = HttpHeaders()\n\tif (clientRegistration.getRegistrationId() == \"spring\") {\n        headers[HttpHeaders.USER_AGENT] = \"my-user-agent\"\n\t}\n\theaders\n}\n----\n======\n\nYou can fully customize headers by re-using `DefaultOAuth2TokenRequestHeadersConverter` or providing a custom implementation using `setHeadersConverter()`.\nThe following example re-uses `DefaultOAuth2TokenRequestHeadersConverter` and disables `encodeClientCredentials` so that HTTP Basic credentials are no longer encoded with `application/x-www-form-urlencoded`:\n\n.Customize HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter headersConverter =\n\tnew DefaultOAuth2TokenRequestHeadersConverter();\nheadersConverter.setEncodeClientCredentials(false);\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter()\nheadersConverter.setEncodeClientCredentials(false)\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[#oauth2-client-{section-id}-access-token-request-parameters]\n=== Customizing Request Parameters\n\nThere are three options for customizing request parameters:\n\n* Add additional parameters by calling `addParametersConverter()`\n* Override parameters by calling `setParametersConverter()`\n* Fully customize parameters by calling `setParametersCustomizer()`\n\n[NOTE]\n====\nUsing `setParametersConverter()` does not fully customize parameters because it would require the user to provide all default parameters themselves.\nDefault parameters are always provided, but can be fully customized or omitted by calling `setParametersCustomizer()`.\n====\n\nYou can include additional parameters without affecting the default parameters added to every request using `addParametersConverter()`.\nThe following example adds an `audience` parameter to the request when the `registrationId` is `keycloak`:\n\n.Include Additional Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tMultiValueMap<String, String> parameters = new LinkedMultiValueMap<String, String>();\n\tif (clientRegistration.getRegistrationId().equals(\"keycloak\")) {\n\t\tparameters.set(OAuth2ParameterNames.AUDIENCE, \"my-audience\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addParametersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"keycloak\") {\n        parameters[OAuth2ParameterNames.AUDIENCE] = \"my-audience\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can override default parameters using `setParametersConverter()`.\nThe following example overrides the `client_id` parameter when the `registrationId` is `okta`:\n\n.Override Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tLinkedMultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n\tif (clientRegistration.getRegistrationId().equals(\"okta\")) {\n\t\tparameters.set(OAuth2ParameterNames.CLIENT_ID, \"my-client\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval parametersConverter = DefaultOAuth2TokenRequestParametersConverter<{grant-request}>()\nparametersConverter.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersConverter { grantRequest ->\n    val clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"okta\") {\n        parameters[OAuth2ParameterNames.CLIENT_ID] = \"my-client\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can fully customize parameters (including omitting default parameters) using `setParametersCustomizer()`.\nThe following example omits the `client_id` parameter when the `client_assertion` parameter is present in the request:\n\n.Omit Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersCustomizer(parameters -> {\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID);\n\t}\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response]\n== Customizing the Access Token Response\n\n`{class-name}` provides hooks for customizing response parameters and error handling of the OAuth 2.0 Access Token Response.\n\n[#oauth2-client-{section-id}-access-token-response-rest-client]\n=== Customizing the `RestClient`\n\nYou can customize the Token Response by providing a pre-configured `RestClient` to `setRestClient()`.\nThe default `RestClient` is configured as follows:\n\n.Default `RestClient` Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nRestClient restClient = RestClient.builder()\n\t.messageConverters(messageConverters -> {\n\t\tmessageConverters.clear();\n\t\tmessageConverters.add(new FormHttpMessageConverter());\n\t\tmessageConverters.add(new OAuth2AccessTokenResponseHttpMessageConverter());\n\t})\n\t.defaultStatusHandler(new OAuth2ErrorResponseErrorHandler())\n\t.build();\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setRestClient(restClient);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval restClient = RestClient.builder()\n\t.messageConverters { messageConverters ->\n\t\tmessageConverters.clear()\n\t\tmessageConverters.add(FormHttpMessageConverter())\n\t\tmessageConverters.add(OAuth2AccessTokenResponseHttpMessageConverter())\n\t}\n\t.defaultStatusHandler(OAuth2ErrorResponseErrorHandler())\n\t.build()\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setRestClient(restClient)\n----\n======\n\n`OAuth2AccessTokenResponseHttpMessageConverter` is an `HttpMessageConverter` for an OAuth 2.0 Access Token Response.\nYou can customize the conversion of Token Response parameters to an `OAuth2AccessTokenResponse` by calling `setAccessTokenResponseConverter()`.\nThe default implementation is `DefaultMapOAuth2AccessTokenResponseConverter`.\n\n`OAuth2ErrorResponseErrorHandler` is a `ResponseErrorHandler` that can handle an OAuth 2.0 Error, such as `400 Bad Request`.\nIt uses an `OAuth2ErrorHttpMessageConverter` for converting the OAuth 2.0 Error parameters to an `OAuth2Error`.\nYou can customize the conversion of Token Response parameters to an `OAuth2Error` by calling `setErrorConverter()`.\n\n[TIP]\n====\nSpring MVC `FormHttpMessageConverter` is required, as it is used when sending the OAuth 2.0 Access Token Request.\n====\n\n[#oauth2-client-{section-id}-access-token-response-parameters]\n=== Customizing Response Parameters\n\nThe following example provides a starting point for customizing the conversion of Token Response parameters to an `OAuth2AccessTokenResponse`:\n\n.Customize Access Token Response Converter\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2AccessTokenResponseHttpMessageConverter accessTokenResponseMessageConverter =\n\tnew OAuth2AccessTokenResponseHttpMessageConverter();\naccessTokenResponseMessageConverter.setAccessTokenResponseConverter(parameters -> {\n\t// ...\n\treturn OAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t// ...\n\t\t.build();\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval accessTokenResponseMessageConverter = OAuth2AccessTokenResponseHttpMessageConverter()\naccessTokenResponseMessageConverter.setAccessTokenResponseConverter { parameters ->\n\t// ...\n\treturn OAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t// ...\n\t\t.build()\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response-errors]\n=== Customizing Error Handling\n\nThe following example provides a starting point for customizing the conversion of Error parameters to an `OAuth2Error`:\n\n.Customize Access Token Error Handler\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2ErrorHttpMessageConverter errorConverter =\n\tnew OAuth2ErrorHttpMessageConverter();\nerrorConverter.setErrorConverter(parameters -> {\n\t// ...\n\treturn new OAuth2Error(\"custom-error\", \"custom description\", \"custom-uri\");\n});\n\nOAuth2ErrorResponseErrorHandler errorHandler =\n\tnew OAuth2ErrorResponseErrorHandler();\nerrorHandler.setErrorConverter(errorConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval errorConverter = OAuth2ErrorHttpMessageConverter()\nerrorConverter.setErrorConverter { parameters ->\n\t// ...\n\treturn OAuth2Error(\"custom-error\", \"custom description\", \"custom-uri\")\n}\n\nval errorHandler = OAuth2ErrorResponseErrorHandler()\nerrorHandler.setErrorConverter(errorConverter)\n----\n======\n\n[[oauth2-client-jwt-bearer-authorized-client-provider-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Requesting an Access Token", "heading_level": 3, "file_order": 141, "section_index": 16, "content_hash": "bd8bddf2d51e37b7b4635cc38db7dc56129a9fc5b586b7d2298250e86c24d9bc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:17866eef89a7192d8ebd5c5c1f3865e4bb4c573bf6ed49e0c313e5745f69eb8d", "content": "Whether you customize `RestClientJwtBearerTokenResponseClient` or provide your own implementation of `OAuth2AccessTokenResponseClient`, you can configure it using the `OAuth2AuthorizedClientProviderBuilder` (as an alternative to <<oauth2-client-jwt-bearer-access-token-response-client-bean,publishing a bean>>) as follows:\n\n.Access Token Response Configuration via Builder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2AccessTokenResponseClient<JwtBearerGrantRequest> jwtBearerTokenResponseClient = ...\n\nJwtBearerOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider = new JwtBearerOAuth2AuthorizedClientProvider();\njwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient);\n\nOAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .provider(jwtBearerAuthorizedClientProvider)\n .build();\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwtBearerTokenResponseClient: OAuth2AccessTokenResponseClient<JwtBearerGrantRequest> = ...\n\nval jwtBearerAuthorizedClientProvider = JwtBearerOAuth2AuthorizedClientProvider()\njwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerTokenResponseClient)\n\nval authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .provider(jwtBearerAuthorizedClientProvider)\n .build()\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n----\n======\n\n[[oauth2-client-jwt-bearer-authorized-client-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customize using the Builder", "heading_level": 3, "file_order": 141, "section_index": 17, "content_hash": "17866eef89a7192d8ebd5c5c1f3865e4bb4c573bf6ed49e0c313e5745f69eb8d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:a6103f7d85fe12195a671042cc64a9f2013d7777b527500b7dfa633c436fc8fc", "content": "Given the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n authorization-grant-type: urn:ietf:params:oauth:grant-type:jwt-bearer\n scope: read\n provider:\n okta:\n token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token\n----\n\n...and the `OAuth2AuthorizedClientManager` `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic OAuth2AuthorizedClientManager authorizedClientManager(\n ClientRegistrationRepository clientRegistrationRepository,\n OAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tJwtBearerOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider =\n new JwtBearerOAuth2AuthorizedClientProvider();\n\n\tOAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .provider(jwtBearerAuthorizedClientProvider)\n .build();\n\n\tDefaultOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ClientRegistrationRepository,\n authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {\n val jwtBearerAuthorizedClientProvider = JwtBearerOAuth2AuthorizedClientProvider()\n val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .provider(jwtBearerAuthorizedClientProvider)\n .build()\n val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======\n\nYou may obtain the `OAuth2AccessToken` as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic class OAuth2ResourceServerController {\n\n\t@Autowired\n\tprivate OAuth2AuthorizedClientManager authorizedClientManager;\n\n\t@GetMapping(\"/resource\")\n\tpublic String resource(JwtAuthenticationToken jwtAuthentication) {\n OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(jwtAuthentication)\n .build();\n OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);\n OAuth2AccessToken accessToken = authorizedClient.getAccessToken();\n\n // ...\n\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass OAuth2ResourceServerController {\n\n @Autowired\n private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager\n\n @GetMapping(\"/resource\")\n fun resource(jwtAuthentication: JwtAuthenticationToken?): String {\n val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(jwtAuthentication)\n .build()\n val authorizedClient = authorizedClientManager.authorize(authorizeRequest)\n val accessToken: OAuth2AccessToken = authorizedClient.accessToken\n\n // ...\n\n }\n}\n----\n======\n\n[NOTE]\n====\n`JwtBearerOAuth2AuthorizedClientProvider` resolves the `Jwt` assertion via `OAuth2AuthorizationContext.getPrincipal().getPrincipal()` by default, hence the use of `JwtAuthenticationToken` in the preceding example.\n====\n\n[TIP]\n====\nIf you need to resolve the `Jwt` assertion from a different source, you can provide `JwtBearerOAuth2AuthorizedClientProvider.setJwtAssertionResolver()` with a custom `Function<OAuth2AuthorizationContext, Jwt>`.\n====\n\n[[oauth2-client-token-exchange]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Using the Access Token", "heading_level": 3, "file_order": 141, "section_index": 18, "content_hash": "a6103f7d85fe12195a671042cc64a9f2013d7777b527500b7dfa633c436fc8fc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:c1f31ddbd94cd9306b603897ca70077d0bca5a9deabc4b11835251b17c89625e", "content": "[NOTE]\n====\nPlease refer to OAuth 2.0 Token Exchange for further details on the https://datatracker.ietf.org/doc/html/rfc8693[Token Exchange] grant.\n====\n\n[[oauth2-client-token-exchange-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "[[oauth2Client-token-exchange-grant]]Token Exchange", "heading_level": 2, "file_order": 141, "section_index": 19, "content_hash": "c1f31ddbd94cd9306b603897ca70077d0bca5a9deabc4b11835251b17c89625e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:ec357a8f89103cffb24e62e8bdec0afd1dcd09c2852ddadea32950c925b45893", "content": "[NOTE]\n====\nPlease refer to the https://datatracker.ietf.org/doc/html/rfc8693#section-2[Token Exchange Request and Response] protocol flow for the Token Exchange grant.\n====\n\nThe default implementation of `OAuth2AccessTokenResponseClient` for the Token Exchange grant is `RestClientTokenExchangeTokenResponseClient`, which uses a `RestClient` instance to obtain an access token at the Authorization Servers Token Endpoint.\n\n`{class-name}` is very flexible and provides several options for customizing the OAuth 2.0 Access Token request and response for the {grant-type} grant.\nChoose from the following use cases to learn more:\n\n* I want to <<oauth2-client-{section-id}-access-token-request-headers,customize headers of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-request-parameters,customize parameters of the Access Token request>>\n* I want to <<oauth2-client-{section-id}-access-token-response-rest-client,customize the instance of `RestClient` that is used>>\n* I want to <<oauth2-client-{section-id}-access-token-response-parameters,customize parameters of the Access Token response>>\n* I want to <<oauth2-client-{section-id}-access-token-response-errors,customize error handling of the Access Token response>>\n\n[#oauth2-client-{section-id}-access-token-request]\n== Customizing the Access Token Request\n\n`{class-name}` provides hooks for customizing HTTP headers and request parameters of the OAuth 2.0 Access Token Request.\n\n[#oauth2-client-{section-id}-access-token-request-headers]\n=== Customizing Request Headers\n\nThere are two options for customizing HTTP headers:\n\n* Add additional headers by calling `addHeadersConverter()`\n* Fully customize headers by calling `setHeadersConverter()`\n\nYou can include additional headers without affecting the default headers added to every request using `addHeadersConverter()`.\nThe following example adds a `User-Agent` header to the request when the `registrationId` is `spring`:\n\n.Include Additional HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addHeadersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tHttpHeaders headers = new HttpHeaders();\n\tif (clientRegistration.getRegistrationId().equals(\"spring\")) {\n\t\theaders.set(HttpHeaders.USER_AGENT, \"my-user-agent\");\n\t}\n\treturn headers;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addHeadersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval headers = HttpHeaders()\n\tif (clientRegistration.getRegistrationId() == \"spring\") {\n        headers[HttpHeaders.USER_AGENT] = \"my-user-agent\"\n\t}\n\theaders\n}\n----\n======\n\nYou can fully customize headers by re-using `DefaultOAuth2TokenRequestHeadersConverter` or providing a custom implementation using `setHeadersConverter()`.\nThe following example re-uses `DefaultOAuth2TokenRequestHeadersConverter` and disables `encodeClientCredentials` so that HTTP Basic credentials are no longer encoded with `application/x-www-form-urlencoded`:\n\n.Customize HTTP Headers\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter headersConverter =\n\tnew DefaultOAuth2TokenRequestHeadersConverter();\nheadersConverter.setEncodeClientCredentials(false);\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter()\nheadersConverter.setEncodeClientCredentials(false)\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[#oauth2-client-{section-id}-access-token-request-parameters]\n=== Customizing Request Parameters\n\nThere are three options for customizing request parameters:\n\n* Add additional parameters by calling `addParametersConverter()`\n* Override parameters by calling `setParametersConverter()`\n* Fully customize parameters by calling `setParametersCustomizer()`\n\n[NOTE]\n====\nUsing `setParametersConverter()` does not fully customize parameters because it would require the user to provide all default parameters themselves.\nDefault parameters are always provided, but can be fully customized or omitted by calling `setParametersCustomizer()`.\n====\n\nYou can include additional parameters without affecting the default parameters added to every request using `addParametersConverter()`.\nThe following example adds an `audience` parameter to the request when the `registrationId` is `keycloak`:\n\n.Include Additional Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.addParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tMultiValueMap<String, String> parameters = new LinkedMultiValueMap<String, String>();\n\tif (clientRegistration.getRegistrationId().equals(\"keycloak\")) {\n\t\tparameters.set(OAuth2ParameterNames.AUDIENCE, \"my-audience\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.addParametersConverter { grantRequest ->\n\tval clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"keycloak\") {\n        parameters[OAuth2ParameterNames.AUDIENCE] = \"my-audience\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can override default parameters using `setParametersConverter()`.\nThe following example overrides the `client_id` parameter when the `registrationId` is `okta`:\n\n.Override Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersConverter(grantRequest -> {\n\tClientRegistration clientRegistration = grantRequest.getClientRegistration();\n\tLinkedMultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n\tif (clientRegistration.getRegistrationId().equals(\"okta\")) {\n\t\tparameters.set(OAuth2ParameterNames.CLIENT_ID, \"my-client\");\n\t}\n\treturn parameters;\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval parametersConverter = DefaultOAuth2TokenRequestParametersConverter<{grant-request}>()\nparametersConverter.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersConverter { grantRequest ->\n    val clientRegistration = grantRequest.getClientRegistration()\n\tval parameters = LinkedMultiValueMap<String, String>()\n\tif (clientRegistration.getRegistrationId() == \"okta\") {\n        parameters[OAuth2ParameterNames.CLIENT_ID] = \"my-client\"\n\t}\n\tparameters\n}\n----\n======\n\nYou can fully customize parameters (including omitting default parameters) using `setParametersCustomizer()`.\nThe following example omits the `client_id` parameter when the `client_assertion` parameter is present in the request:\n\n.Omit Request Parameters\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setParametersCustomizer(parameters -> {\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID);\n\t}\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setParametersCustomizer { parameters ->\n\tif (parameters.containsKey(OAuth2ParameterNames.CLIENT_ASSERTION)) {\n\t\tparameters.remove(OAuth2ParameterNames.CLIENT_ID)\n\t}\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response]\n== Customizing the Access Token Response\n\n`{class-name}` provides hooks for customizing response parameters and error handling of the OAuth 2.0 Access Token Response.\n\n[#oauth2-client-{section-id}-access-token-response-rest-client]\n=== Customizing the `RestClient`\n\nYou can customize the Token Response by providing a pre-configured `RestClient` to `setRestClient()`.\nThe default `RestClient` is configured as follows:\n\n.Default `RestClient` Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"+attributes\"]\n----\nRestClient restClient = RestClient.builder()\n\t.messageConverters(messageConverters -> {\n\t\tmessageConverters.clear();\n\t\tmessageConverters.add(new FormHttpMessageConverter());\n\t\tmessageConverters.add(new OAuth2AccessTokenResponseHttpMessageConverter());\n\t})\n\t.defaultStatusHandler(new OAuth2ErrorResponseErrorHandler())\n\t.build();\n\n{class-name} accessTokenResponseClient =\n\tnew {class-name}();\naccessTokenResponseClient.setRestClient(restClient);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"+attributes\"]\n----\nval restClient = RestClient.builder()\n\t.messageConverters { messageConverters ->\n\t\tmessageConverters.clear()\n\t\tmessageConverters.add(FormHttpMessageConverter())\n\t\tmessageConverters.add(OAuth2AccessTokenResponseHttpMessageConverter())\n\t}\n\t.defaultStatusHandler(OAuth2ErrorResponseErrorHandler())\n\t.build()\n\nval accessTokenResponseClient = {class-name}()\naccessTokenResponseClient.setRestClient(restClient)\n----\n======\n\n`OAuth2AccessTokenResponseHttpMessageConverter` is an `HttpMessageConverter` for an OAuth 2.0 Access Token Response.\nYou can customize the conversion of Token Response parameters to an `OAuth2AccessTokenResponse` by calling `setAccessTokenResponseConverter()`.\nThe default implementation is `DefaultMapOAuth2AccessTokenResponseConverter`.\n\n`OAuth2ErrorResponseErrorHandler` is a `ResponseErrorHandler` that can handle an OAuth 2.0 Error, such as `400 Bad Request`.\nIt uses an `OAuth2ErrorHttpMessageConverter` for converting the OAuth 2.0 Error parameters to an `OAuth2Error`.\nYou can customize the conversion of Token Response parameters to an `OAuth2Error` by calling `setErrorConverter()`.\n\n[TIP]\n====\nSpring MVC `FormHttpMessageConverter` is required, as it is used when sending the OAuth 2.0 Access Token Request.\n====\n\n[#oauth2-client-{section-id}-access-token-response-parameters]\n=== Customizing Response Parameters\n\nThe following example provides a starting point for customizing the conversion of Token Response parameters to an `OAuth2AccessTokenResponse`:\n\n.Customize Access Token Response Converter\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2AccessTokenResponseHttpMessageConverter accessTokenResponseMessageConverter =\n\tnew OAuth2AccessTokenResponseHttpMessageConverter();\naccessTokenResponseMessageConverter.setAccessTokenResponseConverter(parameters -> {\n\t// ...\n\treturn OAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t// ...\n\t\t.build();\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval accessTokenResponseMessageConverter = OAuth2AccessTokenResponseHttpMessageConverter()\naccessTokenResponseMessageConverter.setAccessTokenResponseConverter { parameters ->\n\t// ...\n\treturn OAuth2AccessTokenResponse.withToken(\"custom-token\")\n\t\t// ...\n\t\t.build()\n}\n----\n======\n\n[#oauth2-client-{section-id}-access-token-response-errors]\n=== Customizing Error Handling\n\nThe following example provides a starting point for customizing the conversion of Error parameters to an `OAuth2Error`:\n\n.Customize Access Token Error Handler\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2ErrorHttpMessageConverter errorConverter =\n\tnew OAuth2ErrorHttpMessageConverter();\nerrorConverter.setErrorConverter(parameters -> {\n\t// ...\n\treturn new OAuth2Error(\"custom-error\", \"custom description\", \"custom-uri\");\n});\n\nOAuth2ErrorResponseErrorHandler errorHandler =\n\tnew OAuth2ErrorResponseErrorHandler();\nerrorHandler.setErrorConverter(errorConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval errorConverter = OAuth2ErrorHttpMessageConverter()\nerrorConverter.setErrorConverter { parameters ->\n\t// ...\n\treturn OAuth2Error(\"custom-error\", \"custom description\", \"custom-uri\")\n}\n\nval errorHandler = OAuth2ErrorResponseErrorHandler()\nerrorHandler.setErrorConverter(errorConverter)\n----\n======\n\n[[oauth2-client-token-exchange-authorized-client-provider-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Requesting an Access Token", "heading_level": 3, "file_order": 141, "section_index": 20, "content_hash": "ec357a8f89103cffb24e62e8bdec0afd1dcd09c2852ddadea32950c925b45893", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:923f78666e72b1f669429824a7df9cd874bc4254fc662f090ee4a140508b9083", "content": "Whether you customize `RestClientTokenExchangeTokenResponseClient` or provide your own implementation of `OAuth2AccessTokenResponseClient`, you can configure it using the `OAuth2AuthorizedClientProviderBuilder` (as an alternative to <<oauth2-client-token-exchange-access-token-response-client-bean,publishing a bean>>) as follows:\n\n.Access Token Response Configuration via Builder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> tokenExchangeTokenResponseClient = ...\n\nTokenExchangeOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider = new TokenExchangeOAuth2AuthorizedClientProvider();\ntokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeTokenResponseClient);\n\nOAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .provider(tokenExchangeAuthorizedClientProvider)\n .build();\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval tokenExchangeTokenResponseClient: OAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> = ...\n\nval tokenExchangeAuthorizedClientProvider = TokenExchangeOAuth2AuthorizedClientProvider()\ntokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeTokenResponseClient)\n\nval authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .provider(tokenExchangeAuthorizedClientProvider)\n .build()\n\nauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n----\n======\n\n[[oauth2-client-token-exchange-authorized-client-manager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "Customize using the Builder", "heading_level": 3, "file_order": 141, "section_index": 21, "content_hash": "923f78666e72b1f669429824a7df9cd874bc4254fc662f090ee4a140508b9083", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:1ee18d9b9c20b547bfe9ef801fad2bc2a0291380e2b4eaf0ce5dd96eb4043882", "content": "Given the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n authorization-grant-type: urn:ietf:params:oauth:grant-type:token-exchange\n scope: read\n provider:\n okta:\n token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token\n----\n\n...and the `OAuth2AuthorizedClientManager` `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic OAuth2AuthorizedClientManager authorizedClientManager(\n ClientRegistrationRepository clientRegistrationRepository,\n OAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tTokenExchangeOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider =\n new TokenExchangeOAuth2AuthorizedClientProvider();\n\n\tOAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .provider(tokenExchangeAuthorizedClientProvider)\n .build();\n\n\tDefaultOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ClientRegistrationRepository,\n authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {\n val tokenExchangeAuthorizedClientProvider = TokenExchangeOAuth2AuthorizedClientProvider()\n val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .provider(tokenExchangeAuthorizedClientProvider)\n .build()\n val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======\n\nYou may obtain the `OAuth2AccessToken` as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic class OAuth2ResourceServerController {\n\n\t@Autowired\n\tprivate OAuth2AuthorizedClientManager authorizedClientManager;\n\n\t@GetMapping(\"/resource\")\n\tpublic String resource(JwtAuthenticationToken jwtAuthentication) {\n OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(jwtAuthentication)\n .build();\n OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);\n OAuth2AccessToken accessToken = authorizedClient.getAccessToken();\n\n // ...\n\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass OAuth2ResourceServerController {\n\n @Autowired\n private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager\n\n @GetMapping(\"/resource\")\n fun resource(jwtAuthentication: JwtAuthenticationToken?): String {\n val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId(\"okta\")\n .principal(jwtAuthentication)\n .build()\n val authorizedClient = authorizedClientManager.authorize(authorizeRequest)\n val accessToken: OAuth2AccessToken = authorizedClient.accessToken\n\n // ...\n\n }\n}\n----\n======\n\n[NOTE]\n====\n`TokenExchangeOAuth2AuthorizedClientProvider` resolves the subject token (as an `OAuth2Token`) via `OAuth2AuthorizationContext.getPrincipal().getPrincipal()` by default, hence the use of `JwtAuthenticationToken` in the preceding example.\nAn actor token is not resolved by default.\n====\n\n[TIP]\n====\nIf you need to resolve the subject token from a different source, you can provide `TokenExchangeOAuth2AuthorizedClientProvider.setSubjectTokenResolver()` with a custom `Function<OAuth2AuthorizationContext, OAuth2Token>`.\n====\n\n[TIP]\n====\nIf you need to resolve an actor token, you can provide `TokenExchangeOAuth2AuthorizedClientProvider.setActorTokenResolver()` with a custom `Function<OAuth2AuthorizationContext, OAuth2Token>`.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc", "title": "authorization-grants", "heading": "[[token-exchange-grant-access-token]]Using the Access Token", "heading_level": 3, "file_order": 141, "section_index": 22, "content_hash": "1ee18d9b9c20b547bfe9ef801fad2bc2a0291380e2b4eaf0ce5dd96eb4043882", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorization-grants.adoc"}}
{"id": "sha256:8cacad1bdbc23ed93549e657e81bb01b603685fae75c29379b125c2f1eb7507a", "content": "[[oauth2-client-additional-features]]\n\nThis section covers additional features provided by Spring Security for OAuth2 client.\n\n[[oauth2-client-registered-authorized-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "authorized-clients", "heading_level": 1, "file_order": 142, "section_index": 0, "content_hash": "8cacad1bdbc23ed93549e657e81bb01b603685fae75c29379b125c2f1eb7507a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:1c1bd2704472d448ec6834e760c49ab17a609f166797869abd59f33519ca7a95", "content": "The `@RegisteredOAuth2AuthorizedClient` annotation provides the ability to resolve a method parameter to an argument value of type `OAuth2AuthorizedClient`.\nThis is a convenient alternative compared to accessing the `OAuth2AuthorizedClient` by using the `OAuth2AuthorizedClientManager` or `OAuth2AuthorizedClientService`.\nThe following example shows how to use `@RegisteredOAuth2AuthorizedClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class OAuth2ClientController {\n\n\t@GetMapping(\"/\")\n\tpublic String index(@RegisteredOAuth2AuthorizedClient(\"okta\") OAuth2AuthorizedClient authorizedClient) {\n OAuth2AccessToken accessToken = authorizedClient.getAccessToken();\n\n ...\n\n return \"index\";\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nclass OAuth2ClientController {\n @GetMapping(\"/\")\n fun index(@RegisteredOAuth2AuthorizedClient(\"okta\") authorizedClient: OAuth2AuthorizedClient): String {\n val accessToken = authorizedClient.accessToken\n\n ...\n\n return \"index\"\n }\n}\n----\n======\n\nThe `@RegisteredOAuth2AuthorizedClient` annotation is handled by `OAuth2AuthorizedClientArgumentResolver`, which directly uses an xref:servlet/oauth2/client/core.adoc#oauth2Client-authorized-manager-provider[`OAuth2AuthorizedClientManager`] and, therefore, inherits its capabilities.\n\n[[oauth2-client-rest-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "[[oauth2Client-registered-authorized-client]]Resolving an Authorized Client", "heading_level": 2, "file_order": 142, "section_index": 1, "content_hash": "1c1bd2704472d448ec6834e760c49ab17a609f166797869abd59f33519ca7a95", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:412a6bc494322ed14752d6a43e20733be1fa3160e65f2a60dff32dc464f6ca63", "content": "Support for `RestClient` is provided by `OAuth2ClientHttpRequestInterceptor`.\nThis interceptor provides the ability to make protected resources requests by placing a `Bearer` token in the `Authorization` header of an outbound request.\nThe interceptor directly uses an `OAuth2AuthorizedClientManager` and therefore inherits the following capabilities:\n\n* Performs an OAuth 2.0 Access Token request to obtain `OAuth2AccessToken` if the client has not yet been authorized\n** `authorization_code`: Triggers the Authorization Request redirect to initiate the flow\n** `client_credentials`: The access token is obtained directly from the Token Endpoint\n** Additional grant types are supported by xref:servlet/oauth2/index.adoc#oauth2-client-enable-extension-grant-type[enabling extension grant types]\n* If an existing `OAuth2AccessToken` is expired, it is refreshed (or renewed)\n\nThe following example uses the default `OAuth2AuthorizedClientManager` to configure a `RestClient` capable of accessing protected resources by placing `Bearer` tokens in the `Authorization` header of each request:\n\n.Configure `RestClient` with `ClientHttpRequestInterceptor`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class RestClientConfig {\n\n\t@Bean\n\tpublic RestClient restClient(OAuth2AuthorizedClientManager authorizedClientManager) {\n OAuth2ClientHttpRequestInterceptor requestInterceptor =\n new OAuth2ClientHttpRequestInterceptor(authorizedClientManager);\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass RestClientConfig {\n\n\t@Bean\n\tfun restClient(authorizedClientManager: OAuth2AuthorizedClientManager): RestClient {\n val requestInterceptor = OAuth2ClientHttpRequestInterceptor(authorizedClientManager)\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build()\n\t}\n\n}\n----\n=====\n\n[[oauth2-client-rest-client-registration-id]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "RestClient Integration", "heading_level": 2, "file_order": 142, "section_index": 2, "content_hash": "412a6bc494322ed14752d6a43e20733be1fa3160e65f2a60dff32dc464f6ca63", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:13df2014c0afe2bbef0a5828f533250543ccb0e540df7a06f34dd63f75514c87", "content": "`OAuth2ClientHttpRequestInterceptor` uses a `ClientRegistrationIdResolver` to determine which client is used to obtain an access token.\nBy default, `RequestAttributeClientRegistrationIdResolver` is used to resolve the `clientRegistrationId` from `HttpRequest#attributes()`.\n\nThe following example demonstrates providing a `clientRegistrationId` via attributes:\n\n.Provide `clientRegistrationId` via attributes\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.client.web.client.RequestAttributeClientRegistrationIdResolver.clientRegistrationId;\n\n@Controller\npublic class ResourceController {\n\n\tprivate final RestClient restClient;\n\n\tpublic ResourceController(RestClient restClient) {\n this.restClient = restClient;\n\t}\n\n\t@GetMapping(\"/\")\n\tpublic String index() {\n String resourceUri = \"...\";\n\n String body = this.restClient.get()\n .uri(resourceUri)\n .attributes(clientRegistrationId(\"okta\")) // <1>\n .retrieve()\n .body(String.class);\n\n // ...\n\n return \"index\";\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.client.web.client.RequestAttributeClientRegistrationIdResolver.clientRegistrationId\nimport org.springframework.web.client.body\n\n@Controller\nclass ResourceController(private restClient: RestClient) {\n\n\t@GetMapping(\"/\")\n\tfun index(): String {\n val resourceUri = \"...\"\n\n val body: String = restClient.get()\n .uri(resourceUri)\n .attributes(clientRegistrationId(\"okta\")) // <1>\n .retrieve()\n .body<String>()\n\n // ...\n\n return \"index\"\n\t}\n\n}\n----\n======\n<1> `clientRegistrationId()` is a `static` method in `RequestAttributeClientRegistrationIdResolver`.\n\nAlternatively, a custom `ClientRegistrationIdResolver` can be provided.\nThe following example configures a custom implementation that resolves the `clientRegistrationId` from the current user.\n\n.Configure `ClientHttpRequestInterceptor` with custom `ClientRegistrationIdResolver`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class RestClientConfig {\n\n\t@Bean\n\tpublic RestClient restClient(OAuth2AuthorizedClientManager authorizedClientManager) {\n OAuth2ClientHttpRequestInterceptor requestInterceptor =\n new OAuth2ClientHttpRequestInterceptor(authorizedClientManager);\n requestInterceptor.setClientRegistrationIdResolver(clientRegistrationIdResolver());\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build();\n\t}\n\n\tprivate static ClientRegistrationIdResolver clientRegistrationIdResolver() {\n return (request) -> {\n Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n return (authentication instanceof OAuth2AuthenticationToken principal)\n ? principal.getAuthorizedClientRegistrationId() : null;\n };\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass RestClientConfig {\n\n\t@Bean\n\tfun restClient(authorizedClientManager: OAuth2AuthorizedClientManager): RestClient {\n val requestInterceptor = OAuth2ClientHttpRequestInterceptor(authorizedClientManager)\n requestInterceptor.setClientRegistrationIdResolver(clientRegistrationIdResolver())\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build()\n\t}\n\n\tfun clientRegistrationIdResolver(): ClientRegistrationIdResolver {\n return ClientRegistrationIdResolver { request ->\n val authentication = SecurityContextHolder.getContext().getAuthentication()\n return if (authentication instanceof OAuth2AuthenticationToken) {\n authentication.getAuthorizedClientRegistrationId()\n } else {\n null\n }\n }\n\t}\n\n}\n----\n=====\n\n[[oauth2-client-rest-client-principal]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "Providing the `clientRegistrationId`", "heading_level": 3, "file_order": 142, "section_index": 3, "content_hash": "13df2014c0afe2bbef0a5828f533250543ccb0e540df7a06f34dd63f75514c87", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:7df4e6fcc685eb35efc1820f2f64a8ccdbc00bf0f0cac95ad4e38225478b26c9", "content": "`OAuth2ClientHttpRequestInterceptor` uses a `PrincipalResolver` to determine which principal name is associated with the access token, which allows an application to choose how to scope the `OAuth2AuthorizedClient` that is stored.\nBy default, `SecurityContextHolderPrincipalResolver` is used to resolve the current `principal` from the `SecurityContextHolder`.\n\nAlternatively, the `principal` can be resolved from `HttpRequest#attributes()` by configuring `RequestAttributePrincipalResolver`, as the following example shows:\n\n.Configure `ClientHttpRequestInterceptor` with `RequestAttributePrincipalResolver`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class RestClientConfig {\n\n\t@Bean\n\tpublic RestClient restClient(OAuth2AuthorizedClientManager authorizedClientManager) {\n OAuth2ClientHttpRequestInterceptor requestInterceptor =\n new OAuth2ClientHttpRequestInterceptor(authorizedClientManager);\n requestInterceptor.setPrincipalResolver(new RequestAttributePrincipalResolver());\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass RestClientConfig {\n\n\t@Bean\n\tfun restClient(authorizedClientManager: OAuth2AuthorizedClientManager): RestClient {\n val requestInterceptor = OAuth2ClientHttpRequestInterceptor(authorizedClientManager)\n requestInterceptor.setPrincipalResolver(RequestAttributePrincipalResolver())\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build()\n\t}\n\n}\n----\n=====\n\nThe following example demonstrates providing a `principal` name via attributes that scopes the `OAuth2AuthorizedClient` to the application instead of the current user:\n\n.Provide `principal` name via attributes\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.client.web.client.RequestAttributeClientRegistrationIdResolver.clientRegistrationId;\nimport static org.springframework.security.oauth2.client.web.client.RequestAttributePrincipalResolver.principal;\n\n@Controller\npublic class ResourceController {\n\n\tprivate final RestClient restClient;\n\n\tpublic ResourceController(RestClient restClient) {\n this.restClient = restClient;\n\t}\n\n\t@GetMapping(\"/\")\n\tpublic String index() {\n String resourceUri = \"...\";\n\n String body = this.restClient.get()\n .uri(resourceUri)\n .attributes(clientRegistrationId(\"okta\"))\n .attributes(principal(\"my-application\")) // <1>\n .retrieve()\n .body(String.class);\n\n // ...\n\n return \"index\";\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.client.web.client.RequestAttributeClientRegistrationIdResolver.clientRegistrationId\nimport org.springframework.security.oauth2.client.web.client.RequestAttributePrincipalResolver.principal\nimport org.springframework.web.client.body\n\n@Controller\nclass ResourceController(private restClient: RestClient) {\n\n @GetMapping(\"/\")\n\tfun index(): String {\n val resourceUri = \"...\"\n\n val body: String = restClient.get()\n .uri(resourceUri)\n .attributes(clientRegistrationId(\"okta\"))\n .attributes(principal(\"my-application\")) // <1>\n .retrieve()\n .body<String>()\n\n // ...\n\n return \"index\"\n\t}\n\n}\n----\n======\n<1> `principal()` is a `static` method in `RequestAttributePrincipalResolver`.\n\n[[oauth2-client-rest-client-authorization-failure-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "Providing the `principal`", "heading_level": 3, "file_order": 142, "section_index": 4, "content_hash": "7df4e6fcc685eb35efc1820f2f64a8ccdbc00bf0f0cac95ad4e38225478b26c9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:671e91c4c532300572d06687c8307f842056c9d5a03fe1d89e6a1fc1ea46290a", "content": "If an access token is invalid for any reason (e.g. expired token), it can be beneficial to handle the failure by removing the access token so that it cannot be used again.\nYou can set up the interceptor to do this automatically by providing an `OAuth2AuthorizationFailureHandler` to remove the access token.\n\nThe following example uses an `OAuth2AuthorizedClientRepository` to set up an `OAuth2AuthorizationFailureHandler` that removes an invalid `OAuth2AuthorizedClient` *within* the context of an `HttpServletRequest`:\n\n.Configure `OAuth2AuthorizationFailureHandler` using `OAuth2AuthorizedClientRepository`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class RestClientConfig {\n\n\t@Bean\n\tpublic RestClient restClient(OAuth2AuthorizedClientManager authorizedClientManager,\n OAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n OAuth2ClientHttpRequestInterceptor requestInterceptor =\n new OAuth2ClientHttpRequestInterceptor(authorizedClientManager);\n\n OAuth2AuthorizationFailureHandler authorizationFailureHandler =\n OAuth2ClientHttpRequestInterceptor.authorizationFailureHandler(authorizedClientRepository);\n requestInterceptor.setAuthorizationFailureHandler(authorizationFailureHandler);\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass RestClientConfig {\n\n\t@Bean\n\tfun restClient(authorizedClientManager: OAuth2AuthorizedClientManager,\n authorizedClientRepository: OAuth2AuthorizedClientRepository): RestClient {\n\n val requestInterceptor = OAuth2ClientHttpRequestInterceptor(authorizedClientManager)\n\n val authorizationFailureHandler = OAuth2ClientHttpRequestInterceptor\n .authorizationFailureHandler(authorizedClientRepository)\n requestInterceptor.setAuthorizationFailureHandler(authorizationFailureHandler)\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build()\n\t}\n\n}\n----\n=====\n\nAlternatively, an `OAuth2AuthorizedClientService` can be used to remove an invalid `OAuth2AuthorizedClient` *outside* the context of an `HttpServletRequest`, as the following example shows:\n\n.Configure `OAuth2AuthorizationFailureHandler` using `OAuth2AuthorizedClientService`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class RestClientConfig {\n\n\t@Bean\n\tpublic RestClient restClient(OAuth2AuthorizedClientManager authorizedClientManager,\n OAuth2AuthorizedClientService authorizedClientService) {\n\n OAuth2ClientHttpRequestInterceptor requestInterceptor =\n new OAuth2ClientHttpRequestInterceptor(authorizedClientManager);\n\n OAuth2AuthorizationFailureHandler authorizationFailureHandler =\n OAuth2ClientHttpRequestInterceptor.authorizationFailureHandler(authorizedClientService);\n requestInterceptor.setAuthorizationFailureHandler(authorizationFailureHandler);\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass RestClientConfig {\n\n\t@Bean\n\tfun restClient(authorizedClientManager: OAuth2AuthorizedClientManager,\n authorizedClientService: OAuth2AuthorizedClientService): RestClient {\n\n val requestInterceptor = OAuth2ClientHttpRequestInterceptor(authorizedClientManager)\n\n val authorizationFailureHandler = OAuth2ClientHttpRequestInterceptor\n .authorizationFailureHandler(authorizedClientService)\n requestInterceptor.setAuthorizationFailureHandler(authorizationFailureHandler)\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build()\n\t}\n\n}\n----\n=====\n\n[[oauth2-client-rest-client-interface]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "Handling Failure", "heading_level": 3, "file_order": 142, "section_index": 5, "content_hash": "671e91c4c532300572d06687c8307f842056c9d5a03fe1d89e6a1fc1ea46290a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:c054e74ec84af9f5fd80ce850d1d47eb57067d3cc3edac631b44294a683ec9b9", "content": "Spring Security's OAuth support integrates with xref:features/integrations/rest/http-service-client.adoc[].\n\n[[oauth2-client-web-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "HTTP Service Clients", "heading_level": 3, "file_order": 142, "section_index": 6, "content_hash": "c054e74ec84af9f5fd80ce850d1d47eb57067d3cc3edac631b44294a683ec9b9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:cc58cc9c2ba08f22f0b29d63b3e326b667fae08f7e1882edf0a588b6a4c54a50", "content": "The OAuth 2.0 Client support integrates with `WebClient` by using an `ExchangeFilterFunction`.\n\nThe `ServletOAuth2AuthorizedClientExchangeFilterFunction` provides a mechanism for requesting protected resources by using an `OAuth2AuthorizedClient` and including the associated `OAuth2AccessToken` as a Bearer Token.\nIt directly uses an xref:servlet/oauth2/client/core.adoc#oauth2Client-authorized-manager-provider[`OAuth2AuthorizedClientManager`] and, therefore, inherits the following capabilities:\n\n* An `OAuth2AccessToken` is requested if the client has not yet been authorized.\n** `authorization_code`: Triggers the Authorization Request redirect to initiate the flow.\n** `client_credentials`: The access token is obtained directly from the Token Endpoint.\n* If the `OAuth2AccessToken` is expired, it is refreshed (or renewed) if an `OAuth2AuthorizedClientProvider` is available to perform the authorization\n\nThe following code shows an example of how to configure `WebClient` with OAuth 2.0 Client support:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nWebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {\n\tServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =\n new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);\n\treturn WebClient.builder()\n .apply(oauth2Client.oauth2Configuration())\n .build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {\n val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)\n return WebClient.builder()\n .apply(oauth2Client.oauth2Configuration())\n .build()\n}\n----\n======\n\n[[oauth2-client-web-client-authorized-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "[[oauth2Client-webclient-servlet]]WebClient Integration for Servlet Environments", "heading_level": 2, "file_order": 142, "section_index": 7, "content_hash": "cc58cc9c2ba08f22f0b29d63b3e326b667fae08f7e1882edf0a588b6a4c54a50", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:61050d1179c39f89b588ca5e3412ab3984f08704093d4ed6d08df0e343be8e98", "content": "The `ServletOAuth2AuthorizedClientExchangeFilterFunction` determines the client to use (for a request) by resolving the `OAuth2AuthorizedClient` from the `ClientRequest.attributes()` (request attributes).\n\nThe following code shows how to set an `OAuth2AuthorizedClient` as a request attribute:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/\")\npublic String index(@RegisteredOAuth2AuthorizedClient(\"okta\") OAuth2AuthorizedClient authorizedClient) {\n\tString resourceUri = ...\n\n\tString body = webClient\n .get()\n .uri(resourceUri)\n .attributes(oauth2AuthorizedClient(authorizedClient)) <1>\n .retrieve()\n .bodyToMono(String.class)\n .block();\n\n\t...\n\n\treturn \"index\";\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/\")\nfun index(@RegisteredOAuth2AuthorizedClient(\"okta\") authorizedClient: OAuth2AuthorizedClient): String {\n val resourceUri: String = ...\n val body: String = webClient\n .get()\n .uri(resourceUri)\n .attributes(oauth2AuthorizedClient(authorizedClient)) <1>\n .retrieve()\n .bodyToMono()\n .block()\n\n ...\n\n return \"index\"\n}\n----\n======\n<1> `oauth2AuthorizedClient()` is a `static` method in `ServletOAuth2AuthorizedClientExchangeFilterFunction`.\n\nThe following code shows how to set the `ClientRegistration.getRegistrationId()` as a request attribute:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/\")\npublic String index() {\n\tString resourceUri = ...\n\n\tString body = webClient\n .get()\n .uri(resourceUri)\n .attributes(clientRegistrationId(\"okta\")) <1>\n .retrieve()\n .bodyToMono(String.class)\n .block();\n\n\t...\n\n\treturn \"index\";\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/\")\nfun index(): String {\n val resourceUri: String = ...\n\n val body: String = webClient\n .get()\n .uri(resourceUri)\n .attributes(clientRegistrationId(\"okta\")) <1>\n .retrieve()\n .bodyToMono()\n .block()\n\n ...\n\n return \"index\"\n}\n----\n======\n<1> `clientRegistrationId()` is a `static` method in `ServletOAuth2AuthorizedClientExchangeFilterFunction`.\n\nThe following code shows how to set an `Authentication` as a request attribute:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/\")\npublic String index() {\n\tString resourceUri = ...\n\n\tAuthentication anonymousAuthentication = new AnonymousAuthenticationToken(\n \"anonymous\", \"anonymousUser\", AuthorityUtils.createAuthorityList(\"ROLE_ANONYMOUS\"));\n\tString body = webClient\n .get()\n .uri(resourceUri)\n .attributes(authentication(anonymousAuthentication)) <1>\n .retrieve()\n .bodyToMono(String.class)\n .block();\n\n\t...\n\n\treturn \"index\";\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/\")\nfun index(): String {\n val resourceUri: String = ...\n\n val anonymousAuthentication: Authentication = AnonymousAuthenticationToken(\n \"anonymous\", \"anonymousUser\", AuthorityUtils.createAuthorityList(\"ROLE_ANONYMOUS\"))\n val body: String = webClient\n .get()\n .uri(resourceUri)\n .attributes(authentication(anonymousAuthentication)) <1>\n .retrieve()\n .bodyToMono()\n .block()\n\n ...\n\n return \"index\"\n}\n----\n======\n<1> `authentication()` is a `static` method in `ServletOAuth2AuthorizedClientExchangeFilterFunction`.\n\n[WARNING]\n====\nIt is recommended to be cautious with this feature since all HTTP requests will receive an access token bound to the provided principal.\n====\n\n[[oauth2-client-web-client-default-authorized-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "Providing the Authorized Client", "heading_level": 3, "file_order": 142, "section_index": 8, "content_hash": "61050d1179c39f89b588ca5e3412ab3984f08704093d4ed6d08df0e343be8e98", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:4e9b01a20000cb506a32101de885dc8eefb0742e542ff50bfc3652f4187d2c09", "content": "If neither `OAuth2AuthorizedClient` or `ClientRegistration.getRegistrationId()` is provided as a request attribute, the `ServletOAuth2AuthorizedClientExchangeFilterFunction` can determine the _default_ client to use, depending on its configuration.\n\nIf `setDefaultOAuth2AuthorizedClient(true)` is configured and the user has authenticated by using `HttpSecurity.oauth2Login()`, the `OAuth2AccessToken` associated with the current `OAuth2AuthenticationToken` is used.\n\nThe following code shows the specific configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nWebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {\n\tServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =\n new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);\n\toauth2Client.setDefaultOAuth2AuthorizedClient(true);\n\treturn WebClient.builder()\n .apply(oauth2Client.oauth2Configuration())\n .build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {\n val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)\n oauth2Client.setDefaultOAuth2AuthorizedClient(true)\n return WebClient.builder()\n .apply(oauth2Client.oauth2Configuration())\n .build()\n}\n----\n======\n\n[WARNING]\n====\nBe cautious with this feature, since all HTTP requests receive the access token.\n====\n\nAlternatively, if `setDefaultClientRegistrationId(\"okta\")` is configured with a valid `ClientRegistration`, the `OAuth2AccessToken` associated with the `OAuth2AuthorizedClient` is used.\n\nThe following code shows the specific configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nWebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {\n\tServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =\n new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);\n\toauth2Client.setDefaultClientRegistrationId(\"okta\");\n\treturn WebClient.builder()\n .apply(oauth2Client.oauth2Configuration())\n .build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {\n val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)\n oauth2Client.setDefaultClientRegistrationId(\"okta\")\n return WebClient.builder()\n .apply(oauth2Client.oauth2Configuration())\n .build()\n}\n----\n======\n\n[WARNING]\n====\nBe cautious with this feature, since all HTTP requests receive the access token.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc", "title": "authorized-clients", "heading": "Defaulting the Authorized Client", "heading_level": 3, "file_order": 142, "section_index": 9, "content_hash": "4e9b01a20000cb506a32101de885dc8eefb0742e542ff50bfc3652f4187d2c09", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/authorized-clients.adoc"}}
{"id": "sha256:b66727c4a75e8782843612c2f90ea595d5dc417fabea5eb2526eab4551f7a49e", "content": "[[oauth2-client-authentication]]\n\n[[oauth2-client-authentication-client-credentials]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "client-authentication", "heading_level": 1, "file_order": 143, "section_index": 0, "content_hash": "b66727c4a75e8782843612c2f90ea595d5dc417fabea5eb2526eab4551f7a49e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:592256d062b53e020403546e838f6f086e3a07ec606ab2409424ee5046436a35", "content": "[[oauth2-client-authentication-client-credentials-client-secret-basic]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "[[oauth2Client-client-credentials-auth]]Client Credentials", "heading_level": 2, "file_order": 143, "section_index": 1, "content_hash": "592256d062b53e020403546e838f6f086e3a07ec606ab2409424ee5046436a35", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:effc213ed44da02a6d32acf87d6d9976c2123d68a6aed0d59e9089e25f8c9d08", "content": "Client Authentication with HTTP Basic is supported out of the box and no customization is necessary to enable it.\nThe default implementation is provided by `DefaultOAuth2TokenRequestHeadersConverter`.\n\nGiven the following Spring Boot properties for an OAuth 2.0 client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: client-id\n client-secret: client-secret\n client-authentication-method: client_secret_basic\n authorization-grant-type: authorization_code\n ...\n----\n\nThe following example shows how to configure `RestClientAuthorizationCodeTokenResponseClient` to disable URL encoding of the client credentials:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nDefaultOAuth2TokenRequestHeadersConverter<OAuth2AuthorizationCodeGrantRequest> headersConverter =\n new DefaultOAuth2TokenRequestHeadersConverter<>();\nheadersConverter.setEncodeClientCredentials(false);\n\nRestClientAuthorizationCodeTokenResponseClient tokenResponseClient =\n new RestClientAuthorizationCodeTokenResponseClient();\ntokenResponseClient.setHeadersConverter(headersConverter);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval headersConverter = DefaultOAuth2TokenRequestHeadersConverter<OAuth2AuthorizationCodeGrantRequest>()\nheadersConverter.setEncodeClientCredentials(false)\n\nval tokenResponseClient = RestClientAuthorizationCodeTokenResponseClient()\ntokenResponseClient.setHeadersConverter(headersConverter)\n----\n======\n\n[[oauth2-client-authentication-client-credentials-client-secret-post]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "Authenticate using `client_secret_basic`", "heading_level": 3, "file_order": 143, "section_index": 2, "content_hash": "effc213ed44da02a6d32acf87d6d9976c2123d68a6aed0d59e9089e25f8c9d08", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:fa10cdc051646f415e594afdc2bef5ebbefdcca6c72a720d646b4fb2a7956641", "content": "Client Authentication with client credentials included in the request-body is supported out of the box and no customization is necessary to enable it.\n\nThe following Spring Boot properties for an OAuth 2.0 client registration demonstrate the configuration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: client-id\n client-secret: client-secret\n client-authentication-method: client_secret_post\n authorization-grant-type: authorization_code\n ...\n----\n\n[[oauth2-client-authentication-jwt-bearer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "Authenticate using `client_secret_post`", "heading_level": 3, "file_order": 143, "section_index": 3, "content_hash": "fa10cdc051646f415e594afdc2bef5ebbefdcca6c72a720d646b4fb2a7956641", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:d550c6fc0e82c2acfddff31a6b3a201090f258c152df04356005e53911be2fc2", "content": "[NOTE]\n====\nPlease refer to JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants for further details on https://datatracker.ietf.org/doc/html/rfc7523#section-2.2[JWT Bearer] Client Authentication.\n====\n\nThe default implementation for JWT Bearer Client Authentication is `NimbusJwtClientAuthenticationParametersConverter`,\nwhich is a `Converter` that customizes the Token Request parameters by adding\na signed JSON Web Token (JWS) in the `client_assertion` parameter.\n\nThe `java.security.PrivateKey` or `javax.crypto.SecretKey` used for signing the JWS\nis supplied by the `com.nimbusds.jose.jwk.JWK` resolver associated with `NimbusJwtClientAuthenticationParametersConverter`.\n\n[[oauth2-client-authentication-jwt-bearer-private-key-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "[[oauth2Client-jwt-bearer-auth]]JWT Bearer", "heading_level": 2, "file_order": 143, "section_index": 4, "content_hash": "d550c6fc0e82c2acfddff31a6b3a201090f258c152df04356005e53911be2fc2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:2c9b956613a5e015f0b2c25263c08cf8af8f7e59b4f75f2297735d435104bc32", "content": "Given the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-authentication-method: private_key_jwt\n authorization-grant-type: authorization_code\n ...\n----\n\nThe following example shows how to configure `RestClientAuthorizationCodeTokenResponseClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nFunction<ClientRegistration, JWK> jwkResolver = (clientRegistration) -> {\n\tif (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) {\n // Assuming RSA key type\n RSAPublicKey publicKey = ...\n RSAPrivateKey privateKey = ...\n return new RSAKey.Builder(publicKey)\n .privateKey(privateKey)\n .keyID(UUID.randomUUID().toString())\n .build();\n\t}\n\treturn null;\n};\n\nRestClientAuthorizationCodeTokenResponseClient tokenResponseClient =\n new RestClientAuthorizationCodeTokenResponseClient();\ntokenResponseClient.addParametersConverter(\n new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwkResolver: Function<ClientRegistration, JWK> =\n Function<ClientRegistration, JWK> { clientRegistration ->\n if (clientRegistration.clientAuthenticationMethod.equals(ClientAuthenticationMethod.PRIVATE_KEY_JWT)) {\n // Assuming RSA key type\n var publicKey: RSAPublicKey\n var privateKey: RSAPrivateKey\n RSAKey.Builder(publicKey) = //...\n .privateKey(privateKey) = //...\n .keyID(UUID.randomUUID().toString())\n .build()\n }\n null\n }\n\nval tokenResponseClient = RestClientAuthorizationCodeTokenResponseClient()\ntokenResponseClient.addParametersConverter(\n NimbusJwtClientAuthenticationParametersConverter(jwkResolver)\n)\n----\n======\n\n[[oauth2-client-authentication-jwt-bearer-client-secret-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "Authenticate using `private_key_jwt`", "heading_level": 3, "file_order": 143, "section_index": 5, "content_hash": "2c9b956613a5e015f0b2c25263c08cf8af8f7e59b4f75f2297735d435104bc32", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:ae1081e6973f98a794766fa05662ea8308d321d87ff40fab1e281228f836be84", "content": "Given the following Spring Boot properties for an OAuth 2.0 Client registration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n client-authentication-method: client_secret_jwt\n authorization-grant-type: client_credentials\n ...\n----\n\nThe following example shows how to configure `RestClientClientCredentialsTokenResponseClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nFunction<ClientRegistration, JWK> jwkResolver = (clientRegistration) -> {\n\tif (clientRegistration.getClientAuthenticationMethod().equals(ClientAuthenticationMethod.CLIENT_SECRET_JWT)) {\n SecretKeySpec secretKey = new SecretKeySpec(\n clientRegistration.getClientSecret().getBytes(StandardCharsets.UTF_8),\n \"HmacSHA256\");\n return new OctetSequenceKey.Builder(secretKey)\n .keyID(UUID.randomUUID().toString())\n .build();\n\t}\n\treturn null;\n};\n\nRestClientClientCredentialsTokenResponseClient tokenResponseClient =\n new RestClientClientCredentialsTokenResponseClient();\ntokenResponseClient.addParametersConverter(\n new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwkResolver = Function<ClientRegistration, JWK?> { clientRegistration: ClientRegistration ->\n if (clientRegistration.clientAuthenticationMethod == ClientAuthenticationMethod.CLIENT_SECRET_JWT) {\n val secretKey = SecretKeySpec(\n clientRegistration.clientSecret.toByteArray(StandardCharsets.UTF_8),\n \"HmacSHA256\"\n )\n OctetSequenceKey.Builder(secretKey)\n .keyID(UUID.randomUUID().toString())\n .build()\n }\n null\n}\n\nval tokenResponseClient = RestClientClientCredentialsTokenResponseClient()\ntokenResponseClient.addParametersConverter(\n NimbusJwtClientAuthenticationParametersConverter(jwkResolver)\n)\n----\n======\n\n[[oauth2-client-authentication-jwt-bearer-assertion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "Authenticate using `client_secret_jwt`", "heading_level": 3, "file_order": 143, "section_index": 6, "content_hash": "ae1081e6973f98a794766fa05662ea8308d321d87ff40fab1e281228f836be84", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:bbb7faed7794646e4361ee65fd17ca4ca4e1a443feed1945a4554d11029f1564", "content": "The JWT produced by `NimbusJwtClientAuthenticationParametersConverter` contains the `iss`, `sub`, `aud`, `jti`, `iat` and `exp` claims by default. You can customize the headers and/or claims by providing a `Consumer<NimbusJwtClientAuthenticationParametersConverter.JwtClientAuthenticationContext<T>>` to `setJwtClientAssertionCustomizer()`. The following example shows how to customize claims of the JWT:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nFunction<ClientRegistration, JWK> jwkResolver = ...\n\nNimbusJwtClientAuthenticationParametersConverter<OAuth2ClientCredentialsGrantRequest> converter =\n new NimbusJwtClientAuthenticationParametersConverter<>(jwkResolver);\nconverter.setJwtClientAssertionCustomizer((context) -> {\n\tcontext.getHeaders().header(\"custom-header\", \"header-value\");\n\tcontext.getClaims().claim(\"custom-claim\", \"claim-value\");\n});\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwkResolver = ...\n\nval converter: NimbusJwtClientAuthenticationParametersConverter<OAuth2ClientCredentialsGrantRequest> =\n NimbusJwtClientAuthenticationParametersConverter(jwkResolver)\nconverter.setJwtClientAssertionCustomizer { context ->\n context.headers.header(\"custom-header\", \"header-value\")\n context.claims.claim(\"custom-claim\", \"claim-value\")\n}\n----\n======\n\n[[oauth2-client-authentication-public]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "Customizing the JWT assertion", "heading_level": 3, "file_order": 143, "section_index": 7, "content_hash": "bbb7faed7794646e4361ee65fd17ca4ca4e1a443feed1945a4554d11029f1564", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:69535308d23e0f6c4424f546562477b133a39a10b04ac7deb7ca7e4af979b925", "content": "Public Client Authentication is supported out of the box and no customization is necessary to enable it.\n\nThe following Spring Boot properties for an OAuth 2.0 client registration demonstrate the configuration:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: client-id\n client-authentication-method: none\n authorization-grant-type: authorization_code\n ...\n----\n\n[NOTE]\n====\nPublic Clients are supported using https://tools.ietf.org/html/rfc7636[Proof Key for Code Exchange] (PKCE).\nPKCE will automatically be used when `client-authentication-method` is set to \"none\" (`ClientAuthenticationMethod.NONE`).\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc", "title": "client-authentication", "heading": "[[oauth2Client-public-auth]]Public Authentication", "heading_level": 2, "file_order": 143, "section_index": 8, "content_hash": "69535308d23e0f6c4424f546562477b133a39a10b04ac7deb7ca7e4af979b925", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/client-authentication.adoc"}}
{"id": "sha256:6b64505d379464ed43d166de2962e92b0a907e67a288844b67fb62354fcf0d7b", "content": "[[oauth2Client-core-interface-class]]\n\nThis section describes the OAuth2 core interfaces and classes that Spring Security offers.\n\n[[oauth2Client-client-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc", "title": "core", "heading": "core", "heading_level": 1, "file_order": 144, "section_index": 0, "content_hash": "6b64505d379464ed43d166de2962e92b0a907e67a288844b67fb62354fcf0d7b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc"}}
{"id": "sha256:803289424af392a1f629167adf9f5034d3aa695ce0baa91af0269ecb662cd0aa", "content": "`ClientRegistration` is a representation of a client registered with an OAuth 2.0 or OpenID Connect 1.0 Provider.\n\nA `ClientRegistration` object holds information, such as client id, client secret, authorization grant type, redirect URI, scope(s), authorization URI, token URI, and other details.\n\n`ClientRegistration` and its properties are defined as follows:\n\n[source,java]\n----\npublic final class ClientRegistration {\n\tprivate String registrationId;\t<1>\n\tprivate String clientId;\t<2>\n\tprivate String clientSecret;\t<3>\n\tprivate ClientAuthenticationMethod clientAuthenticationMethod;\t<4>\n\tprivate AuthorizationGrantType authorizationGrantType;\t<5>\n\tprivate String redirectUri;\t<6>\n\tprivate Set<String> scopes;\t<7>\n\tprivate ProviderDetails providerDetails;\n\tprivate String clientName;\t<8>\n\n\tpublic class ProviderDetails {\n private String authorizationUri;\t<9>\n private String tokenUri;\t<10>\n private UserInfoEndpoint userInfoEndpoint;\n private String jwkSetUri;\t<11>\n private String issuerUri;\t<12>\n private Map<String, Object> configurationMetadata; <13>\n\n public class UserInfoEndpoint {\n private String uri;\t<14>\n private AuthenticationMethod authenticationMethod; <15>\n private String userNameAttributeName;\t<16>\n\n }\n\t}\n\n\tpublic static final class ClientSettings {\n private boolean requireProofKey; // <17>\n\t}\n}\n----\n<1> `registrationId`: The ID that uniquely identifies the `ClientRegistration`.\n<2> `clientId`: The client identifier.\n<3> `clientSecret`: The client secret.\n<4> `clientAuthenticationMethod`: The method used to authenticate the Client with the Provider.\nThe supported values are *client_secret_basic*, *client_secret_post*, *private_key_jwt*, *client_secret_jwt* and *none* https://tools.ietf.org/html/rfc6749#section-2.1[(public clients)].\n<5> `authorizationGrantType`: The OAuth 2.0 Authorization Framework defines four https://tools.ietf.org/html/rfc6749#section-1.3[Authorization Grant] types.\n The supported values are `authorization_code`, `client_credentials`, as well as, extension grant type `urn:ietf:params:oauth:grant-type:jwt-bearer`.\n<6> `redirectUri`: The client's registered redirect URI that the _Authorization Server_ redirects the end-user's user-agent\n to after the end-user has authenticated and authorized access to the client.\n<7> `scopes`: The scope(s) requested by the client during the Authorization Request flow, such as openid, email, or profile.\n<8> `clientName`: A descriptive name used for the client.\nThe name may be used in certain scenarios, such as when displaying the name of the client in the auto-generated login page.\n<9> `authorizationUri`: The Authorization Endpoint URI for the Authorization Server.\n<10> `tokenUri`: The Token Endpoint URI for the Authorization Server.\n<11> `jwkSetUri`: The URI used to retrieve the https://tools.ietf.org/html/rfc7517[JSON Web Key (JWK)] Set from the Authorization Server,\nwhich contains the cryptographic key(s) used to verify the https://tools.ietf.org/html/rfc7515[JSON Web Signature (JWS)] of the ID Token and (optionally) the UserInfo Response.\n<12> `issuerUri`: Returns the issuer identifier URI for the OpenID Connect 1.0 provider or the OAuth 2.0 Authorization Server.\n<13> `configurationMetadata`: The https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[OpenID Provider Configuration Information].\nThis information is available only if the Spring Boot property `spring.security.oauth2.client.provider.[providerId].issuerUri` is configured.\n<14> `(userInfoEndpoint)uri`: The UserInfo Endpoint URI used to access the claims and attributes of the authenticated end-user.\n<15> `(userInfoEndpoint)authenticationMethod`: The authentication method used when sending the access token to the UserInfo Endpoint.\nThe supported values are *header*, *form*, and *query*.\n<16> `userNameAttributeName`: The name of the attribute returned in the UserInfo Response that references the Name or Identifier of the end-user.\n<17> [[oauth2Client-client-registration-requireProofKey]]`requireProofKey`: If `true` or if `clientAuthenticationMethod` is `none`, then PKCE will be enabled. Defaults to `true` for `authorization_code` grant type and `false` for other grant types.\n\nYou can initially configure a `ClientRegistration` by using discovery of an OpenID Connect Provider's https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[Configuration endpoint] or an Authorization Server's https://tools.ietf.org/html/rfc8414#section-3[Metadata endpoint].\n\n`ClientRegistrations` provides convenience methods for configuring a `ClientRegistration` in this way, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nClientRegistration clientRegistration =\n ClientRegistrations.fromIssuerLocation(\"https://idp.example.com/issuer\").build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval clientRegistration = ClientRegistrations.fromIssuerLocation(\"https://idp.example.com/issuer\").build()\n----\n======\n\nThe preceding code queries, in series, `https://idp.example.com/issuer/.well-known/openid-configuration`, `https://idp.example.com/.well-known/openid-configuration/issuer`, and `https://idp.example.com/.well-known/oauth-authorization-server/issuer`, stopping at the first to return a 200 response.\n\nAs an alternative, you can use `ClientRegistrations.fromOidcIssuerLocation()` to query only the OpenID Connect Provider's Configuration endpoint.\n\n[[oauth2Client-client-registration-repo]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc", "title": "core", "heading": "ClientRegistration", "heading_level": 2, "file_order": 144, "section_index": 1, "content_hash": "803289424af392a1f629167adf9f5034d3aa695ce0baa91af0269ecb662cd0aa", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc"}}
{"id": "sha256:e16565cedd2f1d540ddae58a7b28d964a0479928d47d15ac1733dbd70caef9ea", "content": "The `ClientRegistrationRepository` serves as a repository for OAuth 2.0 / OpenID Connect 1.0 `ClientRegistration`(s).\n\n[NOTE]\n====\nClient registration information is ultimately stored and owned by the associated Authorization Server.\nThis repository provides the ability to retrieve a subset of the primary client registration information, which is stored with the Authorization Server.\n====\n\nSpring Boot auto-configuration binds each of the properties under `spring.security.oauth2.client.registration._[registrationId]_` to an instance of `ClientRegistration` and then composes each of the `ClientRegistration` instance(s) within a `ClientRegistrationRepository`.\n\n[NOTE]\n====\nThe default implementation of `ClientRegistrationRepository` is `InMemoryClientRegistrationRepository`.\n====\n\nThe auto-configuration also registers the `ClientRegistrationRepository` as a `@Bean` in the `ApplicationContext` so that it is available for dependency injection, if needed by the application.\n\nThe following listing shows an example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class OAuth2ClientController {\n\n\t@Autowired\n\tprivate ClientRegistrationRepository clientRegistrationRepository;\n\n\t@GetMapping(\"/\")\n\tpublic String index() {\n ClientRegistration oktaRegistration =\n this.clientRegistrationRepository.findByRegistrationId(\"okta\");\n\n ...\n\n return \"index\";\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nclass OAuth2ClientController {\n\n @Autowired\n private lateinit var clientRegistrationRepository: ClientRegistrationRepository\n\n @GetMapping(\"/\")\n fun index(): String {\n val oktaRegistration =\n this.clientRegistrationRepository.findByRegistrationId(\"okta\")\n\n //...\n\n return \"index\";\n }\n}\n----\n======\n\n[[oauth2Client-authorized-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc", "title": "core", "heading": "ClientRegistrationRepository", "heading_level": 2, "file_order": 144, "section_index": 2, "content_hash": "e16565cedd2f1d540ddae58a7b28d964a0479928d47d15ac1733dbd70caef9ea", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc"}}
{"id": "sha256:f9fe6c559b2e76fc0f1581c43d8bfb5988a95b9b708ac798e0290a4c9964351a", "content": "`OAuth2AuthorizedClient` is a representation of an Authorized Client.\nA client is considered to be authorized when the end-user (the Resource Owner) has granted authorization to the client to access its protected resources.\n\n`OAuth2AuthorizedClient` serves the purpose of associating an `OAuth2AccessToken` (and optional `OAuth2RefreshToken`) to a `ClientRegistration` (client) and resource owner, who is the `Principal` end-user that granted the authorization.\n\n[[oauth2Client-authorized-repo-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc", "title": "core", "heading": "OAuth2AuthorizedClient", "heading_level": 2, "file_order": 144, "section_index": 3, "content_hash": "f9fe6c559b2e76fc0f1581c43d8bfb5988a95b9b708ac798e0290a4c9964351a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc"}}
{"id": "sha256:5ed875b2ba055bc783e8f496f972a35b07e449078052a2efe35fc6538ce9fa21", "content": "`OAuth2AuthorizedClientRepository` is responsible for persisting `OAuth2AuthorizedClient`(s) between web requests, whereas the primary role of `OAuth2AuthorizedClientService` is to manage `OAuth2AuthorizedClient`(s) at the application-level.\n\nFrom a developer perspective, the `OAuth2AuthorizedClientRepository` or `OAuth2AuthorizedClientService` provides the ability to look up an `OAuth2AccessToken` associated with a client so that it can be used to initiate a protected resource request.\n\nThe following listing shows an example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class OAuth2ClientController {\n\n @Autowired\n private OAuth2AuthorizedClientService authorizedClientService;\n\n @GetMapping(\"/\")\n public String index(Authentication authentication) {\n OAuth2AuthorizedClient authorizedClient =\n this.authorizedClientService.loadAuthorizedClient(\"okta\", authentication.getName());\n\n OAuth2AccessToken accessToken = authorizedClient.getAccessToken();\n\n ...\n\n return \"index\";\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nclass OAuth2ClientController {\n\n @Autowired\n private lateinit var authorizedClientService: OAuth2AuthorizedClientService\n\n @GetMapping(\"/\")\n fun index(authentication: Authentication): String {\n val authorizedClient: OAuth2AuthorizedClient =\n this.authorizedClientService.loadAuthorizedClient(\"okta\", authentication.getName());\n val accessToken = authorizedClient.accessToken\n\n ...\n\n return \"index\";\n }\n}\n----\n======\n\n[NOTE]\n====\nSpring Boot auto-configuration registers an `OAuth2AuthorizedClientRepository` or an `OAuth2AuthorizedClientService` `@Bean` in the `ApplicationContext`.\nHowever, the application can override and register a custom `OAuth2AuthorizedClientRepository` or `OAuth2AuthorizedClientService` `@Bean`.\n====\n\nThe default implementation of `OAuth2AuthorizedClientService` is `InMemoryOAuth2AuthorizedClientService`, which stores `OAuth2AuthorizedClient` objects in-memory.\n\nAlternatively, you can configure the JDBC implementation `JdbcOAuth2AuthorizedClientService` to persist `OAuth2AuthorizedClient` instances in a database.\n\n[NOTE]\n====\n`JdbcOAuth2AuthorizedClientService` depends on the table definition described in xref:servlet/appendix/database-schema.adoc#dbschema-oauth2-client[ OAuth 2.0 Client Schema].\n====\n\n[[oauth2Client-authorized-manager-provider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc", "title": "core", "heading": "OAuth2AuthorizedClientRepository and OAuth2AuthorizedClientService", "heading_level": 2, "file_order": 144, "section_index": 4, "content_hash": "5ed875b2ba055bc783e8f496f972a35b07e449078052a2efe35fc6538ce9fa21", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc"}}
{"id": "sha256:4c4e811d6d0333694b2fdb957e5a8c95a867f5b711dfa212f3713b0391141411", "content": "The `OAuth2AuthorizedClientManager` is responsible for the overall management of `OAuth2AuthorizedClient`(s).\n\nThe primary responsibilities include:\n\n* Authorizing (or re-authorizing) an OAuth 2.0 Client, by using an `OAuth2AuthorizedClientProvider`.\n* Delegating the persistence of an `OAuth2AuthorizedClient`, typically by using an `OAuth2AuthorizedClientService` or `OAuth2AuthorizedClientRepository`.\n* Delegating to an `OAuth2AuthorizationSuccessHandler` when an OAuth 2.0 Client has been successfully authorized (or re-authorized).\n* Delegating to an `OAuth2AuthorizationFailureHandler` when an OAuth 2.0 Client fails to authorize (or re-authorize).\n\nAn `OAuth2AuthorizedClientProvider` implements a strategy for authorizing (or re-authorizing) an OAuth 2.0 Client.\nImplementations typically implement an authorization grant type, such as `authorization_code`, `client_credentials`, and others.\n\nThe default implementation of `OAuth2AuthorizedClientManager` is `DefaultOAuth2AuthorizedClientManager`, which is associated with an `OAuth2AuthorizedClientProvider` that may support multiple authorization grant types using a delegation-based composite.\nYou can use `OAuth2AuthorizedClientProviderBuilder` to configure and build the delegation-based composite.\n\nThe following code shows an example of how to configure and build an `OAuth2AuthorizedClientProvider` composite that provides support for the `authorization_code`, `refresh_token` and `client_credentials` authorization grant types:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic OAuth2AuthorizedClientManager authorizedClientManager(\n ClientRegistrationRepository clientRegistrationRepository,\n OAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tOAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .build();\n\n\tDefaultOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ClientRegistrationRepository,\n authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {\n val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .build()\n val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======\n\nWhen an authorization attempt succeeds, the `DefaultOAuth2AuthorizedClientManager` delegates to the `OAuth2AuthorizationSuccessHandler`, which (by default) saves the `OAuth2AuthorizedClient` through the `OAuth2AuthorizedClientRepository`.\nIn the case of a re-authorization failure (for example, a refresh token is no longer valid), the previously saved `OAuth2AuthorizedClient` is removed from the `OAuth2AuthorizedClientRepository` through the `RemoveAuthorizedClientOAuth2AuthorizationFailureHandler`.\nYou can customize the default behavior through `setAuthorizationSuccessHandler(OAuth2AuthorizationSuccessHandler)` and `setAuthorizationFailureHandler(OAuth2AuthorizationFailureHandler)`.\n\nThe `DefaultOAuth2AuthorizedClientManager` is also associated with a `contextAttributesMapper` of type `Function<OAuth2AuthorizeRequest, Map<String, Object>>`, which is responsible for mapping attribute(s) from the `OAuth2AuthorizeRequest` to a `Map` of attributes to be associated to the `OAuth2AuthorizationContext`.\nThis can be useful when you need to supply an `OAuth2AuthorizedClientProvider` with required (supported) attribute(s).\n\nThe following code shows an example of the `contextAttributesMapper`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic OAuth2AuthorizedClientManager authorizedClientManager(\n ClientRegistrationRepository clientRegistrationRepository,\n OAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tOAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .build();\n\n\tDefaultOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\t// Assuming the attributes are supplied as `HttpServletRequest` parameters,\n\t// map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`\n\tauthorizedClientManager.setContextAttributesMapper(contextAttributesMapper());\n\n\treturn authorizedClientManager;\n}\n\nprivate Function<OAuth2AuthorizeRequest, Map<String, Object>> contextAttributesMapper() {\n\treturn authorizeRequest -> {\n Map<String, Object> contextAttributes = Collections.emptyMap();\n HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName());\n String param1 = servletRequest.getParameter(\"param1\");\n String param2 = servletRequest.getParameter(\"param2\");\n if (StringUtils.hasText(param1) && StringUtils.hasText(param2)) {\n contextAttributes = new HashMap<>();\n contextAttributes.put(\"param1\", param1);\n contextAttributes.put(\"param2\", param2);\n }\n return contextAttributes;\n\t};\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ClientRegistrationRepository,\n authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {\n val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .build()\n val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n\n\t// Assuming the attributes are supplied as `HttpServletRequest` parameters,\n\t// map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`\n authorizedClientManager.setContextAttributesMapper(contextAttributesMapper())\n return authorizedClientManager\n}\n\nprivate fun contextAttributesMapper(): Function<OAuth2AuthorizeRequest, MutableMap<String, Any>> {\n return Function { authorizeRequest ->\n var contextAttributes: MutableMap<String, Any> = mutableMapOf()\n val servletRequest: HttpServletRequest = authorizeRequest.getAttribute(HttpServletRequest::class.java.name)\n val param1: String = servletRequest.getParameter(\"param1\")\n val param2: String = servletRequest.getParameter(\"param2\")\n if (StringUtils.hasText(param1) && StringUtils.hasText(param2)) {\n contextAttributes = hashMapOf()\n contextAttributes[\"param1\"] = param1\n contextAttributes[\"param2\"] = param2\n }\n contextAttributes\n }\n}\n----\n======\n\nThe `DefaultOAuth2AuthorizedClientManager` is designed to be used _within_ the context of a `HttpServletRequest`.\nWhen operating _outside_ of a `HttpServletRequest` context, use `AuthorizedClientServiceOAuth2AuthorizedClientManager` instead.\n\nA service application is a common use case for when to use an `AuthorizedClientServiceOAuth2AuthorizedClientManager`.\nService applications often run in the background, without any user interaction, and typically run under a system-level account instead of a user account.\nAn OAuth 2.0 Client configured with the `client_credentials` grant type can be considered a type of service application.\n\nThe following code shows an example of how to configure an `AuthorizedClientServiceOAuth2AuthorizedClientManager` that provides support for the `client_credentials` grant type:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic OAuth2AuthorizedClientManager authorizedClientManager(\n ClientRegistrationRepository clientRegistrationRepository,\n OAuth2AuthorizedClientService authorizedClientService) {\n\n\tOAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials()\n .build();\n\n\tAuthorizedClientServiceOAuth2AuthorizedClientManager authorizedClientManager =\n new AuthorizedClientServiceOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientService);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ClientRegistrationRepository,\n authorizedClientService: OAuth2AuthorizedClientService): OAuth2AuthorizedClientManager {\n val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .clientCredentials()\n .build()\n val authorizedClientManager = AuthorizedClientServiceOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientService)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc", "title": "core", "heading": "OAuth2AuthorizedClientManager and OAuth2AuthorizedClientProvider", "heading_level": 2, "file_order": 144, "section_index": 5, "content_hash": "4c4e811d6d0333694b2fdb957e5a8c95a867f5b711dfa212f3713b0391141411", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/core.adoc"}}
{"id": "sha256:01a21529cf88b7a1428a08a60cf21688f24035f5cea85fda45ba0b55a4a98d0c", "content": "[[oauth2-client]]\n\nThe OAuth 2.0 Client features provide support for the Client role as defined in the https://tools.ietf.org/html/rfc6749#section-1.1[OAuth 2.0 Authorization Framework].\n\nAt a high-level, the core features available are:\n\n.Authorization Grant support\n* xref:servlet/oauth2/client/authorization-grants.adoc#oauth2-client-authorization-code[Authorization Code]\n* xref:servlet/oauth2/client/authorization-grants.adoc#oauth2-client-refresh-token[Refresh Token]\n* xref:servlet/oauth2/client/authorization-grants.adoc#oauth2-client-client-credentials[Client Credentials]\n* xref:servlet/oauth2/client/authorization-grants.adoc#oauth2-client-jwt-bearer[JWT Bearer]\n* xref:servlet/oauth2/client/authorization-grants.adoc#oauth2-client-token-exchange[Token Exchange]\n\n.Client Authentication support\n* xref:servlet/oauth2/client/client-authentication.adoc#oauth2-client-authentication-jwt-bearer[JWT Bearer]\n\n.HTTP Client support (for requesting protected resources)\n* xref:servlet/oauth2/client/authorized-clients.adoc#oauth2-client-rest-client[`RestClient` integration]\n* xref:servlet/oauth2/client/authorized-clients.adoc#oauth2-client-web-client[`WebClient` integration for Servlet Environments]\n\nThe `HttpSecurity.oauth2Client()` DSL provides a number of configuration options for customizing the core components used by OAuth 2.0 Client.\nIn addition, `HttpSecurity.oauth2Client().authorizationCodeGrant()` enables the customization of the Authorization Code grant.\n\nThe following code shows the complete configuration options provided by the `HttpSecurity.oauth2Client()` DSL:\n\n.OAuth2 Client Configuration Options\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2ClientSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Client((oauth2) -> oauth2\n .clientRegistrationRepository(this.clientRegistrationRepository())\n .authorizedClientRepository(this.authorizedClientRepository())\n .authorizedClientService(this.authorizedClientService())\n .authorizationCodeGrant((codeGrant) -> codeGrant\n .authorizationRequestRepository(this.authorizationRequestRepository())\n .authorizationRequestResolver(this.authorizationRequestResolver())\n .accessTokenResponseClient(this.accessTokenResponseClient())\n )\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2ClientSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Client {\n clientRegistrationRepository = clientRegistrationRepository()\n authorizedClientRepository = authorizedClientRepository()\n authorizedClientService = authorizedClientService()\n authorizationCodeGrant {\n authorizationRequestRepository = authorizationRequestRepository()\n authorizationRequestResolver = authorizationRequestResolver()\n accessTokenResponseClient = accessTokenResponseClient()\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\nIn addition to the `HttpSecurity.oauth2Client()` DSL, XML configuration is also supported.\n\nThe following code shows the complete configuration options available in the xref:servlet/appendix/namespace/http.adoc#nsa-oauth2-client[ security namespace]:\n\n.OAuth2 Client XML Configuration Options\n[source,xml]\n----\n<http>\n\t<oauth2-client client-registration-repository-ref=\"clientRegistrationRepository\"\n authorized-client-repository-ref=\"authorizedClientRepository\"\n authorized-client-service-ref=\"authorizedClientService\">\n <authorization-code-grant\n authorization-request-repository-ref=\"authorizationRequestRepository\"\n authorization-request-resolver-ref=\"authorizationRequestResolver\"\n access-token-response-client-ref=\"accessTokenResponseClient\"/>\n\t</oauth2-client>\n</http>\n----\n\nThe `OAuth2AuthorizedClientManager` is responsible for managing the authorization (or re-authorization) of an OAuth 2.0 Client, in collaboration with one or more `OAuth2AuthorizedClientProvider`(s).\n\nThe following code shows an example of how to register an `OAuth2AuthorizedClientManager` `@Bean` and associate it with an `OAuth2AuthorizedClientProvider` composite that provides support for the `authorization_code`, `refresh_token` and `client_credentials` authorization grant types:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic OAuth2AuthorizedClientManager authorizedClientManager(\n ClientRegistrationRepository clientRegistrationRepository,\n OAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n\tOAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .build();\n\n\tDefaultOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n\tauthorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n\treturn authorizedClientManager;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authorizedClientManager(\n clientRegistrationRepository: ClientRegistrationRepository,\n authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {\n val authorizedClientProvider: OAuth2AuthorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .build()\n val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository)\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n return authorizedClientManager\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/client/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 145, "section_index": 0, "content_hash": "01a21529cf88b7a1428a08a60cf21688f24035f5cea85fda45ba0b55a4a98d0c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/client/index.adoc"}}
{"id": "sha256:7ab8981c22313a5acc07eb7e1c0a87c65bb3c89f5179cd5b2c7585691674610a", "content": "[[oauth2login-advanced]]\n\n`HttpSecurity.oauth2Login()` provides a number of configuration options for customizing OAuth 2.0 Login.\nThe main configuration options are grouped into their protocol endpoint counterparts.\n\nFor example, `oauth2Login().authorizationEndpoint()` allows configuring the _Authorization Endpoint_, whereas `oauth2Login().tokenEndpoint()` allows configuring the _Token Endpoint_.\n\nThe following code shows an example:\n\n.Advanced OAuth2 Login Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Login((oauth2) -> oauth2\n .authorizationEndpoint((authorization) -> authorization\n ...\n )\n .redirectionEndpoint((redirection) -> redirection\n ...\n )\n .tokenEndpoint((token) -> token\n ...\n )\n .userInfoEndpoint((userInfo) -> userInfo\n ...\n )\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Login {\n authorizationEndpoint {\n ...\n }\n redirectionEndpoint {\n ...\n }\n tokenEndpoint {\n ...\n }\n userInfoEndpoint {\n ...\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\nThe main goal of the `oauth2Login()` DSL was to closely align with the naming, as defined in the specifications.\n\nThe OAuth 2.0 Authorization Framework defines the https://tools.ietf.org/html/rfc6749#section-3[Protocol Endpoints] as follows:\n\nThe authorization process uses two authorization server endpoints (HTTP resources):\n\n* Authorization Endpoint: Used by the client to obtain authorization from the resource owner through user-agent redirection.\n* Token Endpoint: Used by the client to exchange an authorization grant for an access token, typically with client authentication.\n\nThe authorization process also uses one client endpoint:\n\n* Redirection Endpoint: Used by the authorization server to return responses that contain authorization credentials to the client through the resource owner user-agent.\n\nThe OpenID Connect Core 1.0 specification defines the https://openid.net/specs/openid-connect-core-1_0.html#UserInfo[UserInfo Endpoint] as follows:\n\nThe UserInfo Endpoint is an OAuth 2.0 Protected Resource that returns claims about the authenticated end-user.\nTo obtain the requested claims about the end-user, the client makes a request to the UserInfo Endpoint by using an access token obtained through OpenID Connect Authentication.\nThese claims are normally represented by a JSON object that contains a collection of name-value pairs for the claims.\n\nThe following code shows the complete configuration options available for the `oauth2Login()` DSL:\n\n.OAuth2 Login Configuration Options\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Login((oauth2) -> oauth2\n .clientRegistrationRepository(this.clientRegistrationRepository())\n .authorizedClientRepository(this.authorizedClientRepository())\n .authorizedClientService(this.authorizedClientService())\n .loginPage(\"/login\")\n .authorizationEndpoint((authorization) -> authorization\n .baseUri(this.authorizationRequestBaseUri())\n .authorizationRequestRepository(this.authorizationRequestRepository())\n .authorizationRequestResolver(this.authorizationRequestResolver())\n )\n .redirectionEndpoint((redirection) -> redirection\n .baseUri(this.authorizationResponseBaseUri())\n )\n .tokenEndpoint((token) -> token\n .accessTokenResponseClient(this.accessTokenResponseClient())\n )\n .userInfoEndpoint((userInfo) -> userInfo\n .userAuthoritiesMapper(this.userAuthoritiesMapper())\n .userService(this.oauth2UserService())\n .oidcUserService(this.oidcUserService())\n )\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Login {\n clientRegistrationRepository = clientRegistrationRepository()\n authorizedClientRepository = authorizedClientRepository()\n authorizedClientService = authorizedClientService()\n loginPage = \"/login\"\n authorizationEndpoint {\n baseUri = authorizationRequestBaseUri()\n authorizationRequestRepository = authorizationRequestRepository()\n authorizationRequestResolver = authorizationRequestResolver()\n }\n redirectionEndpoint {\n baseUri = authorizationResponseBaseUri()\n }\n tokenEndpoint {\n accessTokenResponseClient = accessTokenResponseClient()\n }\n userInfoEndpoint {\n userAuthoritiesMapper = userAuthoritiesMapper()\n userService = oauth2UserService()\n oidcUserService = oidcUserService()\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\nIn addition to the `oauth2Login()` DSL, XML configuration is also supported.\n\nThe following code shows the complete configuration options available in the xref:servlet/appendix/namespace/http.adoc#nsa-oauth2-login[ security namespace]:\n\n.OAuth2 Login XML Configuration Options\n[source,xml]\n----\n<http>\n\t<oauth2-login client-registration-repository-ref=\"clientRegistrationRepository\"\n authorized-client-repository-ref=\"authorizedClientRepository\"\n authorized-client-service-ref=\"authorizedClientService\"\n authorization-request-repository-ref=\"authorizationRequestRepository\"\n authorization-request-resolver-ref=\"authorizationRequestResolver\"\n access-token-response-client-ref=\"accessTokenResponseClient\"\n user-authorities-mapper-ref=\"userAuthoritiesMapper\"\n user-service-ref=\"oauth2UserService\"\n oidc-user-service-ref=\"oidcUserService\"\n login-processing-url=\"/login/oauth2/code/*\"\n login-page=\"/login\"\n authentication-success-handler-ref=\"authenticationSuccessHandler\"\n authentication-failure-handler-ref=\"authenticationFailureHandler\"\n jwt-decoder-factory-ref=\"jwtDecoderFactory\"/>\n</http>\n----\n\nThe following sections go into more detail on each of the configuration options available:\n\n* <<oauth2login-advanced-login-page>>\n* <<oauth2login-advanced-redirection-endpoint>>\n* <<oauth2login-advanced-userinfo-endpoint>>\n* <<oauth2login-advanced-idtoken-verify>>\n* <<oauth2login-advanced-oidc-logout>>\n\n[[oauth2login-advanced-login-page]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc", "title": "advanced", "heading": "advanced", "heading_level": 1, "file_order": 146, "section_index": 0, "content_hash": "7ab8981c22313a5acc07eb7e1c0a87c65bb3c89f5179cd5b2c7585691674610a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc"}}
{"id": "sha256:82230717215206ae72f69bfca27575f25f5c42c39fc0387b5559ac66f16efdee", "content": "By default, the OAuth 2.0 Login Page is auto-generated by the `DefaultLoginPageGeneratingFilter`.\nThe default login page shows each configured OAuth Client with its `ClientRegistration.clientName` as a link, which is capable of initiating the Authorization Request (or OAuth 2.0 Login).\n\n[NOTE]\n====\nFor `DefaultLoginPageGeneratingFilter` to show links for configured OAuth Clients, the registered `ClientRegistrationRepository` needs to also implement `Iterable<ClientRegistration>`.\nSee `InMemoryClientRegistrationRepository` for reference.\n====\n\nThe link's destination for each OAuth Client defaults to the following:\n\n`+OAuth2AuthorizationRequestRedirectFilter.DEFAULT_AUTHORIZATION_REQUEST_BASE_URI + \"/{registrationId}\"+`\n\nThe following line shows an example:\n\n[source,html]\n----\n<a href=\"/oauth2/authorization/google\">Google</a>\n----\n\nTo override the default login page, configure `oauth2Login().loginPage()` and (optionally) `oauth2Login().authorizationEndpoint().baseUri()`.\n\nThe following listing shows an example:\n\n.OAuth2 Login Page Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Login((oauth2) -> oauth2\n .loginPage(\"/login/oauth2\")\n ...\n .authorizationEndpoint((authorization) -> authorization\n .baseUri(\"/login/oauth2/authorization\")\n ...\n )\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Login {\n loginPage = \"/login/oauth2\"\n authorizationEndpoint {\n baseUri = \"/login/oauth2/authorization\"\n }\n }\n }\n return http.build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<oauth2-login login-page=\"/login/oauth2\"\n ...\n />\n</http>\n----\n======\n\n[IMPORTANT]\n====\nYou need to provide a `@Controller` with a `@RequestMapping(\"/login/oauth2\")` that is capable of rendering the custom login page.\n====\n\n[TIP]\n=====\nAs noted earlier, configuring `oauth2Login().authorizationEndpoint().baseUri()` is optional.\nHowever, if you choose to customize it, ensure the link to each OAuth Client matches the `authorizationEndpoint().baseUri()`.\n\nThe following line shows an example:\n[source,html]\n----\n<a href=\"/login/oauth2/authorization/google\">Google</a>\n----\n=====\n\n[[oauth2login-advanced-redirection-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc", "title": "advanced", "heading": "OAuth 2.0 Login Page", "heading_level": 2, "file_order": 146, "section_index": 1, "content_hash": "82230717215206ae72f69bfca27575f25f5c42c39fc0387b5559ac66f16efdee", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc"}}
{"id": "sha256:0d15e7bdf729fbca9475a72955b6dc7f03048b789c1da016ea3477bc8844715c", "content": "The Redirection Endpoint is used by the Authorization Server for returning the Authorization Response (which contains the authorization credentials) to the client through the Resource Owner user-agent.\n\n[TIP]\n====\nOAuth 2.0 Login leverages the Authorization Code Grant.\nTherefore, the authorization credential is the authorization code.\n====\n\nThe default Authorization Response `baseUri` (redirection endpoint) is `*/login/oauth2/code/**`, which is defined in `OAuth2LoginAuthenticationFilter.DEFAULT_FILTER_PROCESSES_URI`.\n\nIf you would like to customize the Authorization Response `baseUri`, configure it as follows:\n\n.Redirection Endpoint Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n @Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Login((oauth2) -> oauth2\n .redirectionEndpoint((redirection) -> redirection\n .baseUri(\"/login/oauth2/callback/*\")\n ...\n )\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Login {\n redirectionEndpoint {\n baseUri = \"/login/oauth2/callback/*\"\n }\n }\n }\n return http.build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<oauth2-login login-processing-url=\"/login/oauth2/callback/*\"\n ...\n />\n</http>\n----\n======\n\n[IMPORTANT]\n=====\nYou also need to ensure the `ClientRegistration.redirectUri` matches the custom Authorization Response `baseUri`.\n\nThe following listing shows an example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",subs=\"-attributes\"]\n----\nreturn CommonOAuth2Provider.GOOGLE.getBuilder(\"google\")\n\t.clientId(\"google-client-id\")\n\t.clientSecret(\"google-client-secret\")\n\t.redirectUri(\"{baseUrl}/login/oauth2/callback/{registrationId}\")\n\t.build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",subs=\"-attributes\"]\n----\nreturn CommonOAuth2Provider.GOOGLE.getBuilder(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .redirectUri(\"{baseUrl}/login/oauth2/callback/{registrationId}\")\n .build()\n----\n======\n=====\n\n[[oauth2login-advanced-userinfo-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc", "title": "advanced", "heading": "Redirection Endpoint", "heading_level": 2, "file_order": 146, "section_index": 2, "content_hash": "0d15e7bdf729fbca9475a72955b6dc7f03048b789c1da016ea3477bc8844715c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc"}}
{"id": "sha256:0dec7e4c5bb41097174ee43014a56d68b6d5f2ba6b977cd52ab7e42be0f7234f", "content": "The UserInfo Endpoint includes a number of configuration options, as described in the following sub-sections:\n\n* <<oauth2login-advanced-map-authorities>>\n* <<oauth2login-advanced-oauth2-user-service>>\n* <<oauth2login-advanced-oidc-user-service>>\n\n[[oauth2login-advanced-map-authorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc", "title": "advanced", "heading": "UserInfo Endpoint", "heading_level": 2, "file_order": 146, "section_index": 3, "content_hash": "0dec7e4c5bb41097174ee43014a56d68b6d5f2ba6b977cd52ab7e42be0f7234f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc"}}
{"id": "sha256:34b73947364138e75085a6461a392f3748d626e3cbb39c334755f302adb1c209", "content": "After the user successfully authenticates with the OAuth 2.0 Provider, the `OAuth2User.getAuthorities()` (or `OidcUser.getAuthorities()`) contains a list of granted authorities populated from `OAuth2UserRequest.getAccessToken().getScopes()` and prefixed with `SCOPE_`.\nThese granted authorities can be mapped to a new set of `GrantedAuthority` instances, which are supplied to `OAuth2AuthenticationToken` when completing the authentication.\n\n[TIP]\n`OAuth2AuthenticationToken.getAuthorities()` is used for authorizing requests, such as in `hasRole('USER')` or `hasRole('ADMIN')`.\n\nThere are a couple of options to choose from when mapping user authorities:\n\n* <<oauth2login-advanced-map-authorities-grantedauthoritiesmapper>>\n* <<oauth2login-advanced-map-authorities-oauth2userservice>>\n\n[[oauth2login-advanced-map-authorities-grantedauthoritiesmapper]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc", "title": "advanced", "heading": "Mapping User Authorities", "heading_level": 3, "file_order": 146, "section_index": 4, "content_hash": "34b73947364138e75085a6461a392f3748d626e3cbb39c334755f302adb1c209", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc"}}
{"id": "sha256:7c6e25c3f1ea4ecc5eb45a1fcc35f4a7dd10b3cb29dc218c6189230600381a5c", "content": "The `GrantedAuthoritiesMapper` is given a list of granted authorities which contains a special authority of type `OAuth2UserAuthority` and the authority string `OAUTH2_USER` (or `OidcUserAuthority` and the authority string `OIDC_USER`).\n\nProvide an implementation of `GrantedAuthoritiesMapper` and configure it, as follows:\n\n.Granted Authorities Mapper Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n @Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Login((oauth2) -> oauth2\n .userInfoEndpoint((userInfo) -> userInfo\n .userAuthoritiesMapper(this.userAuthoritiesMapper())\n ...\n )\n );\n return http.build();\n\t}\n\n\tprivate GrantedAuthoritiesMapper userAuthoritiesMapper() {\n return (authorities) -> {\n Set<GrantedAuthority> mappedAuthorities = new HashSet<>();\n\n authorities.forEach(authority -> {\n if (OidcUserAuthority.class.isInstance(authority)) {\n OidcUserAuthority oidcUserAuthority = (OidcUserAuthority)authority;\n\n OidcIdToken idToken = oidcUserAuthority.getIdToken();\n OidcUserInfo userInfo = oidcUserAuthority.getUserInfo();\n\n // Map the claims found in idToken and/or userInfo\n // to one or more GrantedAuthority's and add it to mappedAuthorities\n\n } else if (OAuth2UserAuthority.class.isInstance(authority)) {\n OAuth2UserAuthority oauth2UserAuthority = (OAuth2UserAuthority)authority;\n\n Map<String, Object> userAttributes = oauth2UserAuthority.getAttributes();\n\n // Map the attributes found in userAttributes\n // to one or more GrantedAuthority's and add it to mappedAuthorities\n\n }\n });\n\n return mappedAuthorities;\n };\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Login {\n userInfoEndpoint {\n userAuthoritiesMapper = userAuthoritiesMapper()\n }\n }\n }\n return http.build()\n }\n\n private fun userAuthoritiesMapper(): GrantedAuthoritiesMapper = GrantedAuthoritiesMapper { authorities: Collection<GrantedAuthority> ->\n val mappedAuthorities = emptySet<GrantedAuthority>()\n\n authorities.forEach { authority ->\n if (authority is OidcUserAuthority) {\n val idToken = authority.idToken\n val userInfo = authority.userInfo\n // Map the claims found in idToken and/or userInfo\n // to one or more GrantedAuthority's and add it to mappedAuthorities\n } else if (authority is OAuth2UserAuthority) {\n val userAttributes = authority.attributes\n // Map the attributes found in userAttributes\n // to one or more GrantedAuthority's and add it to mappedAuthorities\n }\n }\n\n mappedAuthorities\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<oauth2-login user-authorities-mapper-ref=\"userAuthoritiesMapper\"\n ...\n />\n</http>\n----\n======\n\nAlternatively, you can register a `GrantedAuthoritiesMapper` `@Bean` to have it automatically applied to the configuration, as follows:\n\n.Granted Authorities Mapper Bean Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Login(withDefaults());\n return http.build();\n\t}\n\n\t@Bean\n\tpublic GrantedAuthoritiesMapper userAuthoritiesMapper() {\n ...\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Login { }\n }\n return http.build()\n }\n\n @Bean\n fun userAuthoritiesMapper(): GrantedAuthoritiesMapper {\n ...\n }\n}\n----\n======\n\n[TIP]\n====\nOnce authentication completes, it also contains the `FACTOR_AUTHORIZATION_CODE` granted authority.\n====\n\n[[oauth2login-advanced-map-authorities-oauth2userservice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc", "title": "advanced", "heading": "Using a GrantedAuthoritiesMapper", "heading_level": 4, "file_order": 146, "section_index": 5, "content_hash": "7c6e25c3f1ea4ecc5eb45a1fcc35f4a7dd10b3cb29dc218c6189230600381a5c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc"}}
{"id": "sha256:33b6ae5b628a8e07ee3be1962660aab616feca2f36e741497dd730c56ae26151", "content": "This strategy is advanced compared to using a `GrantedAuthoritiesMapper`. However, it is also more flexible, as it gives you access to the `OAuth2UserRequest` and `OAuth2User` (when using an OAuth 2.0 UserService) or `OidcUserRequest` and `OidcUser` (when using an OpenID Connect 1.0 UserService).\n\nThe `OAuth2UserRequest` (and `OidcUserRequest`) provides you access to the associated `OAuth2AccessToken`, which is very useful in cases where the _delegator_ needs to fetch authority information from a protected resource before it can map the custom authorities for the user.\n\nThe following example shows how to implement and configure a delegation-based strategy using an OpenID Connect 1.0 UserService:\n\n.OAuth2UserService Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Login((oauth2) -> oauth2\n .userInfoEndpoint((userInfo) -> userInfo\n .oidcUserService(this.oidcUserService())\n ...\n )\n );\n return http.build();\n\t}\n\n\tprivate OAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() {\n final OidcUserService delegate = new OidcUserService();\n\n return (userRequest) -> {\n // Delegate to the default implementation for loading a user\n OidcUser oidcUser = delegate.loadUser(userRequest);\n\n OAuth2AccessToken accessToken = userRequest.getAccessToken();\n Set<GrantedAuthority> mappedAuthorities = new HashSet<>();\n\n // TODO\n // 1) Fetch the authority information from the protected resource using accessToken\n // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities\n\n // 3) Create a copy of oidcUser but use the mappedAuthorities instead\n ProviderDetails providerDetails = userRequest.getClientRegistration().getProviderDetails();\n String userNameAttributeName = providerDetails.getUserInfoEndpoint().getUserNameAttributeName();\n if (StringUtils.hasText(userNameAttributeName)) {\n oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo(), userNameAttributeName);\n } else {\n oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo());\n }\n\n return oidcUser;\n };\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Login {\n userInfoEndpoint {\n oidcUserService = oidcUserService()\n }\n }\n }\n return http.build()\n }\n\n @Bean\n fun oidcUserService(): OAuth2UserService<OidcUserRequest, OidcUser> {\n val delegate = OidcUserService()\n\n return OAuth2UserService { userRequest ->\n // Delegate to the default implementation for loading a user\n val oidcUser = delegate.loadUser(userRequest)\n\n val accessToken = userRequest.accessToken\n val mappedAuthorities = HashSet<GrantedAuthority>()\n\n // TODO\n // 1) Fetch the authority information from the protected resource using accessToken\n // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities\n // 3) Create a copy of oidcUser but use the mappedAuthorities instead\n val providerDetails = userRequest.getClientRegistration().getProviderDetails()\n val userNameAttributeName = providerDetails.getUserInfoEndpoint().getUserNameAttributeName()\n if (StringUtils.hasText(userNameAttributeName)) {\n DefaultOidcUser(mappedAuthorities, oidcUser.idToken, oidcUser.userInfo, userNameAttributeName)\n } else {\n DefaultOidcUser(mappedAuthorities, oidcUser.idToken, oidcUser.userInfo)\n }\n }\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n\t<oauth2-login oidc-user-service-ref=\"oidcUserService\"\n ...\n />\n</http>\n----\n======\n\n[[oauth2login-advanced-oauth2-user-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc", "title": "advanced", "heading": "Delegation-based Strategy with OAuth2UserService", "heading_level": 4, "file_order": 146, "section_index": 6, "content_hash": "33b6ae5b628a8e07ee3be1962660aab616feca2f36e741497dd730c56ae26151", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc"}}
{"id": "sha256:d1c3a8e41c9cc410b347a10eef6e52d26f44be559d511a608a48e3c5ee158c41", "content": "`DefaultOAuth2UserService` is an implementation of an `OAuth2UserService` that supports standard OAuth 2.0 Provider's.\n\n[NOTE]\n====\n`OAuth2UserService` obtains the user attributes of the end-user (the resource owner) from the UserInfo Endpoint (by using the access token granted to the client during the authorization flow) and returns an `AuthenticatedPrincipal` in the form of an `OAuth2User`.\n====\n\n`DefaultOAuth2UserService` uses a `RestOperations` instance when requesting the user attributes at the UserInfo Endpoint.\n\nIf you need to customize the pre-processing of the UserInfo Request, you can provide `DefaultOAuth2UserService.setRequestEntityConverter()` with a custom `Converter<OAuth2UserRequest, RequestEntity<?>>`.\nThe default implementation `OAuth2UserRequestEntityConverter` builds a `RequestEntity` representation of a UserInfo Request that sets the `OAuth2AccessToken` in the `Authorization` header by default.\n\nOn the other end, if you need to customize the post-handling of the UserInfo Response, you need to provide `DefaultOAuth2UserService.setRestOperations()` with a custom configured `RestOperations`.\nThe default `RestOperations` is configured as follows:\n\n[source,java]\n----\nRestTemplate restTemplate = new RestTemplate();\nrestTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());\n----\n\n`OAuth2ErrorResponseErrorHandler` is a `ResponseErrorHandler` that can handle an OAuth 2.0 Error (400 Bad Request).\nIt uses an `OAuth2ErrorHttpMessageConverter` for converting the OAuth 2.0 Error parameters to an `OAuth2Error`.\n\nWhether you customize `DefaultOAuth2UserService` or provide your own implementation of `OAuth2UserService`, you need to configure it as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Login((oauth2) -> oauth2\n .userInfoEndpoint((userInfo) -> userInfo\n .userService(this.oauth2UserService())\n ...\n )\n );\n return http.build();\n\t}\n\n\tprivate OAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService() {\n ...\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Login {\n userInfoEndpoint {\n userService = oauth2UserService()\n // ...\n }\n }\n }\n return http.build()\n }\n\n private fun oauth2UserService(): OAuth2UserService<OAuth2UserRequest, OAuth2User> {\n // ...\n }\n}\n----\n======\n\n[[oauth2login-advanced-oidc-user-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc", "title": "advanced", "heading": "OAuth 2.0 UserService", "heading_level": 3, "file_order": 146, "section_index": 7, "content_hash": "d1c3a8e41c9cc410b347a10eef6e52d26f44be559d511a608a48e3c5ee158c41", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc"}}
{"id": "sha256:6bac4471b2673ce32a055f02d6f3e5d4efb3ec177f81549a8ee400ea7b4be9ec", "content": "`OidcUserService` is an implementation of an `OAuth2UserService` that supports OpenID Connect 1.0 Provider's.\n\nThe `OidcUserService` leverages the `DefaultOAuth2UserService` when requesting the user attributes at the UserInfo Endpoint.\n\nIf you need to customize the pre-processing of the UserInfo Request or the post-handling of the UserInfo Response, you need to provide `OidcUserService.setOauth2UserService()` with a custom configured `DefaultOAuth2UserService`.\n\nWhether you customize `OidcUserService` or provide your own implementation of `OAuth2UserService` for OpenID Connect 1.0 Provider's, you need to configure it as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .oauth2Login((oauth2) -> oauth2\n .userInfoEndpoint((userInfo) -> userInfo\n .oidcUserService(this.oidcUserService())\n ...\n )\n );\n return http.build();\n\t}\n\n\tprivate OAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() {\n ...\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2LoginSecurityConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n oauth2Login {\n userInfoEndpoint {\n oidcUserService = oidcUserService()\n // ...\n }\n }\n }\n return http.build()\n }\n\n private fun oidcUserService(): OAuth2UserService<OidcUserRequest, OidcUser> {\n // ...\n }\n}\n----\n======\n\n[[oauth2login-advanced-idtoken-verify]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc", "title": "advanced", "heading": "OpenID Connect 1.0 UserService", "heading_level": 3, "file_order": 146, "section_index": 8, "content_hash": "6bac4471b2673ce32a055f02d6f3e5d4efb3ec177f81549a8ee400ea7b4be9ec", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc"}}
{"id": "sha256:c2f1963b12066920a0d0c150825b76ab03a5f7838e8ad299e7d84df1a11a7a61", "content": "OpenID Connect 1.0 Authentication introduces the https://openid.net/specs/openid-connect-core-1_0.html#IDToken[ID Token], which is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when used by a Client.\n\nThe ID Token is represented as a https://tools.ietf.org/html/rfc7519[JSON Web Token] (JWT) and MUST be signed by using https://tools.ietf.org/html/rfc7515[JSON Web Signature] (JWS).\n\nThe `OidcIdTokenDecoderFactory` provides a `JwtDecoder` used for `OidcIdToken` signature verification. The default algorithm is `RS256` but may be different when assigned during client registration.\nFor these cases, you can configure a resolver to return the expected JWS algorithm assigned for a specific client.\n\nThe JWS algorithm resolver is a `Function` that accepts a `ClientRegistration` and returns the expected `JwsAlgorithm` for the client, such as `SignatureAlgorithm.RS256` or `MacAlgorithm.HS256`\n\nThe following code shows how to configure the `OidcIdTokenDecoderFactory` `@Bean` to default to `MacAlgorithm.HS256` for all `ClientRegistration` instances:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtDecoderFactory<ClientRegistration> idTokenDecoderFactory() {\n\tOidcIdTokenDecoderFactory idTokenDecoderFactory = new OidcIdTokenDecoderFactory();\n\tidTokenDecoderFactory.setJwsAlgorithmResolver((clientRegistration) -> clientRegistration.HS256);\n\treturn idTokenDecoderFactory;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun idTokenDecoderFactory(): JwtDecoderFactory<ClientRegistration?> {\n val idTokenDecoderFactory = OidcIdTokenDecoderFactory()\n idTokenDecoderFactory.setJwsAlgorithmResolver { MacAlgorithm.HS256 }\n return idTokenDecoderFactory\n}\n----\n======\n\n[NOTE]\n====\nFor MAC-based algorithms (such as `HS256`, `HS384`, or `HS512`), the `client-secret` that corresponds to the `client-id` is used as the symmetric key for signature verification.\n====\n\n[TIP]\n====\nIf more than one `ClientRegistration` is configured for OpenID Connect 1.0 Authentication, the JWS algorithm resolver may evaluate the provided `ClientRegistration` to determine which algorithm to return.\n====\n\n[[oauth2login-advanced-oidc-logout]]\nThen, you can proceed to configure xref:servlet/oauth2/login/logout.adoc[logout]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc", "title": "advanced", "heading": "ID Token Signature Verification", "heading_level": 2, "file_order": 146, "section_index": 9, "content_hash": "c2f1963b12066920a0d0c150825b76ab03a5f7838e8ad299e7d84df1a11a7a61", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/advanced.adoc"}}
{"id": "sha256:f0b1d47e198cf3ada926613f3b41962dedf2b3c06dfd49139d61fb256bdc3980", "content": "[[oauth2login-sample-boot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Core Configuration", "heading_level": 1, "file_order": 147, "section_index": 0, "content_hash": "f0b1d47e198cf3ada926613f3b41962dedf2b3c06dfd49139d61fb256bdc3980", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:f104feaf2d903aa13cf5157e536679a0fdf4107bae989091563651f69561dc6e", "content": "Spring Boot brings full auto-configuration capabilities for OAuth 2.0 Login.\n\nThis section shows how to configure the {gh-samples-url}/servlet/spring-boot/java/oauth2/login[*OAuth 2.0 Login sample*] by using _Google_ as the _Authentication Provider_ and covers the following topics:\n\n* <<oauth2login-sample-initial-setup>>\n* <<oauth2login-sample-redirect-uri>>\n* <<oauth2login-sample-application-config>>\n* <<oauth2login-sample-boot-application>>\n\n[[oauth2login-sample-initial-setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Spring Boot Sample", "heading_level": 2, "file_order": 147, "section_index": 1, "content_hash": "f104feaf2d903aa13cf5157e536679a0fdf4107bae989091563651f69561dc6e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:da908f2edd4f9728c3ccc287ca7930045a019488a81ada0741bdb13c58d6a2f5", "content": "To use Google's OAuth 2.0 authentication system for login, you must set up a project in the Google API Console to obtain OAuth 2.0 credentials.\n\n[NOTE]\n====\nhttps://developers.google.com/identity/protocols/OpenIDConnect[Google's OAuth 2.0 implementation] for authentication conforms to the https://openid.net/connect/[OpenID Connect 1.0] specification and is https://openid.net/certification/[OpenID certified].\n====\n\nFollow the instructions on the https://developers.google.com/identity/protocols/OpenIDConnect[OpenID Connect] page, starting in the \"`Setting up OAuth 2.0`\" section.\n\nAfter completing the \"`Obtain OAuth 2.0 credentials`\" instructions, you should have new OAuth Client with credentials consisting of a Client ID and a Client Secret.\n\n[[oauth2login-sample-redirect-uri]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Initial Setup", "heading_level": 3, "file_order": 147, "section_index": 2, "content_hash": "da908f2edd4f9728c3ccc287ca7930045a019488a81ada0741bdb13c58d6a2f5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:de8b2122fb6f557696838e9d5b4fe45b3cdff43cd0934c316b8a6cb521642ce6", "content": "The redirect URI is the path in the application that the end-user's user-agent is redirected back to after they have authenticated with Google and have granted access to the OAuth Client (<<oauth2login-sample-initial-setup,created in the previous step>>) on the Consent page.\n\nIn the \"`Set a redirect URI`\" subsection, ensure that the *Authorized redirect URIs* field is set to `http://localhost:8080/login/oauth2/code/google`.\n\n[TIP]\n====\nThe default redirect URI template is `+{baseUrl}/login/oauth2/code/{registrationId}+`.\nThe `registrationId` is a unique identifier for the xref:servlet/oauth2/client/index.adoc#oauth2Client-client-registration[`ClientRegistration`].\n====\n\n[IMPORTANT]\n====\nIf the OAuth Client runs behind a proxy server, you should check the xref:features/exploits/http.adoc#http-proxy-server[Proxy Server Configuration] to ensure the application is correctly configured.\nAlso, see the supported xref:servlet/oauth2/client/authorization-grants.adoc#oauth2Client-auth-code-redirect-uri[ `URI` template variables] for `redirect-uri`.\n====\n\n[[oauth2login-sample-application-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Setting the Redirect URI", "heading_level": 3, "file_order": 147, "section_index": 3, "content_hash": "de8b2122fb6f557696838e9d5b4fe45b3cdff43cd0934c316b8a6cb521642ce6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:e2b7635094d23f3a6e5b5addefbdb72b5fa3c79485673dec36f3fee1b212a5c8", "content": "Now that you have a new OAuth Client with Google, you need to configure the application to use the OAuth Client for the _authentication flow_.\nTo do so:\n\n. Go to `application.yml` and set the following configuration:\n+\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\t<1>\n google:\t<2>\n client-id: google-client-id\n client-secret: google-client-secret\n----\n+\n.OAuth Client properties\n<1> `spring.security.oauth2.client.registration` is the base property prefix for OAuth Client properties.\n<2> Following the base property prefix is the ID for the xref:servlet/oauth2/client/index.adoc#oauth2Client-client-registration[`ClientRegistration`], such as Google.\n\n. Replace the values in the `client-id` and `client-secret` property with the OAuth 2.0 credentials you created earlier.\n\n[[oauth2login-sample-boot-application]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Configure application.yml", "heading_level": 3, "file_order": 147, "section_index": 4, "content_hash": "e2b7635094d23f3a6e5b5addefbdb72b5fa3c79485673dec36f3fee1b212a5c8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:c656e3c7f4daf1c3f63f1cda31b0115d8664f756d2dc502e1dc0ec439a7f59d4", "content": "Launch the Spring Boot sample and go to `http://localhost:8080`.\nYou are then redirected to the default _auto-generated_ login page, which displays a link for Google.\n\nClick on the Google link, and you are then redirected to Google for authentication.\n\nAfter authenticating with your Google account credentials, you see the Consent screen.\nThe Consent screen asks you to either allow or deny access to the OAuth Client you created earlier.\nClick *Allow* to authorize the OAuth Client to access your email address and basic profile information.\n\nAt this point, the OAuth Client retrieves your email address and basic profile information from the https://openid.net/specs/openid-connect-core-1_0.html#UserInfo[UserInfo Endpoint] and establishes an authenticated session.\n\n[[oauth2login-boot-property-mappings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Boot up the Application", "heading_level": 3, "file_order": 147, "section_index": 5, "content_hash": "c656e3c7f4daf1c3f63f1cda31b0115d8664f756d2dc502e1dc0ec439a7f59d4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:ffed7da4ad3ce84799b70f6d34e1eccc1b7e91d1e81cbfcd1afcb1e0ccab33c0", "content": "The following table outlines the mapping of the Spring Boot OAuth Client properties to the xref:servlet/oauth2/client/index.adoc#oauth2Client-client-registration[ClientRegistration] properties.\n\n|===\n|Spring Boot |ClientRegistration\n\n|`spring.security.oauth2.client.registration._[registrationId]_`\n|`registrationId`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.client-id`\n|`clientId`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.client-secret`\n|`clientSecret`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.client-authentication-method`\n|`clientAuthenticationMethod`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.authorization-grant-type`\n|`authorizationGrantType`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.redirect-uri`\n|`redirectUri`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.scope`\n|`scopes`\n\n|`spring.security.oauth2.client.registration._[registrationId]_.client-name`\n|`clientName`\n\n|`spring.security.oauth2.client.provider._[providerId]_.authorization-uri`\n|`providerDetails.authorizationUri`\n\n|`spring.security.oauth2.client.provider._[providerId]_.token-uri`\n|`providerDetails.tokenUri`\n\n|`spring.security.oauth2.client.provider._[providerId]_.jwk-set-uri`\n|`providerDetails.jwkSetUri`\n\n|`spring.security.oauth2.client.provider._[providerId]_.issuer-uri`\n|`providerDetails.issuerUri`\n\n|`spring.security.oauth2.client.provider._[providerId]_.user-info-uri`\n|`providerDetails.userInfoEndpoint.uri`\n\n|`spring.security.oauth2.client.provider._[providerId]_.user-info-authentication-method`\n|`providerDetails.userInfoEndpoint.authenticationMethod`\n\n|`spring.security.oauth2.client.provider._[providerId]_.user-name-attribute`\n|`providerDetails.userInfoEndpoint.userNameAttributeName`\n|===\n\n[TIP]\n====\nYou can initially configure a `ClientRegistration` by using discovery of an OpenID Connect Provider's https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[Configuration endpoint] or an Authorization Server's https://tools.ietf.org/html/rfc8414#section-3[Metadata endpoint], by specifying the `spring.security.oauth2.client.provider._[providerId]_.issuer-uri` property.\n====\n\n[[oauth2login-common-oauth2-provider]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Spring Boot Property Mappings", "heading_level": 2, "file_order": 147, "section_index": 6, "content_hash": "ffed7da4ad3ce84799b70f6d34e1eccc1b7e91d1e81cbfcd1afcb1e0ccab33c0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:863a6db2e24a7a5e8fb97a05a0b3bdf6c0cf8fc46b792e83168507dc383ed40e", "content": "`CommonOAuth2Provider` pre-defines a set of default client properties for a number of well known providers: Google, GitHub, Facebook, X, and Okta.\n\nFor example, the `authorization-uri`, `token-uri`, and `user-info-uri` do not change often for a provider.\nTherefore, it makes sense to provide default values, to reduce the required configuration.\n\nAs demonstrated previously, when we <<oauth2login-sample-application-config,configured a Google client>>, only the `client-id` and `client-secret` properties are required.\n\nThe following listing shows an example:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n google:\n client-id: google-client-id\n client-secret: google-client-secret\n----\n\n[TIP]\nThe auto-defaulting of client properties works seamlessly here because the `registrationId` (`google`) matches the `GOOGLE` `enum` (case-insensitive) in `CommonOAuth2Provider`.\n\nFor cases where you may want to specify a different `registrationId`, such as `google-login`, you can still leverage auto-defaulting of client properties by configuring the `provider` property.\n\nThe following listing shows an example:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n google-login:\t<1>\n provider: google\t<2>\n client-id: google-client-id\n client-secret: google-client-secret\n----\n<1> The `registrationId` is set to `google-login`.\n<2> The `provider` property is set to `google`, which will leverage the auto-defaulting of client properties set in `CommonOAuth2Provider.GOOGLE.getBuilder()`.\n\n[[oauth2login-custom-provider-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "CommonOAuth2Provider", "heading_level": 2, "file_order": 147, "section_index": 7, "content_hash": "863a6db2e24a7a5e8fb97a05a0b3bdf6c0cf8fc46b792e83168507dc383ed40e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:0cf1e22fdafb68e6d6afb35bc331536878a66387ab9aa0e29b5980bcfe253197", "content": "There are some OAuth 2.0 Providers that support multi-tenancy, which results in different protocol endpoints for each tenant (or sub-domain).\n\nFor example, an OAuth Client registered with Okta is assigned to a specific sub-domain and have their own protocol endpoints.\n\nFor these cases, Spring Boot provides the following base property for configuring custom provider properties: `spring.security.oauth2.client.provider._[providerId]_`.\n\nThe following listing shows an example:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n provider:\n okta:\t<1>\n authorization-uri: https://your-subdomain.oktapreview.com/oauth2/v1/authorize\n token-uri: https://your-subdomain.oktapreview.com/oauth2/v1/token\n user-info-uri: https://your-subdomain.oktapreview.com/oauth2/v1/userinfo\n user-name-attribute: sub\n jwk-set-uri: https://your-subdomain.oktapreview.com/oauth2/v1/keys\n----\n<1> The base property (`spring.security.oauth2.client.provider.okta`) allows for custom configuration of protocol endpoint locations.\n\n[[oauth2login-override-boot-autoconfig]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Configuring Custom Provider Properties", "heading_level": 2, "file_order": 147, "section_index": 8, "content_hash": "0cf1e22fdafb68e6d6afb35bc331536878a66387ab9aa0e29b5980bcfe253197", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:5904d340126459f200ad00189d72e72bd9fb77d69d90a5b65d0debc7830b1520", "content": "The Spring Boot auto-configuration class for OAuth Client support is `OAuth2ClientAutoConfiguration`.\n\nIt performs the following tasks:\n\n* Registers a `ClientRegistrationRepository` `@Bean` composed of `ClientRegistration`(s) from the configured OAuth Client properties.\n* Registers a `SecurityFilterChain` `@Bean` and enables OAuth 2.0 Login through `httpSecurity.oauth2Login()`.\n\nIf you need to override the auto-configuration based on your specific requirements, you may do so in the following ways:\n\n* <<oauth2login-register-clientregistrationrepository-bean>>\n* <<oauth2login-provide-securityfilterchain-bean>>\n* <<oauth2login-completely-override-autoconfiguration>>\n\n[[oauth2login-register-clientregistrationrepository-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Overriding Spring Boot Auto-configuration", "heading_level": 2, "file_order": 147, "section_index": 9, "content_hash": "5904d340126459f200ad00189d72e72bd9fb77d69d90a5b65d0debc7830b1520", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:42b35ef5f46cbd6a596da7902f84db5440e9b11777860c62fdb6d299756948c2", "content": "The following example shows how to register a `ClientRegistrationRepository` `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",attrs=\"-attributes\"]\n----\n@Configuration\npublic class OAuth2LoginConfig {\n\n\t@Bean\n\tpublic ClientRegistrationRepository clientRegistrationRepository() {\n return new InMemoryClientRegistrationRepository(this.googleClientRegistration());\n\t}\n\n\tprivate ClientRegistration googleClientRegistration() {\n return ClientRegistration.withRegistrationId(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n .scope(\"openid\", \"profile\", \"email\", \"address\", \"phone\")\n .authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth\")\n .tokenUri(\"https://www.googleapis.com/oauth2/v4/token\")\n .userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n .userNameAttributeName(IdTokenClaimNames.SUB)\n .jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n .clientName(\"Google\")\n .build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",attrs=\"-attributes\"]\n----\n@Configuration\nclass OAuth2LoginConfig {\n @Bean\n fun clientRegistrationRepository(): ClientRegistrationRepository {\n return InMemoryClientRegistrationRepository(googleClientRegistration())\n }\n\n private fun googleClientRegistration(): ClientRegistration {\n return ClientRegistration.withRegistrationId(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n .scope(\"openid\", \"profile\", \"email\", \"address\", \"phone\")\n .authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth\")\n .tokenUri(\"https://www.googleapis.com/oauth2/v4/token\")\n .userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n .userNameAttributeName(IdTokenClaimNames.SUB)\n .jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n .clientName(\"Google\")\n .build()\n }\n}\n----\n======\n\n[[oauth2login-provide-securityfilterchain-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Register a ClientRegistrationRepository @Bean", "heading_level": 3, "file_order": 147, "section_index": 10, "content_hash": "42b35ef5f46cbd6a596da7902f84db5440e9b11777860c62fdb6d299756948c2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:4f9273d920a5155db339f5fa2c6fe058165ae91027d69e6a33fd50752b6cb24c", "content": "The following example shows how to register a `SecurityFilterChain` `@Bean` with `@EnableWebSecurity` and enable OAuth 2.0 login through `httpSecurity.oauth2Login()`:\n\n.OAuth2 Login Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2Login(withDefaults());\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2LoginSecurityConfig {\n\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2Login { }\n }\n return http.build()\n }\n}\n----\n======\n\n[[oauth2login-completely-override-autoconfiguration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Register a SecurityFilterChain @Bean", "heading_level": 3, "file_order": 147, "section_index": 11, "content_hash": "4f9273d920a5155db339f5fa2c6fe058165ae91027d69e6a33fd50752b6cb24c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:10d8022ddc468e54363eb794ecb658d679a5b0cdb511e606617b4dac10e5e930", "content": "The following example shows how to completely override the auto-configuration by registering a `ClientRegistrationRepository` `@Bean` and a `SecurityFilterChain` `@Bean`.\n\n.Overriding the auto-configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\",attrs=\"-attributes\"]\n----\n@Configuration\npublic class OAuth2LoginConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2Login(withDefaults());\n return http.build();\n\t}\n\n\t@Bean\n\tpublic ClientRegistrationRepository clientRegistrationRepository() {\n return new InMemoryClientRegistrationRepository(this.googleClientRegistration());\n\t}\n\n\tprivate ClientRegistration googleClientRegistration() {\n return ClientRegistration.withRegistrationId(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n .scope(\"openid\", \"profile\", \"email\", \"address\", \"phone\")\n .authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth\")\n .tokenUri(\"https://www.googleapis.com/oauth2/v4/token\")\n .userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n .userNameAttributeName(IdTokenClaimNames.SUB)\n .jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n .clientName(\"Google\")\n .build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\",attrs=\"-attributes\"]\n----\n@Configuration\nclass OAuth2LoginConfig {\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2Login { }\n }\n return http.build()\n }\n\n @Bean\n fun clientRegistrationRepository(): ClientRegistrationRepository {\n return InMemoryClientRegistrationRepository(googleClientRegistration())\n }\n\n private fun googleClientRegistration(): ClientRegistration {\n return ClientRegistration.withRegistrationId(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n .scope(\"openid\", \"profile\", \"email\", \"address\", \"phone\")\n .authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth\")\n .tokenUri(\"https://www.googleapis.com/oauth2/v4/token\")\n .userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n .userNameAttributeName(IdTokenClaimNames.SUB)\n .jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n .clientName(\"Google\")\n .build()\n }\n}\n----\n======\n\n[[oauth2login-javaconfig-wo-boot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Completely Override the Auto-configuration", "heading_level": 3, "file_order": 147, "section_index": 12, "content_hash": "10d8022ddc468e54363eb794ecb658d679a5b0cdb511e606617b4dac10e5e930", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:1fc8ea26fba5d803157aa35b2ecd8b0985cbcd2f4dd823ce76b4a0e119b0a4de", "content": "If you are not able to use Spring Boot and would like to configure one of the pre-defined providers in `CommonOAuth2Provider` (for example, Google), apply the following configuration:\n\n.OAuth2 Login Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2Login(withDefaults());\n return http.build();\n\t}\n\n\t@Bean\n\tpublic ClientRegistrationRepository clientRegistrationRepository() {\n return new InMemoryClientRegistrationRepository(this.googleClientRegistration());\n\t}\n\n\t@Bean\n\tpublic OAuth2AuthorizedClientService authorizedClientService(\n ClientRegistrationRepository clientRegistrationRepository) {\n return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository);\n\t}\n\n\t@Bean\n\tpublic OAuth2AuthorizedClientRepository authorizedClientRepository(\n OAuth2AuthorizedClientService authorizedClientService) {\n return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService);\n\t}\n\n\tprivate ClientRegistration googleClientRegistration() {\n return CommonOAuth2Provider.GOOGLE.getBuilder(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nopen class OAuth2LoginConfig {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2Login { }\n }\n return http.build()\n }\n\n @Bean\n open fun clientRegistrationRepository(): ClientRegistrationRepository {\n return InMemoryClientRegistrationRepository(googleClientRegistration())\n }\n\n @Bean\n open fun authorizedClientService(\n clientRegistrationRepository: ClientRegistrationRepository?\n ): OAuth2AuthorizedClientService {\n return InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository)\n }\n\n @Bean\n open fun authorizedClientRepository(\n authorizedClientService: OAuth2AuthorizedClientService?\n ): OAuth2AuthorizedClientRepository {\n return AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService)\n }\n\n private fun googleClientRegistration(): ClientRegistration {\n return CommonOAuth2Provider.GOOGLE.getBuilder(\"google\")\n .clientId(\"google-client-id\")\n .clientSecret(\"google-client-secret\")\n .build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http auto-config=\"true\">\n\t<intercept-url pattern=\"/**\" access=\"authenticated\"/>\n\t<oauth2-login authorized-client-repository-ref=\"authorizedClientRepository\"/>\n</http>\n\n<client-registrations>\n\t<client-registration registration-id=\"google\"\n client-id=\"google-client-id\"\n client-secret=\"google-client-secret\"\n provider-id=\"google\"/>\n</client-registrations>\n\n<b:bean id=\"authorizedClientService\"\n class=\"org.springframework.security.oauth2.client.InMemoryOAuth2AuthorizedClientService\"\n autowire=\"constructor\"/>\n\n<b:bean id=\"authorizedClientRepository\"\n class=\"org.springframework.security.oauth2.client.web.AuthenticatedPrincipalOAuth2AuthorizedClientRepository\">\n\t<b:constructor-arg ref=\"authorizedClientService\"/>\n</b:bean>\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc", "title": "Core Configuration", "heading": "Java Configuration without Spring Boot", "heading_level": 2, "file_order": 147, "section_index": 13, "content_hash": "1fc8ea26fba5d803157aa35b2ecd8b0985cbcd2f4dd823ce76b4a0e119b0a4de", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/core.adoc"}}
{"id": "sha256:f16efe73fd1e25be6f9591d853647f929e8dd2fb75ea431d2c36baeb54961156", "content": "[[oauth2login]]\n\nThe OAuth 2.0 Login feature lets an application have users log in to the application by using their existing account at an OAuth 2.0 Provider (such as GitHub) or OpenID Connect 1.0 Provider (such as Google).\nOAuth 2.0 Login implements two use cases: \"`Login with Google`\" or \"`Login with GitHub`\".\n\n[NOTE]\n====\nOAuth 2.0 Login is implemented by using the *Authorization Code Grant*, as specified in the https://tools.ietf.org/html/rfc6749#section-4.1[OAuth 2.0 Authorization Framework] and https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth[OpenID Connect Core 1.0].\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 148, "section_index": 0, "content_hash": "f16efe73fd1e25be6f9591d853647f929e8dd2fb75ea431d2c36baeb54961156", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/index.adoc"}}
{"id": "sha256:815d23996da192e69603bed3d3230dc786054940b2bed428cabc3aa6eeed9ba7", "content": "Once an end user is able to login to your application, it's important to consider how they will log out.\n\nGenerally speaking, there are three use cases for you to consider:\n\n1. I want to perform only a local logout\n2. I want to log out both my application and the OIDC Provider, initiated by my application\n3. I want to log out both my application and the OIDC Provider, initiated by the OIDC Provider\n\n[[configure-local-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "OIDC Logout", "heading_level": 1, "file_order": 149, "section_index": 0, "content_hash": "815d23996da192e69603bed3d3230dc786054940b2bed428cabc3aa6eeed9ba7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc"}}
{"id": "sha256:f1490d7e1172a1009b44bd2e24d68661432e5744c26a35e9f21f245efcbd5277", "content": "To perform a local logout, no special OIDC configuration is needed.\nSpring Security automatically stands up a local logout endpoint, which you can xref:servlet/authentication/logout.adoc[configure through the `logout()` DSL].\n\n[[configure-client-initiated-oidc-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "Local Logout", "heading_level": 2, "file_order": 149, "section_index": 1, "content_hash": "f1490d7e1172a1009b44bd2e24d68661432e5744c26a35e9f21f245efcbd5277", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc"}}
{"id": "sha256:09bd28e39aca41c2a33c6a44fb6caa681f0e8fa30b42eb07abbdd3730ae233e2", "content": "OpenID Connect Session Management 1.0 allows the ability to log out the end user at the Provider by using the Client.\nOne of the strategies available is https://openid.net/specs/openid-connect-rpinitiated-1_0.html[RP-Initiated Logout].\n\nIf the OpenID Provider supports both Session Management and https://openid.net/specs/openid-connect-discovery-1_0.html[Discovery], the client can obtain the `end_session_endpoint` `URL` from the OpenID Provider's https://openid.net/specs/openid-connect-session-1_0.html#OPMetadata[Discovery Metadata].\nYou can do so by configuring the `ClientRegistration` with the `issuer-uri`, as follows:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n okta:\n client-id: okta-client-id\n client-secret: okta-client-secret\n ...\n provider:\n okta:\n issuer-uri: https://dev-1234.oktapreview.com\n----\n\nAlso, you should configure `OidcClientInitiatedLogoutSuccessHandler`, which implements RP-Initiated Logout, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig {\n\n\t@Autowired\n\tprivate ClientRegistrationRepository clientRegistrationRepository;\n\n\t@Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2Login(withDefaults())\n .logout((logout) -> logout\n .logoutSuccessHandler(oidcLogoutSuccessHandler())\n );\n return http.build();\n\t}\n\n\tprivate LogoutSuccessHandler oidcLogoutSuccessHandler() {\n OidcClientInitiatedLogoutSuccessHandler oidcLogoutSuccessHandler =\n new OidcClientInitiatedLogoutSuccessHandler(this.clientRegistrationRepository);\n\n // Sets the location that the End-User's User Agent will be redirected to\n // after the logout has been performed at the Provider\n oidcLogoutSuccessHandler.setPostLogoutRedirectUri(\"{baseUrl}\");\n\n return oidcLogoutSuccessHandler;\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass OAuth2LoginSecurityConfig {\n @Autowired\n private lateinit var clientRegistrationRepository: ClientRegistrationRepository\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2Login { }\n logout {\n logoutSuccessHandler = oidcLogoutSuccessHandler()\n }\n }\n return http.build()\n }\n\n private fun oidcLogoutSuccessHandler(): LogoutSuccessHandler {\n val oidcLogoutSuccessHandler = OidcClientInitiatedLogoutSuccessHandler(clientRegistrationRepository)\n\n // Sets the location that the End-User's User Agent will be redirected to\n // after the logout has been performed at the Provider\n oidcLogoutSuccessHandler.setPostLogoutRedirectUri(\"{baseUrl}\")\n return oidcLogoutSuccessHandler\n }\n}\n----\n======\n\n[NOTE]\n====\n`OidcClientInitiatedLogoutSuccessHandler` supports the `+{baseUrl}+` placeholder.\nIf used, the application's base URL, such as `https://app.example.org`, replaces it at request time.\n====\n\n[NOTE]\n====\nBy default, `OidcClientInitiatedLogoutSuccessHandler` redirects to the logout URL using a standard HTTP redirect with the `GET` method.\nTo perform the logout using a `POST` request, set the redirect strategy to `FormPostRedirectStrategy`, for example with `OidcClientInitiatedLogoutSuccessHandler.setRedirectStrategy(new FormPostRedirectStrategy())`.\n====\n\n[[configure-provider-initiated-oidc-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "OpenID Connect 1.0 Client-Initiated Logout", "heading_level": 2, "file_order": 149, "section_index": 2, "content_hash": "09bd28e39aca41c2a33c6a44fb6caa681f0e8fa30b42eb07abbdd3730ae233e2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc"}}
{"id": "sha256:9fca7799f72dd0157cdbde09e56366cda183cc6adff794bbf54e0fae6972340a", "content": "OpenID Connect Session Management 1.0 allows the ability to log out the end user at the Client by having the Provider make an API call to the Client.\nThis is referred to as https://openid.net/specs/openid-connect-backchannel-1_0.html[OIDC Back-Channel Logout].\n\nTo enable this, you can stand up the Back-Channel Logout endpoint in the DSL like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nOidcBackChannelLogoutHandler oidcLogoutHandler() {\n\treturn new OidcBackChannelLogoutHandler();\n}\n\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2Login(withDefaults())\n .oidcLogout((logout) -> logout\n .backChannel(Customizer.withDefaults())\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun oidcLogoutHandler(): OidcBackChannelLogoutHandler {\n return OidcBackChannelLogoutHandler()\n}\n\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2Login { }\n oidcLogout {\n backChannel { }\n }\n }\n return http.build()\n}\n----\n======\n\nThen, you need a way listen to events published by Spring Security to remove old `OidcSessionInformation` entries, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic HttpSessionEventPublisher sessionEventPublisher() {\n return new HttpSessionEventPublisher();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun sessionEventPublisher(): HttpSessionEventPublisher {\n return HttpSessionEventPublisher()\n}\n----\n======\n\nThis will make so that if `HttpSession#invalidate` is called, then the session is also removed from memory.\n\nAnd that's it!\n\nThis will stand up the endpoint `+/logout/connect/back-channel/{registrationId}+` which the OIDC Provider can request to invalidate a given session of an end user in your application.\n\n[NOTE]\n`oidcLogout` requires that `oauth2Login` also be configured.\n\n[NOTE]\n`oidcLogout` requires that the session cookie be called `JSESSIONID` in order to correctly log out each session through a backchannel.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "OpenID Connect 1.0 Back-Channel Logout", "heading_level": 2, "file_order": 149, "section_index": 3, "content_hash": "9fca7799f72dd0157cdbde09e56366cda183cc6adff794bbf54e0fae6972340a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc"}}
{"id": "sha256:2567f1d2aa7cabd6401bd5d5a08f6be0d1a6bf5afd822db5803003988ca41479", "content": "Consider a `ClientRegistration` whose identifier is `registrationId`.\n\nThe overall flow for a Back-Channel logout is like this:\n\n1. At login time, Spring Security correlates the ID Token, CSRF Token, and Provider Session ID (if any) to your application's session id in its `OidcSessionRegistry` implementation.\n2. Then at logout time, your OIDC Provider makes an API call to `/logout/connect/back-channel/registrationId` including a Logout Token that indicates either the `sub` (the End User) or the `sid` (the Provider Session ID) to logout.\n3. Spring Security validates the token's signature and claims.\n4. If the token contains a `sid` claim, then only the Client's session that correlates to that provider session is terminated.\n5. Otherwise, if the token contains a `sub` claim, then all that Client's sessions for that End User are terminated.\n\n[NOTE]\nRemember that Spring Security's OIDC support is multi-tenant.\nThis means that it will only terminate sessions whose Client matches the `aud` claim in the Logout Token.\n\nOne notable part of this architecture's implementation is that it propagates the incoming back-channel request internally for each corresponding session.\nInitially, this may seem unnecessary.\nHowever, recall that the Servlet API does not give direct access to the `HttpSession` store.\nBy making an internal logout call, the corresponding session can now be invalidated.\n\nAdditionally, forging a logout call internally allows for each set of ``LogoutHandler``s to be run against that session and corresponding `SecurityContext`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "Back-Channel Logout Architecture", "heading_level": 3, "file_order": 149, "section_index": 4, "content_hash": "2567f1d2aa7cabd6401bd5d5a08f6be0d1a6bf5afd822db5803003988ca41479", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc"}}
{"id": "sha256:18471d3fe749e4acc0fa1bed53e938bb77932df2e93f80d5eb4b1788c6b1128b", "content": "With `OidcBackChannelLogoutHandler` published, the session logout endpoint is `+{baseUrl}+/logout/connect/back-channel/+{registrationId}+`.\n\nIf `OidcBackChannelLogoutHandler` is not wired, then the URL is `+{baseUrl}+/logout/connect/back-channel/+{registrationId}+`, which is not recommended since it requires passing a CSRF token, which can be challenging depending on the kind of repository your application uses.\n\nIn the event that you need to customize the endpoint, you can provide the URL as follows:\n\n[tabs]\n======\nJava::\n+\n[source=java,role=\"primary\"]\n----\nhttp\n // ...\n .oidcLogout((oidc) -> oidc\n .backChannel((backChannel) -> backChannel\n .logoutUri(\"http://localhost:9000/logout/connect/back-channel/+{registrationId}+\")\n )\n );\n----\n\nKotlin::\n+\n[source=kotlin,role=\"secondary\"]\n----\nhttp {\n oidcLogout {\n backChannel {\n logoutUri = \"http://localhost:9000/logout/connect/back-channel/+{registrationId}+\"\n }\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "Customizing the Session Logout Endpoint", "heading_level": 3, "file_order": 149, "section_index": 5, "content_hash": "18471d3fe749e4acc0fa1bed53e938bb77932df2e93f80d5eb4b1788c6b1128b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc"}}
{"id": "sha256:d472007f9d8517cbd82647848b1c3d9b794138423e15aa86a51c6a0e3b4574d5", "content": "By default, the session logout endpoint uses the `JSESSIONID` cookie to correlate the session to the corresponding `OidcSessionInformation`.\n\nHowever, the default cookie name in Spring Session is `SESSION`.\n\nYou can configure Spring Session's cookie name in the DSL like so:\n\n[tabs]\n======\nJava::\n+\n[source=java,role=\"primary\"]\n----\n@Bean\nOidcBackChannelLogoutHandler oidcLogoutHandler(OidcSessionRegistry oidcSessionRegistry) {\n OidcBackChannelLogoutHandler logoutHandler = new OidcBackChannelLogoutHandler(oidcSessionRegistry);\n logoutHandler.setSessionCookieName(\"SESSION\");\n return logoutHandler;\n}\n----\n\nKotlin::\n+\n[source=kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun oidcLogoutHandler(val sessionRegistry: OidcSessionRegistry): OidcBackChannelLogoutHandler {\n val logoutHandler = OidcBackChannelLogoutHandler(sessionRegistry)\n logoutHandler.setSessionCookieName(\"SESSION\")\n return logoutHandler\n}\n----\n======\n\n[[oidc-backchannel-logout-session-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "Customizing the Session Logout Cookie Name", "heading_level": 3, "file_order": 149, "section_index": 6, "content_hash": "d472007f9d8517cbd82647848b1c3d9b794138423e15aa86a51c6a0e3b4574d5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc"}}
{"id": "sha256:e05afca74a306184c866e14c1ea03cb1c87e46e822018381bc7533aa572ea980", "content": "By default, Spring Security stores in-memory all links between the OIDC Provider session and the Client session.\n\nThere are a number of circumstances, like a clustered application, where it would be nice to store this instead in a separate location, like a database.\n\nYou can achieve this by configuring a custom `OidcSessionRegistry`, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic final class MySpringDataOidcSessionRegistry implements OidcSessionRegistry {\n private final OidcProviderSessionRepository sessions;\n\n // ...\n\n @Override\n public void saveSessionInformation(OidcSessionInformation info) {\n this.sessions.save(info);\n }\n\n @Override\n public OidcSessionInformation removeSessionInformation(String clientSessionId) {\n return this.sessions.removeByClientSessionId(clientSessionId);\n }\n\n @Override\n public Iterable<OidcSessionInformation> removeSessionInformation(OidcLogoutToken token) {\n return token.getSessionId() != null ?\n this.sessions.removeBySessionIdAndIssuerAndAudience(...) :\n this.sessions.removeBySubjectAndIssuerAndAudience(...);\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass MySpringDataOidcSessionRegistry: OidcSessionRegistry {\n val sessions: OidcProviderSessionRepository\n\n // ...\n\n @Override\n fun saveSessionInformation(info: OidcSessionInformation) {\n this.sessions.save(info)\n }\n\n @Override\n fun removeSessionInformation(clientSessionId: String): OidcSessionInformation {\n return this.sessions.removeByClientSessionId(clientSessionId);\n }\n\n @Override\n fun removeSessionInformation(token: OidcLogoutToken): Iterable<OidcSessionInformation> {\n return token.getSessionId() != null ?\n this.sessions.removeBySessionIdAndIssuerAndAudience(...) :\n this.sessions.removeBySubjectAndIssuerAndAudience(...);\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc", "title": "OIDC Logout", "heading": "Customizing the OIDC Provider Session Registry", "heading_level": 3, "file_order": 149, "section_index": 7, "content_hash": "e05afca74a306184c866e14c1ea03cb1c87e46e822018381bc7533aa572ea980", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/login/logout.adoc"}}
{"id": "sha256:02ab822caa52e1cbe783577f1e2d0062c6862f52af724e9c37b07abf03af1c83", "content": "[[oauth2resourceserver-bearertoken-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc", "title": "OAuth 2.0 Bearer Tokens", "heading": "OAuth 2.0 Bearer Tokens", "heading_level": 1, "file_order": 150, "section_index": 0, "content_hash": "02ab822caa52e1cbe783577f1e2d0062c6862f52af724e9c37b07abf03af1c83", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc"}}
{"id": "sha256:9efaa48b08069f047c1be606a867f18f23cb3ea756f626ccbd085e98b257f433", "content": "By default, Resource Server looks for a bearer token in the `Authorization` header.\nThis, however, can be customized in a handful of ways.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc", "title": "OAuth 2.0 Bearer Tokens", "heading": "Bearer Token Resolution", "heading_level": 2, "file_order": 150, "section_index": 1, "content_hash": "9efaa48b08069f047c1be606a867f18f23cb3ea756f626ccbd085e98b257f433", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc"}}
{"id": "sha256:2c5061ce7d17306126d0bc70606c48d7f14b7036c2f63a76a8933b58abdc7a49", "content": "For example, you may have a need to read the bearer token from a custom header.\nTo achieve this, you can expose a `DefaultBearerTokenResolver` as a bean, or wire an instance into the DSL, as you can see in the following example:\n\n.Custom Bearer Token Header\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nBearerTokenResolver bearerTokenResolver() {\n DefaultBearerTokenResolver bearerTokenResolver = new DefaultBearerTokenResolver();\n bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION);\n return bearerTokenResolver;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun bearerTokenResolver(): BearerTokenResolver {\n val bearerTokenResolver = DefaultBearerTokenResolver()\n bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION)\n return bearerTokenResolver\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <oauth2-resource-server bearer-token-resolver-ref=\"bearerTokenResolver\"/>\n</http>\n\n<bean id=\"bearerTokenResolver\"\n class=\"org.springframework.security.oauth2.server.resource.web.DefaultBearerTokenResolver\">\n <property name=\"bearerTokenHeaderName\" value=\"Proxy-Authorization\"/>\n</bean>\n----\n======\n\nOr, in circumstances where a provider is using both a custom header and value, you can use `HeaderBearerTokenResolver` instead.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc", "title": "OAuth 2.0 Bearer Tokens", "heading": "Reading the Bearer Token from a Custom Header", "heading_level": 3, "file_order": 150, "section_index": 2, "content_hash": "2c5061ce7d17306126d0bc70606c48d7f14b7036c2f63a76a8933b58abdc7a49", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc"}}
{"id": "sha256:a54be90701630c3c444cf7e952dc26623ed7db2c8904fe97681b7ec13c368187", "content": "Or, you may wish to read the token from a form parameter, which you can do by configuring the `DefaultBearerTokenResolver`, as you can see below:\n\n.Form Parameter Bearer Token\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nDefaultBearerTokenResolver resolver = new DefaultBearerTokenResolver();\nresolver.setAllowFormEncodedBodyParameter(true);\nhttp\n .oauth2ResourceServer((oauth2) -> oauth2\n .bearerTokenResolver(resolver)\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval resolver = DefaultBearerTokenResolver()\nresolver.setAllowFormEncodedBodyParameter(true)\nhttp {\n oauth2ResourceServer {\n bearerTokenResolver = resolver\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <oauth2-resource-server bearer-token-resolver-ref=\"bearerTokenResolver\"/>\n</http>\n\n<bean id=\"bearerTokenResolver\"\n class=\"org.springframework.security.oauth2.server.resource.web.HeaderBearerTokenResolver\">\n <property name=\"allowFormEncodedBodyParameter\" value=\"true\"/>\n</bean>\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc", "title": "OAuth 2.0 Bearer Tokens", "heading": "Reading the Bearer Token from a Form Parameter", "heading_level": 3, "file_order": 150, "section_index": 3, "content_hash": "a54be90701630c3c444cf7e952dc26623ed7db2c8904fe97681b7ec13c368187", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc"}}
{"id": "sha256:b82cba703da7d156f5f7f915a6a916118587abd6a32cbe9cbc7953c76c6cfb2d", "content": "Now that your resource server has validated the token, it might be handy to pass it to downstream services.\nThis is quite simple with javadoc:org.springframework.security.oauth2.server.resource.web.reactive.function.client.ServletBearerExchangeFilterFunction[], which you can see in the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic WebClient rest() {\n return WebClient.builder()\n .filter(new ServletBearerExchangeFilterFunction())\n .build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun rest(): WebClient {\n return WebClient.builder()\n .filter(ServletBearerExchangeFilterFunction())\n .build()\n}\n----\n======\n\nWhen the above `WebClient` is used to perform requests, Spring Security will look up the current `Authentication` and extract any javadoc:org.springframework.security.oauth2.core.AbstractOAuth2Token[] credential.\nThen, it will propagate that token in the `Authorization` header.\n\nFor example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nthis.rest.get()\n .uri(\"https://other-service.example.com/endpoint\")\n .retrieve()\n .bodyToMono(String.class)\n .block()\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nthis.rest.get()\n .uri(\"https://other-service.example.com/endpoint\")\n .retrieve()\n .bodyToMono<String>()\n .block()\n----\n======\n\nWill invoke the `https://other-service.example.com/endpoint`, adding the bearer token `Authorization` header for you.\n\nIn places where you need to override this behavior, it's a simple matter of supplying the header yourself, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nthis.rest.get()\n .uri(\"https://other-service.example.com/endpoint\")\n .headers((headers) -> headers.setBearerAuth(overridingToken))\n .retrieve()\n .bodyToMono(String.class)\n .block()\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nthis.rest.get()\n .uri(\"https://other-service.example.com/endpoint\")\n .headers{ headers -> headers.setBearerAuth(overridingToken)}\n .retrieve()\n .bodyToMono<String>()\n .block()\n----\n======\n\nIn this case, the filter will fall back and simply forward the request onto the rest of the web filter chain.\n\n[NOTE]\nUnlike the javadoc:org.springframework.security.oauth2.client.web.reactive.function.client.ServletOAuth2AuthorizedClientExchangeFilterFunction[OAuth 2.0 Client filter function], this filter function makes no attempt to renew the token, should it be expired.\nTo obtain this level of support, please use the OAuth 2.0 Client filter.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc", "title": "OAuth 2.0 Bearer Tokens", "heading": "Bearer Token Propagation", "heading_level": 2, "file_order": 150, "section_index": 4, "content_hash": "b82cba703da7d156f5f7f915a6a916118587abd6a32cbe9cbc7953c76c6cfb2d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc"}}
{"id": "sha256:083775be7543f6624d3bf62e18d6d445ca3d706c48296f4555c5b89dcba7fd9b", "content": "There is no `RestTemplate` equivalent for `ServletBearerExchangeFilterFunction` at the moment, but you can propagate the request's bearer token quite simply with your own interceptor:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nRestTemplate rest() {\n\tRestTemplate rest = new RestTemplate();\n\trest.getInterceptors().add((request, body, execution) -> {\n Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n if (authentication == null) {\n return execution.execute(request, body);\n }\n\n if (!(authentication.getCredentials() instanceof AbstractOAuth2Token)) {\n return execution.execute(request, body);\n }\n\n AbstractOAuth2Token token = (AbstractOAuth2Token) authentication.getCredentials();\n request.getHeaders().setBearerAuth(token.getTokenValue());\n return execution.execute(request, body);\n\t});\n\treturn rest;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun rest(): RestTemplate {\n val rest = RestTemplate()\n rest.interceptors.add(ClientHttpRequestInterceptor { request, body, execution ->\n val authentication: Authentication? = SecurityContextHolder.getContext().authentication\n if (authentication == null) {\n return execution.execute(request, body)\n }\n\n if (authentication.credentials !is AbstractOAuth2Token) {\n return execution.execute(request, body)\n }\n\n request.headers.setBearerAuth(authentication.credentials.tokenValue)\n execution.execute(request, body)\n })\n return rest\n}\n----\n======\n\n[NOTE]\nUnlike the javadoc:org.springframework.security.oauth2.client.OAuth2AuthorizedClientManager[OAuth 2.0 Authorized Client Manager], this filter interceptor makes no attempt to renew the token, should it be expired.\nTo obtain this level of support, please create an interceptor using the xref:servlet/oauth2/client/index.adoc#oauth2client[OAuth 2.0 Authorized Client Manager].\n\n[[oauth2resourceserver-bearertoken-failure]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc", "title": "OAuth 2.0 Bearer Tokens", "heading": "`RestTemplate` support", "heading_level": 3, "file_order": 150, "section_index": 5, "content_hash": "083775be7543f6624d3bf62e18d6d445ca3d706c48296f4555c5b89dcba7fd9b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc"}}
{"id": "sha256:aac5f481f1d2629fbf7ea387835988849527f06410e4410e6c4dea4b42bd7661", "content": "A bearer token may be invalid for a number of reasons. For example, the token may no longer be active.\n\nIn these circumstances, Resource Server throws an `InvalidBearerTokenException`.\nLike other exceptions, this results in an OAuth 2.0 Bearer Token error response:\n\n[source,http request]\n----\nHTTP/1.1 401 Unauthorized\nWWW-Authenticate: Bearer error_code=\"invalid_token\", error_description=\"Unsupported algorithm of none\", error_uri=\"https://tools.ietf.org/html/rfc6750#section-3.1\"\n----\n\nAdditionally, it is published as an `AuthenticationFailureBadCredentialsEvent`, which you can xref:servlet/authentication/events.adoc#servlet-events[listen for in your application] like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class FailureEvents {\n\t@EventListener\n public void onFailure(AuthenticationFailureBadCredentialsEvent badCredentials) {\n if (badCredentials.getAuthentication() instanceof BearerTokenAuthenticationToken) {\n // ... handle\n }\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass FailureEvents {\n @EventListener\n fun onFailure(badCredentials: AuthenticationFailureBadCredentialsEvent) {\n if (badCredentials.authentication is BearerTokenAuthenticationToken) {\n // ... handle\n }\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc", "title": "OAuth 2.0 Bearer Tokens", "heading": "Bearer Token Failure", "heading_level": 2, "file_order": 150, "section_index": 6, "content_hash": "aac5f481f1d2629fbf7ea387835988849527f06410e4410e6c4dea4b42bd7661", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/bearer-tokens.adoc"}}
{"id": "sha256:95e1181ced875a14a9391494ae8ca73c025f678a08b7c01619547b76e455993b", "content": "[[oauth2-dpop-bound-access-tokens]]\n\nhttps://datatracker.ietf.org/doc/html/rfc9449[RFC 9449 OAuth 2.0 Demonstrating Proof of Possession (DPoP)] is an application-level mechanism for sender-constraining an access token.\n\nThe primary goal of DPoP is to prevent unauthorized or illegitimate clients from using leaked or stolen access tokens, by binding an access token to a public key upon issuance by the authorization server and requiring that the client proves possession of the corresponding private key when using the access token at the resource server.\n\nAccess tokens that are sender-constrained via DPoP stand in contrast to the typical bearer token, which can be used by any client in possession of the access token.\n\nDPoP introduces the concept of a https://datatracker.ietf.org/doc/html/rfc9449#name-dpop-proof-jwts[DPoP Proof], which is a JWT created by the client and sent as a header in an HTTP request.\nA client uses a DPoP proof to prove the possession of a private key corresponding to a certain public key.\n\nWhen the client initiates an <<dpop-access-token-request,access token request>>, it attaches a DPoP proof to the request in an HTTP header.\nThe authorization server binds (sender-constrains) the access token to the public key associated in the DPoP proof.\n\nWhen the client initiates a <<dpop-protected-resource-request,protected resource request>>, it again attaches a DPoP proof to the request in an HTTP header.\n\nThe resource server obtains information about the public key bound to the access token, either directly in the access token (JWT) or via the token introspection endpoint.\nThe resource server then verifies that the public key bound to the access token matches the public key in the DPoP proof.\nIt also verifies that the access token hash in the DPoP proof matches the access token in the request.\n\n[[dpop-access-token-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/dpop-tokens.adoc", "title": "dpop-tokens", "heading": "dpop-tokens", "heading_level": 1, "file_order": 151, "section_index": 0, "content_hash": "95e1181ced875a14a9391494ae8ca73c025f678a08b7c01619547b76e455993b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/dpop-tokens.adoc"}}
{"id": "sha256:05be467853a5e9adbaa5a4ef6e950ba09168cde9fd48ba95887f3ec310787d47", "content": "To request an access token that is bound to a public key using DPoP, the client MUST provide a valid DPoP proof in the `DPoP` header when making an access token request to the authorization server token endpoint.\nThis is applicable for all access token requests regardless of authorization grant type (e.g. `authorization_code`, `refresh_token`, `client_credentials`, etc).\n\nThe following HTTP request shows an `authorization_code` access token request with a DPoP proof in the `DPoP` header:\n\n[source,shell]\n----\nPOST /oauth2/token HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\nDPoP: eyJraWQiOiJyc2EtandrLWtpZCIsInR5cCI6ImRwb3Arand0IiwiYWxnIjoiUlMyNTYiLCJqd2siOnsia3R5IjoiUlNBIiwiZSI6IkFRQUIiLCJraWQiOiJyc2EtandrLWtpZCIsIm4iOiIzRmxxSnI1VFJza0lRSWdkRTNEZDdEOWxib1dkY1RVVDhhLWZKUjdNQXZRbTdYWE5vWWttM3Y3TVFMMU5ZdER2TDJsOENBbmMwV2RTVElOVTZJUnZjNUtxbzJRNGNzTlg5U0hPbUVmem9ST2pRcWFoRWN2ZTFqQlhsdW9DWGRZdVlweDRfMXRmUmdHNmlpNFVoeGg2aUk4cU5NSlFYLWZMZnFoYmZZZnhCUVZSUHl3QmtBYklQNHgxRUFzYkM2RlNObWtoQ3hpTU5xRWd4YUlwWThDMmtKZEpfWklWLVdXNG5vRGR6cEtxSGN3bUI4RnNydW1sVllfRE5WdlVTRElpcGlxOVBiUDRIOTlUWE4xbzc0Nm9SYU5hMDdycTFob0NnTVNTeS04NVNhZ0NveGxteUUtRC1vZjlTc01ZOE9sOXQwcmR6cG9iQnVoeUpfbzVkZnZqS3cifX0.eyJodG0iOiJQT1NUIiwiaHR1IjoiaHR0cHM6Ly9zZXJ2ZXIuZXhhbXBsZS5jb20vb2F1dGgyL3Rva2VuIiwiaWF0IjoxNzQ2ODA2MzA1LCJqdGkiOiI0YjIzNDBkMi1hOTFmLTQwYTUtYmFhOS1kZDRlNWRlYWM4NjcifQ.wq8gJ_G6vpiEinfaY3WhereqCCLoeJOG8tnWBBAzRWx9F1KU5yAAWq-ZVCk_k07-h6DIqz2wgv6y9dVbNpRYwNwDUeik9qLRsC60M8YW7EFVyI3n_NpujLwzZeub_nDYMVnyn4ii0NaZrYHtoGXOlswQfS_-ET-jpC0XWm5nBZsCdUEXjOYtwaACC6Js-pyNwKmSLp5SKIk11jZUR5xIIopaQy521y9qJHhGRwzj8DQGsP7wMZ98UFL0E--1c-hh4rTy8PMeWCqRHdwjj_ry_eTe0DJFcxxYQdeL7-0_0CIO4Ayx5WHEpcUOIzBRoN32RsNpDZc-5slDNj9ku004DA\n\ngrant_type=authorization_code\\\n&client_id=s6BhdRkqt\\\n&code=SplxlOBeZQQYbYS6WxSbIA\\\n&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\\\n&code_verifier=bEaL42izcC-o-xBk0K2vuJ6U-y1p9r_wW2dFWIWgjz-\n----\n\nThe following shows a representation of the DPoP Proof JWT header and claims:\n\n[source,json]\n----\n{\n \"typ\": \"dpop+jwt\",\n \"alg\": \"RS256\",\n \"jwk\": {\n \"kty\": \"RSA\",\n \"e\": \"AQAB\",\n \"n\": \"3FlqJr5TRskIQIgdE3Dd7D9lboWdcTUT8a-fJR7MAvQm7XXNoYkm3v7MQL1NYtDvL2l8CAnc0WdSTINU6IRvc5Kqo2Q4csNX9SHOmEfzoROjQqahEcve1jBXluoCXdYuYpx4_1tfRgG6ii4Uhxh6iI8qNMJQX-fLfqhbfYfxBQVRPywBkAbIP4x1EAsbC6FSNmkhCxiMNqEgxaIpY8C2kJdJ_ZIV-WW4noDdzpKqHcwmB8FsrumlVY_DNVvUSDIipiq9PbP4H99TXN1o746oRaNa07rq1hoCgMSSy-85SagCoxlmyE-D-of9SsMY8Ol9t0rdzpobBuhyJ_o5dfvjKw\"\n }\n}\n----\n\n[source,json]\n----\n{\n \"htm\": \"POST\",\n \"htu\": \"https://server.example.com/oauth2/token\",\n \"iat\": 1746806305,\n \"jti\": \"4b2340d2-a91f-40a5-baa9-dd4e5deac867\"\n}\n----\n\nThe following code shows an example of how to generate the DPoP Proof JWT:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nRSAKey rsaKey = ...\nJWKSource<SecurityContext> jwkSource = (jwkSelector, securityContext) -> jwkSelector\n .select(new JWKSet(rsaKey));\nNimbusJwtEncoder jwtEncoder = new NimbusJwtEncoder(jwkSource);\n\nJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n .type(\"dpop+jwt\")\n .jwk(rsaKey.toPublicJWK().toJSONObject())\n .build();\nJwtClaimsSet claims = JwtClaimsSet.builder()\n .issuedAt(Instant.now())\n .claim(\"htm\", \"POST\")\n .claim(\"htu\", \"https://server.example.com/oauth2/token\")\n .id(UUID.randomUUID().toString())\n .build();\n\nJwt dPoPProof = jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n----\n======\n\nAfter the authorization server successfully validates the DPoP proof, the public key from the DPoP proof will be bound (sender-constrained) to the issued access token.\n\nThe following access token response shows the `token_type` parameter as `DPoP` to signal to the client that the access token was bound to its DPoP proof public key:\n\n[source,shell]\n----\nHTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\n\n{\n \"access_token\": \"Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU\",\n \"token_type\": \"DPoP\",\n \"expires_in\": 2677\n}\n----\n\n[[dpop-public-key-confirmation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/dpop-tokens.adoc", "title": "dpop-tokens", "heading": "DPoP Access Token Request", "heading_level": 2, "file_order": 151, "section_index": 1, "content_hash": "05be467853a5e9adbaa5a4ef6e950ba09168cde9fd48ba95887f3ec310787d47", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/dpop-tokens.adoc"}}
{"id": "sha256:595954c1804dbe372211e24ab329b126c4d8f0c4f44341ec3356c7b655145653", "content": "Resource servers MUST be able to identify whether an access token is DPoP-bound and verify the binding to the public key of the DPoP proof.\nThe binding is accomplished by associating the public key with the access token in a way that can be accessed by the resource server, such as embedding the public key hash in the access token directly (JWT) or through token introspection.\n\nWhen an access token is represented as a JWT, the public key hash is contained in the `jkt` claim under the confirmation method (`cnf`) claim.\n\nThe following example shows the claims of a JWT access token containing a `cnf` claim with a `jkt` claim, which is the JWK SHA-256 Thumbprint of the DPoP proof public key:\n\n[source,json]\n----\n{\n \"sub\":\"user@example.com\",\n \"iss\":\"https://server.example.com\",\n \"nbf\":1562262611,\n \"exp\":1562266216,\n \"cnf\":\n {\n \"jkt\":\"CQMknzRoZ5YUi7vS58jck1q8TmZT8wiIiXrCN1Ny4VU\"\n }\n}\n----\n\n[[dpop-protected-resource-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/dpop-tokens.adoc", "title": "dpop-tokens", "heading": "Public Key Confirmation", "heading_level": 2, "file_order": 151, "section_index": 2, "content_hash": "595954c1804dbe372211e24ab329b126c4d8f0c4f44341ec3356c7b655145653", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/dpop-tokens.adoc"}}
{"id": "sha256:428999e59a9af7d579ed371605b8b22b1d693ff96ca1707ae002e6053e428c8d", "content": "Requests to DPoP-protected resources MUST include both a DPoP proof and the DPoP-bound access token.\nThe DPoP proof MUST include the `ath` claim with a valid hash of the access token.\nThe resource server will calculate the hash of the received access token and verify that it is the same as the `ath` claim in the DPoP proof.\n\nA DPoP-bound access token is sent using the `Authorization` request header with an authentication scheme of `DPoP`.\n\nThe following HTTP request shows a protected resource request with a DPoP-bound access token in the `Authorization` header and the DPoP proof in the `DPoP` header:\n\n[source,shell]\n----\nGET /resource HTTP/1.1\nHost: resource.example.com\nAuthorization: DPoP Kz~8mXK1EalYznwH-LC-1fBAo.4Ljp~zsPE_NeO.gxU\nDPoP: eyJraWQiOiJyc2EtandrLWtpZCIsInR5cCI6ImRwb3Arand0IiwiYWxnIjoiUlMyNTYiLCJqd2siOnsia3R5IjoiUlNBIiwiZSI6IkFRQUIiLCJraWQiOiJyc2EtandrLWtpZCIsIm4iOiIzRmxxSnI1VFJza0lRSWdkRTNEZDdEOWxib1dkY1RVVDhhLWZKUjdNQXZRbTdYWE5vWWttM3Y3TVFMMU5ZdER2TDJsOENBbmMwV2RTVElOVTZJUnZjNUtxbzJRNGNzTlg5U0hPbUVmem9ST2pRcWFoRWN2ZTFqQlhsdW9DWGRZdVlweDRfMXRmUmdHNmlpNFVoeGg2aUk4cU5NSlFYLWZMZnFoYmZZZnhCUVZSUHl3QmtBYklQNHgxRUFzYkM2RlNObWtoQ3hpTU5xRWd4YUlwWThDMmtKZEpfWklWLVdXNG5vRGR6cEtxSGN3bUI4RnNydW1sVllfRE5WdlVTRElpcGlxOVBiUDRIOTlUWE4xbzc0Nm9SYU5hMDdycTFob0NnTVNTeS04NVNhZ0NveGxteUUtRC1vZjlTc01ZOE9sOXQwcmR6cG9iQnVoeUpfbzVkZnZqS3cifX0.eyJodG0iOiJHRVQiLCJodHUiOiJodHRwczovL3Jlc291cmNlLmV4YW1wbGUuY29tL3Jlc291cmNlIiwiYXRoIjoiZlVIeU8ycjJaM0RaNTNFc05yV0JiMHhXWG9hTnk1OUlpS0NBcWtzbVFFbyIsImlhdCI6MTc0NjgwNzEzOCwianRpIjoiM2MyZWU5YmItMDNhYy00MGNmLWI4MTItMDBiZmJhMzQxY2VlIn0.oS6NwjURR6wZemh1ZBNiBjycGeXwnkguLtgiKdCjQSEhFQpEJm04bBa0tdfZgWT17Z2mBgddnNQSkROzUGfssg8rBBldZXOAiduF-whtEGZA-pXXWJilXrwH3Glb6hIOMZOVmIH8fmYCDmqn-sE_DmDIsv57Il2-jdZbgeDcrxADO-6E5gsuNf1jvy7qqHq7INrKX6jRuydti_Re35lecvaAWfTyD7s7tQ_-3x_xLxxPwf_eA6z8OWbc58O2PYoUeO2JKLiOIg6UVZOZzxLEWV42WIKjha_kkoykvsf98W2y8pWOEr65u0VPsn5esw2X3I1eFL_A-XkxstZHRaGXJg\n----\n\nThe following shows a representation of the DPoP Proof JWT header and claims with the `ath` claim:\n\n[source,json]\n----\n{\n \"typ\": \"dpop+jwt\",\n \"alg\": \"RS256\",\n \"jwk\": {\n \"kty\": \"RSA\",\n \"e\": \"AQAB\",\n \"n\": \"3FlqJr5TRskIQIgdE3Dd7D9lboWdcTUT8a-fJR7MAvQm7XXNoYkm3v7MQL1NYtDvL2l8CAnc0WdSTINU6IRvc5Kqo2Q4csNX9SHOmEfzoROjQqahEcve1jBXluoCXdYuYpx4_1tfRgG6ii4Uhxh6iI8qNMJQX-fLfqhbfYfxBQVRPywBkAbIP4x1EAsbC6FSNmkhCxiMNqEgxaIpY8C2kJdJ_ZIV-WW4noDdzpKqHcwmB8FsrumlVY_DNVvUSDIipiq9PbP4H99TXN1o746oRaNa07rq1hoCgMSSy-85SagCoxlmyE-D-of9SsMY8Ol9t0rdzpobBuhyJ_o5dfvjKw\"\n }\n}\n----\n\n[source,json]\n----\n{\n \"htm\": \"GET\",\n \"htu\": \"https://resource.example.com/resource\",\n \"ath\": \"fUHyO2r2Z3DZ53EsNrWBb0xWXoaNy59IiKCAqksmQEo\",\n \"iat\": 1746807138,\n \"jti\": \"3c2ee9bb-03ac-40cf-b812-00bfba341cee\"\n}\n----\n\nThe following code shows an example of how to generate the DPoP Proof JWT:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nRSAKey rsaKey = ...\nJWKSource<SecurityContext> jwkSource = (jwkSelector, securityContext) -> jwkSelector\n .select(new JWKSet(rsaKey));\nNimbusJwtEncoder jwtEncoder = new NimbusJwtEncoder(jwkSource);\n\nString accessToken = ...\n\nJwsHeader jwsHeader = JwsHeader.with(SignatureAlgorithm.RS256)\n .type(\"dpop+jwt\")\n .jwk(rsaKey.toPublicJWK().toJSONObject())\n .build();\nJwtClaimsSet claims = JwtClaimsSet.builder()\n .issuedAt(Instant.now())\n .claim(\"htm\", \"GET\")\n .claim(\"htu\", \"https://resource.example.com/resource\")\n .claim(\"ath\", sha256(accessToken))\n .id(UUID.randomUUID().toString())\n .build();\n\nJwt dPoPProof = jwtEncoder.encode(JwtEncoderParameters.from(jwsHeader, claims));\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/dpop-tokens.adoc", "title": "dpop-tokens", "heading": "DPoP Protected Resource Request", "heading_level": 2, "file_order": 151, "section_index": 3, "content_hash": "428999e59a9af7d579ed371605b8b22b1d693ff96ca1707ae002e6053e428c8d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/dpop-tokens.adoc"}}
{"id": "sha256:484316202828f223c7b3fd0e860153157b89fb4d93d563352733d2a8574ab0ed", "content": "[[oauth2resourceserver]]\n\nSpring Security supports protecting endpoints by using two forms of OAuth 2.0 https://tools.ietf.org/html/rfc6750.html[Bearer Tokens]:\n\n* https://tools.ietf.org/html/rfc7519[JWT]\n* Opaque Tokens\n\nThis is handy in circumstances where an application has delegated its authority management to an https://tools.ietf.org/html/rfc6749[authorization server] (for example, Okta or Ping Identity).\nThis authorization server can be consulted by resource servers to authorize requests.\n\nThis section details how Spring Security provides support for OAuth 2.0 https://tools.ietf.org/html/rfc6750.html[Bearer Tokens].\n\n[NOTE]\n====\nWorking samples for both {gh-samples-url}/servlet/spring-boot/java/oauth2/resource-server/jwe[JWTs] and {gh-samples-url}/servlet/spring-boot/java/oauth2/resource-server/opaque[Opaque Tokens] are available in the {gh-samples-url}[Spring Security Samples repository].\n====\n\nNow we can consider how Bearer Token Authentication works within Spring Security.\nFirst, we see that, as with xref:servlet/authentication/passwords/basic.adoc#servlet-authentication-basic[Basic Authentication], the https://tools.ietf.org/html/rfc7235#section-4.1[WWW-Authenticate] header is sent back to an unauthenticated client:\n\n.Sending WWW-Authenticate Header\n[.invert-dark]\nimage::{figures}/bearerauthenticationentrypoint.png[]\n\nThe figure above builds off our xref:servlet/architecture.adoc#servlet-securityfilterchain[`SecurityFilterChain`] diagram.\n\nimage:{icondir}/number_1.png[] First, a user makes an unauthenticated request to the `/private` resource for which the user is not authorized.\n\nimage:{icondir}/number_2.png[] Spring Security's xref:servlet/authorization/authorize-http-requests.adoc[`AuthorizationFilter`] indicates that the unauthenticated request is _Denied_ by throwing an `AccessDeniedException`.\n\nimage:{icondir}/number_3.png[] Since the user is not authenticated, xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[`ExceptionTranslationFilter`] initiates _Start Authentication_.\nThe configured xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationentrypoint[`AuthenticationEntryPoint`] is an instance of javadoc:org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationEntryPoint[], which sends a `WWW-Authenticate` header.\nThe `RequestCache` is typically a `NullRequestCache` that does not save the request, since the client is capable of replaying the requests it originally requested.\n\nWhen a client receives the `WWW-Authenticate: Bearer` header, it knows it should retry with a bearer token.\nThe following image shows the flow for the bearer token being processed:\n\n[[oauth2resourceserver-authentication-bearertokenauthenticationfilter]]\n.Authenticating Bearer Token\n[.invert-dark]\nimage::{figures}/bearertokenauthenticationfilter.png[]\n\nThe figure builds off our xref:servlet/architecture.adoc#servlet-securityfilterchain[`SecurityFilterChain`] diagram.\n\nimage:{icondir}/number_1.png[] When the user submits their bearer token, the `BearerTokenAuthenticationFilter` creates a `BearerTokenAuthenticationToken` which is a type of xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`] by extracting the token from the `HttpServletRequest`.\n\nimage:{icondir}/number_2.png[] Next, the `HttpServletRequest` is passed to the `AuthenticationManagerResolver`, which selects the `AuthenticationManager`. The `BearerTokenAuthenticationToken` is passed into the `AuthenticationManager` to be authenticated.\nThe details of what `AuthenticationManager` looks like depends on whether you're configured for xref:servlet/oauth2/resource-server/jwt.adoc#oauth2resourceserver-jwt-minimalconfiguration[JWT] or xref:servlet/oauth2/resource-server/opaque-token.adoc#oauth2resourceserver-opaque-minimalconfiguration[opaque token].\n\nimage:{icondir}/number_3.png[] If authentication fails, then __Failure__\n\n* The xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[SecurityContextHolder] is cleared out.\n* The `AuthenticationEntryPoint` is invoked to trigger the WWW-Authenticate header to be sent again.\n\nimage:{icondir}/number_4.png[] If authentication is successful, then __Success__.\n\n* Any already-authenticated `Authentication` in the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[`SecurityContextHolder`] is loaded and its\nauthorities are added to the returned xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`].\n* The xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[Authentication] is set on the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[SecurityContextHolder].\n* The `BearerTokenAuthenticationFilter` invokes `FilterChain.doFilter(request,response)` to continue with the rest of the application logic.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 152, "section_index": 0, "content_hash": "484316202828f223c7b3fd0e860153157b89fb4d93d563352733d2a8574ab0ed", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/index.adoc"}}
{"id": "sha256:4a2b48dde4afcb74e95deba56c3659690a4a03fc3a076c25c5f5999342396db1", "content": "[[oauth2resourceserver-jwt-minimaldependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "OAuth 2.0 Resource Server JWT", "heading_level": 1, "file_order": 153, "section_index": 0, "content_hash": "4a2b48dde4afcb74e95deba56c3659690a4a03fc3a076c25c5f5999342396db1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:17adc7e560ecf1b88520418880454d5e8b820940af503c01c05b39d15ecd3a16", "content": "Most Resource Server support is collected into `spring-security-oauth2-resource-server`.\nHowever, the support for decoding and verifying JWTs is in `spring-security-oauth2-jose`, meaning that both are necessary in order to have a working resource server that supports JWT-encoded Bearer Tokens.\n\n[[oauth2resourceserver-jwt-minimalconfiguration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Minimal Dependencies for JWT", "heading_level": 2, "file_order": 153, "section_index": 1, "content_hash": "17adc7e560ecf1b88520418880454d5e8b820940af503c01c05b39d15ecd3a16", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:3141b76ffd4bfc7aaa6cf707dde9134f4a9de50a9aec8ce28717b7584c239c23", "content": "When using https://spring.io/projects/spring-boot[Spring Boot], configuring an application as a resource server consists of two basic steps.\nFirst, include the needed dependencies and second, indicate the location of the authorization server.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Minimal Configuration for JWTs", "heading_level": 2, "file_order": 153, "section_index": 2, "content_hash": "3141b76ffd4bfc7aaa6cf707dde9134f4a9de50a9aec8ce28717b7584c239c23", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:06bc934764990c18d73e34241a828663688eb701868669913713042b4aa7e0cb", "content": "In a Spring Boot application, to specify which authorization server to use, simply do:\n\n[source,yml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n issuer-uri: https://idp.example.com/issuer\n----\n\nWhere `https://idp.example.com/issuer` is the value contained in the `iss` claim for JWT tokens that the authorization server will issue.\nResource Server will use this property to further self-configure, discover the authorization server's public keys, and subsequently validate incoming JWTs.\n\n[NOTE]\nTo use the `issuer-uri` property, it must also be true that one of `https://idp.example.com/issuer/.well-known/openid-configuration`, `https://idp.example.com/.well-known/openid-configuration/issuer`, or `https://idp.example.com/.well-known/oauth-authorization-server/issuer` is a supported endpoint for the authorization server.\nThis endpoint is referred to as a https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[Provider Configuration] endpoint or a https://tools.ietf.org/html/rfc8414#section-3[Authorization Server Metadata] endpoint.\n\nAnd that's it!", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Specifying the Authorization Server", "heading_level": 3, "file_order": 153, "section_index": 3, "content_hash": "06bc934764990c18d73e34241a828663688eb701868669913713042b4aa7e0cb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:1a0b35e8dbc2c4c29e5ce6b06b858fa416f6d4aa53092bf45b759b36141d8215", "content": "When this property and these dependencies are used, Resource Server will automatically configure itself to validate JWT-encoded Bearer Tokens.\n\nIt achieves this through a deterministic startup process:\n\n1. Query the Provider Configuration or Authorization Server Metadata endpoint for the `jwks_url` property\n2. Query the `jwks_url` endpoint for supported algorithms\n3. Configure the validation strategy to query `jwks_url` for valid public keys of the algorithms found\n4. Configure the validation strategy to validate each JWTs `iss` claim against `https://idp.example.com`.\n\nA consequence of this process is that the authorization server must be up and receiving requests in order for Resource Server to successfully start up.\n\n[NOTE]\nIf the authorization server is down when Resource Server queries it (given appropriate timeouts), then startup will fail.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Startup Expectations", "heading_level": 3, "file_order": 153, "section_index": 4, "content_hash": "1a0b35e8dbc2c4c29e5ce6b06b858fa416f6d4aa53092bf45b759b36141d8215", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:d4a8b8c629fe8151e435496f2232caba9c7ec4c2f71f5b7db24bde826c7fa12a", "content": "Once the application is started up, Resource Server will attempt to process any request containing an `Authorization: Bearer` header:\n\n[source,html]\n----\nGET / HTTP/1.1\nAuthorization: Bearer some-token-value # Resource Server will process this\n----\n\nSo long as this scheme is indicated, Resource Server will attempt to process the request according to the Bearer Token specification.\n\nGiven a well-formed JWT, Resource Server will:\n\n1. Validate its signature against a public key obtained from the `jwks_url` endpoint during startup and matched against the JWT\n2. Validate the JWT's `exp` and `nbf` timestamps and the JWT's `iss` claim, and\n3. Map each scope to an authority with the prefix `SCOPE_`.\n\n[NOTE]\nAs the authorization server makes available new keys, Spring Security will automatically rotate the keys used to validate JWTs.\n\nThe resulting `Authentication#getPrincipal`, by default, is a Spring Security `Jwt` object, and `Authentication#getName` maps to the JWT's `sub` property, if one is present.\n\nFrom here, consider jumping to:\n\n* <<oauth2resourceserver-jwt-architecture,How JWT Authentication Works>>\n* <<oauth2resourceserver-jwt-jwkseturi,How to Configure without tying Resource Server startup to an authorization server's availability>>\n* <<oauth2resourceserver-jwt-sansboot,How to Configure without Spring Boot>>\n\n[[oauth2resourceserver-jwt-architecture]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Runtime Expectations", "heading_level": 3, "file_order": 153, "section_index": 5, "content_hash": "d4a8b8c629fe8151e435496f2232caba9c7ec4c2f71f5b7db24bde826c7fa12a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:7bb760c3a134c077bf0479fffb1246bcc5c05cefc36bd33a3546f71b97496580", "content": "Next, let's see the architectural components that Spring Security uses to support https://tools.ietf.org/html/rfc7519[JWT] Authentication in servlet-based applications, like the one we just saw.\n\njavadoc:org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationProvider[] is an xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationprovider[`AuthenticationProvider`] implementation that leverages a <<oauth2resourceserver-jwt-decoder,`JwtDecoder`>> and <<oauth2resourceserver-jwt-authorization-extraction,`JwtAuthenticationConverter`>> to authenticate a JWT.\n\nLet's take a look at how `JwtAuthenticationProvider` works within Spring Security.\nThe figure explains details of how the xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationmanager[`AuthenticationManager`] in figures from xref:servlet/oauth2/resource-server/index.adoc#oauth2resourceserver-authentication-bearertokenauthenticationfilter[Reading the Bearer Token] works.\n\n.`JwtAuthenticationProvider` Usage\n[.invert-dark]\nimage::{figures}/jwtauthenticationprovider.png[]\n\nimage:{icondir}/number_1.png[] The authentication `Filter` from xref:servlet/oauth2/resource-server/index.adoc#oauth2resourceserver-authentication-bearertokenauthenticationfilter[Reading the Bearer Token] passes a `BearerTokenAuthenticationToken` to the `AuthenticationManager` which is implemented by xref:servlet/authentication/architecture.adoc#servlet-authentication-providermanager[`ProviderManager`].\n\nimage:{icondir}/number_2.png[] The `ProviderManager` is configured to use an xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationprovider[AuthenticationProvider] of type `JwtAuthenticationProvider`.\n\n[[oauth2resourceserver-jwt-architecture-jwtdecoder]]\nimage:{icondir}/number_3.png[] `JwtAuthenticationProvider` decodes, verifies, and validates the `Jwt` using a <<oauth2resourceserver-jwt-decoder,`JwtDecoder`>>.\n\n[[oauth2resourceserver-jwt-architecture-jwtauthenticationconverter]]\nimage:{icondir}/number_4.png[] `JwtAuthenticationProvider` then uses the <<oauth2resourceserver-jwt-authorization-extraction,`JwtAuthenticationConverter`>> to convert the `Jwt` into a `Collection` of granted authorities.\n\nimage:{icondir}/number_5.png[] When authentication is successful, the xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`] that is returned is of type `JwtAuthenticationToken` and has a principal that is the `Jwt` returned by the configured `JwtDecoder` and a set of authorities that contains at least `FACTOR_BEARER`.\nUltimately, the returned `JwtAuthenticationToken` will be set on the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[`SecurityContextHolder`] by the authentication `Filter`.\n\n[[oauth2resourceserver-jwt-jwkseturi]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "How JWT Authentication Works", "heading_level": 2, "file_order": 153, "section_index": 6, "content_hash": "7bb760c3a134c077bf0479fffb1246bcc5c05cefc36bd33a3546f71b97496580", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:a9cd0f807e347ba7f1b00407450966ab723c908baa1f1a43047b9d69288c7f1d", "content": "If the authorization server doesn't support any configuration endpoints, or if Resource Server must be able to start up independently from the authorization server, then the `jwk-set-uri` can be supplied as well:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n issuer-uri: https://idp.example.com\n jwk-set-uri: https://idp.example.com/.well-known/jwks.json\n----\n\n[NOTE]\nThe JWK Set uri is not standardized, but can typically be found in the authorization server's documentation\n\nConsequently, Resource Server will not ping the authorization server at startup.\nWe still specify the `issuer-uri` so that Resource Server still validates the `iss` claim on incoming JWTs.\n\n[NOTE]\nThis property can also be supplied directly on the <<oauth2resourceserver-jwt-jwkseturi-dsl,DSL>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Specifying the Authorization Server JWK Set Uri Directly", "heading_level": 2, "file_order": 153, "section_index": 7, "content_hash": "a9cd0f807e347ba7f1b00407450966ab723c908baa1f1a43047b9d69288c7f1d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:0a9e429d367ca177c8ec5d33b2d4fe4719af87e0a855704e2b51a67824399ab8", "content": "As already seen, the <<_specifying_the_authorization_server, `issuer-uri` property validates the `iss` claim>>; this is who sent the JWT.\n\nBoot also has the `audiences` property for validating the `aud` claim; this is who the JWT was sent to.\n\nA resource server's audience can be indicated like so:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n issuer-uri: https://idp.example.com\n audiences: https://my-resource-server.example.com\n----\n\n[NOTE]\nYou can also add <<oauth2resourceserver-jwt-validation-custom, the `aud` validation programmatically>>, if needed.\n\nThe result will be that if the JWT's `iss` claim is not `https://idp.example.com`, and its `aud` claim does not contain `https://my-resource-server.example.com` in its list, then validation will fail.\n\n[[oauth2resourceserver-jwt-sansboot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Supplying Audiences", "heading_level": 2, "file_order": 153, "section_index": 8, "content_hash": "0a9e429d367ca177c8ec5d33b2d4fe4719af87e0a855704e2b51a67824399ab8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:81b487dd9d1e79d482f6a915d940dc951abf71d25ab618b36d195f570ac442df", "content": "There are two ``@Bean``s that Spring Boot generates on Resource Server's behalf.\n\nThe first is a `SecurityFilterChain` that configures the app as a resource server. When including `spring-security-oauth2-jose`, this `SecurityFilterChain` looks like:\n\n.Default JWT Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2.jwt(Customizer.withDefaults()));\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n jwt { }\n }\n }\n return http.build()\n}\n----\n======\n\nIf the application doesn't expose a `SecurityFilterChain` bean, then Spring Boot will expose the above default one.\n\nReplacing this is as simple as exposing the bean within the application:\n\n.Custom JWT Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope;\n\n@Configuration\n@EnableWebSecurity\npublic class MyCustomSecurityConfiguration {\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/messages/**\").access(hasScope(\"message:read\"))\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt((jwt) -> jwt\n .jwtAuthenticationConverter(myConverter())\n )\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope\n\n@Configuration\n@EnableWebSecurity\nclass MyCustomSecurityConfiguration {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(\"/messages/**\", hasScope(\"message:read\"))\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n jwt {\n jwtAuthenticationConverter = myConverter()\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\nThe above requires the scope of `message:read` for any URL that starts with `/messages/`.\n\nMethods on the `oauth2ResourceServer` DSL will also override or replace auto configuration.\n\n[[oauth2resourceserver-jwt-decoder]]\nFor example, the second `@Bean` Spring Boot creates is a `JwtDecoder`, which <<oauth2resourceserver-jwt-architecture-jwtdecoder,decodes `String` tokens into validated instances of `Jwt`>>:\n\n.JWT Decoder\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtDecoder jwtDecoder() {\n return JwtDecoders.fromIssuerLocation(issuerUri);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n return JwtDecoders.fromIssuerLocation(issuerUri)\n}\n----\n======\n\n[NOTE]\nCalling javadoc:org.springframework.security.oauth2.jwt.JwtDecoders#fromIssuerLocation-java.lang.String-[JwtDecoders#fromIssuerLocation] is what invokes the Provider Configuration or Authorization Server Metadata endpoint in order to derive the JWK Set Uri.\n\nIf the application doesn't expose a `JwtDecoder` bean, then Spring Boot will expose the above default one.\n\nAnd its configuration can be overridden using `jwkSetUri()` or replaced using `decoder()`.\n\nOr, if you're not using Spring Boot at all, then both of these components - the filter chain and a `JwtDecoder` can be specified in XML.\n\nThe filter chain is specified like so:\n\n.Default JWT Configuration\n[tabs]\n======\nXml::\n+\n[source,xml,role=\"primary\"]\n----\n<http>\n <intercept-uri pattern=\"/**\" access=\"authenticated\"/>\n <oauth2-resource-server>\n <jwt decoder-ref=\"jwtDecoder\"/>\n </oauth2-resource-server>\n</http>\n----\n======\n\nAnd the `JwtDecoder` like so:\n\n.JWT Decoder\n[tabs]\n======\nXml::\n+\n[source,xml,role=\"primary\"]\n----\n<bean id=\"jwtDecoder\"\n class=\"org.springframework.security.oauth2.jwt.JwtDecoders\"\n factory-method=\"fromIssuerLocation\">\n <constructor-arg value=\"${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}\"/>\n</bean>\n----\n======\n\n[[oauth2resourceserver-jwt-jwkseturi-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Overriding or Replacing Boot Auto Configuration", "heading_level": 2, "file_order": 153, "section_index": 9, "content_hash": "81b487dd9d1e79d482f6a915d940dc951abf71d25ab618b36d195f570ac442df", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:c60a70510728eeeb26f5fdf171062d9bef1740ffd7be27a432a387bdbfac24c0", "content": "An authorization server's JWK Set Uri can be configured <<oauth2resourceserver-jwt-jwkseturi,as a configuration property>> or it can be supplied in the DSL:\n\n.JWK Set Uri Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class DirectlyConfiguredJwkSetUri {\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt((jwt) -> jwt\n .jwkSetUri(\"https://idp.example.com/.well-known/jwks.json\")\n )\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass DirectlyConfiguredJwkSetUri {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n jwt {\n jwkSetUri = \"https://idp.example.com/.well-known/jwks.json\"\n }\n }\n }\n return http.build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-uri pattern=\"/**\" access=\"authenticated\"/>\n <oauth2-resource-server>\n <jwt jwk-set-uri=\"https://idp.example.com/.well-known/jwks.json\"/>\n </oauth2-resource-server>\n</http>\n----\n======\n\nUsing `jwkSetUri()` takes precedence over any configuration property.\n\n[[oauth2resourceserver-jwt-decoder-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Using `jwkSetUri()`", "heading_level": 3, "file_order": 153, "section_index": 10, "content_hash": "c60a70510728eeeb26f5fdf171062d9bef1740ffd7be27a432a387bdbfac24c0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:27793be512c97fb42553b3a0b8a0ea65f639811c5fe1fb47f79b4c85c4294b18", "content": "More powerful than `jwkSetUri()` is `decoder()`, which will completely replace any Boot auto configuration of <<oauth2resourceserver-jwt-architecture-jwtdecoder,`JwtDecoder`>>:\n\n.JWT Decoder Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class DirectlyConfiguredJwtDecoder {\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt((jwt) -> jwt\n .decoder(myCustomDecoder())\n )\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass DirectlyConfiguredJwtDecoder {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n jwt {\n jwtDecoder = myCustomDecoder()\n }\n }\n }\n return http.build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-uri pattern=\"/**\" access=\"authenticated\"/>\n <oauth2-resource-server>\n <jwt decoder-ref=\"myCustomDecoder\"/>\n </oauth2-resource-server>\n</http>\n----\n======\n\nThis is handy when deeper configuration, like <<oauth2resourceserver-jwt-validation,validation>>, <<oauth2resourceserver-jwt-claimsetmapping,mapping>>, or <<oauth2resourceserver-jwt-timeouts,request timeouts>>, is necessary.\n\n[[oauth2resourceserver-jwt-decoder-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Using `decoder()`", "heading_level": 3, "file_order": 153, "section_index": 11, "content_hash": "27793be512c97fb42553b3a0b8a0ea65f639811c5fe1fb47f79b4c85c4294b18", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:3a148aac6e3dc164365a18f3e35a360145945f06dd363d9a3a8074193475f4e1", "content": "Or, exposing a <<oauth2resourceserver-jwt-architecture-jwtdecoder,`JwtDecoder`>> `@Bean` has the same effect as `decoder()`.\nYou can construct one with a `jwkSetUri` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtDecoder jwtDecoder() {\n return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()\n}\n----\n======\n\nor you can use the issuer and have `NimbusJwtDecoder` look up the `jwkSetUri` when `build()` is invoked, like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtDecoder jwtDecoder() {\n return NimbusJwtDecoder.withIssuerLocation(issuer).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n return NimbusJwtDecoder.withIssuerLocation(issuer).build()\n}\n----\n======\n\nOr, if the defaults work for you, you can also use `JwtDecoders`, which does the above in addition to configuring the decoder's validator:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtDecoders jwtDecoder() {\n return JwtDecoders.fromIssuerLocation(issuer);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoders {\n return JwtDecoders.fromIssuerLocation(issuer)\n}\n----\n======\n\n[[oauth2resourceserver-jwt-decoder-algorithm]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Exposing a `JwtDecoder` `@Bean`", "heading_level": 3, "file_order": 153, "section_index": 12, "content_hash": "3a148aac6e3dc164365a18f3e35a360145945f06dd363d9a3a8074193475f4e1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:6740a6da9a589d855e1b9e7307270a29893752e15e0531e3b87268e29c0a21e7", "content": "By default, `NimbusJwtDecoder`, and hence Resource Server, will only trust and verify tokens using `RS256`.\n\nYou can customize this via <<oauth2resourceserver-jwt-boot-algorithm,Spring Boot>>, <<oauth2resourceserver-jwt-decoder-builder,the NimbusJwtDecoder builder>>, or from the <<oauth2resourceserver-jwt-decoder-jwk-response,JWK Set response>>.\n\n[[oauth2resourceserver-jwt-boot-algorithm]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring Trusted Algorithms", "heading_level": 2, "file_order": 153, "section_index": 13, "content_hash": "6740a6da9a589d855e1b9e7307270a29893752e15e0531e3b87268e29c0a21e7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:c86fe51d43e1e67e16047fcd4f7716df36e284e00ed2881b9d8b44afab6859c2", "content": "The simplest way to set the algorithm is as a property:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n jws-algorithms: RS512\n jwk-set-uri: https://idp.example.org/.well-known/jwks.json\n----\n\n[[oauth2resourceserver-jwt-decoder-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Via Spring Boot", "heading_level": 3, "file_order": 153, "section_index": 14, "content_hash": "c86fe51d43e1e67e16047fcd4f7716df36e284e00ed2881b9d8b44afab6859c2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:a018609ae341c03b4dd46b9340165b68dcbf5801e7efbd4fe417ce6414ac897f", "content": "For greater power, though, we can use a builder that ships with `NimbusJwtDecoder`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n return NimbusJwtDecoder.withIssuerLocation(this.issuer)\n .jwsAlgorithm(RS512).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n return NimbusJwtDecoder.withIssuerLocation(this.issuer)\n .jwsAlgorithm(RS512).build()\n}\n----\n======\n\nCalling `jwsAlgorithm` more than once will configure `NimbusJwtDecoder` to trust more than one algorithm, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n return NimbusJwtDecoder.withIssuerLocation(this.issuer)\n .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n return NimbusJwtDecoder.withIssuerLocation(this.issuer)\n .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build()\n}\n----\n======\n\nOr, you can call `jwsAlgorithms`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n return NimbusJwtDecoder.withIssuerLocation(this.issuer)\n .jwsAlgorithms(algorithms -> {\n algorithms.add(RS512);\n algorithms.add(ES512);\n }).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n return NimbusJwtDecoder.withIssuerLocation(this.issuer)\n .jwsAlgorithms {\n it.add(RS512)\n it.add(ES512)\n }.build()\n}\n----\n======\n\n[[oauth2resourceserver-jwt-decoder-jwk-response]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Using a Builder", "heading_level": 3, "file_order": 153, "section_index": 15, "content_hash": "a018609ae341c03b4dd46b9340165b68dcbf5801e7efbd4fe417ce6414ac897f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:9652b241fc90bc72929ce86d471ae1cdc171d6a3b5b4eff09bdcfb786cbfdb4e", "content": "Since Spring Security's JWT support is based off of Nimbus, you can use all it's great features as well.\n\nFor example, Nimbus has a `JWSKeySelector` implementation that will select the set of algorithms based on the JWK Set URI response.\nYou can use it to generate a `NimbusJwtDecoder` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtDecoder jwtDecoder() {\n // makes a request to the JWK Set endpoint\n JWSKeySelector<SecurityContext> jwsKeySelector =\n JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(this.jwkSetUrl);\n\n DefaultJWTProcessor<SecurityContext> jwtProcessor =\n new DefaultJWTProcessor<>();\n jwtProcessor.setJWSKeySelector(jwsKeySelector);\n\n return new NimbusJwtDecoder(jwtProcessor);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n // makes a request to the JWK Set endpoint\n val jwsKeySelector: JWSKeySelector<SecurityContext> = JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL<SecurityContext>(this.jwkSetUrl)\n val jwtProcessor: DefaultJWTProcessor<SecurityContext> = DefaultJWTProcessor()\n jwtProcessor.jwsKeySelector = jwsKeySelector\n return NimbusJwtDecoder(jwtProcessor)\n}\n----\n======\n\n[[oauth2resourceserver-jwt-decoder-public-key]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "From JWK Set response", "heading_level": 3, "file_order": 153, "section_index": 16, "content_hash": "9652b241fc90bc72929ce86d471ae1cdc171d6a3b5b4eff09bdcfb786cbfdb4e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:cae5a89cfc55bd3fdd2eac19130ed6533f83bfcc64c729aeab2f851f3447cae3", "content": "Simpler than backing a Resource Server with a JWK Set endpoint is to hard-code an RSA public key.\nThe public key can be provided via <<oauth2resourceserver-jwt-decoder-public-key-boot,Spring Boot>> or by <<oauth2resourceserver-jwt-decoder-public-key-builder,Using a Builder>>.\n\n[[oauth2resourceserver-jwt-decoder-public-key-boot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Trusting a Single Asymmetric Key", "heading_level": 2, "file_order": 153, "section_index": 17, "content_hash": "cae5a89cfc55bd3fdd2eac19130ed6533f83bfcc64c729aeab2f851f3447cae3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:4b03128672a06b7db2643c2df1d4512b31f5fa438ec83847edd0ef686f4c916b", "content": "Specifying a key via Spring Boot is quite simple.\nThe key's location can be specified like so:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n public-key-location: classpath:my-key.pub\n----\n\nOr, to allow for a more sophisticated lookup, you can post-process the `RsaKeyConversionServicePostProcessor`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nBeanFactoryPostProcessor conversionServiceCustomizer() {\n return beanFactory ->\n beanFactory.getBean(RsaKeyConversionServicePostProcessor.class)\n .setResourceLoader(new CustomResourceLoader());\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun conversionServiceCustomizer(): BeanFactoryPostProcessor {\n return BeanFactoryPostProcessor { beanFactory ->\n beanFactory.getBean<RsaKeyConversionServicePostProcessor>()\n .setResourceLoader(CustomResourceLoader())\n }\n}\n----\n======\n\nSpecify your key's location:\n\n[source,yaml]\n----\nkey.location: hfds://my-key.pub\n----\n\nAnd then autowire the value:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Value(\"${key.location}\")\nRSAPublicKey key;\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Value(\"\\${key.location}\")\nval key: RSAPublicKey? = null\n----\n======\n\n[[oauth2resourceserver-jwt-decoder-public-key-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Via Spring Boot", "heading_level": 3, "file_order": 153, "section_index": 18, "content_hash": "4b03128672a06b7db2643c2df1d4512b31f5fa438ec83847edd0ef686f4c916b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:8099c550fb7c0a3372974606bf1623cce6e969e24ed4dac82e5fa870f595750c", "content": "To wire an `RSAPublicKey` directly, you can simply use the appropriate `NimbusJwtDecoder` builder, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtDecoder jwtDecoder() {\n return NimbusJwtDecoder.withPublicKey(this.key).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n return NimbusJwtDecoder.withPublicKey(this.key).build()\n}\n----\n======\n\n[[oauth2resourceserver-jwt-decoder-secret-key]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Using a Builder", "heading_level": 3, "file_order": 153, "section_index": 19, "content_hash": "8099c550fb7c0a3372974606bf1623cce6e969e24ed4dac82e5fa870f595750c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:eb9a88b280029811578b79d4e20480f07d1847f6a6695f05a5295f79597b8fdb", "content": "Using a single symmetric key is also simple.\nYou can simply load in your `SecretKey` and use the appropriate `NimbusJwtDecoder` builder, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtDecoder jwtDecoder() {\n return NimbusJwtDecoder.withSecretKey(this.key).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n return NimbusJwtDecoder.withSecretKey(key).build()\n}\n----\n======\n\n[[oauth2resourceserver-jwt-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Trusting a Single Symmetric Key", "heading_level": 2, "file_order": 153, "section_index": 20, "content_hash": "eb9a88b280029811578b79d4e20480f07d1847f6a6695f05a5295f79597b8fdb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:e6143c47793ed0e94727d4f3c3160e0f641b8b7b8a5eb1ed2b1f9c65845e4090", "content": "A JWT that is issued from an OAuth 2.0 Authorization Server will typically either have a `scope` or `scp` attribute, indicating the scopes (or authorities) it's been granted, for example:\n\n`{ ..., \"scope\" : \"messages contacts\"}`\n\nWhen this is the case, Resource Server will attempt to coerce these scopes into a list of granted authorities, prefixing each scope with the string \"SCOPE_\".\n\nThis means that to protect an endpoint or method with a scope derived from a JWT, the corresponding expressions should include this prefix:\n\n.Authorization Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope;\n\n@Configuration\n@EnableWebSecurity\npublic class DirectlyConfiguredJwkSetUri {\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/contacts/**\").access(hasScope(\"contacts\"))\n .requestMatchers(\"/messages/**\").access(hasScope(\"messages\"))\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt(Customizer.withDefaults())\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope;\n\n@Configuration\n@EnableWebSecurity\nclass DirectlyConfiguredJwkSetUri {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(\"/contacts/**\", hasScope(\"contacts\"))\n authorize(\"/messages/**\", hasScope(\"messages\"))\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n jwt { }\n }\n }\n return http.build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-uri pattern=\"/contacts/**\" access=\"hasAuthority('SCOPE_contacts')\"/>\n <intercept-uri pattern=\"/messages/**\" access=\"hasAuthority('SCOPE_messages')\"/>\n <oauth2-resource-server>\n <jwt jwk-set-uri=\"https://idp.example.org/.well-known/jwks.json\"/>\n </oauth2-resource-server>\n</http>\n----\n======\n\nOr similarly with method security:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PreAuthorize(\"hasAuthority('SCOPE_messages')\")\npublic List<Message> getMessages(...) {}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PreAuthorize(\"hasAuthority('SCOPE_messages')\")\nfun getMessages(): List<Message> { }\n----\n======\n\n[[method-security-has-scope]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring Authorization", "heading_level": 2, "file_order": 153, "section_index": 21, "content_hash": "e6143c47793ed0e94727d4f3c3160e0f641b8b7b8a5eb1ed2b1f9c65845e4090", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:0e0ef892b296d452ebb4787506d95bf276126bc379d96a1b25a78d8318e083f9", "content": "Because method security expressions can evaluation `AuthorizationManager` instances, you can also use the `hasScope` API by publishing a `DefaultOAuth2AuthorizationManagerFactory` `@Bean`:\n\ninclude-code::./MethodSecurityHasScopeConfiguration[tag=declare-factory,indent=0]\n\nand then doing:\n\ninclude-code::./MessageService[tag=protected-method,indent=0]\n\nIf you are using xref:servlet/authentication/mfa.adoc[Spring Security's MFA feature], then you can supply its `AuthorizationManagerFactory` instance to ensure that your authentication factors are automatically checked as well by including it in your `DefaultOAuth2AuthorizationManagerFactory` constructor as follows:\n\ninclude-code::./MethodSecurityHasScopeMfaConfiguration[tag=declare-factory,indent=0]\n\n[[oauth2resourceserver-jwt-authorization-extraction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Using `hasScope` in Method Security", "heading_level": 3, "file_order": 153, "section_index": 22, "content_hash": "0e0ef892b296d452ebb4787506d95bf276126bc379d96a1b25a78d8318e083f9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:69765df11440cbe524782b56437519bcc6484418469f2f33e7de04d39bd587b7", "content": "However, there are a number of circumstances where this default is insufficient.\nFor example, some authorization servers don't use the `scope` attribute, but instead have their own custom attribute.\nOr, at other times, the resource server may need to adapt the attribute or a composition of attributes into internalized authorities.\n\nTo this end, Spring Security ships with `JwtAuthenticationConverter`, which is responsible for <<oauth2resourceserver-jwt-architecture-jwtauthenticationconverter,converting a `Jwt` into an `Authentication`>>.\nBy default, Spring Security will wire the `JwtAuthenticationProvider` with a default instance of `JwtAuthenticationConverter`.\n\nAs part of configuring a `JwtAuthenticationConverter`, you can supply a subsidiary converter to go from `Jwt` to a `Collection` of granted authorities.\n\n[[jwt-granted-authorities-custom-claim-name]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Extracting Authorities Manually", "heading_level": 3, "file_order": 153, "section_index": 23, "content_hash": "69765df11440cbe524782b56437519bcc6484418469f2f33e7de04d39bd587b7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:960bf19b7afae5d3dd81b5203e1c7b23d83a55798630058c825bbca9c96de8c9", "content": "Let's say that your authorization server communicates authorities in a custom claim called `authorities`.\n\nIn that case, you can configure the claim that <<oauth2resourceserver-jwt-architecture-jwtauthenticationconverter,`JwtAuthenticationConverter`>> should inspect, like so:\n\n.Authorities Claim Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtAuthenticationConverter jwtAuthenticationConverter() {\n JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();\n grantedAuthoritiesConverter.setAuthoritiesClaimName(\"authorities\");\n\n JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();\n jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);\n return jwtAuthenticationConverter;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtAuthenticationConverter(): JwtAuthenticationConverter {\n val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter()\n grantedAuthoritiesConverter.setAuthoritiesClaimName(\"authorities\")\n\n val jwtAuthenticationConverter = JwtAuthenticationConverter()\n jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter)\n return jwtAuthenticationConverter\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-uri pattern=\"/contacts/**\" access=\"hasAuthority('SCOPE_contacts')\"/>\n <intercept-uri pattern=\"/messages/**\" access=\"hasAuthority('SCOPE_messages')\"/>\n <oauth2-resource-server>\n <jwt jwk-set-uri=\"https://idp.example.org/.well-known/jwks.json\"\n jwt-authentication-converter-ref=\"jwtAuthenticationConverter\"/>\n </oauth2-resource-server>\n</http>\n\n<bean id=\"jwtAuthenticationConverter\"\n class=\"org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter\">\n <property name=\"jwtGrantedAuthoritiesConverter\" ref=\"jwtGrantedAuthoritiesConverter\"/>\n</bean>\n\n<bean id=\"jwtGrantedAuthoritiesConverter\"\n class=\"org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter\">\n <property name=\"authoritiesClaimName\" value=\"authorities\"/>\n</bean>\n----\n======\n\n[[jwt-granted-authorities-custom-scope-prefix]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Using a Custom Claim Name", "heading_level": 4, "file_order": 153, "section_index": 24, "content_hash": "960bf19b7afae5d3dd81b5203e1c7b23d83a55798630058c825bbca9c96de8c9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:1b052024527e315632b10fad1eb476bfa77717c0f5b039628c27d4f11c19db58", "content": "You can also configure the authority prefix to be different as well.\nInstead of prefixing each authority with `SCOPE_`, you can change it to `ROLE_` like so:\n\n.Authorities Prefix Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtAuthenticationConverter jwtAuthenticationConverter() {\n JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();\n grantedAuthoritiesConverter.setAuthorityPrefix(\"ROLE_\");\n\n JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();\n jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);\n return jwtAuthenticationConverter;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtAuthenticationConverter(): JwtAuthenticationConverter {\n val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter()\n grantedAuthoritiesConverter.setAuthorityPrefix(\"ROLE_\")\n\n val jwtAuthenticationConverter = JwtAuthenticationConverter()\n jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter)\n return jwtAuthenticationConverter\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-uri pattern=\"/contacts/**\" access=\"hasAuthority('SCOPE_contacts')\"/>\n <intercept-uri pattern=\"/messages/**\" access=\"hasAuthority('SCOPE_messages')\"/>\n <oauth2-resource-server>\n <jwt jwk-set-uri=\"https://idp.example.org/.well-known/jwks.json\"\n jwt-authentication-converter-ref=\"jwtAuthenticationConverter\"/>\n </oauth2-resource-server>\n</http>\n\n<bean id=\"jwtAuthenticationConverter\"\n class=\"org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter\">\n <property name=\"jwtGrantedAuthoritiesConverter\" ref=\"jwtGrantedAuthoritiesConverter\"/>\n</bean>\n\n<bean id=\"jwtGrantedAuthoritiesConverter\"\n class=\"org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter\">\n <property name=\"authorityPrefix\" value=\"ROLE_\"/>\n</bean>\n----\n======\n\nOr, you can remove the prefix altogether by calling `JwtGrantedAuthoritiesConverter#setAuthorityPrefix(\"\")`.\n\nFor more flexibility, the DSL supports entirely replacing the converter with any class that implements `Converter<Jwt, AbstractAuthenticationToken>`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nstatic class CustomAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> {\n public AbstractAuthenticationToken convert(Jwt jwt) {\n return new CustomAuthenticationToken(jwt);\n }\n}\n\n@Configuration\n@EnableWebSecurity\npublic class CustomAuthenticationConverterConfig {\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt((jwt) -> jwt\n .jwtAuthenticationConverter(new CustomAuthenticationConverter())\n )\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ninternal class CustomAuthenticationConverter : Converter<Jwt, AbstractAuthenticationToken> {\n override fun convert(jwt: Jwt): AbstractAuthenticationToken {\n return CustomAuthenticationToken(jwt)\n }\n}\n\n@Configuration\n@EnableWebSecurity\nclass CustomAuthenticationConverterConfig {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n jwt {\n jwtAuthenticationConverter = CustomAuthenticationConverter()\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[jwt-granted-authorities-spel-expression]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Using a Custom Scope Prefix", "heading_level": 4, "file_order": 153, "section_index": 25, "content_hash": "1b052024527e315632b10fad1eb476bfa77717c0f5b039628c27d4f11c19db58", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:24ea90347b268995b639d609852898c1d911db23451ede018067d90d4eb5a3eb", "content": "In circumstances where the location of scopes is nested or complex in some other way, you can use `ExpressionJwtGrantedAuthoritiesConverter` with a SpEL expression to extract the scopes.\n\nFor example, if your JWT has a claim called `nested` and, inside of that, it has a claim called `scopes`, you can do:\n\ninclude-code::./ExpressionJwtGrantedAuthoritiesConverterTests[tag=spel-expression,indent=0]\n\nThe SpEL expression result should be a `Collection`.\n\n[[oauth2resourceserver-jwt-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Using a SpEL Expression", "heading_level": 4, "file_order": 153, "section_index": 26, "content_hash": "24ea90347b268995b639d609852898c1d911db23451ede018067d90d4eb5a3eb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:cda01ef6099967f99c496978e56b1d49708d84f89c000ed5964d400e33ee2a85", "content": "Using <<oauth2resourceserver-jwt-minimalconfiguration,minimal Spring Boot configuration>>, indicating the authorization server's issuer uri, Resource Server will default to verifying the `iss` claim as well as the `exp` and `nbf` timestamp claims.\n\nIn circumstances where validation needs to be customized, Resource Server ships with two standard validators and also accepts custom `OAuth2TokenValidator` instances.\n\n[[oauth2resourceserver-jwt-validation-clockskew]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring Validation", "heading_level": 2, "file_order": 153, "section_index": 27, "content_hash": "cda01ef6099967f99c496978e56b1d49708d84f89c000ed5964d400e33ee2a85", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:2402c56ebde9b9e8499fbf598ca429483de22f7c639294b4b5e8dfa417d43c4d", "content": "JWT's typically have a window of validity, with the start of the window indicated in the `nbf` claim and the end indicated in the `exp` claim.\n\nHowever, every server can experience clock drift, which can cause tokens to appear expired to one server, but not to another.\nThis can cause some implementation heartburn as the number of collaborating servers increases in a distributed system.\n\nResource Server uses `JwtTimestampValidator` to verify a token's validity window, and it can be configured with a `clockSkew` to alleviate the above problem:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)\n JwtDecoders.fromIssuerLocation(issuerUri);\n\n OAuth2TokenValidator<Jwt> withClockSkew = new DelegatingOAuth2TokenValidator<>(\n new JwtTimestampValidator(Duration.ofSeconds(60)),\n new JwtIssuerValidator(issuerUri));\n\n jwtDecoder.setJwtValidator(withClockSkew);\n\n return jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder\n\n val withClockSkew: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(\n JwtTimestampValidator(Duration.ofSeconds(60)),\n JwtIssuerValidator(issuerUri))\n\n jwtDecoder.setJwtValidator(withClockSkew)\n\n return jwtDecoder\n}\n----\n======\n\n[NOTE]\nBy default, Resource Server configures a clock skew of 60 seconds.\n\n[[oauth2resourceserver-jwt-validation-rfc9068]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Customizing Timestamp Validation", "heading_level": 3, "file_order": 153, "section_index": 28, "content_hash": "2402c56ebde9b9e8499fbf598ca429483de22f7c639294b4b5e8dfa417d43c4d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:9d6b1595a0f82f9079db431bb6579f64dd2a9f68e3824f4301689f761335e8db", "content": "If you need to require tokens that meet https://datatracker.ietf.org/doc/rfc9068/[RFC 9068], you can configure validation in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuerUri)\n .validateTypes(false).build();\n jwtDecoder.setJwtValidator(JwtValidators.createAtJwtValidator()\n .audience(\"https://audience.example.org\")\n .clientId(\"client-identifier\")\n .issuer(\"https://issuer.example.org\").build());\n return jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n val jwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuerUri)\n .validateTypes(false).build()\n jwtDecoder.setJwtValidator(JwtValidators.createAtJwtValidator()\n .audience(\"https://audience.example.org\")\n .clientId(\"client-identifier\")\n .issuer(\"https://issuer.example.org\").build())\n return jwtDecoder\n}\n----\n======\n\n[[oauth2resourceserver-jwt-validation-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring RFC 9068 Validation", "heading_level": 3, "file_order": 153, "section_index": 29, "content_hash": "9d6b1595a0f82f9079db431bb6579f64dd2a9f68e3824f4301689f761335e8db", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:b44b1aad4f6aec861e4047fe7ef51e3a45204aec30e739b82aeafeb7fe5f767f", "content": "Adding a check for <<_supplying_audiences, the `aud` claim>> is simple with the `OAuth2TokenValidator` API:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2TokenValidator<Jwt> audienceValidator() {\n return new JwtClaimValidator<List<String>>(AUD, aud -> aud.contains(\"messaging\"));\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nfun audienceValidator(): OAuth2TokenValidator<Jwt?> {\n return JwtClaimValidator<List<String>>(AUD) { aud -> aud.contains(\"messaging\") }\n}\n----\n======\n\nOr, for more control you can implement your own `OAuth2TokenValidator`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nstatic class AudienceValidator implements OAuth2TokenValidator<Jwt> {\n OAuth2Error error = new OAuth2Error(\"custom_code\", \"Custom error message\", null);\n\n @Override\n public OAuth2TokenValidatorResult validate(Jwt jwt) {\n if (jwt.getAudience().contains(\"messaging\")) {\n return OAuth2TokenValidatorResult.success();\n } else {\n return OAuth2TokenValidatorResult.failure(error);\n }\n }\n}\n\nOAuth2TokenValidator<Jwt> audienceValidator() {\n return new AudienceValidator();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ninternal class AudienceValidator : OAuth2TokenValidator<Jwt> {\n var error: OAuth2Error = OAuth2Error(\"custom_code\", \"Custom error message\", null)\n\n override fun validate(jwt: Jwt): OAuth2TokenValidatorResult {\n return if (jwt.audience.contains(\"messaging\")) {\n OAuth2TokenValidatorResult.success()\n } else {\n OAuth2TokenValidatorResult.failure(error)\n }\n }\n}\n\nfun audienceValidator(): OAuth2TokenValidator<Jwt> {\n return AudienceValidator()\n}\n----\n======\n\nThen, to add into a resource server, it's a matter of specifying the <<oauth2resourceserver-jwt-architecture-jwtdecoder,`JwtDecoder`>> instance:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)\n JwtDecoders.fromIssuerLocation(issuerUri);\n\n OAuth2TokenValidator<Jwt> audienceValidator = audienceValidator();\n OAuth2TokenValidator<Jwt> withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);\n OAuth2TokenValidator<Jwt> withAudience = new DelegatingOAuth2TokenValidator<>(withIssuer, audienceValidator);\n\n jwtDecoder.setJwtValidator(withAudience);\n\n return jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder\n\n val audienceValidator = audienceValidator()\n val withIssuer: OAuth2TokenValidator<Jwt> = JwtValidators.createDefaultWithIssuer(issuerUri)\n val withAudience: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(withIssuer, audienceValidator)\n\n jwtDecoder.setJwtValidator(withAudience)\n\n return jwtDecoder\n}\n----\n======\n\n[TIP]\nAs stated earlier, you can instead <<_supplying_audiences, configure `aud` validation in Boot>>.\n\n[[oauth2resourceserver-jwt-claimsetmapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring a Custom Validator", "heading_level": 3, "file_order": 153, "section_index": 30, "content_hash": "b44b1aad4f6aec861e4047fe7ef51e3a45204aec30e739b82aeafeb7fe5f767f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:922c8233128982849311141fa54aed9476771e90d7a1154d4ec8ebfe3e0b8fdb", "content": "Spring Security uses the https://bitbucket.org/connect2id/nimbus-jose-jwt/wiki/Home[Nimbus] library for parsing JWTs and validating their signatures.\nConsequently, Spring Security is subject to Nimbus's interpretation of each field value and how to coerce each into a Java type.\n\nFor example, because Nimbus remains Java 7 compatible, it doesn't use `Instant` to represent timestamp fields.\n\nAnd it's entirely possible to use a different library or for JWT processing, which may make its own coercion decisions that need adjustment.\n\nOr, quite simply, a resource server may want to add or remove claims from a JWT for domain-specific reasons.\n\nFor these purposes, Resource Server supports mapping the JWT claim set with `MappedJwtClaimSetConverter`.\n\n[[oauth2resourceserver-jwt-claimsetmapping-singleclaim]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring Claim Set Mapping", "heading_level": 2, "file_order": 153, "section_index": 31, "content_hash": "922c8233128982849311141fa54aed9476771e90d7a1154d4ec8ebfe3e0b8fdb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:575202077bb24ddaff69e9f8b7965ea62b3de5b8fa5f60c18ba1aa50451b5ec2", "content": "By default, `MappedJwtClaimSetConverter` will attempt to coerce claims into the following types:\n\n|============\n| Claim | Java Type\n| `aud` | `Collection<String>`\n| `exp` | `Instant`\n| `iat` | `Instant`\n| `iss` | `String`\n| `jti` | `String`\n| `nbf` | `Instant`\n| `sub` | `String`\n|============\n\nAn individual claim's conversion strategy can be configured using `MappedJwtClaimSetConverter.withDefaults`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuer).build();\n\n MappedJwtClaimSetConverter converter = MappedJwtClaimSetConverter\n .withDefaults(Collections.singletonMap(\"sub\", this::lookupUserIdBySub));\n jwtDecoder.setClaimSetConverter(converter);\n\n return jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n val jwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuer).build()\n\n val converter = MappedJwtClaimSetConverter\n .withDefaults(mapOf(\"sub\" to this::lookupUserIdBySub))\n jwtDecoder.setClaimSetConverter(converter)\n\n return jwtDecoder\n}\n----\n======\nThis will keep all the defaults, except it will override the default claim converter for `sub`.\n\n[[oauth2resourceserver-jwt-claimsetmapping-add]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Customizing the Conversion of a Single Claim", "heading_level": 3, "file_order": 153, "section_index": 32, "content_hash": "575202077bb24ddaff69e9f8b7965ea62b3de5b8fa5f60c18ba1aa50451b5ec2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:c0c1839da012808b48b6b9409c533bbd1c3fd6ce9c17c6094d2e05acb4caa281", "content": "`MappedJwtClaimSetConverter` can also be used to add a custom claim, for example, to adapt to an existing system:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nMappedJwtClaimSetConverter.withDefaults(Collections.singletonMap(\"custom\", custom -> \"value\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nMappedJwtClaimSetConverter.withDefaults(mapOf(\"custom\" to Converter<Any, String> { \"value\" }))\n----\n======\n\n[[oauth2resourceserver-jwt-claimsetmapping-remove]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Adding a Claim", "heading_level": 3, "file_order": 153, "section_index": 33, "content_hash": "c0c1839da012808b48b6b9409c533bbd1c3fd6ce9c17c6094d2e05acb4caa281", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:511ea4819c116961bc2e2ef85a4e1de6ed7d06f3324f79941d9da84d971b1c9c", "content": "And removing a claim is also simple, using the same API:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nMappedJwtClaimSetConverter.withDefaults(Collections.singletonMap(\"legacyclaim\", legacy -> null));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nMappedJwtClaimSetConverter.withDefaults(mapOf(\"legacyclaim\" to Converter<Any, Any> { null }))\n----\n======\n\n[[oauth2resourceserver-jwt-claimsetmapping-rename]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Removing a Claim", "heading_level": 3, "file_order": 153, "section_index": 34, "content_hash": "511ea4819c116961bc2e2ef85a4e1de6ed7d06f3324f79941d9da84d971b1c9c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:2e8d77a88726a6f211aeeab29e0625ab417dbea21ab63486bf4006f4f97da635", "content": "In more sophisticated scenarios, like consulting multiple claims at once or renaming a claim, Resource Server accepts any class that implements `Converter<Map<String, Object>, Map<String,Object>>`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class UsernameSubClaimAdapter implements Converter<Map<String, Object>, Map<String, Object>> {\n private final MappedJwtClaimSetConverter delegate =\n MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap());\n\n public Map<String, Object> convert(Map<String, Object> claims) {\n Map<String, Object> convertedClaims = this.delegate.convert(claims);\n\n String username = (String) convertedClaims.get(\"user_name\");\n convertedClaims.put(\"sub\", username);\n\n return convertedClaims;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass UsernameSubClaimAdapter : Converter<Map<String, Any?>, Map<String, Any?>> {\n private val delegate = MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap())\n override fun convert(claims: Map<String, Any?>): Map<String, Any?> {\n val convertedClaims = delegate.convert(claims)\n val username = convertedClaims[\"user_name\"] as String\n convertedClaims[\"sub\"] = username\n return convertedClaims\n }\n}\n----\n======\n\nAnd then, the instance can be supplied like normal:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder() {\n NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuer).build();\n jwtDecoder.setClaimSetConverter(new UsernameSubClaimAdapter());\n return jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(): JwtDecoder {\n val jwtDecoder: NimbusJwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuer).build()\n jwtDecoder.setClaimSetConverter(UsernameSubClaimAdapter())\n return jwtDecoder\n}\n----\n======\n\n[[oauth2resourceserver-jwt-timeouts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Renaming a Claim", "heading_level": 3, "file_order": 153, "section_index": 35, "content_hash": "2e8d77a88726a6f211aeeab29e0625ab417dbea21ab63486bf4006f4f97da635", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:ad1a37894aebf980a52e36908cf5b5ca2fbdd18903c0d8493e058e472ef6fe04", "content": "By default, Resource Server uses connection and socket timeouts of 30 seconds each for coordinating with the authorization server.\n\nThis may be too short in some scenarios.\nFurther, it doesn't take into account more sophisticated patterns like back-off and discovery.\n\nTo adjust the way in which Resource Server connects to the authorization server, `NimbusJwtDecoder` accepts an instance of `RestOperations`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtDecoder jwtDecoder(RestTemplateBuilder builder) {\n RestOperations rest = builder\n .setConnectTimeout(Duration.ofSeconds(60))\n .setReadTimeout(Duration.ofSeconds(60))\n .build();\n\n NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withIssuerLocation(issuer).restOperations(rest).build();\n return jwtDecoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(builder: RestTemplateBuilder): JwtDecoder {\n val rest: RestOperations = builder\n .setConnectTimeout(Duration.ofSeconds(60))\n .setReadTimeout(Duration.ofSeconds(60))\n .build()\n return NimbusJwtDecoder.withIssuerLocation(issuer).restOperations(rest).build()\n}\n----\n======\n\nAlso by default, Resource Server caches in-memory the authorization server's JWK set for 5 minutes, which you may want to adjust.\nFurther, it doesn't take into account more sophisticated caching patterns like eviction or using a shared cache.\n\nTo adjust the way in which Resource Server caches the JWK set, `NimbusJwtDecoder` accepts an instance of `Cache`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JwtDecoder jwtDecoder(CacheManager cacheManager) {\n return NimbusJwtDecoder.withIssuerLocation(issuer)\n .cache(cacheManager.getCache(\"jwks\"))\n .build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(cacheManager: CacheManager): JwtDecoder {\n return NimbusJwtDecoder.withIssuerLocation(issuer)\n .cache(cacheManager.getCache(\"jwks\"))\n .build()\n}\n----\n======\n\nWhen given a `Cache`, Resource Server will use the JWK Set Uri as the key and the JWK Set JSON as the value.\n\nNOTE: Spring isn't a cache provider, so you'll need to make sure to include the appropriate dependencies, like `spring-boot-starter-cache` and your favorite caching provider.\n\nNOTE: Whether it's socket or cache timeouts, you may instead want to work with Nimbus directly.\nTo do so, remember that `NimbusJwtDecoder` ships with a constructor that takes Nimbus's `JWTProcessor`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc", "title": "OAuth 2.0 Resource Server JWT", "heading": "Configuring Timeouts", "heading_level": 2, "file_order": 153, "section_index": 36, "content_hash": "ad1a37894aebf980a52e36908cf5b5ca2fbdd18903c0d8493e058e472ef6fe04", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/jwt.adoc"}}
{"id": "sha256:5a4c85047f06e9dff1b4d53b8de05f03b8f11e47aa877685661060ba870f6b03", "content": "[[oauth2reourceserver-opaqueandjwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc", "title": "OAuth 2.0 Resource Server Multi-tenancy", "heading": "OAuth 2.0 Resource Server Multi-tenancy", "heading_level": 1, "file_order": 154, "section_index": 0, "content_hash": "5a4c85047f06e9dff1b4d53b8de05f03b8f11e47aa877685661060ba870f6b03", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc"}}
{"id": "sha256:fea6a7950d679fe0afba83ee149217cee2d86703375bc390a83c7ae10bf2306d", "content": "In some cases, you may have a need to access both kinds of tokens.\nFor example, you may support more than one tenant where one tenant issues JWTs and the other issues opaque tokens.\n\nIf this decision must be made at request-time, then you can use an `AuthenticationManagerResolver` to achieve it, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nAuthenticationManagerResolver<HttpServletRequest> tokenAuthenticationManagerResolver\n (JwtDecoder jwtDecoder, OpaqueTokenIntrospector opaqueTokenIntrospector) {\n AuthenticationManager jwt = new ProviderManager(new JwtAuthenticationProvider(jwtDecoder));\n AuthenticationManager opaqueToken = new ProviderManager(\n new OpaqueTokenAuthenticationProvider(opaqueTokenIntrospector));\n return (request) -> useJwt(request) ? jwt : opaqueToken;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun tokenAuthenticationManagerResolver\n (jwtDecoder: JwtDecoder, opaqueTokenIntrospector: OpaqueTokenIntrospector):\n AuthenticationManagerResolver<HttpServletRequest> {\n val jwt = ProviderManager(JwtAuthenticationProvider(jwtDecoder))\n val opaqueToken = ProviderManager(OpaqueTokenAuthenticationProvider(opaqueTokenIntrospector));\n\n return AuthenticationManagerResolver { request ->\n if (useJwt(request)) {\n jwt\n } else {\n opaqueToken\n }\n }\n}\n----\n======\n\nNOTE: The implementation of `useJwt(HttpServletRequest)` will likely depend on custom request material like the path.\n\nAnd then specify this `AuthenticationManagerResolver` in the DSL:\n\n.Authentication Manager Resolver\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .authenticationManagerResolver(this.tokenAuthenticationManagerResolver)\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n authenticationManagerResolver = tokenAuthenticationManagerResolver()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <oauth2-resource-server authentication-manager-resolver-ref=\"tokenAuthenticationManagerResolver\"/>\n</http>\n----\n======\n\n[[oauth2resourceserver-multitenancy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc", "title": "OAuth 2.0 Resource Server Multi-tenancy", "heading": "Supporting both JWT and Opaque Token", "heading_level": 2, "file_order": 154, "section_index": 1, "content_hash": "fea6a7950d679fe0afba83ee149217cee2d86703375bc390a83c7ae10bf2306d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc"}}
{"id": "sha256:9532756a620c86591b88b9e30a942097b69e8049c919966899e09b299bf52e6b", "content": "A resource server is considered multi-tenant when there are multiple strategies for verifying a bearer token, keyed by some tenant identifier.\n\nFor example, your resource server may accept bearer tokens from two different authorization servers.\nOr, your authorization server may represent a multiplicity of issuers.\n\nIn each case, there are two things that need to be done and trade-offs associated with how you choose to do them:\n\n1. Resolve the tenant\n2. Propagate the tenant", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc", "title": "OAuth 2.0 Resource Server Multi-tenancy", "heading": "Multi-tenancy", "heading_level": 2, "file_order": 154, "section_index": 2, "content_hash": "9532756a620c86591b88b9e30a942097b69e8049c919966899e09b299bf52e6b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc"}}
{"id": "sha256:fc1580ce97edbe1010b7701c34dd406f622e9ed2ef9f3291330a0c29e2e2f07b", "content": "One way to differentiate tenants is by the issuer claim. Since the issuer claim accompanies signed JWTs, this can be done with the `JwtIssuerAuthenticationManagerResolver`, like so:\n\n.Multi-tenancy Tenant by JWT Claim\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nJwtIssuerAuthenticationManagerResolver authenticationManagerResolver = JwtIssuerAuthenticationManagerResolver\n .fromTrustedIssuers(\"https://idp.example.org/issuerOne\", \"https://idp.example.org/issuerTwo\");\n\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .authenticationManagerResolver(authenticationManagerResolver)\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval customAuthenticationManagerResolver = JwtIssuerAuthenticationManagerResolver\n .fromTrustedIssuers(\"https://idp.example.org/issuerOne\", \"https://idp.example.org/issuerTwo\")\nhttp {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n authenticationManagerResolver = customAuthenticationManagerResolver\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <oauth2-resource-server authentication-manager-resolver-ref=\"authenticationManagerResolver\"/>\n</http>\n\n<bean id=\"authenticationManagerResolver\"\n class=\"org.springframework.security.oauth2.server.resource.authentication.JwtIssuerAuthenticationManagerResolver\">\n <constructor-arg>\n <list>\n <value>https://idp.example.org/issuerOne</value>\n <value>https://idp.example.org/issuerTwo</value>\n </list>\n </constructor-arg>\n</bean>\n----\n======\n\nThis is nice because the issuer endpoints are loaded lazily.\nIn fact, the corresponding `JwtAuthenticationProvider` is instantiated only when the first request with the corresponding issuer is sent.\nThis allows for an application startup that is independent from those authorization servers being up and available.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc", "title": "OAuth 2.0 Resource Server Multi-tenancy", "heading": "Resolving the Tenant By Claim", "heading_level": 3, "file_order": 154, "section_index": 3, "content_hash": "fc1580ce97edbe1010b7701c34dd406f622e9ed2ef9f3291330a0c29e2e2f07b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc"}}
{"id": "sha256:3cf49e83aaeaffcbcb7a02b0d19979849b64c0ff9d3208d1445121f5e9de081a", "content": "Of course, you may not want to restart the application each time a new tenant is added.\nIn this case, you can configure the `JwtIssuerAuthenticationManagerResolver` with a repository of `AuthenticationManager` instances, which you can edit at runtime, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nprivate void addManager(Map<String, AuthenticationManager> authenticationManagers, String issuer) {\n\tJwtAuthenticationProvider authenticationProvider = new JwtAuthenticationProvider\n (JwtDecoders.fromIssuerLocation(issuer));\n\tauthenticationManagers.put(issuer, authenticationProvider::authenticate);\n}\n\nJwtIssuerAuthenticationManagerResolver authenticationManagerResolver =\n new JwtIssuerAuthenticationManagerResolver(authenticationManagers::get);\n\nhttp\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .authenticationManagerResolver(authenticationManagerResolver)\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nprivate fun addManager(authenticationManagers: MutableMap<String, AuthenticationManager>, issuer: String) {\n val authenticationProvider = JwtAuthenticationProvider(JwtDecoders.fromIssuerLocation(issuer))\n authenticationManagers[issuer] = AuthenticationManager {\n authentication: Authentication? -> authenticationProvider.authenticate(authentication)\n }\n}\n\nval customAuthenticationManagerResolver: JwtIssuerAuthenticationManagerResolver =\n JwtIssuerAuthenticationManagerResolver(authenticationManagers::get)\nhttp {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n authenticationManagerResolver = customAuthenticationManagerResolver\n }\n}\n----\n======\n\nIn this case, you construct `JwtIssuerAuthenticationManagerResolver` with a strategy for obtaining the `AuthenticationManager` given the issuer.\nThis approach allows us to add and remove elements from the repository (shown as a `Map` in the snippet) at runtime.\n\nNOTE: It would be unsafe to simply take any issuer and construct an `AuthenticationManager` from it.\nThe issuer should be one that the code can verify from a trusted source like a list of allowed issuers.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc", "title": "OAuth 2.0 Resource Server Multi-tenancy", "heading": "Dynamic Tenants", "heading_level": 4, "file_order": 154, "section_index": 4, "content_hash": "3cf49e83aaeaffcbcb7a02b0d19979849b64c0ff9d3208d1445121f5e9de081a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc"}}
{"id": "sha256:dd3372641763be588af9c28d941c84768ed0281c9d531fb94e4287d9a6e569d4", "content": "You may have observed that this strategy, while simple, comes with the trade-off that the JWT is parsed once by the `AuthenticationManagerResolver` and then again by the xref:servlet/oauth2/resource-server/jwt.adoc#oauth2resourceserver-jwt-architecture-jwtdecoder[`JwtDecoder`] later on in the request.\n\nThis extra parsing can be alleviated by configuring the xref:servlet/oauth2/resource-server/jwt.adoc#oauth2resourceserver-jwt-architecture-jwtdecoder[`JwtDecoder`] directly with a `JWTClaimsSetAwareJWSKeySelector` from Nimbus:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class TenantJWSKeySelector\n implements JWTClaimsSetAwareJWSKeySelector<SecurityContext> {\n\n\tprivate final TenantRepository tenants; <1>\n\tprivate final Map<String, JWSKeySelector<SecurityContext>> selectors = new ConcurrentHashMap<>(); <2>\n\n\tpublic TenantJWSKeySelector(TenantRepository tenants) {\n this.tenants = tenants;\n\t}\n\n\t@Override\n\tpublic List<? extends Key> selectKeys(JWSHeader jwsHeader, JWTClaimsSet jwtClaimsSet, SecurityContext securityContext)\n throws KeySourceException {\n return this.selectors.computeIfAbsent(toTenant(jwtClaimsSet), this::fromTenant)\n .selectJWSKeys(jwsHeader, securityContext);\n\t}\n\n\tprivate String toTenant(JWTClaimsSet claimSet) {\n return (String) claimSet.getClaim(\"iss\");\n\t}\n\n\tprivate JWSKeySelector<SecurityContext> fromTenant(String tenant) {\n return Optional.ofNullable(this.tenants.findById(tenant)) <3>\n .map((t) -> t.getAttrbute(\"jwks_uri\"))\n .map(this::fromUri)\n .orElseThrow(() -> new IllegalArgumentException(\"unknown tenant\"));\n\t}\n\n\tprivate JWSKeySelector<SecurityContext> fromUri(String uri) {\n try {\n return JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(new URL(uri)); <4>\n } catch (Exception ex) {\n throw new IllegalArgumentException(ex);\n }\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass TenantJWSKeySelector(tenants: TenantRepository) : JWTClaimsSetAwareJWSKeySelector<SecurityContext> {\n private val tenants: TenantRepository <1>\n private val selectors: MutableMap<String, JWSKeySelector<SecurityContext>> = ConcurrentHashMap() <2>\n\n init {\n this.tenants = tenants\n }\n\n fun selectKeys(jwsHeader: JWSHeader?, jwtClaimsSet: JWTClaimsSet, securityContext: SecurityContext): List<Key?> {\n return selectors.computeIfAbsent(toTenant(jwtClaimsSet)) { tenant: String -> fromTenant(tenant) }\n .selectJWSKeys(jwsHeader, securityContext)\n }\n\n private fun toTenant(claimSet: JWTClaimsSet): String {\n return claimSet.getClaim(\"iss\") as String\n }\n\n private fun fromTenant(tenant: String): JWSKeySelector<SecurityContext> {\n return Optional.ofNullable(this.tenants.findById(tenant)) <3>\n .map { t -> t.getAttrbute(\"jwks_uri\") }\n .map { uri: String -> fromUri(uri) }\n .orElseThrow { IllegalArgumentException(\"unknown tenant\") }\n }\n\n private fun fromUri(uri: String): JWSKeySelector<SecurityContext?> {\n return try {\n JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(URL(uri)) <4>\n } catch (ex: Exception) {\n throw IllegalArgumentException(ex)\n }\n }\n}\n----\n======\n<1> A hypothetical source for tenant information\n<2> A cache for ``JWSKeySelector``s, keyed by tenant identifier\n<3> Looking up the tenant is more secure than simply calculating the JWK Set endpoint on the fly - the lookup acts as a list of allowed tenants\n<4> Create a `JWSKeySelector` via the types of keys that come back from the JWK Set endpoint - the lazy lookup here means that you don't need to configure all tenants at startup\n\nThe above key selector is a composition of many key selectors.\nIt chooses which key selector to use based on the `iss` claim in the JWT.\n\nNOTE: To use this approach, make sure that the authorization server is configured to include the claim set as part of the token's signature.\nWithout this, you have no guarantee that the issuer hasn't been altered by a bad actor.\n\nNext, we can construct a `JWTProcessor`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJWTProcessor jwtProcessor(JWTClaimsSetAwareJWSKeySelector keySelector) {\n\tConfigurableJWTProcessor<SecurityContext> jwtProcessor =\n new DefaultJWTProcessor();\n\tjwtProcessor.setJWTClaimSetJWSKeySelector(keySelector);\n\treturn jwtProcessor;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtProcessor(keySelector: JWTClaimsSetAwareJWSKeySelector<SecurityContext>): JWTProcessor<SecurityContext> {\n val jwtProcessor = DefaultJWTProcessor<SecurityContext>()\n jwtProcessor.jwtClaimsSetAwareJWSKeySelector = keySelector\n return jwtProcessor\n}\n----\n======\n\nAs you are already seeing, the trade-off for moving tenant-awareness down to this level is more configuration.\nWe have just a bit more.\n\nNext, we still want to make sure you are validating the issuer.\nBut, since the issuer may be different per JWT, then you'll need a tenant-aware validator, too:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class TenantJwtIssuerValidator implements OAuth2TokenValidator<Jwt> {\n private final TenantRepository tenants;\n\n private final OAuth2Error error = new OAuth2Error(OAuth2ErrorCodes.INVALID_TOKEN, \"The iss claim is not valid\",\n \"https://tools.ietf.org/html/rfc6750#section-3.1\");\n\n public TenantJwtIssuerValidator(TenantRepository tenants) {\n this.tenants = tenants;\n }\n\n @Override\n public OAuth2TokenValidatorResult validate(Jwt token) {\n if(this.tenants.findById(token.getIssuer()) != null) {\n return OAuth2TokenValidatorResult.success();\n }\n return OAuth2TokenValidatorResult.failure(this.error);\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass TenantJwtIssuerValidator(private val tenants: TenantRepository) : OAuth2TokenValidator<Jwt> {\n private val error: OAuth2Error = OAuth2Error(OAuth2ErrorCodes.INVALID_TOKEN, \"The iss claim is not valid\",\n \"https://tools.ietf.org/html/rfc6750#section-3.1\")\n\n override fun validate(token: Jwt): OAuth2TokenValidatorResult {\n return if (tenants.findById(token.issuer) != null)\n OAuth2TokenValidatorResult.success() else OAuth2TokenValidatorResult.failure(error)\n }\n}\n----\n======\nNow that we have a tenant-aware processor and a tenant-aware validator, we can proceed with creating our xref:servlet/oauth2/resource-server/jwt.adoc#oauth2resourceserver-jwt-architecture-jwtdecoder[`JwtDecoder`]:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nJwtDecoder jwtDecoder(JWTProcessor jwtProcessor, OAuth2TokenValidator<Jwt> jwtValidator) {\n\tNimbusJwtDecoder decoder = new NimbusJwtDecoder(jwtProcessor);\n\tOAuth2TokenValidator<Jwt> validator = new DelegatingOAuth2TokenValidator<>\n (JwtValidators.createDefault(), jwtValidator);\n\tdecoder.setJwtValidator(validator);\n\treturn decoder;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun jwtDecoder(jwtProcessor: JWTProcessor<SecurityContext>?, jwtValidator: OAuth2TokenValidator<Jwt>?): JwtDecoder {\n val decoder = NimbusJwtDecoder(jwtProcessor)\n val validator: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(JwtValidators.createDefault(), jwtValidator)\n decoder.setJwtValidator(validator)\n return decoder\n}\n----\n======\n\nWe've finished talking about resolving the tenant.\n\nIf you've chosen to resolve the tenant by something other than a JWT claim, then you'll need to make sure you address your downstream resource servers in the same way.\nFor example, if you are resolving it by subdomain, you may need to address the downstream resource server using the same subdomain.\n\nHowever, if you resolve it by a claim in the bearer token, read on to learn about xref:servlet/oauth2/resource-server/bearer-tokens.adoc#oauth2resourceserver-bearertoken-resolver[Spring Security's support for bearer token propagation].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc", "title": "OAuth 2.0 Resource Server Multi-tenancy", "heading": "Parsing the Claim Only Once", "heading_level": 4, "file_order": 154, "section_index": 5, "content_hash": "dd3372641763be588af9c28d941c84768ed0281c9d531fb94e4287d9a6e569d4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/multitenancy.adoc"}}
{"id": "sha256:5e32920ecff4027ba6bdbac56b23dc0604fd73d0ceb4ffdef88aa1d785421eff", "content": "[[oauth2resourceserver-opaque-minimaldependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "OAuth 2.0 Resource Server Opaque Token", "heading_level": 1, "file_order": 155, "section_index": 0, "content_hash": "5e32920ecff4027ba6bdbac56b23dc0604fd73d0ceb4ffdef88aa1d785421eff", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:ab4d840a5f0763a342b6d7bbb0a18889a35db76f4ad61e4b73b2edd2fb528283", "content": "As described in xref:servlet/oauth2/resource-server/jwt.adoc#oauth2resourceserver-jwt-minimaldependencies[Minimal Dependencies for JWT] most of Resource Server support is collected in `spring-security-oauth2-resource-server`.\nHowever unless a custom <<oauth2resourceserver-opaque-introspector,`OpaqueTokenIntrospector`>> is provided, the Resource Server will fallback to `SpringOpaqueTokenIntrospector`.\nThis means that only `spring-security-oauth2-resource-server` is necessary in order to have a working minimal Resource Server that supports opaque Bearer Tokens.\n\n[[oauth2resourceserver-opaque-minimalconfiguration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Minimal Dependencies for Introspection", "heading_level": 2, "file_order": 155, "section_index": 1, "content_hash": "ab4d840a5f0763a342b6d7bbb0a18889a35db76f4ad61e4b73b2edd2fb528283", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:ce26d7126f614128f7899570372d7c7c536d3a950e64cac495198100b0ca9759", "content": "Typically, an opaque token can be verified via an https://tools.ietf.org/html/rfc7662[OAuth 2.0 Introspection Endpoint], hosted by the authorization server.\nThis can be handy when revocation is a requirement.\n\nWhen using https://spring.io/projects/spring-boot[Spring Boot], configuring an application as a resource server that uses introspection consists of two basic steps.\nFirst, include the needed dependencies and second, indicate the introspection endpoint details.\n\n[[oauth2resourceserver-opaque-introspectionuri]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Minimal Configuration for Introspection", "heading_level": 2, "file_order": 155, "section_index": 2, "content_hash": "ce26d7126f614128f7899570372d7c7c536d3a950e64cac495198100b0ca9759", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:efe8210ab1593aa5c6cfdea3cbc85563229f915f81a8349eb1a1c75fea6d2440", "content": "To specify where the introspection endpoint is, simply do:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n opaquetoken:\n introspection-uri: https://idp.example.com/introspect\n client-id: client\n client-secret: secret\n----\n\nWhere `https://idp.example.com/introspect` is the introspection endpoint hosted by your authorization server and `client-id` and `client-secret` are the credentials needed to hit that endpoint.\n\nResource Server will use these properties to further self-configure and subsequently validate incoming JWTs.\n\n[NOTE]\nWhen using introspection, the authorization server's word is the law.\nIf the authorization server responses that the token is valid, then it is.\n\nAnd that's it!", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Specifying the Authorization Server", "heading_level": 3, "file_order": 155, "section_index": 3, "content_hash": "efe8210ab1593aa5c6cfdea3cbc85563229f915f81a8349eb1a1c75fea6d2440", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:36d5d0e7a3cb77479f9e5c00b5a6f92f68539a058ef9988620523bd221ed63b0", "content": "When this property and these dependencies are used, Resource Server will automatically configure itself to validate Opaque Bearer Tokens.\n\nThis startup process is quite a bit simpler than for JWTs since no endpoints need to be discovered and no additional validation rules get added.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Startup Expectations", "heading_level": 3, "file_order": 155, "section_index": 4, "content_hash": "36d5d0e7a3cb77479f9e5c00b5a6f92f68539a058ef9988620523bd221ed63b0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:246a5028540a4b582e7cc3eed9d5bcbf41b2975eb9a2bce2e99764d97f5efcba", "content": "Once the application is started up, Resource Server will attempt to process any request containing an `Authorization: Bearer` header:\n\n[source,http]\n----\nGET / HTTP/1.1\nAuthorization: Bearer some-token-value # Resource Server will process this\n----\n\nSo long as this scheme is indicated, Resource Server will attempt to process the request according to the Bearer Token specification.\n\nGiven an Opaque Token, Resource Server will\n\n1. Query the provided introspection endpoint using the provided credentials and the token\n2. Inspect the response for an `{ 'active' : true }` attribute\n3. Map each scope to an authority with the prefix `SCOPE_`\n\nThe resulting `Authentication#getPrincipal`, by default, is a Spring Security javadoc:org.springframework.security.oauth2.core.OAuth2AuthenticatedPrincipal[] object, and `Authentication#getName` maps to the token's `sub` property, if one is present.\n\nFrom here, you may want to jump to:\n\n* <<oauth2resourceserver-opaque-architecture>>\n* <<oauth2resourceserver-opaque-attributes,Looking Up Attributes Post-Authentication>>\n* <<oauth2resourceserver-opaque-authorization-extraction,Extracting Authorities Manually>>\n* <<oauth2resourceserver-opaque-jwt-introspector,Using Introspection with JWTs>>\n\n[[oauth2resourceserver-opaque-architecture]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Runtime Expectations", "heading_level": 3, "file_order": 155, "section_index": 5, "content_hash": "246a5028540a4b582e7cc3eed9d5bcbf41b2975eb9a2bce2e99764d97f5efcba", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:e5db4efabee66aa91c66d71eff22bad077acabfd4a7d28d52cb3013c2aad678d", "content": "Next, let's see the architectural components that Spring Security uses to support https://tools.ietf.org/html/rfc7662[opaque token] Authentication in servlet-based applications, like the one we just saw.\n\njavadoc:org.springframework.security.oauth2.server.resource.authentication.OpaqueTokenAuthenticationProvider[] is an xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationprovider[`AuthenticationProvider`] implementation that leverages a <<oauth2resourceserver-opaque-introspector,`OpaqueTokenIntrospector`>> to authenticate an opaque token.\n\nLet's take a look at how `OpaqueTokenAuthenticationProvider` works within Spring Security.\nThe figure explains details of how the xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationmanager[`AuthenticationManager`] in figures from xref:servlet/oauth2/resource-server/index.adoc#oauth2resourceserver-authentication-bearertokenauthenticationfilter[Reading the Bearer Token] works.\n\n.`OpaqueTokenAuthenticationProvider` Usage\n[.invert-dark]\nimage::{figures}/opaquetokenauthenticationprovider.png[]\n\nimage:{icondir}/number_1.png[] The authentication `Filter` from xref:servlet/oauth2/resource-server/index.adoc#oauth2resourceserver-authentication-bearertokenauthenticationfilter[Reading the Bearer Token] passes a `BearerTokenAuthenticationToken` to the `AuthenticationManager` which is implemented by xref:servlet/authentication/architecture.adoc#servlet-authentication-providermanager[`ProviderManager`].\n\nimage:{icondir}/number_2.png[] The `ProviderManager` is configured to use an xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationprovider[AuthenticationProvider] of type `OpaqueTokenAuthenticationProvider`.\n\n[[oauth2resourceserver-opaque-architecture-introspector]]\nimage:{icondir}/number_3.png[] `OpaqueTokenAuthenticationProvider` introspects the opaque token and adds granted authorities using an <<oauth2resourceserver-opaque-introspector,`OpaqueTokenIntrospector`>>.\nWhen authentication is successful, the xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`] that is returned is of type `BearerTokenAuthentication` and has a principal that is the `OAuth2AuthenticatedPrincipal` returned by the configured <<oauth2resourceserver-opaque-introspector,`OpaqueTokenIntrospector`>> and a set of authorities that contains at least `FACTOR_BEARER`.\nUltimately, the returned `BearerTokenAuthentication` will be set on the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[`SecurityContextHolder`] by the authentication `Filter`.\n\n[[oauth2resourceserver-opaque-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "How Opaque Token Authentication Works", "heading_level": 2, "file_order": 155, "section_index": 6, "content_hash": "e5db4efabee66aa91c66d71eff22bad077acabfd4a7d28d52cb3013c2aad678d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:9b841373690302d66890ea8aac79a62453a4c025a0f82b3e56a58ca8128dd1d2", "content": "Once a token is authenticated, an instance of `BearerTokenAuthentication` is set in the `SecurityContext`.\n\nThis means that it's available in `@Controller` methods when using `@EnableWebMvc` in your configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/foo\")\npublic String foo(BearerTokenAuthentication authentication) {\n return authentication.getTokenAttributes().get(\"sub\") + \" is the subject\";\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/foo\")\nfun foo(authentication: BearerTokenAuthentication): String {\n return authentication.tokenAttributes[\"sub\"].toString() + \" is the subject\"\n}\n----\n======\n\nSince `BearerTokenAuthentication` holds an `OAuth2AuthenticatedPrincipal`, that also means that it's available to controller methods, too:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/foo\")\npublic String foo(@AuthenticationPrincipal OAuth2AuthenticatedPrincipal principal) {\n return principal.getAttribute(\"sub\") + \" is the subject\";\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/foo\")\nfun foo(@AuthenticationPrincipal principal: OAuth2AuthenticatedPrincipal): String {\n return principal.getAttribute<Any>(\"sub\").toString() + \" is the subject\"\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Looking Up Attributes Post-Authentication", "heading_level": 2, "file_order": 155, "section_index": 7, "content_hash": "9b841373690302d66890ea8aac79a62453a4c025a0f82b3e56a58ca8128dd1d2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:8bd0b78d0c596aba30e955ed3b0a7dbddf5bf5d4911d411275164007ca3e9b46", "content": "Of course, this also means that attributes can be accessed via SpEL.\n\nFor example, if using `@EnableGlobalMethodSecurity` so that you can use `@PreAuthorize` annotations, you can do:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PreAuthorize(\"principal?.attributes['sub'] == 'foo'\")\npublic String forFoosEyesOnly() {\n return \"foo\";\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PreAuthorize(\"principal?.attributes['sub'] == 'foo'\")\nfun forFoosEyesOnly(): String {\n return \"foo\"\n}\n----\n======\n\n[[oauth2resourceserver-opaque-sansboot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Looking Up Attributes Via SpEL", "heading_level": 3, "file_order": 155, "section_index": 8, "content_hash": "8bd0b78d0c596aba30e955ed3b0a7dbddf5bf5d4911d411275164007ca3e9b46", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:b8e82a4d7d83e10a10ab10ffc7deb48129e823c4c85d2fa19fcbff4f86f1e677", "content": "There are two ``@Bean``s that Spring Boot generates on Resource Server's behalf.\n\nThe first is a `SecurityFilterChain` that configures the app as a resource server.\nWhen use Opaque Token, this `SecurityFilterChain` looks like:\n\n.Default Opaque Token Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .opaqueToken(Customizer.withDefaults())\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken { }\n }\n }\n return http.build()\n}\n----\n======\n\nIf the application doesn't expose a `SecurityFilterChain` bean, then Spring Boot will expose the above default one.\n\nReplacing this is as simple as exposing the bean within the application:\n\n.Custom Opaque Token Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope;\n\n@Configuration\n@EnableWebSecurity\npublic class MyCustomSecurityConfiguration {\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/messages/**\").access(hasScope(\"message:read\"))\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .opaqueToken((opaqueToken) -> opaqueToken\n .introspector(myIntrospector())\n )\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope;\n\n@Configuration\n@EnableWebSecurity\nclass MyCustomSecurityConfiguration {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(\"/messages/**\", hasScope(\"SCOPE_message:read\"))\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken {\n introspector = myIntrospector()\n }\n }\n }\n return http.build()\n }\n}\n----\n======\n\nThe above requires the scope of `message:read` for any URL that starts with `/messages/`.\n\nMethods on the `oauth2ResourceServer` DSL will also override or replace auto configuration.\n\n[[oauth2resourceserver-opaque-introspector]]\nFor example, the second `@Bean` Spring Boot creates is an `OpaqueTokenIntrospector`, <<oauth2resourceserver-opaque-architecture-introspector,which decodes `String` tokens into validated instances of `OAuth2AuthenticatedPrincipal`>>:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic OpaqueTokenIntrospector introspector() {\n return SpringOpaqueTokenIntrospector.withIntrospectionUri(introspectionUri)\n .clientId(clientId).clientSecret(clientSecret).build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun introspector(): OpaqueTokenIntrospector {\n return SpringOpaqueTokenIntrospector.withIntrospectionUri(introspectionUri)\n .clientId(clientId).clientSecret(clientSecret).build()\n}\n----\n======\n\nIf the application doesn't expose an <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> bean, then Spring Boot will expose the above default one.\n\nAnd its configuration can be overridden using `introspectionUri()` and `introspectionClientCredentials()` or replaced using `introspector()`.\n\nIf the application doesn't expose an `OpaqueTokenAuthenticationConverter` bean, then spring-security will build `BearerTokenAuthentication`.\n\nOr, if you're not using Spring Boot at all, then all of these components - the filter chain, an <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> and an `OpaqueTokenAuthenticationConverter` can be specified in XML.\n\nThe filter chain is specified like so:\n\n.Default Opaque Token Configuration\n[tabs]\n======\nXml::\n+\n[source,xml,role=\"primary\"]\n----\n<http>\n <intercept-uri pattern=\"/**\" access=\"authenticated\"/>\n <oauth2-resource-server>\n <opaque-token introspector-ref=\"opaqueTokenIntrospector\"\n authentication-converter-ref=\"opaqueTokenAuthenticationConverter\"/>\n </oauth2-resource-server>\n</http>\n----\n======\n\nAnd the <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> like so:\n\n.Opaque Token Introspector\n[tabs]\n======\nXml::\n+\n[source,xml,role=\"primary\"]\n----\n<bean id=\"opaqueTokenIntrospector\"\n class=\"org.springframework.security.oauth2.server.resource.introspection.SpringOpaqueTokenIntrospector\">\n <constructor-arg value=\"${spring.security.oauth2.resourceserver.opaquetoken.introspection_uri}\"/>\n <constructor-arg value=\"${spring.security.oauth2.resourceserver.opaquetoken.client_id}\"/>\n <constructor-arg value=\"${spring.security.oauth2.resourceserver.opaquetoken.client_secret}\"/>\n</bean>\n----\n======\n\nAnd the `OpaqueTokenAuthenticationConverter` like so:\n\n.Opaque Token Authentication Converter\n[tabs]\n======\nXml::\n+\n[source,xml,role=\"primary\"]\n----\n<bean id=\"opaqueTokenAuthenticationConverter\"\n class=\"com.example.CustomOpaqueTokenAuthenticationConverter\"/>\n----\n======\n\n[[oauth2resourceserver-opaque-introspectionuri-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Overriding or Replacing Boot Auto Configuration", "heading_level": 2, "file_order": 155, "section_index": 9, "content_hash": "b8e82a4d7d83e10a10ab10ffc7deb48129e823c4c85d2fa19fcbff4f86f1e677", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:a1f7e56394c30d9ec0f0a759f17ff2ba1539cb7bf2c71dbf026bdccca83db601", "content": "An authorization server's Introspection Uri can be configured <<oauth2resourceserver-opaque-introspectionuri,as a configuration property>> or it can be supplied in the DSL:\n\n.Introspection URI Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class DirectlyConfiguredIntrospectionUri {\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .opaqueToken((opaqueToken) -> opaqueToken\n .introspectionUri(\"https://idp.example.com/introspect\")\n .introspectionClientCredentials(\"client\", \"secret\")\n )\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass DirectlyConfiguredIntrospectionUri {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken {\n introspectionUri = \"https://idp.example.com/introspect\"\n introspectionClientCredentials(\"client\", \"secret\")\n }\n }\n }\n return http.build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<bean id=\"opaqueTokenIntrospector\"\n class=\"org.springframework.security.oauth2.server.resource.introspection.SpringOpaqueTokenIntrospector\">\n <constructor-arg value=\"https://idp.example.com/introspect\"/>\n <constructor-arg value=\"client\"/>\n <constructor-arg value=\"secret\"/>\n</bean>\n----\n======\n\nUsing `introspectionUri()` takes precedence over any configuration property.\n\n[[oauth2resourceserver-opaque-introspector-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Using `introspectionUri()`", "heading_level": 3, "file_order": 155, "section_index": 10, "content_hash": "a1f7e56394c30d9ec0f0a759f17ff2ba1539cb7bf2c71dbf026bdccca83db601", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:5c7a344e1806bf8bdd14bf856f96e5e750248b734e7307d58e9e00e5f069eaee", "content": "More powerful than `introspectionUri()` is `introspector()`, which will completely replace any Boot auto configuration of <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>>:\n\n.Introspector Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class DirectlyConfiguredIntrospector {\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .opaqueToken((opaqueToken) -> opaqueToken\n .introspector(myCustomIntrospector())\n )\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass DirectlyConfiguredIntrospector {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken {\n introspector = myCustomIntrospector()\n }\n }\n }\n return http.build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-uri pattern=\"/**\" access=\"authenticated\"/>\n <oauth2-resource-server>\n <opaque-token introspector-ref=\"myCustomIntrospector\"/>\n </oauth2-resource-server>\n</http>\n----\n======\n\nThis is handy when deeper configuration, like <<oauth2resourceserver-opaque-authorization-extraction,authority mapping>>, <<oauth2resourceserver-opaque-jwt-introspector,JWT revocation>>, or <<oauth2resourceserver-opaque-timeouts,request timeouts>>, is necessary.\n\n[[oauth2resourceserver-opaque-introspector-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Using `introspector()`", "heading_level": 3, "file_order": 155, "section_index": 11, "content_hash": "5c7a344e1806bf8bdd14bf856f96e5e750248b734e7307d58e9e00e5f069eaee", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:415f5406b7f5bd508e19f76a386e36d52832c1b69163011f627c6e8c048b31df", "content": "Or, exposing a <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> `@Bean` has the same effect as `introspector()`:\n\n[source,java]\n----\n@Bean\npublic OpaqueTokenIntrospector introspector() {\n return return SpringOpaqueTokenIntrospector.withIntrospectionUri(introspectionUri)\n .clientId(clientId).clientSecret(clientSecret).build();\n}\n----\n\n[[oauth2resourceserver-opaque-authorization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Exposing a `OpaqueTokenIntrospector` `@Bean`", "heading_level": 3, "file_order": 155, "section_index": 12, "content_hash": "415f5406b7f5bd508e19f76a386e36d52832c1b69163011f627c6e8c048b31df", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:b07f4dff2baf2f6024a5482be12f9a8cb5df0e1d61277b47adf09caac90cae8a", "content": "An OAuth 2.0 Introspection endpoint will typically return a `scope` attribute, indicating the scopes (or authorities) it's been granted, for example:\n\n`{ ..., \"scope\" : \"messages contacts\"}`\n\nWhen this is the case, Resource Server will attempt to coerce these scopes into a list of granted authorities, prefixing each scope with the string \"SCOPE_\".\n\nThis means that to protect an endpoint or method with a scope derived from an Opaque Token, the corresponding expressions should include this prefix:\n\n.Authorization Opaque Token Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope;\n\n@Configuration\n@EnableWebSecurity\npublic class MappedAuthorities {\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorizeRequests) -> authorizeRequests\n .requestMatchers(\"/contacts/**\").access(hasScope(\"contacts\"))\n .requestMatchers(\"/messages/**\").access(hasScope(\"messages\"))\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .opaqueToken(Customizer.withDefaults())\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.core.authorization.OAuth2AuthorizationManagers.hasScope\n\n@Configuration\n@EnableWebSecurity\nclass MappedAuthorities {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(\"/contacts/**\", hasScope(\"contacts\"))\n authorize(\"/messages/**\", hasScope(\"messages\"))\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken { }\n }\n }\n return http.build()\n }\n}\n----\n\nXml::\n+\n[source,xml,role=\"secondary\"]\n----\n<http>\n <intercept-uri pattern=\"/contacts/**\" access=\"hasAuthority('SCOPE_contacts')\"/>\n <intercept-uri pattern=\"/messages/**\" access=\"hasAuthority('SCOPE_messages')\"/>\n <oauth2-resource-server>\n <opaque-token introspector-ref=\"opaqueTokenIntrospector\"/>\n </oauth2-resource-server>\n</http>\n----\n======\n\nOr similarly with method security:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@PreAuthorize(\"hasAuthority('SCOPE_messages')\")\npublic List<Message> getMessages(...) {}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@PreAuthorize(\"hasAuthority('SCOPE_messages')\")\nfun getMessages(): List<Message?> {}\n----\n======\n\n[[method-security-has-scope]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Configuring Authorization", "heading_level": 2, "file_order": 155, "section_index": 13, "content_hash": "b07f4dff2baf2f6024a5482be12f9a8cb5df0e1d61277b47adf09caac90cae8a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:98128b1754c80b9ad830ca2f8f57e6ccdc755aec71200b57a872e3747e0ebf97", "content": "Because method security expressions can evaluation `AuthorizationManager` instances, you can also use the `hasScope` API by publishing a `DefaultOAuth2AuthorizationManagerFactory` `@Bean`:\n\ninclude-code::./MethodSecurityHasScopeConfiguration[tag=declare-factory,indent=0]\n\nand then doing:\n\ninclude-code::./MessageService[tag=protected-method,indent=0]\n\nIf you are using xref:servlet/authentication/mfa.adoc[Spring Security's MFA feature], then you can supply its `AuthorizationManagerFactory` instance to ensure that your authentication factors are automatically checked as well by including it in your `DefaultOAuth2AuthorizationManagerFactory` constructor as follows:\n\ninclude-code::./MethodSecurityHasScopeMfaConfiguration[tag=declare-factory,indent=0]\n\n[[oauth2resourceserver-opaque-authorization-extraction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Using `hasScope` in Method Security", "heading_level": 3, "file_order": 155, "section_index": 14, "content_hash": "98128b1754c80b9ad830ca2f8f57e6ccdc755aec71200b57a872e3747e0ebf97", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:56b8a5801c6158c0582f70196a524814ac7e073d38b12321793be89d947d7e9b", "content": "By default, Opaque Token support will extract the scope claim from an introspection response and parse it into individual `GrantedAuthority` instances.\n\nFor example, if the introspection response were:\n\n[source,json]\n----\n{\n \"active\" : true,\n \"scope\" : \"message:read message:write\"\n}\n----\n\nThen Resource Server would generate an `Authentication` with two authorities, one for `message:read` and the other for `message:write`.\n\nThis can, of course, be customized using a custom <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> that takes a look at the attribute set and converts in its own way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class CustomAuthoritiesOpaqueTokenIntrospector implements OpaqueTokenIntrospector {\n private OpaqueTokenIntrospector delegate = SpringOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build();\n\n public OAuth2AuthenticatedPrincipal introspect(String token) {\n OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);\n return new DefaultOAuth2AuthenticatedPrincipal(\n principal.getName(), principal.getAttributes(), extractAuthorities(principal));\n }\n\n private Collection<GrantedAuthority> extractAuthorities(OAuth2AuthenticatedPrincipal principal) {\n List<String> scopes = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE);\n return scopes.stream()\n .map(SimpleGrantedAuthority::new)\n .collect(Collectors.toList());\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass CustomAuthoritiesOpaqueTokenIntrospector : OpaqueTokenIntrospector {\n private val delegate: OpaqueTokenIntrospector = SpringOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build()\n override fun introspect(token: String): OAuth2AuthenticatedPrincipal {\n val principal: OAuth2AuthenticatedPrincipal = delegate.introspect(token)\n return DefaultOAuth2AuthenticatedPrincipal(\n principal.name, principal.attributes, extractAuthorities(principal))\n }\n\n private fun extractAuthorities(principal: OAuth2AuthenticatedPrincipal): Collection<GrantedAuthority> {\n val scopes: List<String> = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE)\n return scopes\n .map { SimpleGrantedAuthority(it) }\n }\n}\n----\n======\n\nThereafter, this custom introspector can be configured simply by exposing it as a `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic OpaqueTokenIntrospector introspector() {\n return new CustomAuthoritiesOpaqueTokenIntrospector();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun introspector(): OpaqueTokenIntrospector {\n return CustomAuthoritiesOpaqueTokenIntrospector()\n}\n----\n======\n\n[[oauth2resourceserver-opaque-timeouts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Extracting Authorities Manually", "heading_level": 3, "file_order": 155, "section_index": 15, "content_hash": "56b8a5801c6158c0582f70196a524814ac7e073d38b12321793be89d947d7e9b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:2bd6dbccce0fffad1cee7fce2bec8bd683ecd4a0ec955519e17f68105d9f6a84", "content": "By default, Resource Server uses connection and socket timeouts of 30 seconds each for coordinating with the authorization server.\n\nThis may be too short in some scenarios.\nFurther, it doesn't take into account more sophisticated patterns like back-off and discovery.\n\nTo adjust the way in which Resource Server connects to the authorization server, `SpringOpaqueTokenIntrospector` accepts an instance of `RestOperations`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic OpaqueTokenIntrospector introspector(RestTemplateBuilder builder, OAuth2ResourceServerProperties properties) {\n RestOperations rest = builder\n .basicAuthentication(properties.getOpaquetoken().getClientId(), properties.getOpaquetoken().getClientSecret())\n .setConnectTimeout(Duration.ofSeconds(60))\n .setReadTimeout(Duration.ofSeconds(60))\n .build();\n\n return new SpringOpaqueTokenIntrospector(introspectionUri, rest);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun introspector(builder: RestTemplateBuilder, properties: OAuth2ResourceServerProperties): OpaqueTokenIntrospector? {\n val rest: RestOperations = builder\n .basicAuthentication(properties.opaquetoken.clientId, properties.opaquetoken.clientSecret)\n .setConnectTimeout(Duration.ofSeconds(60))\n .setReadTimeout(Duration.ofSeconds(60))\n .build()\n return SpringOpaqueTokenIntrospector(introspectionUri, rest)\n}\n----\n======\n\n[[oauth2resourceserver-opaque-jwt-introspector]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Configuring Timeouts", "heading_level": 2, "file_order": 155, "section_index": 16, "content_hash": "2bd6dbccce0fffad1cee7fce2bec8bd683ecd4a0ec955519e17f68105d9f6a84", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:4987c872a165a9efd21dfb5a9fc436a14a3e16cb23118edfd969a6add7ed927c", "content": "A common question is whether or not introspection is compatible with JWTs.\nSpring Security's Opaque Token support has been designed to not care about the format of the token -- it will gladly pass any token to the introspection endpoint provided.\n\nSo, let's say that you've got a requirement that requires you to check with the authorization server on each request, in case the JWT has been revoked.\n\nEven though you are using the JWT format for the token, your validation method is introspection, meaning you'd want to do:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n opaquetoken:\n introspection-uri: https://idp.example.org/introspection\n client-id: client\n client-secret: secret\n----\n\nIn this case, the resulting `Authentication` would be `BearerTokenAuthentication`.\nAny attributes in the corresponding `OAuth2AuthenticatedPrincipal` would be whatever was returned by the introspection endpoint.\n\nBut, let's say that, oddly enough, the introspection endpoint only returns whether or not the token is active.\nNow what?\n\nIn this case, you can create a custom <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> that still hits the endpoint, but then updates the returned principal to have the JWTs claims as the attributes:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class JwtOpaqueTokenIntrospector implements OpaqueTokenIntrospector {\n private OpaqueTokenIntrospector delegate = SpringOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build();\n private JwtDecoder jwtDecoder = new NimbusJwtDecoder(new ParseOnlyJWTProcessor());\n\n public OAuth2AuthenticatedPrincipal introspect(String token) {\n OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);\n try {\n Jwt jwt = this.jwtDecoder.decode(token);\n return new DefaultOAuth2AuthenticatedPrincipal(jwt.getClaims(), NO_AUTHORITIES);\n } catch (JwtException ex) {\n throw new OAuth2IntrospectionException(ex);\n }\n }\n\n private static class ParseOnlyJWTProcessor extends DefaultJWTProcessor<SecurityContext> {\n JWTClaimsSet process(SignedJWT jwt, SecurityContext context)\n throws JOSEException {\n return jwt.getJWTClaimsSet();\n }\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass JwtOpaqueTokenIntrospector : OpaqueTokenIntrospector {\n private val delegate: OpaqueTokenIntrospector = SpringOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build()\n private val jwtDecoder: JwtDecoder = NimbusJwtDecoder(ParseOnlyJWTProcessor())\n override fun introspect(token: String): OAuth2AuthenticatedPrincipal {\n val principal = delegate.introspect(token)\n return try {\n val jwt: Jwt = jwtDecoder.decode(token)\n DefaultOAuth2AuthenticatedPrincipal(jwt.claims, NO_AUTHORITIES)\n } catch (ex: JwtException) {\n throw OAuth2IntrospectionException(ex.message)\n }\n }\n\n private class ParseOnlyJWTProcessor : DefaultJWTProcessor<SecurityContext>() {\n override fun process(jwt: SignedJWT, context: SecurityContext): JWTClaimsSet {\n return jwt.jwtClaimsSet\n }\n }\n}\n----\n======\n\nThereafter, this custom introspector can be configured simply by exposing it as a `@Bean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic OpaqueTokenIntrospector introspector() {\n return new JwtOpaqueTokenIntrospector();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun introspector(): OpaqueTokenIntrospector {\n return JwtOpaqueTokenIntrospector()\n}\n----\n======\n\n[[oauth2resourceserver-opaque-userinfo]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Using Introspection with JWTs", "heading_level": 2, "file_order": 155, "section_index": 17, "content_hash": "4987c872a165a9efd21dfb5a9fc436a14a3e16cb23118edfd969a6add7ed927c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:0bdfd189fef67697e7c15011236e20d04cd349a094282d04e0885b14d7e983b3", "content": "Generally speaking, a Resource Server doesn't care about the underlying user, but instead about the authorities that have been granted.\n\nThat said, at times it can be valuable to tie the authorization statement back to a user.\n\nIf an application is also using `spring-security-oauth2-client`, having set up the appropriate `ClientRegistrationRepository`, then this is quite simple with a custom <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>>.\nThis implementation below does three things:\n\n* Delegates to the introspection endpoint, to affirm the token's validity\n* Looks up the appropriate client registration associated with the `/userinfo` endpoint\n* Invokes and returns the response from the `/userinfo` endpoint\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {\n private final OpaqueTokenIntrospector delegate = SpringOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build();\n private final OAuth2UserService oauth2UserService = new DefaultOAuth2UserService();\n\n private final ClientRegistrationRepository repository;\n\n // ... constructor\n\n @Override\n public OAuth2AuthenticatedPrincipal introspect(String token) {\n OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);\n Instant issuedAt = authorized.getAttribute(ISSUED_AT);\n Instant expiresAt = authorized.getAttribute(EXPIRES_AT);\n ClientRegistration clientRegistration = this.repository.findByRegistrationId(\"registration-id\");\n OAuth2AccessToken token = new OAuth2AccessToken(BEARER, token, issuedAt, expiresAt);\n OAuth2UserRequest oauth2UserRequest = new OAuth2UserRequest(clientRegistration, token);\n return this.oauth2UserService.loadUser(oauth2UserRequest);\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector {\n private val delegate: OpaqueTokenIntrospector = SpringOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build()\n private val oauth2UserService = DefaultOAuth2UserService()\n private val repository: ClientRegistrationRepository? = null\n\n // ... constructor\n\n override fun introspect(token: String): OAuth2AuthenticatedPrincipal {\n val authorized = delegate.introspect(token)\n val issuedAt: Instant? = authorized.getAttribute(ISSUED_AT)\n val expiresAt: Instant? = authorized.getAttribute(EXPIRES_AT)\n val clientRegistration: ClientRegistration = repository!!.findByRegistrationId(\"registration-id\")\n val accessToken = OAuth2AccessToken(BEARER, token, issuedAt, expiresAt)\n val oauth2UserRequest = OAuth2UserRequest(clientRegistration, accessToken)\n return oauth2UserService.loadUser(oauth2UserRequest)\n }\n}\n----\n======\n\nIf you aren't using `spring-security-oauth2-client`, it's still quite simple.\nYou will simply need to invoke the `/userinfo` with your own instance of `WebClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {\n private final OpaqueTokenIntrospector delegate = SpringOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build();\n private final WebClient rest = WebClient.create();\n\n @Override\n public OAuth2AuthenticatedPrincipal introspect(String token) {\n OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);\n return makeUserInfoRequest(authorized);\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nclass UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector {\n private val delegate: OpaqueTokenIntrospector = SpringOpaqueTokenIntrospector\n .withIntrospectionUri(\"https://idp.example.org/introspect\")\n .clientId(\"client\").clientSecret(\"secret\").build()\n private val rest: WebClient = WebClient.create()\n\n override fun introspect(token: String): OAuth2AuthenticatedPrincipal {\n val authorized = delegate.introspect(token)\n return makeUserInfoRequest(authorized)\n }\n}\n----\n======\n\nEither way, having created your <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>>, you should publish it as a `@Bean` to override the defaults:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nOpaqueTokenIntrospector introspector() {\n return new UserInfoOpaqueTokenIntrospector(...);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun introspector(): OpaqueTokenIntrospector {\n return UserInfoOpaqueTokenIntrospector(...)\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc", "title": "OAuth 2.0 Resource Server Opaque Token", "heading": "Calling a `/userinfo` Endpoint", "heading_level": 2, "file_order": 155, "section_index": 18, "content_hash": "0bdfd189fef67697e7c15011236e20d04cd349a094282d04e0885b14d7e983b3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/opaque-token.adoc"}}
{"id": "sha256:c9994b24818a9afd7a94913d06a597a5569bf508d3909ba7e2d18048cfaaa922", "content": "[[oauth2resourceserver-protected-resource-metadata]]\n\n`OAuth2ResourceServerConfigurer.ProtectedResourceMetadataConfigurer` provides the ability to customize the https://www.rfc-editor.org/rfc/rfc9728.html#section-3[OAuth 2.0 Protected Resource Metadata endpoint].\nIt defines an extension point that lets you customize the https://www.rfc-editor.org/rfc/rfc9728.html#section-3.2[OAuth 2.0 Protected Resource Metadata response].\n\n`OAuth2ResourceServerConfigurer.ProtectedResourceMetadataConfigurer` provides the following configuration option:\n\n[source,java]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n\thttp\n .oauth2ResourceServer((resourceServer) ->\n resourceServer\n .protectedResourceMetadata(protectedResourceMetadata ->\n protectedResourceMetadata\n .protectedResourceMetadataCustomizer(protectedResourceMetadataCustomizer) <1>\n )\n );\n\n\treturn http.build();\n}\n----\n<1> `protectedResourceMetadataCustomizer()`: The `Consumer` providing access to the `OAuth2ProtectedResourceMetadata.Builder` allowing the ability to customize the claims of the Resource Server's configuration.\n\n`OAuth2ResourceServerConfigurer.ProtectedResourceMetadataConfigurer` configures the `OAuth2ProtectedResourceMetadataFilter` and registers it with the Resource Server `SecurityFilterChain` `@Bean`.\n`OAuth2ProtectedResourceMetadataFilter` is the `Filter` that returns the https://www.rfc-editor.org/rfc/rfc9728.html#section-3.2[OAuth2ProtectedResourceMetadata response].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/resource-server/protected-resource-metadata.adoc", "title": "protected-resource-metadata", "heading": "protected-resource-metadata", "heading_level": 1, "file_order": 156, "section_index": 0, "content_hash": "c9994b24818a9afd7a94913d06a597a5569bf508d3909ba7e2d18048cfaaa922", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/resource-server/protected-resource-metadata.adoc"}}
{"id": "sha256:b340407f47734a6ac8e9530f4fc6ecfad3cd92aac87e7536a2baffa57fbf1a0f", "content": "Spring Security provides comprehensive OAuth 2.0 support.\nThis section discusses how to integrate OAuth 2.0 into your servlet based application.\n\n[[oauth2-overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "OAuth2", "heading_level": 1, "file_order": 157, "section_index": 0, "content_hash": "b340407f47734a6ac8e9530f4fc6ecfad3cd92aac87e7536a2baffa57fbf1a0f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:e5f74c288fc5e54a6d6b1c14d795d50f623c294288158934571a29024300551b", "content": "Spring Security's OAuth 2.0 support consists of three primary feature sets:\n\n* <<oauth2-resource-server>>\n* <<oauth2-client>>\n* xref:servlet/oauth2/authorization-server/index.adoc[OAuth2 Authorization Server]\n\n[NOTE]\n====\n<<oauth2-client-log-users-in,OAuth2 Login>> is a very powerful OAuth2 Client feature that deserves its own section in the reference documentation.\nHowever, it does not exist as a standalone feature and requires OAuth2 Client in order to function.\n====\n\nThese feature sets cover the _resource server_, _client_ and _authorization server_ roles defined in the https://tools.ietf.org/html/rfc6749#section-1.1[OAuth 2.0 Authorization Framework].\n\nThe _resource server_ and _client_ roles in OAuth2 are typically represented by one or more server-side applications.\nAdditionally, the _authorization server_ role can be represented by one or more third parties (as is the case when centralizing identity management and/or authentication within an organization) *-or-* it can be represented by an application (as is the case with the _authorization server_ feature).\n\nFor example, a typical OAuth2-based microservices architecture might consist of a single user-facing client application, several backend resource servers providing REST APIs and a third party authorization server for managing users and authentication concerns.\nIt is also common to have a single application representing only one of these roles with the need to integrate with one or more third parties that are providing the other roles.\n\nSpring Security handles these scenarios and more.\nThe following sections cover the roles provided by Spring Security and contain examples for common scenarios.\n\n[[oauth2-resource-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Overview", "heading_level": 2, "file_order": 157, "section_index": 1, "content_hash": "e5f74c288fc5e54a6d6b1c14d795d50f623c294288158934571a29024300551b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:3d22e50ac4e2232461b43eb6ebfece5dcc627b551346c57bf87e77241b2e918f", "content": "[NOTE]\n====\nThis section contains a summary of OAuth2 Resource Server features with examples.\nSee xref:servlet/oauth2/resource-server/index.adoc[OAuth 2.0 Resource Server] for complete reference documentation.\n====\n\nTo get started, add the `spring-security-oauth2-resource-server` dependency to your project.\nWhen using Spring Boot, add the following starter:\n\n.OAuth2 Resource Server with Spring Boot\n[tabs]\n======\nGradle::\n+\n[source,gradle,role=\"primary\"]\n----\nimplementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'\n----\n\nMaven::\n+\n[source,maven,role=\"secondary\"]\n----\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-oauth2-resource-server</artifactId>\n</dependency>\n----\n======\n\n[TIP]\n====\nSee xref:getting-spring-security.adoc[] for additional options when not using Spring Boot.\n====\n\nConsider the following use cases for OAuth2 Resource Server:\n\n* I want to <<oauth2-resource-server-access-token,protect access to the API using OAuth2>> (authorization server provides JWT or opaque access token)\n* I want to <<oauth2-resource-server-custom-jwt,protect access to the API using a JWT>> (custom token)\n\n[[oauth2-resource-server-access-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "OAuth2 Resource Server", "heading_level": 2, "file_order": 157, "section_index": 2, "content_hash": "3d22e50ac4e2232461b43eb6ebfece5dcc627b551346c57bf87e77241b2e918f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:22a32d0f2d3bb77d005ca1c8debc6a056e6b05c79e28c526a234dba6e508dee0", "content": "It is very common to protect access to an API using OAuth2 access tokens.\nIn most cases, Spring Security requires only minimal configuration to secure an application with OAuth2.\n\nThere are two types of `Bearer` tokens supported by Spring Security which each use a different component for validation:\n\n* <<oauth2-resource-server-access-token-jwt,JWT support>> uses a `JwtDecoder` bean to validate signatures and decode tokens\n* <<oauth2-resource-server-access-token-opaque,Opaque token support>> uses an `OpaqueTokenIntrospector` bean to introspect tokens\n\n[[oauth2-resource-server-access-token-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Protect Access with an OAuth2 Access Token", "heading_level": 3, "file_order": 157, "section_index": 3, "content_hash": "22a32d0f2d3bb77d005ca1c8debc6a056e6b05c79e28c526a234dba6e508dee0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:a8735ad5aeaf84f2dc510c6b759aa92ac9beb99d8730946a23e99b22877da745", "content": "The following example configures a `JwtDecoder` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n issuer-uri: https://my-auth-server.com\n----\n\nWhen using Spring Boot, this is all that is required.\nThe default arrangement provided by Spring Boot is equivalent to the following:\n\n.Configure Resource Server with JWTs\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt(Customizer.withDefaults())\n );\n return http.build();\n\t}\n\n\t@Bean\n\tpublic JwtDecoder jwtDecoder() {\n return JwtDecoders.fromIssuerLocation(\"https://my-auth-server.com\");\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n jwt { }\n }\n }\n\n return http.build()\n\t}\n\n\t@Bean\n\tfun jwtDecoder(): JwtDecoder {\n return JwtDecoders.fromIssuerLocation(\"https://my-auth-server.com\")\n\t}\n\n}\n----\n=====\n\n[[oauth2-resource-server-access-token-opaque]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "JWT Support", "heading_level": 4, "file_order": 157, "section_index": 4, "content_hash": "a8735ad5aeaf84f2dc510c6b759aa92ac9beb99d8730946a23e99b22877da745", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:7e585b0488f832596a827dbcf65151881c1b5801a62267624af3276c16da8d45", "content": "The following example configures an `OpaqueTokenIntrospector` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n opaquetoken:\n introspection-uri: https://my-auth-server.com/oauth2/introspect\n client-id: my-client-id\n client-secret: my-client-secret\n----\n\nWhen using Spring Boot, this is all that is required.\nThe default arrangement provided by Spring Boot is equivalent to the following:\n\n.Configure Resource Server with Opaque Tokens\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .opaqueToken(Customizer.withDefaults())\n );\n return http.build();\n\t}\n\n\t@Bean\n\tpublic OpaqueTokenIntrospector opaqueTokenIntrospector() {\n return new SpringOpaqueTokenIntrospector(\n \"https://my-auth-server.com/oauth2/introspect\", \"my-client-id\", \"my-client-secret\");\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n opaqueToken { }\n }\n }\n\n return http.build()\n\t}\n\n\t@Bean\n\tfun opaqueTokenIntrospector(): OpaqueTokenIntrospector {\n return SpringOpaqueTokenIntrospector(\n \"https://my-auth-server.com/oauth2/introspect\", \"my-client-id\", \"my-client-secret\"\n )\n\t}\n\n}\n----\n=====\n\n[[oauth2-resource-server-custom-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Opaque Token Support", "heading_level": 4, "file_order": 157, "section_index": 5, "content_hash": "7e585b0488f832596a827dbcf65151881c1b5801a62267624af3276c16da8d45", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:2cb63a26568341c8e3f70da549c9e5e7be2721d4e7353978d7f0e571d4e336c6", "content": "It is a fairly common goal to protect access to an API using JWTs, particularly when the frontend is developed as a single-page application.\nThe OAuth2 Resource Server support in Spring Security can be used for any type of `Bearer` token, including a custom JWT.\n\nAll that is required to protect an API using JWTs is a `JwtDecoder` bean, which is used to validate signatures and decode tokens.\nSpring Security will automatically use the provided bean to configure protection within the `SecurityFilterChain`.\n\nThe following example configures a `JwtDecoder` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n resourceserver:\n jwt:\n public-key-location: classpath:my-public-key.pub\n----\n\n[NOTE]\n====\nYou can provide the public key as a classpath resource (called `my-public-key.pub` in this example).\n====\n\nWhen using Spring Boot, this is all that is required.\nThe default arrangement provided by Spring Boot is equivalent to the following:\n\n.Configure Resource Server with Custom JWTs\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2ResourceServer((oauth2) -> oauth2\n .jwt(Customizer.withDefaults())\n );\n return http.build();\n\t}\n\n\t@Bean\n\tpublic JwtDecoder jwtDecoder() {\n return NimbusJwtDecoder.withPublicKey(publicKey()).build();\n\t}\n\n\tprivate RSAPublicKey publicKey() {\n // ...\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2ResourceServer {\n jwt { }\n }\n }\n\n return http.build()\n\t}\n\n\t@Bean\n\tfun jwtDecoder(): JwtDecoder {\n return NimbusJwtDecoder.withPublicKey(publicKey()).build()\n\t}\n\n\tprivate fun publicKey(): RSAPublicKey {\n // ...\n\t}\n\n}\n----\n=====\n\n[NOTE]\n====\nSpring Security does not provide an endpoint for minting tokens.\nHowever, Spring Security does provide the `JwtEncoder` interface along with one implementation, which is `NimbusJwtEncoder`.\n====\n\n[[oauth2-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Protect Access with a custom JWT", "heading_level": 3, "file_order": 157, "section_index": 6, "content_hash": "2cb63a26568341c8e3f70da549c9e5e7be2721d4e7353978d7f0e571d4e336c6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:edc85cbd66cbdef9e652cebc2c4ff75da401c7d70e643ef97a2c0a3c6e53ea7b", "content": "[NOTE]\n====\nThis section contains a summary of OAuth2 Client features with examples.\nSee xref:servlet/oauth2/client/index.adoc[OAuth 2.0 Client] and xref:servlet/oauth2/login/index.adoc[OAuth 2.0 Login] for complete reference documentation.\n====\n\nTo get started, add the `spring-security-oauth2-client` dependency to your project.\nWhen using Spring Boot, add the following starter:\n\n.OAuth2 Client with Spring Boot\n[tabs]\n======\nGradle::\n+\n[source,gradle,role=\"primary\"]\n----\nimplementation 'org.springframework.boot:spring-boot-starter-oauth2-client'\n----\n\nMaven::\n+\n[source,maven,role=\"secondary\"]\n----\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-oauth2-client</artifactId>\n</dependency>\n----\n======\n\n[TIP]\n====\nSee xref:getting-spring-security.adoc[] for additional options when not using Spring Boot.\n====\n\nConsider the following use cases for OAuth2 Client:\n\n* I want to <<oauth2-client-log-users-in,log users in using OAuth 2.0 or OpenID Connect 1.0>>\n* I want to <<oauth2-client-access-protected-resources,use `RestClient` to obtain an access token for users>> in order to access a third-party API\n* I want to <<oauth2-client-access-protected-resources-webclient,use `WebClient` to obtain an access token for users>> in order to access a third-party API\n* I want to <<oauth2-client-access-protected-resources-current-user,do both>> (log users in _and_ access a third-party API)\n* I want to <<oauth2-client-client-credentials,use the `client_credentials` grant type>> to obtain a single token per application\n* I want to <<oauth2-client-enable-extension-grant-type,enable an extension grant type>>\n* I want to <<oauth2-client-customize-existing-grant-type,customize an existing grant type>>\n* I want to <<oauth2-client-customize-request-parameters,customize token request parameters>>\n* I want to <<oauth2-client-customize-rest-client,customize the `RestClient` used by OAuth2 Client components>>\n\n[[oauth2-client-log-users-in]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "OAuth2 Client", "heading_level": 2, "file_order": 157, "section_index": 7, "content_hash": "edc85cbd66cbdef9e652cebc2c4ff75da401c7d70e643ef97a2c0a3c6e53ea7b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:59ea07887ff13e4418fa1d1677648bafc0324c22fa986e0f87f7a6aa9d81aa34", "content": "It is very common to require users to log in via OAuth2.\nhttps://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect 1.0] provides a special token called the `id_token` which is designed to provide an OAuth2 Client with the ability to perform user identity verification and log users in.\nIn certain cases, OAuth2 can be used directly to log users in (as is the case with popular social login providers that do not implement OpenID Connect such as GitHub and Facebook).\n\nThe following example configures the application to act as an OAuth2 Client capable of logging users in with OAuth2 or OpenID Connect:\n\n.Configure OAuth2 Login\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .oauth2Login(Customizer.withDefaults());\n return http.build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n oauth2Login { }\n }\n\n return http.build()\n\t}\n\n}\n----\n=====\n\nIn addition to the above configuration, the application requires at least one `ClientRegistration` to be configured through the use of a `ClientRegistrationRepository` bean.\nThe following example configures an `InMemoryClientRegistrationRepository` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n my-oidc-client:\n provider: my-oidc-provider\n client-id: my-client-id\n client-secret: my-client-secret\n authorization-grant-type: authorization_code\n scope: openid,profile\n provider:\n my-oidc-provider:\n issuer-uri: https://my-oidc-provider.com\n----\n\nWith the above configuration, the application now supports two additional endpoints:\n\n1. The login endpoint (e.g. `/oauth2/authorization/my-oidc-client`) is used to initiate login and perform a redirect to the third party authorization server.\n2. The redirection endpoint (e.g. `/login/oauth2/code/my-oidc-client`) is used by the authorization server to redirect back to the client application, and will contain a `code` parameter used to obtain an `id_token` and/or `access_token` via the access token request.\n\n[NOTE]\n====\nThe presence of the `openid` scope in the above configuration indicates that OpenID Connect 1.0 should be used.\nThis instructs Spring Security to use OIDC-specific components (such as `OidcUserService`) during request processing.\nWithout this scope, Spring Security will use OAuth2-specific components (such as `DefaultOAuth2UserService`) instead.\n====\n\n[[oauth2-client-access-protected-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Log Users In with OAuth2", "heading_level": 3, "file_order": 157, "section_index": 8, "content_hash": "59ea07887ff13e4418fa1d1677648bafc0324c22fa986e0f87f7a6aa9d81aa34", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:eea957f8f2761c1083509addfd3f0af84615eeadfae9bcb7dc39d2affca2b026", "content": "Making requests to a third party API that is protected by OAuth2 is a core use case of OAuth2 Client.\nThis is accomplished by authorizing a client (represented by the `OAuth2AuthorizedClient` class in Spring Security) and accessing protected resources by placing a `Bearer` token in the `Authorization` header of an outbound request.\n\nThe following example configures the application to act as an OAuth2 Client capable of requesting protected resources from a third party API:\n\n.Configure OAuth2 Client\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .oauth2Client(Customizer.withDefaults());\n return http.build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n oauth2Client { }\n }\n\n return http.build()\n\t}\n\n}\n----\n=====\n\n[NOTE]\n====\nThe above example does not provide a way to log users in.\nYou can use any other login mechanism (such as `formLogin()`).\nSee the <<oauth2-client-access-protected-resources-current-user,next section>> for an example combining `oauth2Client()` with `oauth2Login()`.\n====\n\nIn addition to the above configuration, the application requires at least one `ClientRegistration` to be configured through the use of a `ClientRegistrationRepository` bean.\nThe following example configures an `InMemoryClientRegistrationRepository` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n my-oauth2-client:\n provider: my-auth-server\n client-id: my-client-id\n client-secret: my-client-secret\n authorization-grant-type: authorization_code\n scope: message.read,message.write\n provider:\n my-auth-server:\n issuer-uri: https://my-auth-server.com\n----\n\nIn addition to configuring Spring Security to support OAuth2 Client features, you will also need to decide how you will be accessing protected resources and configure your application accordingly.\nSpring Security provides implementations of `OAuth2AuthorizedClientManager` for obtaining access tokens that can be used to access protected resources.\n\n[TIP]\n====\nSpring Security registers a default `OAuth2AuthorizedClientManager` bean for you when one does not exist.\n====\n\nThe easiest way to use an `OAuth2AuthorizedClientManager` is via a `ClientHttpRequestInterceptor` that intercepts requests through a `RestClient`, which is already available when `spring-web` is on the classpath.\n\nThe following example uses the default `OAuth2AuthorizedClientManager` to configure a `RestClient` capable of accessing protected resources by placing `Bearer` tokens in the `Authorization` header of each request:\n\n.Configure `RestClient` with `ClientHttpRequestInterceptor`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class RestClientConfig {\n\n\t@Bean\n\tpublic RestClient restClient(OAuth2AuthorizedClientManager authorizedClientManager) {\n OAuth2ClientHttpRequestInterceptor requestInterceptor =\n new OAuth2ClientHttpRequestInterceptor(authorizedClientManager);\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass RestClientConfig {\n\n\t@Bean\n\tfun restClient(authorizedClientManager: OAuth2AuthorizedClientManager): RestClient {\n val requestInterceptor = OAuth2ClientHttpRequestInterceptor(authorizedClientManager)\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build()\n\t}\n\n}\n----\n=====\n\nThis configured `RestClient` can be used as in the following example:\n\n[[oauth2-client-accessing-protected-resources-example]]\n.Use `RestClient` to Access Protected Resources\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.client.web.client.RequestAttributeClientRegistrationIdResolver.clientRegistrationId;\n\n@RestController\npublic class MessagesController {\n\n\tprivate final RestClient restClient;\n\n\tpublic MessagesController(RestClient restClient) {\n this.restClient = restClient;\n\t}\n\n\t@GetMapping(\"/messages\")\n\tpublic ResponseEntity<List<Message>> messages() {\n Message[] messages = this.restClient.get()\n .uri(\"http://localhost:8090/messages\")\n .attributes(clientRegistrationId(\"my-oauth2-client\"))\n .retrieve()\n .body(Message[].class);\n return ResponseEntity.ok(Arrays.asList(messages));\n\t}\n\n\tpublic record Message(String message) {\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.client.web.client.RequestAttributeClientRegistrationIdResolver.clientRegistrationId\nimport org.springframework.web.client.body\n\n@RestController\nclass MessagesController(private val restClient: RestClient) {\n\n\t@GetMapping(\"/messages\")\n\tfun messages(): ResponseEntity<List<Message>> {\n val messages = restClient.get()\n .uri(\"http://localhost:8090/messages\")\n .attributes(clientRegistrationId(\"my-oauth2-client\"))\n .retrieve()\n .body<Array<Message>>()!!\n .toList()\n return ResponseEntity.ok(messages)\n\t}\n\n\tdata class Message(val message: String)\n\n}\n----\n=====\n\n[[oauth2-client-access-protected-resources-webclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Access Protected Resources", "heading_level": 3, "file_order": 157, "section_index": 9, "content_hash": "eea957f8f2761c1083509addfd3f0af84615eeadfae9bcb7dc39d2affca2b026", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:3d6be669803e7c832549d4beaad41b40d9dd119ea7845a307ca79b639d1001ea", "content": "Making requests to a third party API that is protected by OAuth2 is a core use case of OAuth2 Client.\nThis is accomplished by authorizing a client (represented by the `OAuth2AuthorizedClient` class in Spring Security) and accessing protected resources by placing a `Bearer` token in the `Authorization` header of an outbound request.\n\nThe following example configures the application to act as an OAuth2 Client capable of requesting protected resources from a third party API:\n\n.Configure OAuth2 Client\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .oauth2Client(Customizer.withDefaults());\n return http.build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n oauth2Client { }\n }\n\n return http.build()\n\t}\n\n}\n----\n=====\n\n[NOTE]\n====\nThe above example does not provide a way to log users in.\nYou can use any other login mechanism (such as `formLogin()`).\nSee the <<oauth2-client-access-protected-resources-current-user,previous section>> for an example combining `oauth2Client()` with `oauth2Login()`.\n====\n\nIn addition to the above configuration, the application requires at least one `ClientRegistration` to be configured through the use of a `ClientRegistrationRepository` bean.\nThe following example configures an `InMemoryClientRegistrationRepository` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n my-oauth2-client:\n provider: my-auth-server\n client-id: my-client-id\n client-secret: my-client-secret\n authorization-grant-type: authorization_code\n scope: message.read,message.write\n provider:\n my-auth-server:\n issuer-uri: https://my-auth-server.com\n----\n\nIn addition to configuring Spring Security to support OAuth2 Client features, you will also need to decide how you will be accessing protected resources and configure your application accordingly.\nSpring Security provides implementations of `OAuth2AuthorizedClientManager` for obtaining access tokens that can be used to access protected resources.\n\n[TIP]\n====\nSpring Security registers a default `OAuth2AuthorizedClientManager` bean for you when one does not exist.\n====\n\n<<oauth2-client-access-protected-resources,Instead of configuring a `RestClient`>>, another way to use an `OAuth2AuthorizedClientManager` is via an `ExchangeFilterFunction` that intercepts requests through a `WebClient`.\nTo use `WebClient`, you will need to add the `spring-webflux` dependency along with a reactive client implementation:\n\n.Add Spring WebFlux Dependency\n[tabs]\n======\nGradle::\n+\n[source,gradle,role=\"primary\"]\n----\nimplementation 'org.springframework:spring-webflux'\nimplementation 'io.projectreactor.netty:reactor-netty'\n----\n\nMaven::\n+\n[source,maven,role=\"secondary\"]\n----\n<dependency>\n\t<groupId>org.springframework</groupId>\n\t<artifactId>spring-webflux</artifactId>\n</dependency>\n<dependency>\n\t<groupId>io.projectreactor.netty</groupId>\n\t<artifactId>reactor-netty</artifactId>\n</dependency>\n----\n======\n\nThe following example uses the default `OAuth2AuthorizedClientManager` to configure a `WebClient` capable of accessing protected resources by placing `Bearer` tokens in the `Authorization` header of each request:\n\n.Configure `WebClient` with `ExchangeFilterFunction`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class WebClientConfig {\n\n\t@Bean\n\tpublic WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {\n ServletOAuth2AuthorizedClientExchangeFilterFunction filter =\n new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);\n return WebClient.builder()\n .apply(filter.oauth2Configuration())\n .build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass WebClientConfig {\n\n\t@Bean\n\tfun webClient(authorizedClientManager: OAuth2AuthorizedClientManager): WebClient {\n val filter = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)\n return WebClient.builder()\n .apply(filter.oauth2Configuration())\n .build()\n\t}\n\n}\n----\n=====\n\nThis configured `WebClient` can be used as in the following example:\n\n.Use `WebClient` to Access Protected Resources\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.client.web.reactive.function.client.ServletOAuth2AuthorizedClientExchangeFilterFunction.clientRegistrationId;\n\n@RestController\npublic class MessagesController {\n\n\tprivate final WebClient webClient;\n\n\tpublic MessagesController(WebClient webClient) {\n this.webClient = webClient;\n\t}\n\n\t@GetMapping(\"/messages\")\n\tpublic ResponseEntity<List<Message>> messages() {\n return this.webClient.get()\n .uri(\"http://localhost:8090/messages\")\n .attributes(clientRegistrationId(\"my-oauth2-client\"))\n .retrieve()\n .toEntityList(Message.class)\n .block();\n\t}\n\n\tpublic record Message(String message) {\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.client.web.reactive.function.client.ServletOAuth2AuthorizedClientExchangeFilterFunction.clientRegistrationId\n\n@RestController\nclass MessagesController(private val webClient: WebClient) {\n\n\t@GetMapping(\"/messages\")\n\tfun messages(): ResponseEntity<List<Message>> {\n return webClient.get()\n .uri(\"http://localhost:8090/messages\")\n .attributes(clientRegistrationId(\"my-oauth2-client\"))\n .retrieve()\n .toEntityList<Message>()\n .block()!!\n\t}\n\n\tdata class Message(val message: String)\n\n}\n----\n=====\n\n[[oauth2-client-access-protected-resources-current-user]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Access Protected Resources with `WebClient`", "heading_level": 3, "file_order": 157, "section_index": 10, "content_hash": "3d6be669803e7c832549d4beaad41b40d9dd119ea7845a307ca79b639d1001ea", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:25c7a9fd2ecc15a860a6100805cf1760c34da7becc647b71aa0948748e6bf59e", "content": "When a user is logged in via OAuth2 or OpenID Connect, the authorization server may provide an access token that can be used directly to access protected resources.\nThis is convenient because it only requires a single `ClientRegistration` to be configured for both use cases simultaneously.\n\n[NOTE]\n====\nThis section combines <<oauth2-client-log-users-in>> and <<oauth2-client-access-protected-resources>> into a single configuration.\nOther advanced scenarios exist, such as configuring one `ClientRegistration` for login and another for accessing protected resources.\nAll such scenarios would use the same basic configuration.\n====\n\nThe following example configures the application to act as an OAuth2 Client capable of logging the user in _and_ requesting protected resources from a third party API:\n\n.Configure OAuth2 Login and OAuth2 Client\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .oauth2Login(Customizer.withDefaults())\n .oauth2Client(Customizer.withDefaults());\n return http.build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n // ...\n oauth2Login { }\n oauth2Client { }\n }\n\n return http.build()\n\t}\n\n}\n----\n=====\n\nIn addition to the above configuration, the application requires at least one `ClientRegistration` to be configured through the use of a `ClientRegistrationRepository` bean.\nThe following example configures an `InMemoryClientRegistrationRepository` bean using Spring Boot configuration properties:\n\n[source,yaml]\n----\nspring:\n security:\n oauth2:\n client:\n registration:\n my-combined-client:\n provider: my-auth-server\n client-id: my-client-id\n client-secret: my-client-secret\n authorization-grant-type: authorization_code\n scope: openid,profile,message.read,message.write\n provider:\n my-auth-server:\n issuer-uri: https://my-auth-server.com\n----\n\n[NOTE]\n====\nThe main difference between the previous examples (<<oauth2-client-log-users-in>>, <<oauth2-client-access-protected-resources>>) and this one is what is configured via the `scope` property, which combines the standard scopes `openid` and `profile` with the custom scopes `message.read` and `message.write`.\n====\n\nIn addition to configuring Spring Security to support OAuth2 Client features, you will also need to decide how you will be accessing protected resources and configure your application accordingly.\nSpring Security provides implementations of `OAuth2AuthorizedClientManager` for obtaining access tokens that can be used to access protected resources.\n\n[TIP]\n====\nSpring Security registers a default `OAuth2AuthorizedClientManager` bean for you when one does not exist.\n====\n\nThe easiest way to use an `OAuth2AuthorizedClientManager` is via a `ClientHttpRequestInterceptor` that intercepts requests through a `RestClient`, which is already available when `spring-web` is on the classpath.\n\nThe following example uses the default `OAuth2AuthorizedClientManager` to configure a `RestClient` capable of accessing protected resources by placing `Bearer` tokens in the `Authorization` header of each request:\n\n.Configure `RestClient` with `ClientHttpRequestInterceptor`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class RestClientConfig {\n\n\t@Bean\n\tpublic RestClient restClient(OAuth2AuthorizedClientManager authorizedClientManager) {\n OAuth2ClientHttpRequestInterceptor requestInterceptor =\n new OAuth2ClientHttpRequestInterceptor(authorizedClientManager);\n requestInterceptor.setClientRegistrationIdResolver(clientRegistrationIdResolver());\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build();\n\t}\n\n\tprivate static ClientRegistrationIdResolver clientRegistrationIdResolver() {\n return (request) -> {\n Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n return (authentication instanceof OAuth2AuthenticationToken principal)\n ? principal.getAuthorizedClientRegistrationId()\n : null;\n };\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass RestClientConfig {\n\n\t@Bean\n\tfun restClient(authorizedClientManager: OAuth2AuthorizedClientManager): RestClient {\n val requestInterceptor = OAuth2ClientHttpRequestInterceptor(authorizedClientManager)\n requestInterceptor.setClientRegistrationIdResolver(clientRegistrationIdResolver())\n\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build()\n\t}\n\n\tprivate fun clientRegistrationIdResolver(): OAuth2ClientHttpRequestInterceptor.ClientRegistrationIdResolver {\n return OAuth2ClientHttpRequestInterceptor.ClientRegistrationIdResolver { request ->\n val authentication = SecurityContextHolder.getContext().authentication\n if (authentication is OAuth2AuthenticationToken) {\n authentication.authorizedClientRegistrationId\n } else {\n null\n }\n }\n\t}\n\n}\n----\n=====\n\nThis configured `RestClient` can be used as in the following example:\n\n[[oauth2-client-accessing-protected-resources-current-user-example]]\n.Use `RestClient` to Access Protected Resources (Current User)\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@RestController\npublic class MessagesController {\n\n\tprivate final RestClient restClient;\n\n\tpublic MessagesController(RestClient restClient) {\n this.restClient = restClient;\n\t}\n\n\t@GetMapping(\"/messages\")\n\tpublic ResponseEntity<List<Message>> messages() {\n Message[] messages = this.restClient.get()\n .uri(\"http://localhost:8090/messages\")\n .retrieve()\n .body(Message[].class);\n return ResponseEntity.ok(Arrays.asList(messages));\n\t}\n\n\tpublic record Message(String message) {\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.web.client.body\n\n@RestController\nclass MessagesController(private val restClient: RestClient) {\n\n\t@GetMapping(\"/messages\")\n\tfun messages(): ResponseEntity<List<Message>> {\n val messages = restClient.get()\n .uri(\"http://localhost:8090/messages\")\n .retrieve()\n .body<Array<Message>>()!!\n .toList()\n return ResponseEntity.ok(messages)\n\t}\n\n\tdata class Message(val message: String)\n\n}\n----\n=====\n\n[NOTE]\n====\nUnlike the <<oauth2-client-accessing-protected-resources-example,previous example>>, notice that we do not need to tell Spring Security about the `clientRegistrationId` we'd like to use.\nThis is because it can be derived from the currently logged in user.\n====\n\n[[oauth2-client-client-credentials]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Access Protected Resources for the Current User", "heading_level": 3, "file_order": 157, "section_index": 11, "content_hash": "25c7a9fd2ecc15a860a6100805cf1760c34da7becc647b71aa0948748e6bf59e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:67bbf4b18843e9305825588771a6e9e58d2075530e1fd88d7a16860fdfa6dc3a", "content": "[NOTE]\n====\nThis section focuses on additional considerations for the client credentials grant type.\nSee <<oauth2-client-access-protected-resources>> for general setup and usage with all grant types.\n====\n\nThe https://tools.ietf.org/html/rfc6749#section-1.3.4[client credentials grant] allows a client to obtain an `access_token` on behalf of itself.\nThe client credentials grant is a simple flow that does not involve a resource owner (i.e. a user).\n\n[WARNING]\n====\nIt is important to note that typical use of the client credentials grant implies that any request (or user) can potentially obtain an access token and make protected resources requests to a resource server.\nExercise caution when designing applications to ensure that users cannot make unauthorized requests since every request will be able to obtain an access token.\n====\n\nWhen obtaining access tokens within a web application where users can log in, the default behavior of Spring Security is to obtain an access token per user.\n\n[NOTE]\n====\nBy default, access tokens are scoped to the principal name of the current user which means every user will receive a unique access token.\n====\n\nClients using the client credentials grant typically require access tokens to be scoped to the application instead of to individual users so there is only one access token per application.\nIn order to scope access tokens to the application, you will need to set a strategy for resolving a custom principal name.\nThe following example does this by configuring a `RestClient` with the `RequestAttributePrincipalResolver`:\n\n.Configure `RestClient` for `client_credentials`\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class RestClientConfig {\n\n\t@Bean\n\tpublic RestClient restClient(OAuth2AuthorizedClientManager authorizedClientManager) {\n OAuth2ClientHttpRequestInterceptor requestInterceptor =\n new OAuth2ClientHttpRequestInterceptor(authorizedClientManager);\n requestInterceptor.setPrincipalResolver(new RequestAttributePrincipalResolver());\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass RestClientConfig {\n\n\t@Bean\n\tfun restClient(authorizedClientManager: OAuth2AuthorizedClientManager): RestClient {\n val requestInterceptor = OAuth2ClientHttpRequestInterceptor(authorizedClientManager)\n requestInterceptor.setPrincipalResolver(RequestAttributePrincipalResolver())\n return RestClient.builder()\n .requestInterceptor(requestInterceptor)\n .build()\n\t}\n\n}\n----\n=====\n\nWith the above configuration in place, a principal name can be specified for each request.\nThe following example demonstrates how to scope access tokens to the application by specifying a principal name:\n\n.Scope Access Tokens to the Application\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.oauth2.client.web.client.RequestAttributeClientRegistrationIdResolver.clientRegistrationId;\nimport static org.springframework.security.oauth2.client.web.client.RequestAttributePrincipalResolver.principal;\n\n@RestController\npublic class MessagesController {\n\n\tprivate final RestClient restClient;\n\n\tpublic MessagesController(RestClient restClient) {\n this.restClient = restClient;\n\t}\n\n\t@GetMapping(\"/messages\")\n\tpublic ResponseEntity<List<Message>> messages() {\n Message[] messages = this.restClient.get()\n .uri(\"http://localhost:8090/messages\")\n .attributes(clientRegistrationId(\"my-oauth2-client\"))\n .attributes(principal(\"my-application\"))\n .retrieve()\n .body(Message[].class);\n return ResponseEntity.ok(Arrays.asList(messages));\n\t}\n\n\tpublic record Message(String message) {\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.oauth2.client.web.client.RequestAttributeClientRegistrationIdResolver.clientRegistrationId\nimport org.springframework.security.oauth2.client.web.client.RequestAttributePrincipalResolver.principal\nimport org.springframework.web.client.body\n\n@RestController\nclass MessagesController(private val restClient: RestClient) {\n\n\t@GetMapping(\"/messages\")\n\tfun messages(): ResponseEntity<List<Message>> {\n val messages = restClient.get()\n .uri(\"http://localhost:8090/messages\")\n .attributes(clientRegistrationId(\"my-oauth2-client\"))\n .attributes(principal(\"my-application\"))\n .retrieve()\n .body<Array<Message>>()!!\n .toList()\n return ResponseEntity.ok(messages)\n\t}\n\n\tdata class Message(val message: String)\n\n}\n----\n=====\n\n[NOTE]\n====\nWhen specifying a principal name via attributes as in the above example, there will only be a single access token and it will be used for all requests.\n====\n\n[[oauth2-client-enable-extension-grant-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Use the Client Credentials Grant", "heading_level": 3, "file_order": 157, "section_index": 12, "content_hash": "67bbf4b18843e9305825588771a6e9e58d2075530e1fd88d7a16860fdfa6dc3a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:296b10eaa6cbeaad55ae35dd7da5cd7d9074800ccc24b967de3760d2ad8fe6a0", "content": "A common use case involves enabling and/or configuring an extension grant type.\nFor example, Spring Security provides support for the `jwt-bearer` and `token-exchange` grant types, but does not enable them by default because they are not part of the core OAuth 2.0 specification.\n\nWith Spring Security 6.2 and later, we can simply publish a bean for one or more `OAuth2AuthorizedClientProvider` and they will be picked up automatically.\nThe following example simply enables the `jwt-bearer` grant type:\n\n.Enable `jwt-bearer` Grant Type\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic OAuth2AuthorizedClientProvider jwtBearer() {\n return new JwtBearerOAuth2AuthorizedClientProvider();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun jwtBearer(): OAuth2AuthorizedClientProvider {\n return JwtBearerOAuth2AuthorizedClientProvider()\n\t}\n\n}\n----\n=====\n\nA default `OAuth2AuthorizedClientManager` will be published automatically by Spring Security when one is not already provided.\n\n[TIP]\n====\nAny custom `OAuth2AuthorizedClientProvider` bean will also be picked up and applied to the provided `OAuth2AuthorizedClientManager` after the default grant types.\n====\n\nIn order to achieve the above configuration prior to Spring Security 6.2, we had to publish this bean ourselves and ensure we re-enabled default grant types as well.\nTo understand what is being configured behind the scenes, here's what the configuration might have looked like:\n\n.Enable `jwt-bearer` Grant Type (prior to 6.2)\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic OAuth2AuthorizedClientManager authorizedClientManager(\n ClientRegistrationRepository clientRegistrationRepository,\n OAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n OAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .provider(new JwtBearerOAuth2AuthorizedClientProvider())\n .build();\n\n DefaultOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n return authorizedClientManager;\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun authorizedClientManager(\n clientRegistrationRepository: ClientRegistrationRepository,\n authorizedClientRepository: OAuth2AuthorizedClientRepository\n\t): OAuth2AuthorizedClientManager {\n val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken()\n .clientCredentials()\n .provider(JwtBearerOAuth2AuthorizedClientProvider())\n .build()\n\n val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository\n )\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n\n return authorizedClientManager\n\t}\n\n}\n----\n=====\n\n[[oauth2-client-customize-existing-grant-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Enable an Extension Grant Type", "heading_level": 3, "file_order": 157, "section_index": 13, "content_hash": "296b10eaa6cbeaad55ae35dd7da5cd7d9074800ccc24b967de3760d2ad8fe6a0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:56012aaab33407105365a4773249975fbc519c7d32b1a379a63326911a304512", "content": "The ability to <<oauth2-client-enable-extension-grant-type,enable extension grant types>> by publishing a bean also provides the opportunity for customizing an existing grant type without the need to re-define the defaults.\nFor example, if we want to customize the clock skew of the `OAuth2AuthorizedClientProvider` for the `client_credentials` grant, we can simply publish a bean like so:\n\n.Customize Client Credentials Grant Type\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic OAuth2AuthorizedClientProvider clientCredentials() {\n ClientCredentialsOAuth2AuthorizedClientProvider authorizedClientProvider =\n new ClientCredentialsOAuth2AuthorizedClientProvider();\n authorizedClientProvider.setClockSkew(Duration.ofMinutes(5));\n\n return authorizedClientProvider;\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun clientCredentials(): OAuth2AuthorizedClientProvider {\n val authorizedClientProvider = ClientCredentialsOAuth2AuthorizedClientProvider()\n authorizedClientProvider.setClockSkew(Duration.ofMinutes(5))\n return authorizedClientProvider\n\t}\n\n}\n----\n=====\n\n[[oauth2-client-customize-request-parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Customize an Existing Grant Type", "heading_level": 3, "file_order": 157, "section_index": 14, "content_hash": "56012aaab33407105365a4773249975fbc519c7d32b1a379a63326911a304512", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:c5cbd6bf6f838f72cfab8aa997c8fbc37cbe0f601ebc775140b1da80ed71c454", "content": "The need to customize request parameters when obtaining an access token is fairly common.\nFor example, let's say we want to add a custom `audience` parameter to the token request because the provider requires this parameter for the `authorization_code` grant.\n\nWith Spring Security 6.2 and later, we can simply publish a bean of type `OAuth2AccessTokenResponseClient` with the generic type `OAuth2AuthorizationCodeGrantRequest` and it will be used by Spring Security to configure OAuth2 Client components.\n\nThe following example customizes token request parameters for the `authorization_code` grant without the DSL:\n\n.Customize Token Request Parameters for Authorization Code Grant\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() {\n RestClientAuthorizationCodeTokenResponseClient accessTokenResponseClient =\n new RestClientAuthorizationCodeTokenResponseClient();\n accessTokenResponseClient.addParametersConverter(parametersConverter());\n\n return accessTokenResponseClient;\n\t}\n\n\tprivate static Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> parametersConverter() {\n return (grantRequest) -> {\n MultiValueMap<String, String> parameters = new LinkedMultiValueMap<>();\n parameters.set(\"audience\", \"xyz_value\");\n\n return parameters;\n };\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun authorizationCodeAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {\n val accessTokenResponseClient = RestClientAuthorizationCodeTokenResponseClient()\n accessTokenResponseClient.addParametersConverter(parametersConverter())\n\n return accessTokenResponseClient\n\t}\n\n\tprivate fun parametersConverter(): Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> {\n return Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> { grantRequest ->\n LinkedMultiValueMap<String, String>().also { parameters ->\n parameters[\"audience\"] = \"xyz_value\"\n }\n }\n\t}\n\n}\n----\n=====\n\n[TIP]\n====\nNotice that we don't need to customize the `SecurityFilterChain` bean in this case, and can stick with the defaults.\nIf using Spring Boot with no additional customizations, we can actually omit the `SecurityFilterChain` bean entirely.\n====\n\nPrior to Spring Security 6.2, we had to ensure that this customization was applied for both OAuth2 Login (if we are using this feature) and OAuth2 Client components using the Spring Security DSL.\nTo understand what is being configured behind the scenes, here's what the configuration might have looked like:\n\n.Customize Token Request Parameters for Authorization Code Grant (prior to 6.2)\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n RestClientAuthorizationCodeTokenResponseClient accessTokenResponseClient =\n new RestClientAuthorizationCodeTokenResponseClient();\n accessTokenResponseClient.addParametersConverter(parametersConverter());\n\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .oauth2Login((oauth2Login) -> oauth2Login\n .tokenEndpoint((tokenEndpoint) -> tokenEndpoint\n .accessTokenResponseClient(accessTokenResponseClient)\n )\n )\n .oauth2Client((oauth2Client) -> oauth2Client\n .authorizationCodeGrant((authorizationCode) -> authorizationCode\n .accessTokenResponseClient(accessTokenResponseClient)\n )\n );\n\n return http.build();\n\t}\n\n\tprivate static Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> parametersConverter() {\n // ...\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n val tokenResponseClient = RestClientAuthorizationCodeTokenResponseClient()\n tokenResponseClient.addParametersConverter(parametersConverter())\n\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n oauth2Login {\n tokenEndpoint {\n accessTokenResponseClient = tokenResponseClient\n }\n }\n oauth2Client {\n authorizationCodeGrant {\n accessTokenResponseClient = tokenResponseClient\n }\n }\n }\n\n return http.build()\n\t}\n\n\tprivate fun parametersConverter(): Converter<OAuth2AuthorizationCodeGrantRequest, MultiValueMap<String, String>> {\n // ...\n\t}\n\n}\n----\n=====\n\nFor other grant types we can publish additional `OAuth2AccessTokenResponseClient` beans to override the defaults.\nFor example, to customize token requests for the `client_credentials` grant we can publish the following bean:\n\n.Customize Token Request Parameters for Client Credentials Grant\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsAccessTokenResponseClient() {\n RestClientClientCredentialsTokenResponseClient accessTokenResponseClient =\n new RestClientClientCredentialsTokenResponseClient();\n accessTokenResponseClient.addParametersConverter(parametersConverter());\n\n return accessTokenResponseClient;\n\t}\n\n\tprivate static Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> parametersConverter() {\n // ...\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun clientCredentialsAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> {\n val accessTokenResponseClient = RestClientClientCredentialsTokenResponseClient()\n accessTokenResponseClient.addParametersConverter(parametersConverter())\n\n return accessTokenResponseClient\n\t}\n\n\tprivate fun parametersConverter(): Converter<OAuth2ClientCredentialsGrantRequest, MultiValueMap<String, String>> {\n // ...\n\t}\n\n}\n----\n=====\n\nSpring Security automatically resolves the following generic types of `OAuth2AccessTokenResponseClient` beans:\n\n* `OAuth2AuthorizationCodeGrantRequest` (see `RestClientAuthorizationCodeTokenResponseClient`)\n* `OAuth2RefreshTokenGrantRequest` (see `RestClientRefreshTokenTokenResponseClient`)\n* `OAuth2ClientCredentialsGrantRequest` (see `RestClientClientCredentialsTokenResponseClient`)\n* `JwtBearerGrantRequest` (see `RestClientJwtBearerTokenResponseClient`)\n* `TokenExchangeGrantRequest` (see `RestClientTokenExchangeTokenResponseClient`)\n\n[TIP]\n====\nPublishing a bean of type `OAuth2AccessTokenResponseClient<JwtBearerGrantRequest>` will automatically enable the `jwt-bearer` grant type without the need to <<oauth2-client-enable-extension-grant-type,configure it separately>>.\n====\n\n[TIP]\n====\nPublishing a bean of type `OAuth2AccessTokenResponseClient<TokenExchangeGrantRequest>` will automatically enable the `token-exchange` grant type without the need to <<oauth2-client-enable-extension-grant-type,configure it separately>>.\n====\n\n[[oauth2-client-customize-rest-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Customize Token Request Parameters", "heading_level": 3, "file_order": 157, "section_index": 15, "content_hash": "c5cbd6bf6f838f72cfab8aa997c8fbc37cbe0f601ebc775140b1da80ed71c454", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:ff879a2f067aa092e7bae07a6960e5277e4ab83ab5b6ad4fabdb46d5701fff77", "content": "Another common use case is the need to customize the `RestClient` used when obtaining an access token.\nWe might need to do this to customize processing of the response (via a custom `HttpMessageConverter`) or to apply proxy settings for a corporate network (via a customized `ClientHttpRequestFactory`).\n\nWith Spring Security 6.2 and later, we can simply publish beans of type `OAuth2AccessTokenResponseClient` and Spring Security will configure and publish an `OAuth2AuthorizedClientManager` bean for us.\n\nThe following example customizes the `RestClient` for all of the supported grant types:\n\n.Customize `RestClient` for OAuth2 Client\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeAccessTokenResponseClient() {\n RestClientAuthorizationCodeTokenResponseClient accessTokenResponseClient =\n new RestClientAuthorizationCodeTokenResponseClient();\n accessTokenResponseClient.setRestClient(restClient());\n\n return accessTokenResponseClient;\n\t}\n\n\t@Bean\n\tpublic OAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> refreshTokenAccessTokenResponseClient() {\n RestClientRefreshTokenTokenResponseClient accessTokenResponseClient =\n new RestClientRefreshTokenTokenResponseClient();\n accessTokenResponseClient.setRestClient(restClient());\n\n return accessTokenResponseClient;\n\t}\n\n\t@Bean\n\tpublic OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsAccessTokenResponseClient() {\n RestClientClientCredentialsTokenResponseClient accessTokenResponseClient =\n new RestClientClientCredentialsTokenResponseClient();\n accessTokenResponseClient.setRestClient(restClient());\n\n return accessTokenResponseClient;\n\t}\n\n\t@Bean\n\tpublic OAuth2AccessTokenResponseClient<JwtBearerGrantRequest> jwtBearerAccessTokenResponseClient() {\n RestClientJwtBearerTokenResponseClient accessTokenResponseClient =\n new RestClientJwtBearerTokenResponseClient();\n accessTokenResponseClient.setRestClient(restClient());\n\n return accessTokenResponseClient;\n\t}\n\n\t@Bean\n\tpublic OAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> tokenExchangeAccessTokenResponseClient() {\n RestClientTokenExchangeTokenResponseClient accessTokenResponseClient =\n new RestClientTokenExchangeTokenResponseClient();\n accessTokenResponseClient.setRestClient(restClient());\n\n return accessTokenResponseClient;\n\t}\n\n\t@Bean\n\tpublic RestClient restClient() {\n // ...\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig {\n\n\t@Bean\n\tfun authorizationCodeAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> {\n val accessTokenResponseClient = RestClientAuthorizationCodeTokenResponseClient()\n accessTokenResponseClient.setRestClient(restClient())\n\n return accessTokenResponseClient\n\t}\n\n\t@Bean\n\tfun refreshTokenAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> {\n val accessTokenResponseClient = RestClientRefreshTokenTokenResponseClient()\n accessTokenResponseClient.setRestClient(restClient())\n\n return accessTokenResponseClient\n\t}\n\n\t@Bean\n\tfun clientCredentialsAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> {\n val accessTokenResponseClient = RestClientClientCredentialsTokenResponseClient()\n accessTokenResponseClient.setRestClient(restClient())\n\n return accessTokenResponseClient\n\t}\n\n\t@Bean\n\tfun jwtBearerAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<JwtBearerGrantRequest> {\n val accessTokenResponseClient = RestClientJwtBearerTokenResponseClient()\n accessTokenResponseClient.setRestClient(restClient())\n\n return accessTokenResponseClient\n\t}\n\n\t@Bean\n\tfun tokenExchangeAccessTokenResponseClient(): OAuth2AccessTokenResponseClient<TokenExchangeGrantRequest> {\n val accessTokenResponseClient = RestClientTokenExchangeTokenResponseClient()\n accessTokenResponseClient.setRestClient(restClient())\n\n return accessTokenResponseClient\n\t}\n\n\t@Bean\n\tfun restClient(): RestClient {\n // ...\n\t}\n\n}\n----\n=====\n\nA default `OAuth2AuthorizedClientManager` will be published automatically by Spring Security when one is not already provided.\n\n[TIP]\n====\nNotice that we don't need to customize the `SecurityFilterChain` bean in this case, and can stick with the defaults.\nIf using Spring Boot with no additional customizations, we can actually omit the `SecurityFilterChain` bean entirely.\n====\n\nPrior to Spring Security 6.2, we had to ensure this customization was applied to both OAuth2 Login (if we are using this feature) and OAuth2 Client components.\nWe had to use both the Spring Security DSL (for the `authorization_code` grant) and publish a bean of type `OAuth2AuthorizedClientManager` for other grant types.\nTo understand what is being configured behind the scenes, here's what the configuration might have looked like:\n\n.Customize `RestClient` for OAuth2 Client (prior to 6.2)\n[tabs]\n=====\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n\t@Bean\n\tpublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n RestClientAuthorizationCodeTokenResponseClient accessTokenResponseClient =\n new RestClientAuthorizationCodeTokenResponseClient();\n accessTokenResponseClient.setRestClient(restClient());\n\n http\n // ...\n .oauth2Login((oauth2Login) -> oauth2Login\n .tokenEndpoint((tokenEndpoint) -> tokenEndpoint\n .accessTokenResponseClient(accessTokenResponseClient)\n )\n )\n .oauth2Client((oauth2Client) -> oauth2Client\n .authorizationCodeGrant((authorizationCode) -> authorizationCode\n .accessTokenResponseClient(accessTokenResponseClient)\n )\n );\n\n return http.build();\n\t}\n\n\t@Bean\n\tpublic OAuth2AuthorizedClientManager authorizedClientManager(\n ClientRegistrationRepository clientRegistrationRepository,\n OAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n RestClientRefreshTokenTokenResponseClient refreshTokenAccessTokenResponseClient =\n new RestClientRefreshTokenTokenResponseClient();\n refreshTokenAccessTokenResponseClient.setRestClient(restClient());\n\n RestClientClientCredentialsTokenResponseClient clientCredentialsAccessTokenResponseClient =\n new RestClientClientCredentialsTokenResponseClient();\n clientCredentialsAccessTokenResponseClient.setRestClient(restClient());\n\n RestClientJwtBearerTokenResponseClient jwtBearerAccessTokenResponseClient =\n new RestClientJwtBearerTokenResponseClient();\n jwtBearerAccessTokenResponseClient.setRestClient(restClient());\n\n JwtBearerOAuth2AuthorizedClientProvider jwtBearerAuthorizedClientProvider =\n new JwtBearerOAuth2AuthorizedClientProvider();\n jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerAccessTokenResponseClient);\n\n RestClientTokenExchangeTokenResponseClient tokenExchangeAccessTokenResponseClient =\n new RestClientTokenExchangeTokenResponseClient();\n tokenExchangeAccessTokenResponseClient.setRestClient(restClient());\n\n TokenExchangeOAuth2AuthorizedClientProvider tokenExchangeAuthorizedClientProvider =\n new TokenExchangeOAuth2AuthorizedClientProvider();\n tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeAccessTokenResponseClient);\n\n OAuth2AuthorizedClientProvider authorizedClientProvider =\n OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken((refreshToken) -> refreshToken\n .accessTokenResponseClient(refreshTokenAccessTokenResponseClient)\n )\n .clientCredentials((clientCredentials) -> clientCredentials\n .accessTokenResponseClient(clientCredentialsAccessTokenResponseClient)\n )\n .provider(jwtBearerAuthorizedClientProvider)\n .provider(tokenExchangeAuthorizedClientProvider)\n .build();\n\n DefaultOAuth2AuthorizedClientManager authorizedClientManager =\n new DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository);\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n return authorizedClientManager;\n\t}\n\n\t@Bean\n\tpublic RestClient restClient() {\n // ...\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.annotation.web.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n\t@Bean\n\tfun securityFilterChain(http: HttpSecurity): SecurityFilterChain {\n val tokenResponseClient = RestClientAuthorizationCodeTokenResponseClient()\n tokenResponseClient.setRestClient(restClient())\n\n http {\n // ...\n oauth2Login {\n tokenEndpoint {\n accessTokenResponseClient = tokenResponseClient\n }\n }\n oauth2Client {\n authorizationCodeGrant {\n accessTokenResponseClient = tokenResponseClient\n }\n }\n }\n\n return http.build()\n\t}\n\n\t@Bean\n\tfun authorizedClientManager(\n clientRegistrationRepository: ClientRegistrationRepository?,\n authorizedClientRepository: OAuth2AuthorizedClientRepository?\n\t): OAuth2AuthorizedClientManager {\n val refreshTokenAccessTokenResponseClient = RestClientRefreshTokenTokenResponseClient()\n refreshTokenAccessTokenResponseClient.setRestClient(restClient())\n\n val clientCredentialsAccessTokenResponseClient = RestClientClientCredentialsTokenResponseClient()\n clientCredentialsAccessTokenResponseClient.setRestClient(restClient())\n\n val jwtBearerAccessTokenResponseClient = RestClientJwtBearerTokenResponseClient()\n jwtBearerAccessTokenResponseClient.setRestClient(restClient())\n\n val jwtBearerAuthorizedClientProvider = JwtBearerOAuth2AuthorizedClientProvider()\n jwtBearerAuthorizedClientProvider.setAccessTokenResponseClient(jwtBearerAccessTokenResponseClient)\n\n val tokenExchangeAccessTokenResponseClient = RestClientTokenExchangeTokenResponseClient()\n tokenExchangeAccessTokenResponseClient.setRestClient(restClient())\n\n val tokenExchangeAuthorizedClientProvider = TokenExchangeOAuth2AuthorizedClientProvider()\n tokenExchangeAuthorizedClientProvider.setAccessTokenResponseClient(tokenExchangeAccessTokenResponseClient)\n\n val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()\n .authorizationCode()\n .refreshToken { refreshToken ->\n refreshToken.accessTokenResponseClient(refreshTokenAccessTokenResponseClient)\n }\n .clientCredentials { clientCredentials ->\n clientCredentials.accessTokenResponseClient(clientCredentialsAccessTokenResponseClient)\n }\n .provider(jwtBearerAuthorizedClientProvider)\n .provider(tokenExchangeAuthorizedClientProvider)\n .build()\n\n val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(\n clientRegistrationRepository, authorizedClientRepository\n )\n authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)\n\n return authorizedClientManager\n\t}\n\n\t@Bean\n\tfun restClient(): RestClient {\n // ...\n\t}\n\n}\n----\n=====\n\n[[further-reading]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Customize the `RestClient` used by OAuth2 Client Components", "heading_level": 3, "file_order": 157, "section_index": 16, "content_hash": "ff879a2f067aa092e7bae07a6960e5277e4ab83ab5b6ad4fabdb46d5701fff77", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:32e26f103561373e27ec330dab4eb647f582445c619e625aecf8931cfda95bf6", "content": "The preceding sections introduced Spring Security's support for OAuth2 with examples for common scenarios.\nYou can read more about OAuth2 Client, Resource Server and Authorization Server in the following sections of the reference documentation:\n\n* xref:servlet/oauth2/login/index.adoc[]\n* xref:servlet/oauth2/client/index.adoc[]\n* xref:servlet/oauth2/resource-server/index.adoc[]\n* xref:servlet/oauth2/authorization-server/index.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/oauth2/index.adoc", "title": "OAuth2", "heading": "Further Reading", "heading_level": 2, "file_order": 157, "section_index": 17, "content_hash": "32e26f103561373e27ec330dab4eb647f582445c619e625aecf8931cfda95bf6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/oauth2/index.adoc"}}
{"id": "sha256:3fd2458b42a94328a8bfbe89489c0b4766717b515d680803d88f467d11af1654", "content": "[[servlet-saml2login-sp-initiated-factory]]\n\nAs stated earlier, Spring Security's SAML 2.0 support produces a `<saml2:AuthnRequest>` to commence authentication with the asserting party.\n\nSpring Security achieves this in part by registering the `Saml2WebSsoAuthenticationRequestFilter` in the filter chain.\nThis filter by default responds to the endpoints `+/saml2/authenticate/{registrationId}+` and `+/saml2/authenticate?registrationId={registrationId}+`.\n\nFor example, if you were deployed to `https://rp.example.com` and you gave your registration an ID of `okta`, you could navigate to:\n\n`https://rp.example.org/saml2/authenticate/okta`\n\nand the result would be a redirect that included a `SAMLRequest` parameter containing the signed, deflated, and encoded `<saml2:AuthnRequest>`.\n\n[[configuring-authentication-request-uri]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc", "title": "authentication-requests", "heading": "authentication-requests", "heading_level": 1, "file_order": 158, "section_index": 0, "content_hash": "3fd2458b42a94328a8bfbe89489c0b4766717b515d680803d88f467d11af1654", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc"}}
{"id": "sha256:d160fafebe33cbc6f20b587a768860730f1573b26d992711a8781d45fc372985", "content": "To configure the endpoint differently from the default, you can set the value in `saml2Login`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain filterChain(HttpSecurity http) {\n\thttp\n .saml2Login((saml2) -> saml2\n .authenticationRequestUriQuery(\"/custom/auth/sso?peerEntityID={registrationId}\")\n );\n\treturn new CustomSaml2AuthenticationRequestRepository();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n saml2Login {\n authenticationRequestUriQuery = \"/custom/auth/sso?peerEntityID={registrationId}\"\n }\n }\n return CustomSaml2AuthenticationRequestRepository()\n}\n----\n======\n\n[[servlet-saml2login-store-authn-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc", "title": "authentication-requests", "heading": "Configuring the `<saml2:AuthnRequest>` Endpoint", "heading_level": 2, "file_order": 158, "section_index": 1, "content_hash": "d160fafebe33cbc6f20b587a768860730f1573b26d992711a8781d45fc372985", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc"}}
{"id": "sha256:64669d7ed108ef4aa80b25e90d17dde4c25f04141a274cba1c701a6646ead5d5", "content": "`Saml2WebSsoAuthenticationRequestFilter` uses an `Saml2AuthenticationRequestRepository` to persist an `AbstractSaml2AuthenticationRequest` instance before xref:servlet/saml2/login/authentication-requests.adoc#servlet-saml2login-sp-initiated-factory[sending the `<saml2:AuthnRequest>`] to the asserting party.\n\nAdditionally, `Saml2WebSsoAuthenticationFilter` and `Saml2AuthenticationTokenConverter` use an `Saml2AuthenticationRequestRepository` to load any `AbstractSaml2AuthenticationRequest` as part of xref:servlet/saml2/login/authentication.adoc#servlet-saml2login-authenticate-responses[authenticating the `<saml2:Response>`].\n\nBy default, Spring Security uses an `HttpSessionSaml2AuthenticationRequestRepository`, which stores the `AbstractSaml2AuthenticationRequest` in the `HttpSession`.\n\nIf you have a custom implementation of `Saml2AuthenticationRequestRepository`, you may configure it by exposing it as a `@Bean` as shown in the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSaml2AuthenticationRequestRepository<AbstractSaml2AuthenticationRequest> authenticationRequestRepository() {\n\treturn new CustomSaml2AuthenticationRequestRepository();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun authenticationRequestRepository(): Saml2AuthenticationRequestRepository<AbstractSaml2AuthenticationRequest> {\n return CustomSaml2AuthenticationRequestRepository()\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc", "title": "authentication-requests", "heading": "Changing How the `<saml2:AuthnRequest>` Gets Stored", "heading_level": 2, "file_order": 158, "section_index": 2, "content_hash": "64669d7ed108ef4aa80b25e90d17dde4c25f04141a274cba1c701a6646ead5d5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc"}}
{"id": "sha256:2610e96a9562be835521db1744d9e58066bc6072233adcecdcaf65bb05911978", "content": "If you don't want to use the session to store the `<saml2:AuthnRequest>`, you can also store it in a distributed cache.\nThis can be helpful if you are trying to use `SameSite=Strict` and are losing the authentication request in the redirect from the Identity Provider.\n\n[NOTE]\n=====\nIt's important to remember that there are security benefits to storing it in the session.\nOne such benefit is the natural login fixation defense it provides.\nFor example, if an application looks the authentication request up from the session, then even if an attacker provides their own SAML response to a victim, the login will fail.\n\nOn the other hand, if we trust the InResponseTo or RelayState to retrieve the authentication request, then there's no way to know if the SAML response was requested by that handshake.\n=====\n\nTo help with this, Spring Security has `CacheSaml2AuthenticationRequestRepository`, which you can publish as a bean for the filter chain to pick up:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSaml2AuthenticationRequestRepository<?> authenticationRequestRepository() {\n\treturn new CacheSaml2AuthenticationRequestRepository();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationRequestRepository(): Saml2AuthenticationRequestRepository<*> {\n return CacheSaml2AuthenticationRequestRepository()\n}\n----\n======\n\n[[servlet-saml2login-sp-initiated-factory-signing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc", "title": "authentication-requests", "heading": "Caching the `<saml2:AuthnRequest>` by the Relay State", "heading_level": 3, "file_order": 158, "section_index": 3, "content_hash": "2610e96a9562be835521db1744d9e58066bc6072233adcecdcaf65bb05911978", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc"}}
{"id": "sha256:d06fe6b0e5754c4caf156f45d2573467ad7f6fafb932c7fa5064ec37b8a6b648", "content": "By default, Spring Security signs each `<saml2:AuthnRequest>` and send it as a GET to the asserting party.\n\nMany asserting parties don't require a signed `<saml2:AuthnRequest>`.\nThis can be configured automatically via `RelyingPartyRegistrations`, or you can supply it manually, like so:\n\n.Not Requiring Signed AuthnRequests\n[tabs]\n======\nBoot::\n+\n[source,yaml,role=\"primary\"]\n----\nspring:\n security:\n saml2:\n relyingparty:\n registration:\n okta:\n assertingparty:\n entity-id: ...\n singlesignon.sign-request: false\n----\n\nJava::\n+\n[source,java,role=\"secondary\"]\n----\nRelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId(\"okta\")\n // ...\n .assertingPartyMetadata((party) -> party\n // ...\n .wantAuthnRequestsSigned(false)\n )\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nvar relyingPartyRegistration: RelyingPartyRegistration =\n RelyingPartyRegistration.withRegistrationId(\"okta\")\n // ...\n .assertingPartyMetadata { party: AssertingPartyMetadata.Builder -> party\n // ...\n .wantAuthnRequestsSigned(false)\n }\n .build()\n----\n======\n\nOtherwise, you will need to specify a private key to `RelyingPartyRegistration#signingX509Credentials` so that Spring Security can sign the `<saml2:AuthnRequest>` before sending.\n\n[[servlet-saml2login-sp-initiated-factory-algorithm]]\nBy default, Spring Security will sign the `<saml2:AuthnRequest>` using `rsa-sha256`, though some asserting parties will require a different algorithm, as indicated in their metadata.\n\nYou can configure the algorithm based on the asserting party's xref:servlet/saml2/login/overview.adoc#servlet-saml2login-relyingpartyregistrationrepository[metadata using `RelyingPartyRegistrations`].\n\nOr, you can provide it manually:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nString metadataLocation = \"classpath:asserting-party-metadata.xml\";\nRelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistrations.fromMetadataLocation(metadataLocation)\n // ...\n .assertingPartyMetadata((party) -> party\n // ...\n .signingAlgorithms((sign) -> sign.add(SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA512))\n )\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nvar metadataLocation = \"classpath:asserting-party-metadata.xml\"\nvar relyingPartyRegistration: RelyingPartyRegistration =\n RelyingPartyRegistrations.fromMetadataLocation(metadataLocation)\n // ...\n .assertingPartyMetadata { party: AssertingPartyMetadata.Builder -> party\n // ...\n .signingAlgorithms { sign: MutableList<String?> ->\n sign.add(\n SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA512\n )\n }\n }\n .build()\n----\n======\n\nNOTE: The snippet above uses the OpenSAML `SignatureConstants` class to supply the algorithm name.\nBut, that's just for convenience.\nSince the datatype is `String`, you can supply the name of the algorithm directly.\n\n[[servlet-saml2login-sp-initiated-factory-binding]]\nSome asserting parties require that the `<saml2:AuthnRequest>` be POSTed.\nThis can be configured automatically via `RelyingPartyRegistrations`, or you can supply it manually, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nRelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId(\"okta\")\n // ...\n .assertingPartyMetadata((party) -> party\n // ...\n .singleSignOnServiceBinding(Saml2MessageBinding.POST)\n )\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nvar relyingPartyRegistration: RelyingPartyRegistration? =\n RelyingPartyRegistration.withRegistrationId(\"okta\")\n // ...\n .assertingPartyMetadata { party: AssertingPartyMetadata.Builder -> party\n // ...\n .singleSignOnServiceBinding(Saml2MessageBinding.POST)\n }\n .build()\n----\n======\n\n[[servlet-saml2login-sp-initiated-factory-custom-authnrequest]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc", "title": "authentication-requests", "heading": "Changing How the `<saml2:AuthnRequest>` Gets Sent", "heading_level": 2, "file_order": 158, "section_index": 4, "content_hash": "d06fe6b0e5754c4caf156f45d2573467ad7f6fafb932c7fa5064ec37b8a6b648", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc"}}
{"id": "sha256:1d0b36437e3f0146494fa509894b338a917eec3ee7525adc05c45096cfa67652", "content": "There are a number of reasons that you may want to adjust an `AuthnRequest`.\nFor example, you may want `ForceAuthN` to be set to `true`, which Spring Security sets to `false` by default.\n\nYou can customize elements of OpenSAML's `AuthnRequest` by publishing an `OpenSaml5AuthenticationRequestResolver` as a `@Bean`, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSaml2AuthenticationRequestResolver authenticationRequestResolver(RelyingPartyRegistrationRepository registrations) {\n RelyingPartyRegistrationResolver registrationResolver =\n new DefaultRelyingPartyRegistrationResolver(registrations);\n OpenSaml5AuthenticationRequestResolver authenticationRequestResolver =\n new OpenSaml5AuthenticationRequestResolver(registrationResolver);\n authenticationRequestResolver.setAuthnRequestCustomizer((context) -> context\n .getAuthnRequest().setForceAuthn(true));\n return authenticationRequestResolver;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationRequestResolver(registrations : RelyingPartyRegistrationRepository) : Saml2AuthenticationRequestResolver {\n val registrationResolver : RelyingPartyRegistrationResolver =\n new DefaultRelyingPartyRegistrationResolver(registrations)\n val authenticationRequestResolver : OpenSaml5AuthenticationRequestResolver =\n new OpenSaml5AuthenticationRequestResolver(registrationResolver)\n authenticationRequestResolver.setAuthnRequestCustomizer((context) -> context\n .getAuthnRequest().setForceAuthn(true))\n return authenticationRequestResolver\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc", "title": "authentication-requests", "heading": "Customizing OpenSAML's `AuthnRequest` Instance", "heading_level": 2, "file_order": 158, "section_index": 5, "content_hash": "1d0b36437e3f0146494fa509894b338a917eec3ee7525adc05c45096cfa67652", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication-requests.adoc"}}
{"id": "sha256:76e0b52caf42d6d8f26ebb4cf264d554bb8878046fdfa615d4e44c3a60410f65", "content": "[[servlet-saml2login-authenticate-responses]]\n\nTo verify SAML 2.0 Responses, Spring Security uses xref:servlet/saml2/login/overview.adoc#servlet-saml2login-authentication-saml2authenticationtokenconverter[`Saml2AuthenticationTokenConverter`] to populate the `Authentication` request and xref:servlet/saml2/login/overview.adoc#servlet-saml2login-architecture[`OpenSaml5AuthenticationProvider`] to authenticate it.\n\nYou can configure this in a number of ways including:\n\n1. Changing the way the `RelyingPartyRegistration` is Looked Up\n2. Setting a clock skew to timestamp validation\n3. Mapping the response to a list of `GrantedAuthority` instances\n4. Customizing the strategy for validating assertions\n5. Customizing the strategy for decrypting response and assertion elements\n\nTo configure these, you'll use the `saml2Login#authenticationManager` method in the DSL.\n\n[[saml2-response-processing-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "authentication", "heading_level": 1, "file_order": 159, "section_index": 0, "content_hash": "76e0b52caf42d6d8f26ebb4cf264d554bb8878046fdfa615d4e44c3a60410f65", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:d4be51a8a96ea9bdbb678a970a6b03aaf38e6604f4d706aa7159afdccb94ba72", "content": "The default endpoint is `+/login/saml2/sso/{registrationId}+`.\nYou can change this in the DSL and in the associated metadata like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain securityFilters(HttpSecurity http) throws Exception {\n\thttp\n // ...\n .saml2Login((saml2) -> saml2.loginProcessingUrl(\"/saml2/login/sso\"))\n // ...\n\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun securityFilters(val http: HttpSecurity): SecurityFilterChain {\n\thttp {\n // ...\n .saml2Login {\n loginProcessingUrl = \"/saml2/login/sso\"\n }\n // ...\n }\n\n return http.build()\n}\n----\n======\n\nand:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nrelyingPartyRegistrationBuilder.assertionConsumerServiceLocation(\"/saml/SSO\")\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nrelyingPartyRegistrationBuilder.assertionConsumerServiceLocation(\"/saml/SSO\")\n----\n======\n\n[[relyingpartyregistrationresolver-apply]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Changing the SAML Response Processing Endpoint", "heading_level": 2, "file_order": 159, "section_index": 1, "content_hash": "d4be51a8a96ea9bdbb678a970a6b03aaf38e6604f4d706aa7159afdccb94ba72", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:9b848bc58cbdd9515271c1af5e8736501d355246a1306b9e2d78e678688b4511", "content": "By default, this converter will match against any associated `<saml2:AuthnRequest>` or any `registrationId` it finds in the URL.\nOr, if it cannot find one in either of those cases, then it attempts to look it up by the `<saml2:Response#Issuer>` element.\n\nThere are a number of circumstances where you might need something more sophisticated, like if you are supporting `ARTIFACT` binding.\nIn those cases, you can customize lookup through a custom `AuthenticationConverter`, which you can customize like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain securityFilters(HttpSecurity http, AuthenticationConverter authenticationConverter) throws Exception {\n\thttp\n // ...\n .saml2Login((saml2) -> saml2.authenticationConverter(authenticationConverter))\n // ...\n\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun securityFilters(val http: HttpSecurity, val converter: AuthenticationConverter): SecurityFilterChain {\n\thttp {\n // ...\n .saml2Login {\n authenticationConverter = converter\n }\n // ...\n }\n\n return http.build()\n}\n----\n======\n\n[[servlet-saml2login-opensamlauthenticationprovider-clockskew]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Changing `RelyingPartyRegistration` lookup", "heading_level": 2, "file_order": 159, "section_index": 2, "content_hash": "9b848bc58cbdd9515271c1af5e8736501d355246a1306b9e2d78e678688b4511", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:c980c19ae33250c6890573458dbecb2e5ade7a7ed3464901574ad5080b49c363", "content": "It's not uncommon for the asserting and relying parties to have system clocks that aren't perfectly synchronized.\nFor that reason, you can configure `OpenSaml5AuthenticationProvider.AssertionValidator` as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n OpenSaml5AuthenticationProvider authenticationProvider = new OpenSaml5AuthenticationProvider();\n AssertionValidator assertionValidator = AssertionValidator.builder()\n .clockSkew(Duration.ofMinutes(10)).build();\n authenticationProvider.setAssertionValidator(assertionValidator);\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .saml2Login((saml2) -> saml2\n .authenticationManager(new ProviderManager(authenticationProvider))\n );\n return http.build();\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n\n@Configuration @EnableWebSecurity\nclass SecurityConfig {\n @Bean\n @Throws(Exception::class)\n fun filterChain(http: HttpSecurity): SecurityFilterChain {\n val authenticationProvider = OpenSaml5AuthenticationProvider()\n val assertionValidator = AssertionValidator.builder().clockSkew(Duration.ofMinutes(10)).build()\n authenticationProvider.setAssertionValidator(assertionValidator)\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n saml2Login {\n authenticationManager = ProviderManager(authenticationProvider)\n }\n }\n return http.build()\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Setting a Clock Skew", "heading_level": 2, "file_order": 159, "section_index": 3, "content_hash": "c980c19ae33250c6890573458dbecb2e5ade7a7ed3464901574ad5080b49c363", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:713a6adaf3101cd1a23d088fec50ff253e7748c28c74dc9c627e1244ae31b36d", "content": "`OpenSamlXAuthenticationProvider#setResponseAuthenticationConverter` provides a way for you to change how it converts your assertion into an `Authentication` instance.\n\nYou can set a custom converter in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n @Autowired\n Converter<ResponseToken, Saml2Authentication> authenticationConverter;\n\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n OpenSaml5AuthenticationProvider authenticationProvider = new OpenSaml5AuthenticationProvider();\n authenticationProvider.setResponseAuthenticationConverter(this.authenticationConverter);\n\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated())\n .saml2Login((saml2) -> saml2\n .authenticationManager(new ProviderManager(authenticationProvider))\n );\n return http.build();\n }\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nopen class SecurityConfig {\n @Autowired\n var authenticationConverter: Converter<ResponseToken, Saml2Authentication>? = null\n\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n val authenticationProvider = OpenSaml5AuthenticationProvider()\n authenticationProvider.setResponseAuthenticationConverter(this.authenticationConverter)\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n saml2Login {\n authenticationManager = ProviderManager(authenticationProvider)\n }\n }\n return http.build()\n }\n}\n----\n======\n\nThe ensuing examples all build off of this common construct to show you different ways this converter comes in handy.\n\n[[servlet-saml2login-opensamlauthenticationprovider-userdetailsservice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Converting an `Assertion` into an `Authentication`", "heading_level": 2, "file_order": 159, "section_index": 4, "content_hash": "713a6adaf3101cd1a23d088fec50ff253e7748c28c74dc9c627e1244ae31b36d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:974be7983c18496aea5bf12a292b001fc95e09c25058bf5fe3a0d5285046493a", "content": "Or, perhaps you would like to include user details from a legacy `UserDetailsService`.\nIn that case, the response authentication converter can come in handy, as can be seen below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\nclass MyUserDetailsResponseAuthenticationConverter implements Converter<ResponseToken, Saml2Authentication> {\n\tprivate final ResponseAuthenticationConverter delegate = new ResponseAuthenticationConverter();\n\tprivate final UserDetailsService userDetailsService;\n\n\tMyUserDetailsResponseAuthenticationConverter(UserDetailsService userDetailsService) {\n this.userDetailsService = userDetailsService;\n\t}\n\n\t@Override\n public Saml2Authentication convert(ResponseToken responseToken) {\n Saml2Authentication authentication = this.delegate.convert(responseToken); <1>\n String username = authentication.getName();\n UserDetails user = this.userDetailsService.loadUserByUsername(username); <2>\n String saml2Response = authentication.getSaml2Response();\n Saml2ResponseAssertionAccessor assertion = new OpenSamlResponseAssertionAccessor(\n saml2Response, CollectionUtils.getFirst(responseToken.getResponse().getAssertions()));\n Collection<GrantedAuthority> authorities = user.getAuthorities();\n return new Saml2AssertionAuthentication(user, assertion, authorities); <3>\n }\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class MyUserDetailsResponseAuthenticationConverter(private val userDetailsService: UserDetailsService) : Converter<ResponseToken, Saml2Authentication> {\n\n private val delegate = ResponseAuthenticationConverter()\n\n override fun convert(responseToken: ResponseToken): Saml2Authentication {\n val authentication = this.delegate.convert(responseToken) <1>\n val username = authentication.name\n val userDetails = this.userDetailsService.loadUserByUsername(username) <2>\n val saml2Response = authentication.saml2Response\n val assertion = OpenSamlResponseAssertionAccessor(\n saml2Response, responseToken.response.assertions.firstOrNull())\n val authorities = principal.getAuthorities()\n return Saml2AssertionAuthentication(userDetails, assertion, userDetails.authorities) <3>\n }\n\n}\n----\n======\n<1> First, call the default converter, which extracts attributes and authorities from the response\n<2> Second, call the xref:servlet/authentication/passwords/user-details-service.adoc#servlet-authentication-userdetailsservice[`UserDetailsService`] using the relevant information\n<3> Third, return an authentication that includes the user details\n\n[TIP]\n====\nIf your `UserDetailsService` returns a value that also implements `AuthenticatedPrincipal`, then you don't need a custom authentication implementation.\n====\n\n[NOTE]\nIt's not required to call ``OpenSaml5AuthenticationProvider``'s default authentication converter.\nIt returns a `Saml2AuthenticatedPrincipal` containing the attributes it extracted from ``AttributeStatement``s as well as the single `ROLE_USER` authority.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Coordinating with a `UserDetailsService`", "heading_level": 2, "file_order": 159, "section_index": 5, "content_hash": "974be7983c18496aea5bf12a292b001fc95e09c25058bf5fe3a0d5285046493a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:d29cf8ebd9b86578c16a8e1e2ea8ddee1fbd71a2c797ce262fab010993712138", "content": "Sometimes, the principal name is not in the `<saml2:NameID>` element.\nIn that case, you can configure the `ResponseAuthenticationConverter` with a custom strategy like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nResponseAuthenticationConverter authenticationConverter() {\n\tResponseAuthenticationConverter authenticationConverter = new ResponseAuthenticationConverter();\n\tauthenticationConverter.setPrincipalNameConverter((assertion) -> {\n // ... work with OpenSAML's Assertion object to extract the principal\n\t});\n\treturn authenticationConverter;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationConverter(): ResponseAuthenticationConverter {\n val authenticationConverter: ResponseAuthenticationConverter = ResponseAuthenticationConverter()\n authenticationConverter.setPrincipalNameConverter { assertion ->\n // ... work with OpenSAML's Assertion object to extract the principal\n }\n return authenticationConverter\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Configuring the Principal Name", "heading_level": 3, "file_order": 159, "section_index": 6, "content_hash": "d29cf8ebd9b86578c16a8e1e2ea8ddee1fbd71a2c797ce262fab010993712138", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:0b0573ec56a3ec534bf58029f1aa9d7ea4ce58d4cbce53a3db8aa9c4c4169825", "content": "Spring Security automatically grants `ROLE_USER` when using `OpenSamlXAuhenticationProvider`.\nWith `OpenSaml5AuthenticationProvider`, you can configure a different set of granted authorities like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nResponseAuthenticationConverter authenticationConverter() {\n\tResponseAuthenticationConverter authenticationConverter = new ResponseAuthenticationConverter();\n\tauthenticationConverter.setPrincipalNameConverter((assertion) -> {\n // ... grant the needed authorities based on attributes in the assertion\n\t});\n\treturn authenticationConverter;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun authenticationConverter(): ResponseAuthenticationConverter {\n val authenticationConverter = ResponseAuthenticationConverter()\n authenticationConverter.setPrincipalNameConverter{ assertion ->\n // ... grant the needed authorities based on attributes in the assertion\n }\n return authenticationConverter\n}\n----\n======\n\n[[servlet-saml2login-opensamlauthenticationprovider-additionalvalidation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Configuring a Principal's Granted Authorities", "heading_level": 3, "file_order": 159, "section_index": 7, "content_hash": "0b0573ec56a3ec534bf58029f1aa9d7ea4ce58d4cbce53a3db8aa9c4c4169825", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:c530fbf4da8a79eb89047347a635a0d4b7c76faf51a9cd437b6e12cad002c367", "content": "`OpenSaml5AuthenticationProvider` validates the `Issuer` and `Destination` values right after decrypting the `Response`.\nYou can customize the validation by extending the default validator concatenating with your own response validator, or you can replace it entirely with yours.\n\nFor example, you can throw a custom exception with any additional information available in the `Response` object, like so:\n[source,java]\n----\nOpenSaml5AuthenticationProvider provider = new OpenSaml5AuthenticationProvider();\nResponseValidator responseValidator = ResponseValidator.withDefaults(myCustomValidator);\nprovider.setResponseValidator(responseValidator);\n----\n\nYou can also customize which validation steps Spring Security should do.\nFor example, if you want to skip `Response#InResponseTo` validation, you can call ``ResponseValidator``'s constructor, excluding `InResponseToValidator` from the list:\n\n[source,java]\n----\nOpenSaml5AuthenticationProvider provider = new OpenSaml5AuthenticationProvider();\nResponseValidator responseValidator = new ResponseValidator(new DestinationValidator(), new IssuerValidator());\nprovider.setResponseValidator(responseValidator);\n----\n\n[TIP]\n====\nOpenSAML performs `Asssertion#InResponseTo` validation in its `BearerSubjectConfirmationValidator` class, which is configurable using <<_performing_additional_assertion_validation, setAssertionValidator>>.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Performing Additional Response Validation", "heading_level": 2, "file_order": 159, "section_index": 8, "content_hash": "c530fbf4da8a79eb89047347a635a0d4b7c76faf51a9cd437b6e12cad002c367", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:f49201e0711367573a920dc8357e4a6c3cd3811261529304b3af033c391c9544", "content": "`OpenSaml5AuthenticationProvider` performs minimal validation on SAML 2.0 Assertions.\nAfter verifying the signature, it will:\n\n1. Validate `<AudienceRestriction>` and `<DelegationRestriction>` conditions\n2. Validate ``<SubjectConfirmation>``s, expect for any IP address information\n\nTo perform additional validation, you can configure your own assertion validator that delegates to ``OpenSaml5AuthenticationProvider``'s default and then performs its own.\n\n[[servlet-saml2login-opensamlauthenticationprovider-onetimeuse]]\nFor example, you can use OpenSAML's `OneTimeUseConditionValidator` to also validate a `<OneTimeUse>` condition, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOpenSaml5AuthenticationProvider provider = new OpenSaml5AuthenticationProvider();\nOneTimeUseConditionValidator validator = ...;\nAssertionValidator assertionValidator = AssertionValidator.builder()\n .conditionValidators((c) -> c.add(validator)).build();\nprovider.setAssertionValidator(assertionValidator);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval provider = OpenSaml5AuthenticationProvider()\nval validator: OneTimeUseConditionValidator = ...;\nval assertionValidator = AssertionValidator.builder()\n .conditionValidators { add(validator) }.build()\nprovider.setAssertionValidator(assertionValidator)\n----\n======\n\nYou can use this same builder to remove validators that you don't want to use like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOpenSaml5AuthenticationProvider provider = new OpenSaml5AuthenticationProvider();\nAssertionValidator assertionValidator = AssertionValidator.builder()\n .conditionValidators((c) -> c.removeIf(AudienceRestrictionValidator.class::isInstance)).build();\nprovider.setAssertionValidator(assertionValidator);\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval provider = new OpenSaml5AuthenticationProvider()\nval assertionValidator = AssertionValidator.builder()\n .conditionValidators {\n c: List<ConditionValidator> -> c.removeIf { it is AudienceRestrictionValidator }\n }.build()\nprovider.setAssertionValidator(assertionValidator)\n----\n======\n\n[[servlet-saml2login-opensamlauthenticationprovider-decryption]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Performing Additional Assertion Validation", "heading_level": 2, "file_order": 159, "section_index": 9, "content_hash": "f49201e0711367573a920dc8357e4a6c3cd3811261529304b3af033c391c9544", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:49986f7969bbb8b166d4976c46877e53bc68f70d7273395b8655777a2055b5bd", "content": "Spring Security decrypts `<saml2:EncryptedAssertion>`, `<saml2:EncryptedAttribute>`, and `<saml2:EncryptedID>` elements automatically by using the decryption xref:servlet/saml2/login/overview.adoc#servlet-saml2login-rpr-credentials[`Saml2X509Credential` instances] registered in the xref:servlet/saml2/login/overview.adoc#servlet-saml2login-relyingpartyregistration[`RelyingPartyRegistration`].\n\n`OpenSaml5AuthenticationProvider` exposes xref:servlet/saml2/login/overview.adoc#servlet-saml2login-architecture[two decryption strategies].\nThe response decrypter is for decrypting encrypted elements of the `<saml2:Response>`, like `<saml2:EncryptedAssertion>`.\nThe assertion decrypter is for decrypting encrypted elements of the `<saml2:Assertion>`, like `<saml2:EncryptedAttribute>` and `<saml2:EncryptedID>`.\n\nYou can replace ``OpenSaml5AuthenticationProvider``'s default decryption strategy with your own.\nFor example, if you have a separate service that decrypts the assertions in a `<saml2:Response>`, you can use it instead like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nMyDecryptionService decryptionService = ...;\nOpenSaml5AuthenticationProvider provider = new OpenSaml5AuthenticationProvider();\nprovider.setResponseElementsDecrypter((responseToken) -> decryptionService.decrypt(responseToken.getResponse()));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval decryptionService: MyDecryptionService = ...\nval provider = OpenSaml5AuthenticationProvider()\nprovider.setResponseElementsDecrypter { responseToken -> decryptionService.decrypt(responseToken.response) }\n----\n======\n\nIf you are also decrypting individual elements in a `<saml2:Assertion>`, you can customize the assertion decrypter, too:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nprovider.setAssertionElementsDecrypter((assertionToken) -> decryptionService.decrypt(assertionToken.getAssertion()));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nprovider.setAssertionElementsDecrypter { assertionToken -> decryptionService.decrypt(assertionToken.assertion) }\n----\n======\n\nNOTE: There are two separate decrypters since assertions can be signed separately from responses.\nTrying to decrypt a signed assertion's elements before signature verification may invalidate the signature.\nIf your asserting party signs the response only, then it's safe to decrypt all elements using only the response decrypter.\n\n[[servlet-saml2login-authenticationmanager-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Customizing Decryption", "heading_level": 2, "file_order": 159, "section_index": 10, "content_hash": "49986f7969bbb8b166d4976c46877e53bc68f70d7273395b8655777a2055b5bd", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:90e4db22f3d4deff433d5604d249e834eb3e97d66a906cff049248df24f45f55", "content": "[[servlet-saml2login-opensamlauthenticationprovider-authenticationmanager]]\nOf course, the `authenticationManager` DSL method can be also used to perform a completely custom SAML 2.0 authentication.\nThis authentication manager should expect a `Saml2AuthenticationToken` object containing the SAML 2.0 Response XML data.\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n @Bean\n\tpublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n AuthenticationManager authenticationManager = new MySaml2AuthenticationManager(...);\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .saml2Login((saml2) -> saml2\n .authenticationManager(authenticationManager)\n )\n ;\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nopen class SecurityConfig {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n val customAuthenticationManager: AuthenticationManager = MySaml2AuthenticationManager(...)\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n saml2Login {\n authenticationManager = customAuthenticationManager\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[[servlet-saml2login-authenticatedprincipal]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Using a Custom Authentication Manager", "heading_level": 2, "file_order": 159, "section_index": 11, "content_hash": "90e4db22f3d4deff433d5604d249e834eb3e97d66a906cff049248df24f45f55", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:5a10a77da51d32c22121c03a4f12747bbd0dfc6dc9a9448223c1bbc8b5f31c3b", "content": "With the relying party correctly configured for a given asserting party, it's ready to accept assertions.\nOnce the relying party validates an assertion, the result is a `Saml2Authentication` with a `Saml2AuthenticatedPrincipal`.\n\nThis means that you can access the principal in your controller like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Controller\npublic class MainController {\n\t@GetMapping(\"/\")\n\tpublic String index(@AuthenticationPrincipal Saml2AuthenticatedPrincipal principal, Model model) {\n String email = principal.getFirstAttribute(\"email\");\n model.setAttribute(\"email\", email);\n return \"index\";\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Controller\nclass MainController {\n @GetMapping(\"/\")\n fun index(@AuthenticationPrincipal principal: Saml2AuthenticatedPrincipal, model: Model): String {\n val email = principal.getFirstAttribute<String>(\"email\")\n model.setAttribute(\"email\", email)\n return \"index\"\n }\n}\n----\n======\n\n[TIP]\nBecause the SAML 2.0 specification allows for each attribute to have multiple values, you can either call `getAttribute` to get the list of attributes or `getFirstAttribute` to get the first in the list.\n`getFirstAttribute` is quite handy when you know that there is only one value.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc", "title": "authentication", "heading": "Using `Saml2AuthenticatedPrincipal`", "heading_level": 2, "file_order": 159, "section_index": 12, "content_hash": "5a10a77da51d32c22121c03a4f12747bbd0dfc6dc9a9448223c1bbc8b5f31c3b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/authentication.adoc"}}
{"id": "sha256:075e0f217014dcef0d58da8e64399df08d2739998833075fe87b79128ea1cbc4", "content": "[[servlet-saml2login]]\n\nThe SAML 2.0 Login feature provides an application with the ability to act as a SAML 2.0 relying party, having users https://wiki.shibboleth.net/confluence/display/CONCEPT/FlowsAndConfig[log in] to the application by using their existing account at a SAML 2.0 Asserting Party (Okta, ADFS, and others).\n\n[NOTE]\n====\nSAML 2.0 Login is implemented by using the *Web Browser SSO Profile*, as specified in\nhttps://www.oasis-open.org/committees/download.php/35389/sstc-saml-profiles-errata-2.0-wd-06-diff.pdf#page=15[SAML 2 Profiles].\n====\n\n[[servlet-saml2login-spring-security-history]]\nSince 2009, support for relying parties has existed as an https://github.com/spring-projects/spring-security-saml/tree/1e013b07a7772defd6a26fcfae187c9bf661ee8f#spring-saml[extension project].\nIn 2019, the process began to port that into https://github.com/spring-projects/spring-security[Spring Security] proper.\nThis process is similar to the one started in 2017 for xref:servlet/oauth2/index.adoc[Spring Security's OAuth 2.0 support].\n\n[NOTE]\n====\nA working sample for {gh-samples-url}/servlet/spring-boot/java/saml2/login[SAML 2.0 Login] is available in the {gh-samples-url}[Spring Security Samples repository].\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 160, "section_index": 0, "content_hash": "075e0f217014dcef0d58da8e64399df08d2739998833075fe87b79128ea1cbc4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/index.adoc"}}
{"id": "sha256:8f277f2c5508f471a108584a5173d9d372c4435383c7d74bd25fa5be43cebbf4", "content": "We start by examining how SAML 2.0 Relying Party Authentication works within Spring Security.\nFirst, we see that, like <<oauth2login, OAuth 2.0 Login>>, Spring Security takes the user to a third party for performing authentication.\nIt does this through a series of redirects:\n\n.Redirecting to Asserting Party Authentication\n[.invert-dark]\nimage::{figures}/saml2webssoauthenticationrequestfilter.png[]\n\n[NOTE]\n====\nThe figure above builds off our xref:servlet/architecture.adoc#servlet-securityfilterchain[`SecurityFilterChain`] and xref:servlet/authentication/architecture.adoc#servlet-authentication-abstractprocessingfilter[`AbstractAuthenticationProcessingFilter`] diagrams:\n====\n\nimage:{icondir}/number_1.png[] First, a user makes an unauthenticated request to the `/private` resource, for which it is not authorized.\n\nimage:{icondir}/number_2.png[] Spring Security's xref:servlet/authorization/authorize-http-requests.adoc[`AuthorizationFilter`] indicates that the unauthenticated request is _Denied_ by throwing an `AccessDeniedException`.\n\nimage:{icondir}/number_3.png[] Since the user lacks authorization, the xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[`ExceptionTranslationFilter`] initiates _Start Authentication_.\nThe configured xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationentrypoint[`AuthenticationEntryPoint`] is an instance of javadoc:org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint[], which redirects to <<servlet-saml2login-sp-initiated-factory,the `<saml2:AuthnRequest>` generating endpoint>>, `Saml2WebSsoAuthenticationRequestFilter`.\nAlternatively, if you have <<servlet-saml2login-relyingpartyregistrationrepository,configured more than one asserting party>>, it first redirects to a picker page.\n\nimage:{icondir}/number_4.png[] Next, the `Saml2WebSsoAuthenticationRequestFilter` creates, signs, serializes, and encodes a `<saml2:AuthnRequest>` using its configured <<servlet-saml2login-sp-initiated-factory,`Saml2AuthenticationRequestFactory`>>.\n\nimage:{icondir}/number_5.png[] Then the browser takes this `<saml2:AuthnRequest>` and presents it to the asserting party.\nThe asserting party tries to authentication the user.\nIf successful, it returns a `<saml2:Response>` back to the browser.\n\nimage:{icondir}/number_6.png[] The browser then POSTs the `<saml2:Response>` to the assertion consumer service endpoint.\n\nThe following image shows how Spring Security authenticates a `<saml2:Response>`.\n\n[[servlet-saml2login-authentication-saml2webssoauthenticationfilter]]\n.Authenticating a `<saml2:Response>`\n[.invert-dark]\nimage::{figures}/saml2webssoauthenticationfilter.png[]\n\n[NOTE]\n====\nThe figure builds off our xref:servlet/architecture.adoc#servlet-securityfilterchain[`SecurityFilterChain`] diagram.\n====\n\n[[servlet-saml2login-authentication-saml2authenticationtokenconverter]]\nimage:{icondir}/number_1.png[] When the browser submits a `<saml2:Response>` to the application, it xref:servlet/saml2/login/authentication.adoc#servlet-saml2login-authenticate-responses[delegates to `Saml2WebSsoAuthenticationFilter`].\nThis filter calls its configured `AuthenticationConverter` to create a `Saml2AuthenticationToken` by extracting the response from the `HttpServletRequest`.\nThis converter additionally resolves the <<servlet-saml2login-relyingpartyregistration, `RelyingPartyRegistration`>> and supplies it to `Saml2AuthenticationToken`.\n\nimage:{icondir}/number_2.png[] Next, the filter passes the token to its configured xref:servlet/authentication/architecture.adoc#servlet-authentication-providermanager[`AuthenticationManager`].\nBy default, it uses the <<servlet-saml2login-architecture,`OpenSaml5AuthenticationProvider`>>.\n\nimage:{icondir}/number_3.png[] If authentication fails, then _Failure_.\n\n* The xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[`SecurityContextHolder`] is cleared out.\n* The xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationentrypoint[`AuthenticationEntryPoint`] is invoked to restart the authentication process.\n\nimage:{icondir}/number_4.png[] If authentication is successful, then _Success_.\n\n* The xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`] is set on the xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[`SecurityContextHolder`].\n* The `Saml2WebSsoAuthenticationFilter` invokes `FilterChain#doFilter(request,response)` to continue with the rest of the application logic.\n\n[[servlet-saml2login-minimaldependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "SAML 2.0 Login Overview", "heading_level": 1, "file_order": 161, "section_index": 0, "content_hash": "8f277f2c5508f471a108584a5173d9d372c4435383c7d74bd25fa5be43cebbf4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:094a93d285df82df8421aad0b8a7991859b54d5010c9049e7cb5aa8b11bf5de6", "content": "SAML 2.0 service provider support resides in `spring-security-saml2-service-provider`.\nIt builds off of the OpenSAML library, and, for that reason, you must also include the Shibboleth Maven repository in your build configuration.\nCheck https://shibboleth.atlassian.net/wiki/spaces/DEV/pages/1123844333/Use+of+Maven+Central#Publishing-to-Maven-Central[this link] for more details about why a separate repository is needed.\n\n[tabs]\n======\nMaven::\n+\n[source,xml,role=\"primary\"]\n----\n<repositories>\n <!-- ... -->\n <repository>\n <id>shibboleth-releases</id>\n <name>Shibboleth Releases Repository</name>\n <url>https://build.shibboleth.net/maven/releases/</url>\n <snapshots>\n <enabled>false</enabled>\n </snapshots>\n </repository>\n</repositories>\n<dependency>\n <groupId>org.springframework.security</groupId>\n <artifactId>spring-security-saml2-service-provider</artifactId>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,role=\"secondary\"]\n----\nrepositories {\n // ...\n maven { url \"https://build.shibboleth.net/nexus/content/repositories/releases/\" }\n}\ndependencies {\n // ...\n implementation 'org.springframework.security:spring-security-saml2-service-provider'\n}\n----\n======\n\n[[servlet-saml2login-minimalconfiguration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "Minimal Dependencies", "heading_level": 2, "file_order": 161, "section_index": 1, "content_hash": "094a93d285df82df8421aad0b8a7991859b54d5010c9049e7cb5aa8b11bf5de6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:5d9e6337ba966352cbc7ffeba22dbe1a05ff58e9a8a50e79ff6caa4b7c82156a", "content": "When using https://spring.io/projects/spring-boot[Spring Boot], configuring an application as a service provider consists of two basic steps:\n. Include the needed dependencies.\n. Indicate the necessary asserting party metadata.\n\n[NOTE]\nAlso, this configuration presupposes that you have already xref:servlet/saml2/metadata.adoc#servlet-saml2login-metadata[registered the relying party with your asserting party].\n\n[[saml2-specifying-identity-provider-metadata]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "Minimal Configuration", "heading_level": 2, "file_order": 161, "section_index": 2, "content_hash": "5d9e6337ba966352cbc7ffeba22dbe1a05ff58e9a8a50e79ff6caa4b7c82156a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:753b4bafa013097d5de5e1db0e8e028b82d0b1e3b46668dcf040be225cb4d603", "content": "In a Spring Boot application, to specify an identity provider's metadata, create configuration similar to the following:\n\n[source,yml]\n----\nspring:\n security:\n saml2:\n relyingparty:\n registration:\n adfs:\n assertingparty:\n entity-id: https://idp.example.com/issuer\n verification.credentials:\n - certificate-location: \"classpath:idp.crt\"\n singlesignon.url: https://idp.example.com/issuer/sso\n singlesignon.sign-request: false\n----\n\nwhere:\n\n* `https://idp.example.com/issuer` is the value contained in the `Issuer` attribute of the SAML responses that the identity provider issues.\n* `classpath:idp.crt` is the location on the classpath for the identity provider's certificate for verifying SAML responses.\n* `https://idp.example.com/issuer/sso` is the endpoint where the identity provider is expecting `AuthnRequest` instances.\n* `adfs` is <<servlet-saml2login-relyingpartyregistrationid, an arbitrary identifier you choose>>\n\nAnd that's it!\n\n[NOTE]\n====\nIdentity Provider and Asserting Party are synonymous, as are Service Provider and Relying Party.\nThese are frequently abbreviated as AP and RP, respectively.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "Specifying Identity Provider Metadata", "heading_level": 3, "file_order": 161, "section_index": 3, "content_hash": "753b4bafa013097d5de5e1db0e8e028b82d0b1e3b46668dcf040be225cb4d603", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:3b6066d8ff2c44e5f1e34ae2480930b4d17fd5da390cf7c3af938e439359944d", "content": "As configured <<saml2-specifying-identity-provider-metadata,earlier>>, the application processes any `+POST /login/saml2/sso/{registrationId}+` request containing a `SAMLResponse` parameter:\n\n[source,http]\n----\nPOST /login/saml2/sso/adfs HTTP/1.1\n\nSAMLResponse=PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZ...\n----\n\nThere are two ways to induce your asserting party to generate a `SAMLResponse`:\n\n* You can navigate to your asserting party.\nIt likely has some kind of link or button for each registered relying party that you can click to send the `SAMLResponse`.\n* You can navigate to a protected page in your application -- for example, `http://localhost:8080`.\nYour application then redirects to the configured asserting party, which then sends the `SAMLResponse`.\n\nFrom here, consider jumping to:\n\n* <<servlet-saml2login-architecture,How SAML 2.0 Login Integrates with OpenSAML>>\n* xref:servlet/saml2/login/authentication.adoc#servlet-saml2login-authenticatedprincipal[How to Use the `Saml2AuthenticatedPrincipal`]\n* <<servlet-saml2login-sansboot,How to Override or Replace Spring Boot's Auto Configuration>>\n\n[[servlet-saml2login-architecture]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "Runtime Expectations", "heading_level": 3, "file_order": 161, "section_index": 4, "content_hash": "3b6066d8ff2c44e5f1e34ae2480930b4d17fd5da390cf7c3af938e439359944d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:63092768486e1f6b9d0c1a7efed6a2eea144076972475baa0c66be726da34de2", "content": "Spring Security's SAML 2.0 support has a couple of design goals:\n\n* Rely on a library for SAML 2.0 operations and domain objects.\nTo achieve this, Spring Security uses OpenSAML.\n* Ensure that this library is not required when using Spring Security's SAML support.\nTo achieve this, any interfaces or classes where Spring Security uses OpenSAML in the contract remain encapsulated.\nThis makes it possible for you to switch out OpenSAML for some other library or an unsupported version of OpenSAML.\n\nAs a natural outcome of these two goals, Spring Security's SAML API is quite small relative to other modules.\nInstead, such classes as `OpenSamlXAuthenticationRequestFactory` and `OpenSamlXAuthenticationProvider` expose `Converter` implementations that customize various steps in the authentication process.\n\nFor example, once your application receives a `SAMLResponse` and delegates to `Saml2WebSsoAuthenticationFilter`, the filter delegates to `OpenSamlXAuthenticationProvider`:\n\n.Authenticating an OpenSAML `Response`\nimage:{figures}/opensamlauthenticationprovider.png[]\n\nThis figure builds off of the <<servlet-saml2login-authentication-saml2webssoauthenticationfilter,`Saml2WebSsoAuthenticationFilter` diagram>>.\n\nimage:{icondir}/number_1.png[] The `Saml2WebSsoAuthenticationFilter` formulates the `Saml2AuthenticationToken` and invokes the xref:servlet/authentication/architecture.adoc#servlet-authentication-providermanager[`AuthenticationManager`].\n\nimage:{icondir}/number_2.png[] The xref:servlet/authentication/architecture.adoc#servlet-authentication-providermanager[`AuthenticationManager`] invokes the OpenSAML authentication provider.\n\nimage:{icondir}/number_3.png[] The authentication provider deserializes the response into an OpenSAML `Response` and checks its signature.\nIf the signature is invalid, authentication fails.\n\nimage:{icondir}/number_4.png[] Then the provider xref:servlet/saml2/login/authentication.adoc#servlet-saml2login-opensamlauthenticationprovider-decryption[decrypts any `EncryptedAssertion` elements].\nIf any decryptions fail, authentication fails.\n\nimage:{icondir}/number_5.png[] Next, the provider validates the response's `Issuer` and `Destination` values.\nIf they do not match what's in the `RelyingPartyRegistration`, authentication fails.\n\nimage:{icondir}/number_6.png[] After that, the provider verifies the signature of each `Assertion`.\nIf any signature is invalid, authentication fails.\nAlso, if neither the response nor the assertions have signatures, authentication fails.\nEither the response or all the assertions must have signatures.\n\nimage:{icondir}/number_7.png[] Then, the provider xref:servlet/saml2/login/authentication.adoc#servlet-saml2login-opensamlauthenticationprovider-decryption[decrypts any `EncryptedID` or `EncryptedAttribute` elements].\nIf any decryptions fail, authentication fails.\n\nimage:{icondir}/number_8.png[] Next, the provider validates each assertion's `ExpiresAt` and `NotBefore` timestamps, the `<Subject>` and any `<AudienceRestriction>` conditions.\nIf any validations fail, authentication fails.\n\nimage:{icondir}/number_9.png[] Following that, the provider takes the first assertion's `AttributeStatement` and maps it to a `Map<String, List<Object>>`.\nIt also grants the `FACTOR_SAML_RESPONSE` and `ROLE_USER` granted authorities.\n\nimage:{icondir}/number_10.png[] And finally, it takes the `NameID` from the first assertion, the `Map` of attributes, and the `GrantedAuthority` and constructs a `Saml2AuthenticatedPrincipal`.\nThen, it places that principal and the authorities into a `Saml2Authentication`.\n\nThe resulting `Authentication#getPrincipal` is a Spring Security `Saml2AuthenticatedPrincipal` object, and `Authentication#getName` maps to the first assertion's `NameID` element.\n`Saml2AuthenticatedPrincipal#getRelyingPartyRegistrationId` holds the <<servlet-saml2login-relyingpartyregistrationid,identifier to the associated `RelyingPartyRegistration`>>.\n\n[[servlet-saml2login-opensaml-customization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "How SAML 2.0 Login Integrates with OpenSAML", "heading_level": 2, "file_order": 161, "section_index": 5, "content_hash": "63092768486e1f6b9d0c1a7efed6a2eea144076972475baa0c66be726da34de2", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:3431d8ce622cb5a54813c88537f9f724e3146ae63b3d2915f93806ef0da4d7c5", "content": "Any class that uses both Spring Security and OpenSAML should statically initialize `OpenSamlInitializationService` at the beginning of the class:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nstatic {\n\tOpenSamlInitializationService.initialize();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ncompanion object {\n init {\n OpenSamlInitializationService.initialize()\n }\n}\n----\n======\n\nThis replaces OpenSAML's `InitializationService#initialize`.\n\nOccasionally, it can be valuable to customize how OpenSAML builds, marshalls, and unmarshalls SAML objects.\nIn these circumstances, you may instead want to call `OpenSamlInitializationService#requireInitialize(Consumer)` that gives you access to OpenSAML's `XMLObjectProviderFactory`.\n\nFor example, when sending an unsigned AuthNRequest, you may want to force reauthentication.\nIn that case, you can register your own `AuthnRequestMarshaller`, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nstatic {\n OpenSamlInitializationService.requireInitialize(factory -> {\n AuthnRequestMarshaller marshaller = new AuthnRequestMarshaller() {\n @Override\n public Element marshall(XMLObject object, Element element) throws MarshallingException {\n configureAuthnRequest((AuthnRequest) object);\n return super.marshall(object, element);\n }\n\n public Element marshall(XMLObject object, Document document) throws MarshallingException {\n configureAuthnRequest((AuthnRequest) object);\n return super.marshall(object, document);\n }\n\n private void configureAuthnRequest(AuthnRequest authnRequest) {\n authnRequest.setForceAuthn(true);\n }\n }\n\n factory.getMarshallerFactory().registerMarshaller(AuthnRequest.DEFAULT_ELEMENT_NAME, marshaller);\n });\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\ncompanion object {\n init {\n OpenSamlInitializationService.requireInitialize {\n val marshaller = object : AuthnRequestMarshaller() {\n override fun marshall(xmlObject: XMLObject, element: Element): Element {\n configureAuthnRequest(xmlObject as AuthnRequest)\n return super.marshall(xmlObject, element)\n }\n\n override fun marshall(xmlObject: XMLObject, document: Document): Element {\n configureAuthnRequest(xmlObject as AuthnRequest)\n return super.marshall(xmlObject, document)\n }\n\n private fun configureAuthnRequest(authnRequest: AuthnRequest) {\n authnRequest.isForceAuthn = true\n }\n }\n it.marshallerFactory.registerMarshaller(AuthnRequest.DEFAULT_ELEMENT_NAME, marshaller)\n }\n }\n}\n----\n======\n\nThe `requireInitialize` method may be called only once per application instance.\n\n[[servlet-saml2login-sansboot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "Customizing OpenSAML Configuration", "heading_level": 3, "file_order": 161, "section_index": 6, "content_hash": "3431d8ce622cb5a54813c88537f9f724e3146ae63b3d2915f93806ef0da4d7c5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:268123935ebbeb4196bc8e82af3c66282f6b490dce3b774a55c942ef24a9da1a", "content": "Spring Boot generates two `@Bean` objects for a relying party.\n\nThe first is a `SecurityFilterChain` that configures the application as a relying party.\nWhen including `spring-security-saml2-service-provider`, the `SecurityFilterChain` looks like:\n\n.Default SAML 2.0 Login Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .saml2Login(withDefaults());\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n saml2Login { }\n }\n return http.build()\n}\n----\n======\n\nIf the application does not expose a `SecurityFilterChain` bean, Spring Boot exposes the preceding default one.\n\nYou can replace this by exposing the bean within the application:\n\n.Custom SAML 2.0 Login Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class MyCustomSecurityConfiguration {\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/messages/**\").hasAuthority(\"ROLE_USER\")\n .anyRequest().authenticated()\n )\n .saml2Login(withDefaults());\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass MyCustomSecurityConfiguration {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(\"/messages/**\", hasAuthority(\"ROLE_USER\"))\n authorize(anyRequest, authenticated)\n }\n saml2Login {\n }\n }\n return http.build()\n }\n}\n----\n======\n\nThe preceding example requires the role of `USER` for any URL that starts with `/messages/`.\n\n[[servlet-saml2login-relyingpartyregistrationrepository]]\nThe second `@Bean` Spring Boot creates is a javadoc:org.springframework.security.saml2.provider.service.registration.RelyingPartyRegistrationRepository[], which represents the asserting party and relying party metadata.\nThis includes such things as the location of the SSO endpoint the relying party should use when requesting authentication from the asserting party.\n\nYou can override the default by publishing your own `RelyingPartyRegistrationRepository` bean.\nFor example, you can look up the asserting party's configuration by hitting its metadata endpoint:\n\n.Relying Party Registration Repository\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Value(\"${metadata.location}\")\nString assertingPartyMetadataLocation;\n\n@Bean\npublic RelyingPartyRegistrationRepository relyingPartyRegistrations() {\n RelyingPartyRegistration registration = RelyingPartyRegistrations\n .fromMetadataLocation(assertingPartyMetadataLocation)\n .registrationId(\"example\")\n .build();\n return new InMemoryRelyingPartyRegistrationRepository(registration);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Value(\"\\${metadata.location}\")\nvar assertingPartyMetadataLocation: String? = null\n\n@Bean\nopen fun relyingPartyRegistrations(): RelyingPartyRegistrationRepository? {\n val registration = RelyingPartyRegistrations\n .fromMetadataLocation(assertingPartyMetadataLocation)\n .registrationId(\"example\")\n .build()\n return InMemoryRelyingPartyRegistrationRepository(registration)\n}\n----\n======\n\n[[servlet-saml2login-relyingpartyregistrationid]]\n[NOTE]\nThe `registrationId` is an arbitrary value that you choose for differentiating between registrations.\n\nAlternatively, you can provide each detail manually:\n\n.Relying Party Registration Repository Manual Configuration\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Value(\"${verification.key}\")\nFile verificationKey;\n\n@Bean\npublic RelyingPartyRegistrationRepository relyingPartyRegistrations() throws Exception {\n X509Certificate certificate = X509Support.decodeCertificate(this.verificationKey);\n Saml2X509Credential credential = Saml2X509Credential.verification(certificate);\n RelyingPartyRegistration registration = RelyingPartyRegistration\n .withRegistrationId(\"example\")\n .assertingPartyMetadata((party) -> party\n .entityId(\"https://idp.example.com/issuer\")\n .singleSignOnServiceLocation(\"https://idp.example.com/SSO.saml2\")\n .wantAuthnRequestsSigned(false)\n .verificationX509Credentials((c) -> c.add(credential))\n )\n .build();\n return new InMemoryRelyingPartyRegistrationRepository(registration);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Value(\"\\${verification.key}\")\nvar verificationKey: File? = null\n\n@Bean\nopen fun relyingPartyRegistrations(): RelyingPartyRegistrationRepository {\n val certificate: X509Certificate? = X509Support.decodeCertificate(verificationKey!!)\n val credential: Saml2X509Credential = Saml2X509Credential.verification(certificate)\n val registration = RelyingPartyRegistration\n .withRegistrationId(\"example\")\n .assertingPartyMetadata { party: AssertingPartyMetadata.Builder ->\n party\n .entityId(\"https://idp.example.com/issuer\")\n .singleSignOnServiceLocation(\"https://idp.example.com/SSO.saml2\")\n .wantAuthnRequestsSigned(false)\n .verificationX509Credentials { c: MutableCollection<Saml2X509Credential?> ->\n c.add(\n credential\n )\n }\n }\n .build()\n return InMemoryRelyingPartyRegistrationRepository(registration)\n}\n----\n======\n\n[NOTE]\n====\n`X509Support` is an OpenSAML class, used in the preceding snippet for brevity.\n====\n\n[[servlet-saml2login-relyingpartyregistrationrepository-dsl]]\nAlternatively, you can directly wire up the repository by using the DSL, which also overrides the auto-configured `SecurityFilterChain`:\n\n.Custom Relying Party Registration DSL\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class MyCustomSecurityConfiguration {\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .requestMatchers(\"/messages/**\").hasAuthority(\"ROLE_USER\")\n .anyRequest().authenticated()\n )\n .saml2Login((saml2) -> saml2\n .relyingPartyRegistrationRepository(relyingPartyRegistrations())\n );\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass MyCustomSecurityConfiguration {\n @Bean\n open fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n authorize(\"/messages/**\", hasAuthority(\"ROLE_USER\"))\n authorize(anyRequest, authenticated)\n }\n saml2Login {\n relyingPartyRegistrationRepository = relyingPartyRegistrations()\n }\n }\n return http.build()\n }\n}\n----\n======\n\n[NOTE]\n====\nA relying party can be multi-tenant by registering more than one relying party in the `RelyingPartyRegistrationRepository`.\n====\n\n[[servlet-saml2login-relyingpartyregistrationrepository-caching]]\nIf you want your metadata to be refreshable on a periodic basis, you can wrap your repository in `CachingRelyingPartyRegistrationRepository` like so:\n\n.Caching Relying Party Registration Repository\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class MyCustomSecurityConfiguration {\n @Bean\n public RelyingPartyRegistrationRepository registrations(CacheManager cacheManager) {\n Supplier<IterableRelyingPartyRegistrationRepository> delegate = () ->\n new InMemoryRelyingPartyRegistrationRepository(RelyingPartyRegistrations\n .fromMetadataLocation(\"https://idp.example.org/ap/metadata\")\n .registrationId(\"ap\").build());\n CachingRelyingPartyRegistrationRepository registrations =\n new CachingRelyingPartyRegistrationRepository(delegate);\n registrations.setCache(cacheManager.getCache(\"my-cache-name\"));\n return registrations;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\n@EnableWebSecurity\nclass MyCustomSecurityConfiguration {\n @Bean\n fun registrations(cacheManager: CacheManager): RelyingPartyRegistrationRepository {\n val delegate = Supplier<IterableRelyingPartyRegistrationRepository> {\n InMemoryRelyingPartyRegistrationRepository(RelyingPartyRegistrations\n .fromMetadataLocation(\"https://idp.example.org/ap/metadata\")\n .registrationId(\"ap\").build())\n }\n val registrations = CachingRelyingPartyRegistrationRepository(delegate)\n registrations.setCache(cacheManager.getCache(\"my-cache-name\"))\n return registrations\n }\n}\n----\n======\n\nIn this way, the set of ``RelyingPartyRegistration``s will refresh based on {spring-framework-reference-url}integration/cache/store-configuration.html[the cache's eviction schedule].\n\n[[servlet-saml2login-relyingpartyregistration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "Overriding or Replacing Boot Auto Configuration", "heading_level": 2, "file_order": 161, "section_index": 7, "content_hash": "268123935ebbeb4196bc8e82af3c66282f6b490dce3b774a55c942ef24a9da1a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:4da9e14544fed1633e8dbd09a2957bcb2a160125e6c6e04e554f7774e66dfe74", "content": "A javadoc:org.springframework.security.saml2.provider.service.registration.RelyingPartyRegistration[]\ninstance represents a link between an relying party and an asserting party's metadata.\n\nIn a `RelyingPartyRegistration`, you can provide relying party metadata like its `Issuer` value, where it expects SAML Responses to be sent to, and any credentials that it owns for the purposes of signing or decrypting payloads.\n\nAlso, you can provide asserting party metadata like its `Issuer` value, where it expects AuthnRequests to be sent to, and any public credentials that it owns for the purposes of the relying party verifying or encrypting payloads.\n\nThe following `RelyingPartyRegistration` is the minimum required for most setups:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nRelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistrations\n .fromMetadataLocation(\"https://ap.example.org/metadata\")\n .registrationId(\"my-id\")\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval relyingPartyRegistration = RelyingPartyRegistrations\n .fromMetadataLocation(\"https://ap.example.org/metadata\")\n .registrationId(\"my-id\")\n .build()\n----\n======\n\nNote that you can also create a `RelyingPartyRegistration` from an arbitrary `InputStream` source.\nOne such example is when the metadata is stored in a database:\n\n[source,java]\n----\nString xml = fromDatabase();\ntry (InputStream source = new ByteArrayInputStream(xml.getBytes())) {\n RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistrations\n .fromMetadata(source)\n .registrationId(\"my-id\")\n .build();\n}\n----\n\nA more sophisticated setup is also possible:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nRelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId(\"my-id\")\n .entityId(\"{baseUrl}/{registrationId}\")\n .decryptionX509Credentials((c) -> c.add(relyingPartyDecryptingCredential()))\n .assertionConsumerServiceLocation(\"/my-login-endpoint/{registrationId}\")\n .assertingPartyMetadata((party) -> party\n .entityId(\"https://ap.example.org\")\n .verificationX509Credentials((c) -> c.add(assertingPartyVerifyingCredential()))\n .singleSignOnServiceLocation(\"https://ap.example.org/SSO.saml2\")\n )\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval relyingPartyRegistration =\n RelyingPartyRegistration.withRegistrationId(\"my-id\")\n .entityId(\"{baseUrl}/{registrationId}\")\n .decryptionX509Credentials { c: MutableCollection<Saml2X509Credential?> ->\n c.add(relyingPartyDecryptingCredential())\n }\n .assertionConsumerServiceLocation(\"/my-login-endpoint/{registrationId}\")\n .assertingPartyMetadata { party -> party\n .entityId(\"https://ap.example.org\")\n .verificationX509Credentials { c -> c.add(assertingPartyVerifyingCredential()) }\n .singleSignOnServiceLocation(\"https://ap.example.org/SSO.saml2\")\n }\n .build()\n----\n======\n\n[TIP]\n====\nThe top-level metadata methods are details about the relying party.\nThe methods inside `AssertingPartyMetadata` are details about the asserting party.\n====\n\n[NOTE]\n====\nThe location where a relying party is expecting SAML Responses is the Assertion Consumer Service Location.\n====\n\nThe default for the relying party's `entityId` is `+{baseUrl}/saml2/service-provider-metadata/{registrationId}+`.\nThis is this value needed when configuring the asserting party to know about your relying party.\n\nThe default for the `assertionConsumerServiceLocation` is `+/login/saml2/sso/{registrationId}+`.\nBy default, it is mapped to <<servlet-saml2login-authentication-saml2webssoauthenticationfilter,`Saml2WebSsoAuthenticationFilter`>> in the filter chain.\n\n[[servlet-saml2login-rpr-uripatterns]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "RelyingPartyRegistration", "heading_level": 2, "file_order": 161, "section_index": 8, "content_hash": "4da9e14544fed1633e8dbd09a2957bcb2a160125e6c6e04e554f7774e66dfe74", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:5969cb4ca3d057b5f90b902a0765ac51e81a8a244130f63e61b413fb3bfc2ecc", "content": "You probably noticed the `+{baseUrl}+` and `+{registrationId}+` placeholders in the preceding examples.\n\nThese are useful for generating URIs. As a result, the relying party's `entityId` and `assertionConsumerServiceLocation` support the following placeholders:\n\n* `baseUrl` - the scheme, host, and port of a deployed application\n* `registrationId` - the registration id for this relying party\n* `baseScheme` - the scheme of a deployed application\n* `baseHost` - the host of a deployed application\n* `basePort` - the port of a deployed application\n\nFor example, the `assertionConsumerServiceLocation` defined earlier was:\n\n`+/my-login-endpoint/{registrationId}+`\n\nIn a deployed application, it translates to:\n\n`+/my-login-endpoint/adfs+`\n\nThe `entityId` shown earlier was defined as:\n\n`+{baseUrl}/{registrationId}+`\n\nIn a deployed application, that translates to:\n\n`+https://rp.example.com/adfs+`\n\nThe prevailing URI patterns are as follows:\n\n* `+/saml2/authenticate/{registrationId}+` - The endpoint that xref:servlet/saml2/login/authentication-requests.adoc[generates a `<saml2:AuthnRequest>`] based on the configurations for that `RelyingPartyRegistration` and sends it to the asserting party\n* `+/login/saml2/sso/+` - The endpoint that xref:servlet/saml2/login/authentication.adoc[authenticates an asserting party's `<saml2:Response>`]; the `RelyingPartyRegistration` is looked up from previously authenticated state or the response's issuer if needed; also supports `+/login/saml2/sso/{registrationId}+`\n* `+/logout/saml2/sso+` - The endpoint that xref:servlet/saml2/logout.adoc[processes `<saml2:LogoutRequest>` and `<saml2:LogoutResponse>` payloads]; the `RelyingPartyRegistration` is looked up from previously authenticated state or the request's issuer if needed; also supports `+/logout/saml2/slo/{registrationId}+`\n* `+/saml2/metadata+` - The xref:servlet/saml2/metadata.adoc[relying party metadata] for the set of ``RelyingPartyRegistration``s; also supports `+/saml2/metadata/{registrationId}+` or `+/saml2/service-provider-metadata/{registrationId}+` for a specific `RelyingPartyRegistration`\n\nSince the `registrationId` is the primary identifier for a `RelyingPartyRegistration`, it is needed in the URL for unauthenticated scenarios.\nIf you wish to remove the `registrationId` from the URL for any reason, you can <<servlet-saml2login-rpr-relyingpartyregistrationresolver,specify a `RelyingPartyRegistrationResolver`>> to tell Spring Security how to look up the `registrationId`.\n\n[[servlet-saml2login-rpr-credentials]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "URI Patterns", "heading_level": 3, "file_order": 161, "section_index": 9, "content_hash": "5969cb4ca3d057b5f90b902a0765ac51e81a8a244130f63e61b413fb3bfc2ecc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:30bd3484d517efbc6a731615f8f262a858823885df105f52b629b9551365157c", "content": "In the example shown <<servlet-saml2login-relyingpartyregistration,earlier>>, you also likely noticed the credential that was used.\n\nOftentimes, a relying party uses the same key to sign payloads as well as decrypt them.\nAlternatively, it can use the same key to verify payloads as well as encrypt them.\n\nBecause of this, Spring Security ships with `Saml2X509Credential`, a SAML-specific credential that simplifies configuring the same key for different use cases.\n\nAt a minimum, you need to have a certificate from the asserting party so that the asserting party's signed responses can be verified.\n\nTo construct a `Saml2X509Credential` that you can use to verify assertions from the asserting party, you can load the file and use\nthe `CertificateFactory`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nResource resource = new ClassPathResource(\"ap.crt\");\ntry (InputStream is = resource.getInputStream()) {\n X509Certificate certificate = (X509Certificate)\n CertificateFactory.getInstance(\"X.509\").generateCertificate(is);\n return Saml2X509Credential.verification(certificate);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval resource = ClassPathResource(\"ap.crt\")\nresource.inputStream.use {\n return Saml2X509Credential.verification(\n CertificateFactory.getInstance(\"X.509\").generateCertificate(it) as X509Certificate?\n )\n}\n----\n======\n\nSuppose that the asserting party is going to also encrypt the assertion.\nIn that case, the relying party needs a private key to decrypt the encrypted value.\n\nIn that case, you need an `RSAPrivateKey` as well as its corresponding `X509Certificate`.\nYou can load the first by using Spring Security's `RsaKeyConverters` utility class and the second as you did before:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nX509Certificate certificate = relyingPartyDecryptionCertificate();\nResource resource = new ClassPathResource(\"rp.crt\");\ntry (InputStream is = resource.getInputStream()) {\n RSAPrivateKey rsa = RsaKeyConverters.pkcs8().convert(is);\n return Saml2X509Credential.decryption(rsa, certificate);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval certificate: X509Certificate = relyingPartyDecryptionCertificate()\nval resource = ClassPathResource(\"rp.crt\")\nresource.inputStream.use {\n val rsa: RSAPrivateKey = RsaKeyConverters.pkcs8().convert(it)\n return Saml2X509Credential.decryption(rsa, certificate)\n}\n----\n======\n\n[TIP]\n====\nWhen you specify the locations of these files as the appropriate Spring Boot properties, Spring Boot performs these conversions for you.\n====\n\n[[servlet-saml2login-rpr-duplicated]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "Credentials", "heading_level": 3, "file_order": 161, "section_index": 10, "content_hash": "30bd3484d517efbc6a731615f8f262a858823885df105f52b629b9551365157c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:0c448c372272c7c9c18ed0fa81f5ff4babd3957874833655398a057e147cd262", "content": "When an application uses multiple asserting parties, some configuration is duplicated between `RelyingPartyRegistration` instances:\n\n* The relying party's `entityId`\n* Its `assertionConsumerServiceLocation`\n* Its credentials -- for example, its signing or decryption credentials\n\nThis setup may let credentials be more easily rotated for some identity providers versus others.\n\nThe duplication can be alleviated in a few different ways.\n\nFirst, in YAML this can be alleviated with references:\n\n[source,yaml]\n----\nspring:\n security:\n saml2:\n relyingparty:\n registration:\n okta:\n signing.credentials: &relying-party-credentials\n - private-key-location: classpath:rp.key\n certificate-location: classpath:rp.crt\n assertingparty:\n entity-id: ...\n azure:\n signing.credentials: *relying-party-credentials\n assertingparty:\n entity-id: ...\n----\n\nSecond, in a database, you need not replicate the model of `RelyingPartyRegistration`.\n\nThird, in Java, you can create a custom configuration method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nprivate RelyingPartyRegistration.Builder\n addRelyingPartyDetails(RelyingPartyRegistration.Builder builder) {\n\n Saml2X509Credential signingCredential = ...\n builder.signingX509Credentials((c) -> c.addAll(signingCredential));\n // ... other relying party configurations\n}\n\n@Bean\npublic RelyingPartyRegistrationRepository relyingPartyRegistrations() {\n RelyingPartyRegistration okta = addRelyingPartyDetails(\n RelyingPartyRegistrations\n .fromMetadataLocation(oktaMetadataUrl)\n .registrationId(\"okta\")).build();\n\n RelyingPartyRegistration azure = addRelyingPartyDetails(\n RelyingPartyRegistrations\n .fromMetadataLocation(oktaMetadataUrl)\n .registrationId(\"azure\")).build();\n\n return new InMemoryRelyingPartyRegistrationRepository(okta, azure);\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nprivate fun addRelyingPartyDetails(builder: RelyingPartyRegistration.Builder): RelyingPartyRegistration.Builder {\n val signingCredential: Saml2X509Credential = ...\n builder.signingX509Credentials { c: MutableCollection<Saml2X509Credential?> ->\n c.add(\n signingCredential\n )\n }\n // ... other relying party configurations\n}\n\n@Bean\nopen fun relyingPartyRegistrations(): RelyingPartyRegistrationRepository? {\n val okta = addRelyingPartyDetails(\n RelyingPartyRegistrations\n .fromMetadataLocation(oktaMetadataUrl)\n .registrationId(\"okta\")\n ).build()\n val azure = addRelyingPartyDetails(\n RelyingPartyRegistrations\n .fromMetadataLocation(oktaMetadataUrl)\n .registrationId(\"azure\")\n ).build()\n return InMemoryRelyingPartyRegistrationRepository(okta, azure)\n}\n----\n======\n\n[[servlet-saml2login-rpr-relyingpartyregistrationresolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "Duplicated Relying Party Configurations", "heading_level": 3, "file_order": 161, "section_index": 11, "content_hash": "0c448c372272c7c9c18ed0fa81f5ff4babd3957874833655398a057e147cd262", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:366a974d48499eb69ed37d7d3aca717c3a64d86761d29fd93c537e1a23f76e43", "content": "As seen so far, Spring Security resolves the `RelyingPartyRegistration` by looking for the registration id in the URI path.\n\nDepending on the use case, a number of other strategies are also employed to derive one.\nFor example:\n\n* For processing ``<saml2:Response>``s, the `RelyingPartyRegistration` is looked up from the associated `<saml2:AuthRequest>` or from the `<saml2:Response#Issuer>` element\n* For processing ``<saml2:LogoutRequest>``s, the `RelyingPartyRegistration` is looked up from the currently logged in user or from the `<saml2:LogoutRequest#Issuer>` element\n* For publishing metadata, the ``RelyingPartyRegistration``s are looked up from any repository that also implements `Iterable<RelyingPartyRegistration>`\n\nWhen this needs adjustment, you can turn to the specific components for each of these endpoints targeted at customizing this:\n\n* For SAML Responses, customize the `AuthenticationConverter`\n* For Logout Requests, customize the `Saml2LogoutRequestValidatorParametersResolver`\n* For Metadata, customize the `Saml2MetadataResponseResolver`\n\n[[federating-saml2-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "Resolving the `RelyingPartyRegistration` from the Request", "heading_level": 3, "file_order": 161, "section_index": 12, "content_hash": "366a974d48499eb69ed37d7d3aca717c3a64d86761d29fd93c537e1a23f76e43", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:e4e4da6f1941db8333ab8704d4bf51032ff491a6a425c3061c0876aabe46492a", "content": "One common arrangement with SAML 2.0 is an identity provider that has multiple asserting parties.\nIn this case, the identity provider's metadata endpoint returns multiple `<md:IDPSSODescriptor>` elements.\n\nThese multiple asserting parties can be accessed in a single call to `RelyingPartyRegistrations` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nCollection<RelyingPartyRegistration> registrations = RelyingPartyRegistrations\n .collectionFromMetadataLocation(\"https://example.org/saml2/idp/metadata.xml\")\n .stream().map((builder) -> builder\n .registrationId(UUID.randomUUID().toString())\n .entityId(\"https://example.org/saml2/sp\")\n .build()\n )\n .collect(Collectors.toList());\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nvar registrations: Collection<RelyingPartyRegistration> = RelyingPartyRegistrations\n .collectionFromMetadataLocation(\"https://example.org/saml2/idp/metadata.xml\")\n .stream().map { builder : RelyingPartyRegistration.Builder -> builder\n .registrationId(UUID.randomUUID().toString())\n .entityId(\"https://example.org/saml2/sp\")\n .assertionConsumerServiceLocation(\"{baseUrl}/login/saml2/sso\")\n .build()\n }\n .collect(Collectors.toList())\n----\n======\n\nNote that because the registration id is set to a random value, this will change certain SAML 2.0 endpoints to be unpredictable.\nThere are several ways to address this; let's focus on a way that suits the specific use case of federation.\n\nIn many federation cases, all the asserting parties share service provider configuration.\nGiven that Spring Security will by default include the `registrationId` in the service provider metadata, another step is to change corresponding URIs to exclude the `registrationId`, which you can see has already been done in the above sample where the `entityId` and `assertionConsumerServiceLocation` are configured with a static endpoint.\n\nYou can see a completed example of this in {gh-samples-url}/servlet/spring-boot/java/saml2/saml-extension-federation[our `saml-extension-federation` sample].\n\n[[using-spring-security-saml-extension-uris]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "Federating Login", "heading_level": 3, "file_order": 161, "section_index": 13, "content_hash": "e4e4da6f1941db8333ab8704d4bf51032ff491a6a425c3061c0876aabe46492a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:b9a7ca1bd8e5d4346a0b68353fd704845abafed40efd51a3697b1075ed6ae055", "content": "In the event that you are migrating from the Spring Security SAML Extension, there may be some benefit to configuring your application to use the SAML Extension URI defaults.\n\nFor more information on this, please see {gh-samples-url}/servlet/spring-boot/java/saml2/saml-extension-urls[our `saml-extension-urls` sample] and {gh-samples-url}/servlet/spring-boot/java/saml2/saml-extension-federation[our `saml-extension-federation` sample].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc", "title": "SAML 2.0 Login Overview", "heading": "Using Spring Security SAML Extension URIs", "heading_level": 3, "file_order": 161, "section_index": 14, "content_hash": "b9a7ca1bd8e5d4346a0b68353fd704845abafed40efd51a3697b1075ed6ae055", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/login/overview.adoc"}}
{"id": "sha256:bdd3bdbc09b33bdf4c94099ac646dd6321b6698352327a0ac16c428621388cb5", "content": "[[servlet-saml2]]\n\nSpring Security provides comprehensive SAML 2 support.\nThis section discusses how to integrate SAML 2 into your servlet based application.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 162, "section_index": 0, "content_hash": "bdd3bdbc09b33bdf4c94099ac646dd6321b6698352327a0ac16c428621388cb5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/index.adoc"}}
{"id": "sha256:ee2c3d9f2cf6d34de77ef0904925df7aedbc9c5290abe53924f29218060dcc41", "content": "[[servlet-saml2login-logout]]\n\nAmong its xref:servlet/authentication/logout.adoc[other logout mechanisms], Spring Security ships with support for RP- and AP-initiated SAML 2.0 Single Logout.\n\nBriefly, there are two use cases Spring Security supports:\n\n* **RP-Initiated** - Your application has an endpoint that, when POSTed to, will logout the user and send a `saml2:LogoutRequest` to the asserting party.\nThereafter, the asserting party will send back a `saml2:LogoutResponse` and allow your application to respond\n* **AP-Initiated** - Your application has an endpoint that will receive a `saml2:LogoutRequest` from the asserting party.\nYour application will complete its logout at that point and then send a `saml2:LogoutResponse` to the asserting party.\n\n[NOTE]\nIn the **AP-Initiated** scenario, any local redirection that your application would do post-logout is rendered moot.\nOnce your application sends a `saml2:LogoutResponse`, it no longer has control of the browser.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "logout", "heading_level": 1, "file_order": 163, "section_index": 0, "content_hash": "ee2c3d9f2cf6d34de77ef0904925df7aedbc9c5290abe53924f29218060dcc41", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:349863d75cb58328018a9ecd15d8b627f5af239e835e5a6d4f4919219258e28a", "content": "To use Spring Security's SAML 2.0 Single Logout feature, you will need the following things:\n\n* First, the asserting party must support SAML 2.0 Single Logout\n* Second, the asserting party should be configured to sign and POST `saml2:LogoutRequest` s and `saml2:LogoutResponse` s your application's `/logout/saml2/slo` endpoint\n* Third, your application must have a PKCS#8 private key and X.509 certificate for signing `saml2:LogoutRequest` s and `saml2:LogoutResponse` s\n\nYou can achieve this in Spring Boot in the following way:\n\n[source,yaml]\n----\nspring:\n security:\n saml2:\n relyingparty:\n registration:\n metadata:\n signing.credentials: <3>\n - private-key-location: classpath:credentials/rp-private.key\n certificate-location: classpath:credentials/rp-certificate.crt\n singlelogout.url: \"{baseUrl}/logout/saml2/slo\" <2>\n assertingparty:\n metadata-uri: https://ap.example.com/metadata <1>\n\n----\n<1> - The metadata URI of the IDP, which will indicate to your application its support of SLO\n<2> - The SLO endpoint in your application\n<3> - The signing credentials to sign ``<saml2:LogoutRequest>``s and ``<saml2:LogoutResponse>``s\n\n[NOTE]\n----\nAn asserting party supports Single Logout if their metadata includes the `<SingleLogoutService>` element in their metadata.\n----\n\nAnd that's it!\n\nSpring Security's logout support offers a number of configuration points.\nConsider the following use cases:\n\n* Understand how the above <<_startup_expectations, minimal configuration works>>\n* Get a picture of <<architecture, the overall architecture>>\n* Allow users to <<separating-local-saml2-logout, logout out of the app only>>\n* Customize <<_configuring_logout_endpoints, logout endpoints>>\n* Storing `<saml2:LogoutRequests>` somewhere <<_customizing_storage, other than the session>>", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Minimal Configuration for Single Logout", "heading_level": 2, "file_order": 163, "section_index": 1, "content_hash": "349863d75cb58328018a9ecd15d8b627f5af239e835e5a6d4f4919219258e28a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:a200ff0f453bb40c99358f53438f47a16e880a63c9270d9bd108ba4907c45854", "content": "When these properties are used, in addition to login, SAML 2.0 Service Provider will automatically configure itself facilitate logout by way of ``<saml2:LogoutRequest>``s and ``<saml2:LogoutResponse>``s using either RP- or AP-initiated logout.\n\nIt achieves this through a deterministic startup process:\n\n1. Query the Identity Server Metadata endpoint for the `<SingleLogoutService>` element\n2. Scan the metadata and cache any public signature verification keys\n3. Prepare the appropriate endpoints\n\nA consequence of this process is that the identity server must be up and receiving requests in order for Service Provider to successfully start up.\n\n[NOTE]\nIf the identity server is down when Service Provider queries it (given appropriate timeouts), then startup will fail.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Startup Expectations", "heading_level": 3, "file_order": 163, "section_index": 2, "content_hash": "a200ff0f453bb40c99358f53438f47a16e880a63c9270d9bd108ba4907c45854", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:389a1af58b934fd94af0231dc622883014c9044137d1d88b3ce1c6f160f648e9", "content": "Given the above configuration any logged-in user can send a `POST /logout` to your application to perform RP-initiated SLO.\nYour application will then do the following:\n\n1. Logout the user and invalidate the session\n2. Produce a `<saml2:LogoutRequest>` and POST it to the associated asserting party's SLO endpoint\n3. Then, if the asserting party responds with a `<saml2:LogoutResponse>`, the application with verify it and redirect to the configured success endpoint\n\nAlso, your application can participate in an AP-initiated logout when the asserting party sends a `<saml2:LogoutRequest>` to `/logout/saml2/slo`.\nWhen this happens, your application will do the following:\n\n1. Verify the `<saml2:LogoutRequest>`\n2. Logout the user and invalidate the session\n3. Produce a `<saml2:LogoutResponse>` and POST it back to the asserting party's SLO endpoint", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Runtime Expectations", "heading_level": 3, "file_order": 163, "section_index": 3, "content_hash": "389a1af58b934fd94af0231dc622883014c9044137d1d88b3ce1c6f160f648e9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:ded51e2ac7b9fc97bf28f028c98823d138552bf907758d623822f5c36f27c980", "content": "Instead of Boot properties, you can also achieve the same outcome by publishing the beans directly like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SecurityConfig {\n @Value(\"${private.key}\") RSAPrivateKey key;\n @Value(\"${public.certificate}\") X509Certificate certificate;\n\n @Bean\n RelyingPartyRegistrationRepository registrations() {\n Saml2X509Credential credential = Saml2X509Credential.signing(key, certificate);\n RelyingPartyRegistration registration = RelyingPartyRegistrations\n .fromMetadataLocation(\"https://ap.example.org/metadata\") <1>\n .registrationId(\"metadata\")\n .singleLogoutServiceLocation(\"{baseUrl}/logout/saml2/slo\") <2>\n .signingX509Credentials((signing) -> signing.add(credential)) <3>\n .build();\n return new InMemoryRelyingPartyRegistrationRepository(registration);\n }\n\n @Bean\n SecurityFilterChain web(HttpSecurity http) throws Exception {\n http\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n )\n .saml2Login(withDefaults())\n .saml2Logout(withDefaults()); <4>\n\n return http.build();\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Configuration\nclass SecurityConfig(@Value(\"${private.key}\") val key: RSAPrivateKey,\n @Value(\"${public.certificate}\") val certificate: X509Certificate) {\n\n @Bean\n fun registrations(): RelyingPartyRegistrationRepository {\n val credential = Saml2X509Credential.signing(key, certificate)\n val registration = RelyingPartyRegistrations\n .fromMetadataLocation(\"https://ap.example.org/metadata\") <1>\n .registrationId(\"metadata\")\n .singleLogoutServiceLocation(\"{baseUrl}/logout/saml2/slo\") <2>\n .signingX509Credentials({ signing: List<Saml2X509Credential> -> signing.add(credential) }) <3>\n .build()\n return InMemoryRelyingPartyRegistrationRepository(registration)\n }\n\n @Bean\n fun web(http: HttpSecurity): SecurityFilterChain {\n http {\n authorizeHttpRequests {\n anyRequest = authenticated\n }\n saml2Login {\n\n }\n saml2Logout { <4>\n\n }\n }\n\n return http.build()\n }\n}\n----\n======\n<1> - The metadata URI of the IDP, which will indicate to your application its support of SLO\n<2> - The SLO endpoint in your application\n<3> - The signing credentials to sign ``<saml2:LogoutRequest>``s and ``<saml2:LogoutResponse>``s, which you can also add to xref:servlet/saml2/login/overview.adoc#servlet-saml2login-rpr-duplicated[multiple relying parties]\n<4> - Second, indicate that your application wants to use SAML SLO to logout the end user\n\n[NOTE]\nAdding `saml2Logout` adds the capability for logout to your service provider as a whole.\nBecause it is an optional capability, you need to enable it for each individual `RelyingPartyRegistration`.\nYou do this by setting the `RelyingPartyRegistration.Builder#singleLogoutServiceLocation` property as seen above.\n\n[[architecture]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Minimal Configuration Sans Boot", "heading_level": 2, "file_order": 163, "section_index": 4, "content_hash": "ded51e2ac7b9fc97bf28f028c98823d138552bf907758d623822f5c36f27c980", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:ad3003ad34c106738985c6c960d37ca22d98d3d86b5eae409ad5bfa64a2b99fb", "content": "Next, let's see the architectural components that Spring Security uses to support https://docs.oasis-open.org/security/saml/v2.0/saml-profiles-2.0-os.pdf#page=37[SAML 2.0 Logout] in servlet-based applications, like the one we just saw.\n\nFor RP-initiated logout:\n\nimage:{icondir}/number_1.png[] Spring Security executes its xref:servlet/authentication/logout.adoc#logout-architecture[logout flow], calling its ``LogoutHandler``s to invalidate the session and perform other cleanup.\nIt then invokes the javadoc:org.springframework.security.saml2.provider.service.web.authentication.logout.Saml2RelyingPartyInitiatedLogoutSuccessHandler[].\n\nimage:{icondir}/number_2.png[] The logout success handler uses an instance of\njavadoc:org.springframework.security.saml2.provider.service.web.authentication.logout.Saml2LogoutRequestResolver[] to create, sign, and serialize a `<saml2:LogoutRequest>`.\nIt uses the keys and configuration from the xref:servlet/saml2/login/overview.adoc#servlet-saml2login-relyingpartyregistration[`RelyingPartyRegistration`] that is associated with the current `Saml2AuthenticatedPrincipal`.\nThen, it redirect-POSTs the `<saml2:LogoutRequest>` to the asserting party SLO endpoint\n\nThe browser hands control over to the asserting party.\nIf the asserting party redirects back (which it may not), then the application proceeds to step image:{icondir}/number_3.png[].\n\nimage:{icondir}/number_3.png[] The javadoc:org.springframework.security.saml2.provider.service.web.authentication.logout.Saml2LogoutResponseFilter[] deserializes, verifies, and processes the `<saml2:LogoutResponse>` with its javadoc:org.springframework.security.saml2.provider.service.authentication.logout.Saml2LogoutResponseValidator[].\n\nimage:{icondir}/number_4.png[] If valid, then it completes the local logout flow by redirecting to `/login?logout`, or whatever has been configured.\nIf invalid, then it responds with a 400.\n\nFor AP-initiated logout:\n\nimage:{icondir}/number_1.png[] The javadoc:org.springframework.security.saml2.provider.service.web.authentication.logout.Saml2LogoutRequestFilter[] deserializes, verifies, and processes the `<saml2:LogoutRequest>` with its javadoc:org.springframework.security.saml2.provider.service.authentication.logout.Saml2LogoutRequestValidator[].\n\nimage:{icondir}/number_2.png[] If valid, then the filter calls the configured ``LogoutHandler``s, invalidating the session and performing other cleanup.\n\nimage:{icondir}/number_3.png[] It uses a javadoc:org.springframework.security.saml2.provider.service.web.authentication.logout.Saml2LogoutResponseResolver[] to create, sign and serialize a `<saml2:LogoutResponse>`.\nIt uses the keys and configuration from the xref:servlet/saml2/login/overview.adoc#servlet-saml2login-relyingpartyregistration[`RelyingPartyRegistration`] derived from the endpoint or from the contents of the `<saml2:LogoutRequest>`.\nThen, it redirect-POSTs the `<saml2:LogoutResponse>` to the asserting party SLO endpoint.\n\nThe browser hands control over to the asserting party.\n\nimage:{icondir}/number_4.png[] If invalid, then it https://github.com/spring-projects/spring-security/pull/14676[responds with a 400].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "How Saml 2.0 Logout Works", "heading_level": 2, "file_order": 163, "section_index": 5, "content_hash": "ad3003ad34c106738985c6c960d37ca22d98d3d86b5eae409ad5bfa64a2b99fb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:29f8cb883b0aff5dd65b137e50f7d6c56babeffb8c0a9cc7c7364cc72b891e80", "content": "There are three behaviors that can be triggered by different endpoints:\n\n* RP-initiated logout, which allows an authenticated user to `POST` and trigger the logout process by sending the asserting party a `<saml2:LogoutRequest>`\n* AP-initiated logout, which allows an asserting party to send a `<saml2:LogoutRequest>` to the application\n* AP logout response, which allows an asserting party to send a `<saml2:LogoutResponse>` in response to the RP-initiated `<saml2:LogoutRequest>`\n\nThe first is triggered by performing normal `POST /logout` when the principal is of type `Saml2AuthenticatedPrincipal`.\n\nThe second is triggered by POSTing to the `/logout/saml2/slo` endpoint with a `SAMLRequest` signed by the asserting party.\n\nThe third is triggered by POSTing to the `/logout/saml2/slo` endpoint with a `SAMLResponse` signed by the asserting party.\n\nBecause the user is already logged in or the original Logout Request is known, the `registrationId` is already known.\nFor this reason, `+{registrationId}+` is not part of these URLs by default.\n\nThis URL is customizable in the DSL.\n\nFor example, if you are migrating your existing relying party over to Spring Security, your asserting party may already be pointing to `GET /SLOService.saml2`.\nTo reduce changes in configuration for the asserting party, you can configure the filter in the DSL like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .saml2Logout((saml2) -> saml2\n .logoutRequest((request) -> request.logoutUrl(\"/SLOService.saml2\"))\n .logoutResponse((response) -> response.logoutUrl(\"/SLOService.saml2\"))\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n saml2Logout {\n logoutRequest {\n logoutUrl = \"/SLOService.saml2\"\n }\n logoutResponse {\n logoutUrl = \"/SLOService.saml2\"\n }\n }\n}\n----\n======\n\nYou should also configure these endpoints in your `RelyingPartyRegistration`.\n\nAlso, you can customize the endpoint for triggering logout locally like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .saml2Logout((saml2) -> saml2.logoutUrl(\"/saml2/logout\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n saml2Logout {\n logoutUrl = \"/saml2/logout\"\n }\n}\n----\n======\n\n[[separating-local-saml2-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Configuring Logout Endpoints", "heading_level": 2, "file_order": 163, "section_index": 6, "content_hash": "29f8cb883b0aff5dd65b137e50f7d6c56babeffb8c0a9cc7c7364cc72b891e80", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:ed26167dbddcb82a4b5caef432a60053132bce4ccb2294fb7a1de239d312b081", "content": "In some cases, you may want to expose one logout endpoint for local logout and another for RP-initiated SLO.\nLike is the case with other logout mechanisms, you can register more than one, so long as they each have a different endpoint.\n\nSo, for example, you can wire the DSL like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .logout((logout) -> logout.logoutUrl(\"/logout\"))\n .saml2Logout((saml2) -> saml2.logoutUrl(\"/saml2/logout\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n logout {\n logoutUrl = \"/logout\"\n }\n saml2Logout {\n logoutUrl = \"/saml2/logout\"\n }\n}\n----\n======\n\nand now if a client sends a `POST /logout`, the session will be cleared, but there won't be a `<saml2:LogoutRequest>` sent to the asserting party.\nBut, if the client sends a `POST /saml2/logout`, then the application will initiate SAML 2.0 SLO as normal.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Separating Local Logout from SAML 2.0 Logout", "heading_level": 3, "file_order": 163, "section_index": 7, "content_hash": "ed26167dbddcb82a4b5caef432a60053132bce4ccb2294fb7a1de239d312b081", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:55d8f5c9b702767d8e12e218e712a90cbfd75c40d6d36c90f40bf0fdd3e0d64a", "content": "It's common to need to set other values in the `<saml2:LogoutRequest>` than the defaults that Spring Security provides.\n\nBy default, Spring Security will issue a `<saml2:LogoutRequest>` and supply:\n\n* The `DestinationValidator` attribute - from `RelyingPartyRegistration#getAssertingPartyMetadata#getSingleLogoutServiceLocation`\n* The `ID` attribute - a GUID\n* The `<Issuer>` element - from `RelyingPartyRegistration#getEntityId`\n* The `<NameID>` element - from `Authentication#getName`\n\nTo add other values, you can use delegation, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSaml2LogoutRequestResolver logoutRequestResolver(RelyingPartyRegistrationRepository registrations) {\n\tOpenSaml5LogoutRequestResolver logoutRequestResolver =\n new OpenSaml5LogoutRequestResolver(registrations);\n\tlogoutRequestResolver.setParametersConsumer((parameters) -> {\n String name = ((Saml2AuthenticatedPrincipal) parameters.getAuthentication().getPrincipal()).getFirstAttribute(\"CustomAttribute\");\n String format = \"urn:oasis:names:tc:SAML:2.0:nameid-format:transient\";\n LogoutRequest logoutRequest = parameters.getLogoutRequest();\n NameID nameId = logoutRequest.getNameID();\n nameId.setValue(name);\n nameId.setFormat(format);\n\t});\n\treturn logoutRequestResolver;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun logoutRequestResolver(registrations:RelyingPartyRegistrationRepository?): Saml2LogoutRequestResolver {\n val logoutRequestResolver = OpenSaml5LogoutRequestResolver(registrations)\n logoutRequestResolver.setParametersConsumer { parameters: LogoutRequestParameters ->\n val name: String = (parameters.getAuthentication().getPrincipal() as Saml2AuthenticatedPrincipal).getFirstAttribute(\"CustomAttribute\")\n val format = \"urn:oasis:names:tc:SAML:2.0:nameid-format:transient\"\n val logoutRequest: LogoutRequest = parameters.getLogoutRequest()\n val nameId: NameID = logoutRequest.getNameID()\n nameId.setValue(name)\n nameId.setFormat(format)\n }\n return logoutRequestResolver\n}\n----\n======\n\nThen, you can supply your custom `Saml2LogoutRequestResolver` in the DSL as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .saml2Logout((saml2) -> saml2\n .logoutRequest((request) -> request\n .logoutRequestResolver(this.logoutRequestResolver)\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n saml2Logout {\n logoutRequest {\n logoutRequestResolver = this.logoutRequestResolver\n }\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Customizing `<saml2:LogoutRequest>` Resolution", "heading_level": 2, "file_order": 163, "section_index": 8, "content_hash": "55d8f5c9b702767d8e12e218e712a90cbfd75c40d6d36c90f40bf0fdd3e0d64a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:d71225becd6d977cc7085f2d0061b8fb0938ef8f002b29595fe24df0823ee670", "content": "It's common to need to set other values in the `<saml2:LogoutResponse>` than the defaults that Spring Security provides.\n\nBy default, Spring Security will issue a `<saml2:LogoutResponse>` and supply:\n\n* The `DestinationValidator` attribute - from `RelyingPartyRegistration#getAssertingPartyMetadata#getSingleLogoutServiceResponseLocation`\n* The `ID` attribute - a GUID\n* The `<Issuer>` element - from `RelyingPartyRegistration#getEntityId`\n* The `<Status>` element - `SUCCESS`\n\nTo add other values, you can use delegation, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic Saml2LogoutResponseResolver logoutResponseResolver(RelyingPartyRegistrationRepository registrations) {\n\tOpenSaml5LogoutResponseResolver resolver =\n new OpenSaml5LogoutResponseResolver(registrations);\n\tresolver.setParametersConsumer((parameters) -> {\n if (checkOtherPrevailingConditions(parameters.getRequest())) {\n parameters.getLogoutResponse().getStatus().getStatusCode().setCode(StatusCode.PARTIAL_LOGOUT);\n }\n\t});\n\treturn resolver;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun logoutResponseResolver(registrations: RelyingPartyRegistrationRepository?): Saml2LogoutResponseResolver {\n val resolver = OpenSaml5LogoutResponseResolver(registrations)\n resolver.setParametersConsumer { parameters ->\n if (checkOtherPrevailingConditions(parameters.request)) {\n parameters.logoutResponse.status.statusCode.code = StatusCode.PARTIAL_LOGOUT\n }\n }\n return resolver\n}\n----\n======\n\nThen, you can supply your custom `Saml2LogoutResponseResolver` in the DSL as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .saml2Logout((saml2) -> saml2\n .logoutResponse((request) -> request\n .logoutResponseResolver(this.logoutResponseResolver)\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n saml2Logout {\n logoutResponse {\n logoutResponseResolver = logoutResponseResolver\n }\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Customizing `<saml2:LogoutResponse>` Resolution", "heading_level": 2, "file_order": 163, "section_index": 9, "content_hash": "d71225becd6d977cc7085f2d0061b8fb0938ef8f002b29595fe24df0823ee670", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:4e5307a40530ecdb7d9fb6eac87728d4863a12ff61f28954d0dcf671fe9550d4", "content": "To customize validation, you can implement your own `Saml2LogoutRequestValidator`.\nAt this point, the validation is minimal, so you may be able to first delegate to the default `Saml2LogoutRequestValidator` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class MyOpenSamlLogoutRequestValidator implements Saml2LogoutRequestValidator {\n\tprivate final Saml2LogoutRequestValidator delegate = new OpenSaml5LogoutRequestValidator();\n\n\t@Override\n public Saml2LogoutValidatorResult validate(Saml2LogoutRequestValidatorParameters parameters) {\n // verify signature, issuer, destination, and principal name\n Saml2LogoutValidatorResult result = delegate.validate(authentication);\n\n if(result.hasErrors()){\n return result;\n }\n\n // perform custom validation\n\n return result;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class MyOpenSamlLogoutRequestValidator : Saml2LogoutRequestValidator {\n\tprivate val delegate = OpenSaml5LogoutRequestValidator()\n\n\t@Override\n fun validate(parameters: Saml2LogoutRequestValidatorParameters): Saml2LogoutValidatorResult {\n // verify signature, issuer, destination, and principal name\n val result = delegate.validate(authentication)\n\n if (result.hasErrors()) {\n return result\n }\n\n // perform custom validation\n\n return result\n }\n}\n----\n======\n\nThen, you can supply your custom `Saml2LogoutRequestValidator` in the DSL as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .saml2Logout((saml2) -> saml2\n .logoutRequest((request) -> request\n .logoutRequestValidator(myOpenSamlLogoutRequestValidator)\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n saml2Logout {\n logoutRequest {\n logoutRequestValidator = myOpenSamlLogoutRequestValidator\n }\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Customizing `<saml2:LogoutRequest>` Authentication", "heading_level": 2, "file_order": 163, "section_index": 10, "content_hash": "4e5307a40530ecdb7d9fb6eac87728d4863a12ff61f28954d0dcf671fe9550d4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:c3d184d7fc5f63cc5fcb915ef22f8b0438c8b55b62304cc19a9d2ce6510d4d98", "content": "To customize validation, you can implement your own `Saml2LogoutResponseValidator`.\nAt this point, the validation is minimal, so you may be able to first delegate to the default `Saml2LogoutResponseValidator` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class MyOpenSamlLogoutResponseValidator implements Saml2LogoutResponseValidator {\n\tprivate final Saml2LogoutResponseValidator delegate = new OpenSaml5LogoutResponseValidator();\n\n\t@Override\n public Saml2LogoutValidatorResult validate(Saml2LogoutResponseValidatorParameters parameters) {\n // verify signature, issuer, destination, and status\n Saml2LogoutValidatorResult result = delegate.validate(parameters);\n\n if (result.hasErrors()) {\n return result;\n }\n\n // perform custom validation\n\n return result;\n }\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nopen class MyOpenSamlLogoutResponseValidator : Saml2LogoutResponseValidator {\n\tprivate val delegate = OpenSaml5LogoutResponseValidator()\n\n override fun validate(parameters: Saml2LogoutResponseValidatorParameters): Saml2LogoutValidatorResult {\n // verify signature, issuer, destination, and status\n val result = delegate.validate(authentication)\n\n if (result.hasErrors()) {\n return result\n }\n\n // perform custom validation\n\n return result\n }\n}\n----\n======\n\nThen, you can supply your custom `Saml2LogoutResponseValidator` in the DSL as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .saml2Logout((saml2) -> saml2\n .logoutResponse((response) -> response\n .logoutResponseValidator(myOpenSamlLogoutResponseValidator)\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n saml2Logout {\n logoutResponse {\n logoutResponseValidator = myOpenSamlLogoutResponseValidator\n }\n }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Customizing `<saml2:LogoutResponse>` Authentication", "heading_level": 2, "file_order": 163, "section_index": 11, "content_hash": "c3d184d7fc5f63cc5fcb915ef22f8b0438c8b55b62304cc19a9d2ce6510d4d98", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:b010a08a8bb8dbbcac99483f64cb94bd188c226ac752305beb9764b0e8a720f3", "content": "When your application sends a `<saml2:LogoutRequest>`, the value is stored in the session so that the `RelayState` parameter and the `InResponseTo` attribute in the `<saml2:LogoutResponse>` can be verified.\n\nIf you want to store logout requests in some place other than the session, you can supply your custom implementation in the DSL, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n .saml2Logout((saml2) -> saml2\n .logoutRequest((request) -> request\n .logoutRequestRepository(myCustomLogoutRequestRepository)\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n saml2Logout {\n logoutRequest {\n logoutRequestRepository = myCustomLogoutRequestRepository\n }\n }\n}\n----\n======\n\n[[jc-logout-references]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Customizing `<saml2:LogoutRequest>` storage", "heading_level": 2, "file_order": 163, "section_index": 12, "content_hash": "b010a08a8bb8dbbcac99483f64cb94bd188c226ac752305beb9764b0e8a720f3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:f454676252029a4e1414277fa79ea0b4a657ba5b1424d28c4399763127682563", "content": "- xref:servlet/test/mockmvc/logout.adoc#test-logout[Testing Logout]\n- xref:servlet/integrations/servlet-api.adoc#servletapi-logout[HttpServletRequest.logout()]\n- xref:servlet/exploits/csrf.adoc#csrf-considerations-logout[Logging Out] in section CSRF Caveats", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/logout.adoc", "title": "logout", "heading": "Further Logout-Related References", "heading_level": 2, "file_order": 163, "section_index": 13, "content_hash": "f454676252029a4e1414277fa79ea0b4a657ba5b1424d28c4399763127682563", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/logout.adoc"}}
{"id": "sha256:f16e11ac5a10a420ddaabd04b7fa6ef2f8ce58ab444808bf578dd49daadd770e", "content": "[[servlet-saml2login-metadata]]\n\nSpring Security can <<parsing-asserting-party-metadata,parse asserting party metadata>> to produce an `AssertingPartyMetadata` instance as well as <<publishing-relying-party-metadata,publish relying party metadata>> from a `RelyingPartyRegistration` instance.\n\n[[parsing-asserting-party-metadata]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/metadata.adoc", "title": "metadata", "heading": "metadata", "heading_level": 1, "file_order": 164, "section_index": 0, "content_hash": "f16e11ac5a10a420ddaabd04b7fa6ef2f8ce58ab444808bf578dd49daadd770e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/metadata.adoc"}}
{"id": "sha256:1b8aba69807cc73ab22bc52ef0b916fd14227f8e673cde021d76157e75722176", "content": "You can parse an asserting party's metadata xref:servlet/saml2/login/overview.adoc#servlet-saml2login-relyingpartyregistrationrepository[using `RelyingPartyRegistrations`].\n\nWhen using the OpenSAML vendor support, the resulting `AssertingPartyMetadata` will be of type `OpenSamlAssertingPartyDetails`.\nThis means you'll be able to do get the underlying OpenSAML XMLObject by doing the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOpenSamlAssertingPartyDetails details = (OpenSamlAssertingPartyDetails)\n registration.getAssertingPartyMetadata();\nEntityDescriptor openSamlEntityDescriptor = details.getEntityDescriptor();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval details: OpenSamlAssertingPartyDetails =\n registration.getAssertingPartyMetadata() as OpenSamlAssertingPartyDetails\nval openSamlEntityDescriptor: EntityDescriptor = details.getEntityDescriptor()\n----\n======\n\n[[using-assertingpartymetadatarepository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/metadata.adoc", "title": "metadata", "heading": "Parsing `<saml2:IDPSSODescriptor>` metadata", "heading_level": 2, "file_order": 164, "section_index": 1, "content_hash": "1b8aba69807cc73ab22bc52ef0b916fd14227f8e673cde021d76157e75722176", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/metadata.adoc"}}
{"id": "sha256:9bc639cb555e272454f81463eebe95d9d8461b74180e6ca1f7bd170e4f59d725", "content": "You can also be more targeted than `RelyingPartyRegistrations` by using `AssertingPartyMetadataRepository`, an interface that allows for only retrieving the asserting party metadata.\n\nThis allows three valuable features:\n\n* Implementations can refresh asserting party metadata in an expiry-aware fashion\n* Implementations of `RelyingPartyRegistrationRepository` can more easily articulate a relationship between a relying party and its one or many corresponding asserting parties\n* Implementations can verify metadata signatures\n\nFor example, `OpenSaml5AssertingPartyMetadataRepository` uses OpenSAML's `MetadataResolver`, and API whose implementations regularly refresh the underlying metadata in an expiry-aware fashion.\n\nThis means that you can now create a refreshable `RelyingPartyRegistrationRepository` in just a few lines of code:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Component\npublic class RefreshableRelyingPartyRegistrationRepository\n implements IterableRelyingPartyRegistrationRepository {\n\n\tprivate final AssertingPartyMetadataRepository metadata =\n OpenSaml5AssertingPartyMetadataRepository\n .fromTrustedMetadataLocation(\"https://idp.example.org/metadata\").build();\n\n\t@Override\n public RelyingPartyRegistration findByRegistrationId(String registrationId) {\n AssertingPartyMetadata metadata = this.metadata.findByEntityId(registrationId);\n if (metadata == null) {\n return null;\n }\n return applyRelyingParty(metadata);\n }\n\n\t@Override\n public Iterator<RelyingPartyRegistration> iterator() {\n return StreamSupport.stream(this.metadata.spliterator(), false)\n .map(this::applyRelyingParty).iterator();\n }\n\n\tprivate RelyingPartyRegistration applyRelyingParty(AssertingPartyMetadata metadata) {\n return RelyingPartyRegistration.withAssertingPartyMetadata(metadata)\n // apply any relying party configuration\n .build();\n\t}\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Component\nclass RefreshableRelyingPartyRegistrationRepository : IterableRelyingPartyRegistrationRepository {\n\n private val metadata: AssertingPartyMetadataRepository =\n OpenSaml5AssertingPartyMetadataRepository.fromTrustedMetadataLocation(\n \"https://idp.example.org/metadata\").build()\n\n fun findByRegistrationId(registrationId:String?): RelyingPartyRegistration {\n val metadata = this.metadata.findByEntityId(registrationId)\n if (metadata == null) {\n return null\n }\n return applyRelyingParty(metadata)\n }\n\n fun iterator(): Iterator<RelyingPartyRegistration> {\n return StreamSupport.stream(this.metadata.spliterator(), false)\n .map(this::applyRelyingParty).iterator()\n }\n\n private fun applyRelyingParty(metadata: AssertingPartyMetadata): RelyingPartyRegistration {\n val details: AssertingPartyMetadata = metadata as AssertingPartyMetadata\n return RelyingPartyRegistration.withAssertingPartyMetadata(details)\n // apply any relying party configuration\n .build()\n }\n }\n----\n======\n\n[TIP]\n`OpenSaml5AssertingPartyMetadataRepository` also ships with a constructor so you can provide a custom `MetadataResolver`. Since the underlying `MetadataResolver` is doing the expiring and refreshing, if you use the constructor directly, you will only get these features by providing an implementation that does so.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/metadata.adoc", "title": "metadata", "heading": "Using `AssertingPartyMetadataRepository`", "heading_level": 3, "file_order": 164, "section_index": 2, "content_hash": "9bc639cb555e272454f81463eebe95d9d8461b74180e6ca1f7bd170e4f59d725", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/metadata.adoc"}}
{"id": "sha256:5c45f9fbb4a42dd4ef591030fac6262b486622ccb080a672f0ed5beba0a62649", "content": "You can also verify metadata signatures using `OpenSaml5AssertingPartyMetadataRepository` by providing the appropriate set of ``Saml2X509Credential``s as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOpenSaml5AssertingPartyMetadataRepository.withMetadataLocation(\"https://idp.example.org/metadata\")\n .verificationCredentials((c) -> c.add(myVerificationCredential))\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nOpenSaml5AssertingPartyMetadataRepository.withMetadataLocation(\"https://idp.example.org/metadata\")\n .verificationCredentials({ c : Collection<Saml2X509Credential> ->\n c.add(myVerificationCredential) })\n .build()\n----\n======\n\n[NOTE]\nIf no credentials are provided, the component will not perform signature validation.\n\n[[publishing-relying-party-metadata]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/metadata.adoc", "title": "metadata", "heading": "Verifying Metadata Signatures", "heading_level": 3, "file_order": 164, "section_index": 3, "content_hash": "5c45f9fbb4a42dd4ef591030fac6262b486622ccb080a672f0ed5beba0a62649", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/metadata.adoc"}}
{"id": "sha256:aac2df43c8c60f6ca937b449db296561af61091056262366cd229ec5ed14499e", "content": "You can publish a metadata endpoint using the `saml2Metadata` DSL method, as you'll see below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nhttp\n // ...\n .saml2Login(withDefaults())\n .saml2Metadata(withDefaults());\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nhttp {\n //...\n saml2Login { }\n saml2Metadata { }\n}\n----\n======\n\nYou can use this metadata endpoint to register your relying party with your asserting party.\nThis is often as simple as finding the correct form field to supply the metadata endpoint.\n\nBy default, the metadata endpoint is `+/saml2/metadata+`, though it also responds to `+/saml2/metadata/{registrationId}+` and `+/saml2/service-provider-metadata/{registrationId}+`.\n\nYou can change this by calling the `metadataUrl` method in the DSL:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n.saml2Metadata((saml2) -> saml2.metadataUrl(\"/saml/metadata\"))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nsaml2Metadata {\n\tmetadataUrl = \"/saml/metadata\"\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/metadata.adoc", "title": "metadata", "heading": "Producing `<saml2:SPSSODescriptor>` Metadata", "heading_level": 2, "file_order": 164, "section_index": 4, "content_hash": "aac2df43c8c60f6ca937b449db296561af61091056262366cd229ec5ed14499e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/metadata.adoc"}}
{"id": "sha256:5f9db975112d4cbdab22efc580f69c71e25b14ea97337d38364d689a5a07b733", "content": "If you have a different strategy for identifying which `RelyingPartyRegistration` to use, you can configure your own `Saml2MetadataResponseResolver` like the one below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSaml2MetadataResponseResolver metadataResponseResolver(RelyingPartyRegistrationRepository registrations) {\n\tRequestMatcherMetadataResponseResolver metadata = new RequestMatcherMetadataResponseResolver(\n (id) -> registrations.findByRegistrationId(\"relying-party\"));\n\tmetadata.setMetadataFilename(\"metadata.xml\");\n\treturn metadata;\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun metadataResponseResolver(val registrations: RelyingPartyRegistrationRepository): Saml2MetadataResponseResolver {\n val metadata = new RequestMatcherMetadataResponseResolver(\n id: String -> registrations.findByRegistrationId(\"relying-party\"))\n\tmetadata.setMetadataFilename(\"metadata.xml\")\n\treturn metadata\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/metadata.adoc", "title": "metadata", "heading": "Changing the Way a `RelyingPartyRegistration` Is Looked Up", "heading_level": 2, "file_order": 164, "section_index": 5, "content_hash": "5f9db975112d4cbdab22efc580f69c71e25b14ea97337d38364d689a5a07b733", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/metadata.adoc"}}
{"id": "sha256:7c08ad838e0eb10fb3a477d1ab1fb3d9e83225ecabc47ce52f7fdd8584c6818a", "content": "This document contains guidance for moving SAML 2.0 Service Providers from Spring Security SAML Extensions 1.x to Spring Security Since Spring Security doesnt provide Identity Provider support, migrating a Spring Security SAML Extensions Identity Provider is out of scope for this document.\n\nBecause the two approaches are as different as they are, this document will tend to cover patterns more than precise search-and-replace steps.\n\n[[saml2-login-logout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc", "title": "SAML 2.0 Extension Migration", "heading": "SAML 2.0 Extension Migration", "heading_level": 1, "file_order": 165, "section_index": 0, "content_hash": "7c08ad838e0eb10fb3a477d1ab1fb3d9e83225ecabc47ce52f7fdd8584c6818a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc"}}
{"id": "sha256:9f823bdf13551f2970f7e846b49474d3f4bb18eea3a717907482522210f62322", "content": "https://github.com/spring-projects/spring-security[Spring Security] takes a slightly different approach from https://github.com/spring-projects/spring-security-saml[Spring Security SAML Extensions] in a few notable ways.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc", "title": "SAML 2.0 Extension Migration", "heading": "Changes In Approach", "heading_level": 3, "file_order": 165, "section_index": 1, "content_hash": "9f823bdf13551f2970f7e846b49474d3f4bb18eea3a717907482522210f62322", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc"}}
{"id": "sha256:37d22f54109f212883730c4b1fc84b87226c5155cb39c4b15b0c8f3a876f0e91", "content": "Spring Security SAML Extensions support for Service Providers is provided by a series of filters enabled by adding each filter manually in the correct order to various Spring Security filter chains.\n\nSpring Securitys SAML 2.0 Service Provider support is enabled via the Spring Security DSL methods:\nxref:servlet/saml2/login/index.adoc[`saml2Login`],\nxref:servlet/saml2/logout.adoc[`saml2Logout`], and\nxref:servlet/saml2/metadata.adoc[`saml2Metadata`]. It selects the correct filters to add and puts them in the appropriate places in the filter chain.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc", "title": "SAML 2.0 Extension Migration", "heading": "Simplified Enablement", "heading_level": 4, "file_order": 165, "section_index": 2, "content_hash": "37d22f54109f212883730c4b1fc84b87226c5155cb39c4b15b0c8f3a876f0e91", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc"}}
{"id": "sha256:e90ece21ae27493f25397ca7902de483bdea7ee5c81ee677a52ccedc1a44306f", "content": "Like Spring Security SAML Extensions, Spring Security bases its SAML support on OpenSAML. The Extensions project exposes OpenSAML over public interfaces, blurring the lines between the two projects, effectively requiring OpenSAML, and making upgrades to later versions of OpenSAML more complicated.\n\nSpring Security provides stronger encapsulation. No public interfaces expose OpenSAML components and any class that exposes OpenSAML in its public API is named with an `OpenSaml` prefix for additional clarity.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc", "title": "SAML 2.0 Extension Migration", "heading": "Stronger Encapsulation", "heading_level": 4, "file_order": 165, "section_index": 3, "content_hash": "e90ece21ae27493f25397ca7902de483bdea7ee5c81ee677a52ccedc1a44306f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc"}}
{"id": "sha256:06bd1ecd4f66e6230c6d2795f761d5cf777b82a5f3a77b281d4363bef9be63db", "content": "Spring Security SAML Extensions offered some lightweight support for declaring more than one Identity Provider and accessing it at login time using the `idp` request parameter. This was limiting as far as changing things at runtime was concerned and also doesnt allow for a many-to-many relationship between relying and asserting parties.\n\nSpring Security builds SAML 2.0 multitenancy into its default URLs and basic components in the form of a `RelyingPartyRegistration`. This component acts as a link between a Relying Partys metadata and an Asserting Partys metadata, and all pairs are available for lookup in a `RelyingPartyRegistrationRepository`. Each URL represents a unique registration pair to be retrieved.\n\nWhether its AuthnRequests, Responses, LogoutRequests, LogoutResponses, or EntityDescriptors, each filter is based off of `RelyingPartyRegistrationRepository` and so is fundamentally multi-tenant.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc", "title": "SAML 2.0 Extension Migration", "heading": "Out-of-the-box Multitenancy", "heading_level": 4, "file_order": 165, "section_index": 4, "content_hash": "06bd1ecd4f66e6230c6d2795f761d5cf777b82a5f3a77b281d4363bef9be63db", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc"}}
{"id": "sha256:9b7d662014b4b4d1ca8476417ce8d56f1e7e1c5ffe5b5c9d61b4e7904b962f2d", "content": "Both Spring Security and Spring Security SAML Extensions have examples for how to configure the Service Provider:\n\n[options=\"header\"]\n|===\n| Use case | Spring Security | Spring Security SAML Extension\n\n| Login & Logout | https://github.com/spring-projects/spring-security-samples/tree/main/servlet/spring-boot/java/saml2/login[Sample] |\nhttps://github.com/jzheaux/spring-security-saml-migrate/tree/main/login-logout[Sample]\n| Login using SAML Extension URLs | https://github.com/spring-projects/spring-security-samples/tree/main/servlet/spring-boot/java/saml2/custom-urls[Sample] | -\n| Metadata support | https://github.com/spring-projects/spring-security-samples/tree/main/servlet/spring-boot/java/saml2/refreshable-metadata[Sample] | -\n|===\n\nYou can also see a showcase example in https://github.com/spring-projects/spring-security-saml/tree/main/sample[Spring Security SAML Extension]'s GitHub project.\n\n[NOTE]\n====\nSpring Security does not support HTTP-Redirect binding for SAML 2.0 Responses.\nAccording to the SAML specification, the HTTP-Redirect binding is not permitted for SAML Responses due to URL length and signature limitations. Attempting to use this binding may result in unexpected errors.\nUse HTTP-POST binding instead when configuring your identity provider.\n====\n\n[[saml2-unported]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc", "title": "SAML 2.0 Extension Migration", "heading": "Examples Matrix", "heading_level": 3, "file_order": 165, "section_index": 5, "content_hash": "9b7d662014b4b4d1ca8476417ce8d56f1e7e1c5ffe5b5c9d61b4e7904b962f2d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc"}}
{"id": "sha256:3fdc1440013115afd8c44c642c27185a6e2af759328ab987225941ee2bb0e4cc", "content": "There are some features that are not yet ported over and there are as yet no plans to do so:\n\n* HTTP-Redirect binding for SAML 2.0 Responses\n* Artifact binding support", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc", "title": "SAML 2.0 Extension Migration", "heading": "Unported Features", "heading_level": 2, "file_order": 165, "section_index": 6, "content_hash": "3fdc1440013115afd8c44c642c27185a6e2af759328ab987225941ee2bb0e4cc", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/saml2/saml-extension-migration.adoc"}}
{"id": "sha256:72154e20d95408f365bdafebbaf54596c369d39a09f0ea7c51e35a7b25bdae0a", "content": "[[test-mockmvc-securitycontextholder]]\n\nIt is often desirable to run tests as a specific user.\nThere are two simple ways to populate the user:\n\n* <<test-mockmvc-securitycontextholder-rpp,Running as a User in Spring MVC Test with RequestPostProcessor>>\n* <<test-mockmvc-withmockuser,Running as a User in Spring MVC Test with Annotations>>\n\n[[test-mockmvc-securitycontextholder-rpp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/authentication.adoc", "title": "authentication", "heading": "authentication", "heading_level": 1, "file_order": 166, "section_index": 0, "content_hash": "72154e20d95408f365bdafebbaf54596c369d39a09f0ea7c51e35a7b25bdae0a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/authentication.adoc"}}
{"id": "sha256:65e023219e434a17db8caf462a050be3297c7b68c22d6bbeda1ca249aef5d183", "content": "You have a number of options to associate a user to the current `HttpServletRequest`.\nThe following example runs as a user (which does not need to exist) whose username is `user`, whose password is `password`, and whose role is `ROLE_USER`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(get(\"/\").with(user(\"user\")))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/\") {\n with(user(\"user\"))\n}\n----\n======\n\n[NOTE]\n====\nThe support works by associating the user to the `HttpServletRequest`.\nTo associate the request to the `SecurityContextHolder`, you need to ensure that the `SecurityContextPersistenceFilter` is associated with the `MockMvc` instance.\nYou can do so in a number of ways:\n\n* Invoking xref:servlet/test/mockmvc/setup.adoc#test-mockmvc-setup[`apply(springSecurity())`]\n* Adding Spring Security's `FilterChainProxy` to `MockMvc`\n* Manually adding `SecurityContextPersistenceFilter` to the `MockMvc` instance may make sense when using `MockMvcBuilders.standaloneSetup`\n====\n\nYou can easily make customizations.\nFor example, the following will run as a user (which does not need to exist) with the username \"admin\", the password \"pass\", and the roles \"ROLE_USER\" and \"ROLE_ADMIN\".\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(get(\"/admin\").with(user(\"admin\").password(\"pass\").roles(\"USER\",\"ADMIN\")))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/admin\") {\n with(user(\"admin\").password(\"pass\").roles(\"USER\",\"ADMIN\"))\n}\n----\n======\n\nIf you have a custom `UserDetails` that you would like to use, you can easily specify that as well.\nFor example, the following will use the specified `UserDetails` (which does not need to exist) to run with a `UsernamePasswordAuthenticationToken` that has a principal of the specified `UserDetails`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(get(\"/\").with(user(userDetails)))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/\") {\n with(user(userDetails))\n}\n----\n======\n\nYou can run as anonymous user using the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(get(\"/\").with(anonymous()))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/\") {\n with(anonymous())\n}\n----\n======\n\nThis is especially useful if you are running with a default user and wish to process a few requests as an anonymous user.\n\nIf you want a custom `Authentication` (which does not need to exist) you can do so using the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(get(\"/\").with(authentication(authentication)))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/\") {\n with(authentication(authentication))\n}\n----\n======\n\nYou can even customize the `SecurityContext` using the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(get(\"/\").with(securityContext(securityContext)))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/\") {\n with(securityContext(securityContext))\n}\n----\n======\n\nWe can also ensure to run as a specific user for every request by using ``MockMvcBuilders``'s default request.\nFor example, the following will run as a user (which does not need to exist) with the username \"admin\", the password \"password\", and the role \"ROLE_ADMIN\":\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc = MockMvcBuilders\n .webAppContextSetup(context)\n .defaultRequest(get(\"/\").with(user(\"user\").roles(\"ADMIN\")))\n .apply(springSecurity())\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc = MockMvcBuilders\n .webAppContextSetup(context)\n .defaultRequest<DefaultMockMvcBuilder>(get(\"/\").with(user(\"user\").roles(\"ADMIN\")))\n .apply<DefaultMockMvcBuilder>(springSecurity())\n .build()\n----\n======\n\nIf you find you are using the same user in many of your tests, it is recommended to move the user to a method.\nFor example, you can specify the following in your own class named `CustomSecurityMockMvcRequestPostProcessors`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic static RequestPostProcessor rob() {\n\treturn user(\"rob\").roles(\"ADMIN\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nfun rob(): RequestPostProcessor {\n return user(\"rob\").roles(\"ADMIN\")\n}\n----\n======\n\nNow you can perform a static import on `CustomSecurityMockMvcRequestPostProcessors` and use that within your tests:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static sample.CustomSecurityMockMvcRequestPostProcessors.*;\n\n...\n\nmvc\n\t.perform(get(\"/\").with(rob()))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport sample.CustomSecurityMockMvcRequestPostProcessors.*\n\nmvc.get(\"/\") {\n with(rob())\n}\n----\n======\n\n[[test-mockmvc-withmockuser]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/authentication.adoc", "title": "authentication", "heading": "Running as a User in Spring MVC Test with RequestPostProcessor", "heading_level": 2, "file_order": 166, "section_index": 1, "content_hash": "65e023219e434a17db8caf462a050be3297c7b68c22d6bbeda1ca249aef5d183", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/authentication.adoc"}}
{"id": "sha256:accc5aa552b1921833f9bb439e2b47fe3c7e9056d9c76bb86d8d5e8520c508ff", "content": "As an alternative to using a `RequestPostProcessor` to create your user, you can use annotations described in xref:servlet/test/method.adoc[Testing Method Security].\nFor example, the following will run the test with the user with username \"user\", password \"password\", and role \"ROLE_USER\":\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Test\n@WithMockUser\npublic void requestProtectedUrlWithUser() throws Exception {\nmvc\n .perform(get(\"/\"))\n ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Test\n@WithMockUser\nfun requestProtectedUrlWithUser() {\n mvc\n .get(\"/\")\n // ...\n}\n----\n======\n\nAlternatively, the following will run the test with the user with username \"user\", password \"password\", and role \"ROLE_ADMIN\":\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Test\n@WithMockUser(roles=\"ADMIN\")\npublic void requestProtectedUrlWithUser() throws Exception {\nmvc\n .perform(get(\"/\"))\n ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Test\n@WithMockUser(roles = [\"ADMIN\"])\nfun requestProtectedUrlWithUser() {\n mvc\n .get(\"/\")\n // ...\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/authentication.adoc", "title": "authentication", "heading": "Running as a User in Spring MVC Test with Annotations", "heading_level": 2, "file_order": 166, "section_index": 2, "content_hash": "accc5aa552b1921833f9bb439e2b47fe3c7e9056d9c76bb86d8d5e8520c508ff", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/authentication.adoc"}}
{"id": "sha256:0268d511a5a6d741dca248c84271da178303ce06b5bab22a80aa9c20e0913086", "content": "[[test-mockmvc-csrf]]\n\nWhen testing any non-safe HTTP methods and using Spring Security's CSRF protection, you must include a valid CSRF Token in the request.\nTo specify a valid CSRF token as a request parameter use the CSRF xref:servlet/test/mockmvc/request-post-processors.adoc[`RequestPostProcessor`] like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(post(\"/\").with(csrf()))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.post(\"/\") {\n with(csrf())\n}\n----\n======\n\nIf you like, you can include CSRF token in the header instead:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(post(\"/\").with(csrf().asHeader()))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.post(\"/\") {\n with(csrf().asHeader())\n}\n----\n======\n\nYou can also test providing an invalid CSRF token by using the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(post(\"/\").with(csrf().useInvalidToken()))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.post(\"/\") {\n with(csrf().useInvalidToken())\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/csrf.adoc", "title": "csrf", "heading": "csrf", "heading_level": 1, "file_order": 167, "section_index": 0, "content_hash": "0268d511a5a6d741dca248c84271da178303ce06b5bab22a80aa9c20e0913086", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/csrf.adoc"}}
{"id": "sha256:811e65f282a7d317d30046061ce7eb4f176398d7f1942e58a7fe31f16aa7d1e8", "content": "You can easily create a request to test a form based authentication using Spring Security's testing support.\nFor example, the following `formLogin` xref:servlet/test/mockmvc/request-post-processors.adoc[`RequestPostProcessor`] will submit a POST to \"/login\" with the username \"user\", the password \"password\", and a valid CSRF token:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(formLogin())\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc\n\t.perform(formLogin())\n----\n======\n\nIt is easy to customize the request.\nFor example, the following will submit a POST to \"/auth\" with the username \"admin\", the password \"pass\", and a valid CSRF token:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(formLogin(\"/auth\").user(\"admin\").password(\"pass\"))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc\n .perform(formLogin(\"/auth\").user(\"admin\").password(\"pass\"))\n----\n======\n\nWe can also customize the parameters names that the username and password are included on.\nFor example, this is the above request modified to include the username on the HTTP parameter \"u\" and the password on the HTTP parameter \"p\".\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(formLogin(\"/auth\").user(\"u\",\"admin\").password(\"p\",\"pass\"))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc\n .perform(formLogin(\"/auth\").user(\"u\",\"admin\").password(\"p\",\"pass\"))\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/form-login.adoc", "title": "Testing Form Based Authentication", "heading": "Testing Form Based Authentication", "heading_level": 1, "file_order": 168, "section_index": 0, "content_hash": "811e65f282a7d317d30046061ce7eb4f176398d7f1942e58a7fe31f16aa7d1e8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/form-login.adoc"}}
{"id": "sha256:77425f5a798771afe926655ea81460e6021e11cb20200b1bf7e7a3401d2e6701", "content": "While it has always been possible to authenticate with HTTP Basic, it was a bit tedious to remember the header name, format, and encode the values.\nNow this can be done using Spring Security's `httpBasic` xref:servlet/test/mockmvc/request-post-processors.adoc[`RequestPostProcessor`].\nFor example, the snippet below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(get(\"/\").with(httpBasic(\"user\",\"password\")))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/\") {\n with(httpBasic(\"user\",\"password\"))\n}\n----\n======\n\nwill attempt to use HTTP Basic to authenticate a user with the username \"user\" and the password \"password\" by ensuring the following header is populated on the HTTP Request:\n\n[source,text]\n----\nAuthorization: Basic dXNlcjpwYXNzd29yZA==\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/http-basic.adoc", "title": "Testing HTTP Basic Authentication", "heading": "Testing HTTP Basic Authentication", "heading_level": 1, "file_order": 169, "section_index": 0, "content_hash": "77425f5a798771afe926655ea81460e6021e11cb20200b1bf7e7a3401d2e6701", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/http-basic.adoc"}}
{"id": "sha256:920c67811b5cb002c3100a66fd3881dcc923319139d0a8de2325702538f63006", "content": "[[test-mockmvc]]\n\nSpring Security provides comprehensive integration with {spring-framework-reference-url}testing/mockmvc.html[Spring MVC Test]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 170, "section_index": 0, "content_hash": "920c67811b5cb002c3100a66fd3881dcc923319139d0a8de2325702538f63006", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/index.adoc"}}
{"id": "sha256:a54cbdfd119061c5dc56d910fb7d2b22155c8c12c0269b5fbd29cff880c51eb4", "content": "[[test-logout]]\n\nWhile fairly trivial using standard Spring MVC Test, you can use Spring Security's testing support to make testing log out easier.\nFor example, the following `logout` xref:servlet/test/mockmvc/request-post-processors.adoc[`RequestPostProcessor`] will submit a POST to \"/logout\" with a valid CSRF token:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(logout())\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc\n .perform(logout())\n----\n======\n\nYou can also customize the URL to post to.\nFor example, the snippet below will submit a POST to \"/signout\" with a valid CSRF token:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(logout(\"/signout\"))\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc\n\t.perform(logout(\"/signout\"))\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/logout.adoc", "title": "logout", "heading": "logout", "heading_level": 1, "file_order": 171, "section_index": 0, "content_hash": "a54cbdfd119061c5dc56d910fb7d2b22155c8c12c0269b5fbd29cff880c51eb4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/logout.adoc"}}
{"id": "sha256:0dca9c1bc99710dfb18339133c157efa0155e3f8a1fce343124845bedaf86f79", "content": "[[testing-oauth2]]\n\nWhen it comes to OAuth 2.0, the same principles covered earlier still apply: Ultimately, it depends on what your method under test is expecting to be in the `SecurityContextHolder`.\n\nFor example, for a controller that looks like this:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic String foo(Principal user) {\n return user.getName();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(user: Principal): String {\n return user.name\n}\n----\n======\n\nThere's nothing OAuth2-specific about it, so you will likely be able to simply xref:servlet/test/method.adoc#test-method-withmockuser[use `@WithMockUser`] and be fine.\n\nBut, in cases where your controllers are bound to some aspect of Spring Security's OAuth 2.0 support, like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic String foo(@AuthenticationPrincipal OidcUser user) {\n return user.getIdToken().getSubject();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(@AuthenticationPrincipal user: OidcUser): String {\n return user.idToken.subject\n}\n----\n======\n\nthen Spring Security's test support can come in handy.\n\n[[testing-oidc-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "oauth2", "heading_level": 1, "file_order": 172, "section_index": 0, "content_hash": "0dca9c1bc99710dfb18339133c157efa0155e3f8a1fce343124845bedaf86f79", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:45763c6b9ca45e14ec30e7570af61b798f0e56af245d46d0fa9f6d8cd13c01a6", "content": "Testing the method above with Spring MVC Test would require simulating some kind of grant flow with an authorization server.\nCertainly this would be a daunting task, which is why Spring Security ships with support for removing this boilerplate.\n\nFor example, we can tell Spring Security to include a default `OidcUser` using the `oidcLogin` xref:servlet/test/mockmvc/request-post-processors.adoc[`RequestPostProcessor`], like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\").with(oidcLogin()));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(oidcLogin())\n}\n----\n======\n\nWhat this will do is configure the associated `MockHttpServletRequest` with an `OidcUser` that includes a simple `OidcIdToken`, `OidcUserInfo`, and `Collection` of granted authorities.\n\nSpecifically, it will include an `OidcIdToken` with a `sub` claim set to `user`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(user.getIdToken().getClaim(\"sub\")).isEqualTo(\"user\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(user.idToken.getClaim<String>(\"sub\")).isEqualTo(\"user\")\n----\n======\n\nan `OidcUserInfo` with no claims set:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(user.getUserInfo().getClaims()).isEmpty();\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(user.userInfo.claims).isEmpty()\n----\n======\n\nand a `Collection` of authorities with just one authority, `SCOPE_read`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(user.getAuthorities()).hasSize(1);\nassertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority(\"SCOPE_read\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(user.authorities).hasSize(1)\nassertThat(user.authorities).containsExactly(SimpleGrantedAuthority(\"SCOPE_read\"))\n----\n======\n\nSpring Security does the necessary work to make sure that the `OidcUser` instance is available for xref:servlet/integrations/mvc.adoc#mvc-authentication-principal[the `@AuthenticationPrincipal` annotation].\n\nFurther, it also links that `OidcUser` to a simple instance of `OAuth2AuthorizedClient` that it deposits into an mock `OAuth2AuthorizedClientRepository`.\nThis can be handy if your tests <<testing-oauth2-client,use the `@RegisteredOAuth2AuthorizedClient` annotation>>..\n\n[[testing-oidc-login-authorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Testing OIDC Login", "heading_level": 2, "file_order": 172, "section_index": 1, "content_hash": "45763c6b9ca45e14ec30e7570af61b798f0e56af245d46d0fa9f6d8cd13c01a6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:7dca272107c17a0ab9be91c2d5f669738f575128d7f798ec2cb89e334c05c63a", "content": "In many circumstances, your method is protected by filter or method security and needs your `Authentication` to have certain granted authorities to allow the request.\n\nIn this case, you can supply what granted authorities you need using the `authorities()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\")\n .with(oidcLogin()\n .authorities(new SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(oidcLogin()\n .authorities(SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n}\n----\n======\n\n[[testing-oidc-login-claims]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Configuring Authorities", "heading_level": 2, "file_order": 172, "section_index": 2, "content_hash": "7dca272107c17a0ab9be91c2d5f669738f575128d7f798ec2cb89e334c05c63a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:c7ebc95a146a551a9038c9efb979ebe29eb8fd9ada7d8700c2d863d5860b5ece", "content": "And while granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0.\n\nLet's say, for example, that you've got a `user_id` claim that indicates the user's id in your system.\nYou might access it like so in a controller:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic String foo(@AuthenticationPrincipal OidcUser oidcUser) {\n String userId = oidcUser.getIdToken().getClaim(\"user_id\");\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(@AuthenticationPrincipal oidcUser: OidcUser): String {\n val userId = oidcUser.idToken.getClaim<String>(\"user_id\")\n // ...\n}\n----\n======\n\nIn that case, you'd want to specify that claim with the `idToken()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\")\n .with(oidcLogin()\n .idToken((token) -> token.claim(\"user_id\", \"1234\"))\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(oidcLogin()\n .idToken {\n it.claim(\"user_id\", \"1234\")\n }\n )\n}\n----\n======\n\nsince `OidcUser` collects its claims from `OidcIdToken`.\n\n[[testing-oidc-login-user]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Configuring Claims", "heading_level": 2, "file_order": 172, "section_index": 3, "content_hash": "c7ebc95a146a551a9038c9efb979ebe29eb8fd9ada7d8700c2d863d5860b5ece", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:cce440267ab341cf7925c822c747a9106266d02f575843ce6f29bfe1f7104c71", "content": "There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:\n\n* `userInfo(OidcUserInfo.Builder)` - For configuring the `OidcUserInfo` instance\n* `clientRegistration(ClientRegistration)` - For configuring the associated `OAuth2AuthorizedClient` with a given `ClientRegistration`\n* `oidcUser(OidcUser)` - For configuring the complete `OidcUser` instance\n\nThat last one is handy if you:\n1. Have your own implementation of `OidcUser`, or\n2. Need to change the name attribute\n\nFor example, let's say that your authorization server sends the principal name in the `user_name` claim instead of the `sub` claim.\nIn that case, you can configure an `OidcUser` by hand:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOidcUser oidcUser = new DefaultOidcUser(\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\"),\n OidcIdToken.withTokenValue(\"id-token\").claim(\"user_name\", \"foo_user\").build(),\n \"user_name\");\n\nmvc\n .perform(get(\"/endpoint\")\n .with(oidcLogin().oidcUser(oidcUser))\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval oidcUser: OidcUser = DefaultOidcUser(\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\"),\n OidcIdToken.withTokenValue(\"id-token\").claim(\"user_name\", \"foo_user\").build(),\n \"user_name\"\n)\n\nmvc.get(\"/endpoint\") {\n with(oidcLogin().oidcUser(oidcUser))\n}\n----\n======\n\n[[testing-oauth2-login]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Additional Configurations", "heading_level": 2, "file_order": 172, "section_index": 4, "content_hash": "cce440267ab341cf7925c822c747a9106266d02f575843ce6f29bfe1f7104c71", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:b902c0bd855eba84beb417a6e46ebe01293bf6ddd8e4c8611a41f46c0ff55ebf", "content": "As with <<testing-oidc-login,testing OIDC login>>, testing OAuth 2.0 Login presents a similar challenge of mocking a grant flow.\nAnd because of that, Spring Security also has test support for non-OIDC use cases.\n\nLet's say that we've got a controller that gets the logged-in user as an `OAuth2User`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic String foo(@AuthenticationPrincipal OAuth2User oauth2User) {\n return oauth2User.getAttribute(\"sub\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(@AuthenticationPrincipal oauth2User: OAuth2User): String? {\n return oauth2User.getAttribute(\"sub\")\n}\n----\n======\n\nIn that case, we can tell Spring Security to include a default `OAuth2User` using the `oauth2Login` xref:servlet/test/mockmvc/request-post-processors.adoc[`RequestPostProcessor`], like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\").with(oauth2Login()));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(oauth2Login())\n}\n----\n======\n\nWhat this will do is configure the associated `MockHttpServletRequest` with an `OAuth2User` that includes a simple `Map` of attributes and `Collection` of granted authorities.\n\nSpecifically, it will include a `Map` with a key/value pair of `sub`/`user`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat((String) user.getAttribute(\"sub\")).isEqualTo(\"user\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(user.getAttribute<String>(\"sub\")).isEqualTo(\"user\")\n----\n======\n\nand a `Collection` of authorities with just one authority, `SCOPE_read`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(user.getAuthorities()).hasSize(1);\nassertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority(\"SCOPE_read\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(user.authorities).hasSize(1)\nassertThat(user.authorities).containsExactly(SimpleGrantedAuthority(\"SCOPE_read\"))\n----\n======\n\nSpring Security does the necessary work to make sure that the `OAuth2User` instance is available for xref:servlet/integrations/mvc.adoc#mvc-authentication-principal[the `@AuthenticationPrincipal` annotation].\n\nFurther, it also links that `OAuth2User` to a simple instance of `OAuth2AuthorizedClient` that it deposits in a mock `OAuth2AuthorizedClientRepository`.\nThis can be handy if your tests <<testing-oauth2-client,use the `@RegisteredOAuth2AuthorizedClient` annotation>>.\n\n[[testing-oauth2-login-authorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Testing OAuth 2.0 Login", "heading_level": 2, "file_order": 172, "section_index": 5, "content_hash": "b902c0bd855eba84beb417a6e46ebe01293bf6ddd8e4c8611a41f46c0ff55ebf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:fab71284c97d0b770f8ec68c0b502ae91e1075c7fc70f484a9fe37324e0a6275", "content": "In many circumstances, your method is protected by filter or method security and needs your `Authentication` to have certain granted authorities to allow the request.\n\nIn this case, you can supply what granted authorities you need using the `authorities()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\")\n .with(oauth2Login()\n .authorities(new SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(oauth2Login()\n .authorities(SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n}\n----\n======\n\n[[testing-oauth2-login-claims]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Configuring Authorities", "heading_level": 2, "file_order": 172, "section_index": 6, "content_hash": "fab71284c97d0b770f8ec68c0b502ae91e1075c7fc70f484a9fe37324e0a6275", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:23cfe7b78115ec78322f75352db655b0aa1bceca7c9835080fb49c51f5d1903f", "content": "And while granted authorities are quite common across all of Spring Security, we also have claims in the case of OAuth 2.0.\n\nLet's say, for example, that you've got a `user_id` attribute that indicates the user's id in your system.\nYou might access it like so in a controller:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic String foo(@AuthenticationPrincipal OAuth2User oauth2User) {\n String userId = oauth2User.getAttribute(\"user_id\");\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(@AuthenticationPrincipal oauth2User: OAuth2User): String {\n val userId = oauth2User.getAttribute<String>(\"user_id\")\n // ...\n}\n----\n======\n\nIn that case, you'd want to specify that attribute with the `attributes()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\")\n .with(oauth2Login()\n .attributes((attrs) -> attrs.put(\"user_id\", \"1234\"))\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(oauth2Login()\n .attributes { attrs -> attrs[\"user_id\"] = \"1234\" }\n )\n}\n----\n======\n\n[[testing-oauth2-login-user]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Configuring Claims", "heading_level": 2, "file_order": 172, "section_index": 7, "content_hash": "23cfe7b78115ec78322f75352db655b0aa1bceca7c9835080fb49c51f5d1903f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:37b0df0de5a0d43a0f68afb3757d68572753305c22311976fa06dc71dd0b6cf0", "content": "There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:\n\n* `clientRegistration(ClientRegistration)` - For configuring the associated `OAuth2AuthorizedClient` with a given `ClientRegistration`\n* `oauth2User(OAuth2User)` - For configuring the complete `OAuth2User` instance\n\nThat last one is handy if you:\n1. Have your own implementation of `OAuth2User`, or\n2. Need to change the name attribute\n\nFor example, let's say that your authorization server sends the principal name in the `user_name` claim instead of the `sub` claim.\nIn that case, you can configure an `OAuth2User` by hand:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nOAuth2User oauth2User = new DefaultOAuth2User(\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\"),\n Collections.singletonMap(\"user_name\", \"foo_user\"),\n \"user_name\");\n\nmvc\n .perform(get(\"/endpoint\")\n .with(oauth2Login().oauth2User(oauth2User))\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval oauth2User: OAuth2User = DefaultOAuth2User(\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\"),\n mapOf(Pair(\"user_name\", \"foo_user\")),\n \"user_name\"\n)\n\nmvc.get(\"/endpoint\") {\n with(oauth2Login().oauth2User(oauth2User))\n}\n----\n======\n\n[[testing-oauth2-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Additional Configurations", "heading_level": 2, "file_order": 172, "section_index": 8, "content_hash": "37b0df0de5a0d43a0f68afb3757d68572753305c22311976fa06dc71dd0b6cf0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:1df155fd7a00db8c848eceb6859c73a98843175fefa56e7270f6f813bcb0d5fe", "content": "Independent of how your user authenticates, you may have other tokens and client registrations that are in play for the request you are testing.\nFor example, your controller may be relying on the client credentials grant to get a token that isn't associated with the user at all:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic String foo(@RegisteredOAuth2AuthorizedClient(\"my-app\") OAuth2AuthorizedClient authorizedClient) {\n return this.webClient.get()\n .attributes(oauth2AuthorizedClient(authorizedClient))\n .retrieve()\n .bodyToMono(String.class)\n .block();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(@RegisteredOAuth2AuthorizedClient(\"my-app\") authorizedClient: OAuth2AuthorizedClient?): String? {\n return this.webClient.get()\n .attributes(oauth2AuthorizedClient(authorizedClient))\n .retrieve()\n .bodyToMono(String::class.java)\n .block()\n}\n----\n======\n\nSimulating this handshake with the authorization server could be cumbersome.\nInstead, you can use the `oauth2Client` xref:servlet/test/mockmvc/request-post-processors.adoc[`RequestPostProcessor`] to add a `OAuth2AuthorizedClient` into a mock `OAuth2AuthorizedClientRepository`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\").with(oauth2Client(\"my-app\")));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(\n oauth2Client(\"my-app\")\n )\n}\n----\n======\n\nWhat this will do is create an `OAuth2AuthorizedClient` that has a simple `ClientRegistration`, `OAuth2AccessToken`, and resource owner name.\n\nSpecifically, it will include a `ClientRegistration` with a client id of \"test-client\" and client secret of \"test-secret\":\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(authorizedClient.getClientRegistration().getClientId()).isEqualTo(\"test-client\");\nassertThat(authorizedClient.getClientRegistration().getClientSecret()).isEqualTo(\"test-secret\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(authorizedClient.clientRegistration.clientId).isEqualTo(\"test-client\")\nassertThat(authorizedClient.clientRegistration.clientSecret).isEqualTo(\"test-secret\")\n----\n======\n\na resource owner name of \"user\":\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(authorizedClient.getPrincipalName()).isEqualTo(\"user\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(authorizedClient.principalName).isEqualTo(\"user\")\n----\n======\n\nand an `OAuth2AccessToken` with just one scope, `read`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(authorizedClient.getAccessToken().getScopes()).hasSize(1);\nassertThat(authorizedClient.getAccessToken().getScopes()).containsExactly(\"read\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(authorizedClient.accessToken.scopes).hasSize(1)\nassertThat(authorizedClient.accessToken.scopes).containsExactly(\"read\")\n----\n======\n\nThe client can then be retrieved as normal using `@RegisteredOAuth2AuthorizedClient` in a controller method.\n\n[[testing-oauth2-client-scopes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Testing OAuth 2.0 Clients", "heading_level": 2, "file_order": 172, "section_index": 9, "content_hash": "1df155fd7a00db8c848eceb6859c73a98843175fefa56e7270f6f813bcb0d5fe", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:aee7be2707d83f5523b4cf276e80a780544ef02aaa1daec70dbf8bc1cde6f067", "content": "In many circumstances, the OAuth 2.0 access token comes with a set of scopes.\nIf your controller inspects these, say like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic String foo(@RegisteredOAuth2AuthorizedClient(\"my-app\") OAuth2AuthorizedClient authorizedClient) {\n Set<String> scopes = authorizedClient.getAccessToken().getScopes();\n if (scopes.contains(\"message:read\")) {\n return this.webClient.get()\n .attributes(oauth2AuthorizedClient(authorizedClient))\n .retrieve()\n .bodyToMono(String.class)\n .block();\n }\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(@RegisteredOAuth2AuthorizedClient(\"my-app\") authorizedClient: OAuth2AuthorizedClient): String? {\n val scopes = authorizedClient.accessToken.scopes\n if (scopes.contains(\"message:read\")) {\n return webClient.get()\n .attributes(oauth2AuthorizedClient(authorizedClient))\n .retrieve()\n .bodyToMono(String::class.java)\n .block()\n }\n // ...\n}\n----\n======\n\nthen you can configure the scope using the `accessToken()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\")\n .with(oauth2Client(\"my-app\")\n .accessToken(new OAuth2AccessToken(BEARER, \"token\", null, null, Collections.singleton(\"message:read\"))))\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(oauth2Client(\"my-app\")\n .accessToken(OAuth2AccessToken(BEARER, \"token\", null, null, Collections.singleton(\"message:read\")))\n )\n}\n----\n======\n\n[[testing-oauth2-client-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Configuring Scopes", "heading_level": 2, "file_order": 172, "section_index": 10, "content_hash": "aee7be2707d83f5523b4cf276e80a780544ef02aaa1daec70dbf8bc1cde6f067", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:268372bf717284fc074757a1cbbc202f6b240599335ae6b9863462a26ab43793", "content": "There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects:\n\n* `principalName(String)` - For configuring the resource owner name\n* `clientRegistration(Consumer<ClientRegistration.Builder>)` - For configuring the associated `ClientRegistration`\n* `clientRegistration(ClientRegistration)` - For configuring the complete `ClientRegistration`\n\nThat last one is handy if you want to use a real `ClientRegistration`\n\nFor example, let's say that you are wanting to use one of your app's `ClientRegistration` definitions, as specified in your `application.yml`.\n\nIn that case, your test can autowire the `ClientRegistrationRepository` and look up the one your test needs:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Autowired\nClientRegistrationRepository clientRegistrationRepository;\n\nmvc\n .perform(get(\"/endpoint\")\n .with(oauth2Client()\n .clientRegistration(this.clientRegistrationRepository.findByRegistrationId(\"facebook\"))));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Autowired\nlateinit var clientRegistrationRepository: ClientRegistrationRepository\n\nmvc.get(\"/endpoint\") {\n with(oauth2Client(\"my-app\")\n .clientRegistration(clientRegistrationRepository.findByRegistrationId(\"facebook\"))\n )\n}\n----\n======\n\n[[testing-jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Additional Configurations", "heading_level": 2, "file_order": 172, "section_index": 11, "content_hash": "268372bf717284fc074757a1cbbc202f6b240599335ae6b9863462a26ab43793", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:74952253e77fefc9f886534448f90008df7c9c60b9a8df2c79ec4bc34fad35e7", "content": "In order to make an authorized request on a resource server, you need a bearer token.\n\nIf your resource server is configured for JWTs, then this would mean that the bearer token needs to be signed and then encoded according to the JWT specification.\nAll of this can be quite daunting, especially when this isn't the focus of your test.\n\nFortunately, there are a number of simple ways that you can overcome this difficulty and allow your tests to focus on authorization and not on representing bearer tokens.\nWe'll look at two of them now:", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Testing JWT Authentication", "heading_level": 2, "file_order": 172, "section_index": 12, "content_hash": "74952253e77fefc9f886534448f90008df7c9c60b9a8df2c79ec4bc34fad35e7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:c3e05ff48f197efb2c943450c8a64961fb4bc7c96fb1283bd589ff0b867ba434", "content": "The first way is via the `jwt` xref:servlet/test/mockmvc/request-post-processors.adoc[`RequestPostProcessor`].\nThe simplest of these would look something like this:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\").with(jwt()));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(jwt())\n}\n----\n======\n\nWhat this will do is create a mock `Jwt`, passing it correctly through any authentication APIs so that it's available for your authorization mechanisms to verify.\n\nBy default, the `JWT` that it creates has the following characteristics:\n\n[source,json]\n----\n{\n \"headers\" : { \"alg\" : \"none\" },\n \"claims\" : {\n \"sub\" : \"user\",\n \"scope\" : \"read\"\n }\n}\n----\n\nAnd the resulting `Jwt`, were it tested, would pass in the following way:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(jwt.getTokenValue()).isEqualTo(\"token\");\nassertThat(jwt.getHeaders().get(\"alg\")).isEqualTo(\"none\");\nassertThat(jwt.getSubject()).isEqualTo(\"sub\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(jwt.tokenValue).isEqualTo(\"token\")\nassertThat(jwt.headers[\"alg\"]).isEqualTo(\"none\")\nassertThat(jwt.subject).isEqualTo(\"sub\")\n----\n======\n\nThese values can, of course be configured.\n\nAny headers or claims can be configured with their corresponding methods:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\")\n .with(jwt().jwt((jwt) -> jwt.header(\"kid\", \"one\").claim(\"iss\", \"https://idp.example.org\"))));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(\n jwt().jwt { jwt -> jwt.header(\"kid\", \"one\").claim(\"iss\", \"https://idp.example.org\") }\n )\n}\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\")\n .with(jwt().jwt((jwt) -> jwt.claims((claims) -> claims.remove(\"scope\")))));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(\n jwt().jwt { jwt -> jwt.claims { claims -> claims.remove(\"scope\") } }\n )\n}\n----\n======\n\nThe `scope` and `scp` claims are processed the same way here as they are in a normal bearer token request.\nHowever, this can be overridden simply by providing the list of `GrantedAuthority` instances that you need for your test:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\")\n .with(jwt().authorities(new SimpleGrantedAuthority(\"SCOPE_messages\"))));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(\n jwt().authorities(SimpleGrantedAuthority(\"SCOPE_messages\"))\n )\n}\n----\n======\n\nOr, if you have a custom `Jwt` to `Collection<GrantedAuthority>` converter, you can also use that to derive the authorities:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\")\n .with(jwt().authorities(new MyConverter())));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(\n jwt().authorities(MyConverter())\n )\n}\n----\n======\n\nYou can also specify a complete `Jwt`, for which javadoc:org.springframework.security.oauth2.jwt.Jwt$Builder[] comes quite handy:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nJwt jwt = Jwt.withTokenValue(\"token\")\n .header(\"alg\", \"none\")\n .claim(\"sub\", \"user\")\n .claim(\"scope\", \"read\")\n .build();\n\nmvc\n .perform(get(\"/endpoint\")\n .with(jwt().jwt(jwt)));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwt: Jwt = Jwt.withTokenValue(\"token\")\n .header(\"alg\", \"none\")\n .claim(\"sub\", \"user\")\n .claim(\"scope\", \"read\")\n .build()\n\nmvc.get(\"/endpoint\") {\n with(\n jwt().jwt(jwt)\n )\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "`jwt() RequestPostProcessor`", "heading_level": 2, "file_order": 172, "section_index": 13, "content_hash": "c3e05ff48f197efb2c943450c8a64961fb4bc7c96fb1283bd589ff0b867ba434", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:b8bc92b8106d5be5a05941ebeb3db5700abf477e3808e08150f04527ab1b6982", "content": "The second way is by using the `authentication()` xref:servlet/test/mockmvc/request-post-processors.adoc[`RequestPostProcessor`].\nEssentially, you can instantiate your own `JwtAuthenticationToken` and provide it in your test, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nJwt jwt = Jwt.withTokenValue(\"token\")\n .header(\"alg\", \"none\")\n .claim(\"sub\", \"user\")\n .build();\nCollection<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList(\"SCOPE_read\");\nJwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities);\n\nmvc\n .perform(get(\"/endpoint\")\n .with(authentication(token)));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval jwt = Jwt.withTokenValue(\"token\")\n .header(\"alg\", \"none\")\n .claim(\"sub\", \"user\")\n .build()\nval authorities: Collection<GrantedAuthority> = AuthorityUtils.createAuthorityList(\"SCOPE_read\")\nval token = JwtAuthenticationToken(jwt, authorities)\n\nmvc.get(\"/endpoint\") {\n with(\n authentication(token)\n )\n}\n----\n======\n\nNote that as an alternative to these, you can also mock the `JwtDecoder` bean itself with a `@MockBean` annotation.\n\n[[testing-opaque-token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "`authentication()` `RequestPostProcessor`", "heading_level": 2, "file_order": 172, "section_index": 14, "content_hash": "b8bc92b8106d5be5a05941ebeb3db5700abf477e3808e08150f04527ab1b6982", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:6215f4c422eea0a1f8b54f7ea942f9c7d560d09443ca77bcb79d833220f14ba3", "content": "Similar to <<testing-jwt,JWTs>>, opaque tokens require an authorization server in order to verify their validity, which can make testing more difficult.\nTo help with that, Spring Security has test support for opaque tokens.\n\nLet's say that we've got a controller that retrieves the authentication as a `BearerTokenAuthentication`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic String foo(BearerTokenAuthentication authentication) {\n return (String) authentication.getTokenAttributes().get(\"sub\");\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(authentication: BearerTokenAuthentication): String {\n return authentication.tokenAttributes[\"sub\"] as String\n}\n----\n======\n\nIn that case, we can tell Spring Security to include a default `BearerTokenAuthentication` using the `opaqueToken` xref:servlet/test/mockmvc/request-post-processors.adoc[`RequestPostProcessor`] method, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\").with(opaqueToken()));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(opaqueToken())\n}\n----\n======\n\nWhat this will do is configure the associated `MockHttpServletRequest` with a `BearerTokenAuthentication` that includes a simple `OAuth2AuthenticatedPrincipal`, `Map` of attributes, and `Collection` of granted authorities.\n\nSpecifically, it will include a `Map` with a key/value pair of `sub`/`user`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat((String) token.getTokenAttributes().get(\"sub\")).isEqualTo(\"user\");\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(token.tokenAttributes[\"sub\"] as String).isEqualTo(\"user\")\n----\n======\n\nand a `Collection` of authorities with just one authority, `SCOPE_read`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nassertThat(token.getAuthorities()).hasSize(1);\nassertThat(token.getAuthorities()).containsExactly(new SimpleGrantedAuthority(\"SCOPE_read\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nassertThat(token.authorities).hasSize(1)\nassertThat(token.authorities).containsExactly(SimpleGrantedAuthority(\"SCOPE_read\"))\n----\n======\n\nSpring Security does the necessary work to make sure that the `BearerTokenAuthentication` instance is available for your controller methods.\n\n[[testing-opaque-token-authorities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Testing Opaque Token Authentication", "heading_level": 2, "file_order": 172, "section_index": 15, "content_hash": "6215f4c422eea0a1f8b54f7ea942f9c7d560d09443ca77bcb79d833220f14ba3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:092c52b4725f364bcb5b59689a0391995367d18b7caf056f97c79de3a2be4d88", "content": "In many circumstances, your method is protected by filter or method security and needs your `Authentication` to have certain granted authorities to allow the request.\n\nIn this case, you can supply what granted authorities you need using the `authorities()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\")\n .with(opaqueToken()\n .authorities(new SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(opaqueToken()\n .authorities(SimpleGrantedAuthority(\"SCOPE_message:read\"))\n )\n}\n----\n======\n\n[[testing-opaque-token-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Configuring Authorities", "heading_level": 2, "file_order": 172, "section_index": 16, "content_hash": "092c52b4725f364bcb5b59689a0391995367d18b7caf056f97c79de3a2be4d88", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:dc9ac194e5328beeafd5d7636cfae7439e3e251789f7cac715ffdb9f0ede6a86", "content": "And while granted authorities are quite common across all of Spring Security, we also have attributes in the case of OAuth 2.0.\n\nLet's say, for example, that you've got a `user_id` attribute that indicates the user's id in your system.\nYou might access it like so in a controller:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@GetMapping(\"/endpoint\")\npublic String foo(BearerTokenAuthentication authentication) {\n String userId = (String) authentication.getTokenAttributes().get(\"user_id\");\n // ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@GetMapping(\"/endpoint\")\nfun foo(authentication: BearerTokenAuthentication): String {\n val userId = authentication.tokenAttributes[\"user_id\"] as String\n // ...\n}\n----\n======\n\nIn that case, you'd want to specify that attribute with the `attributes()` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n .perform(get(\"/endpoint\")\n .with(opaqueToken()\n .attributes((attrs) -> attrs.put(\"user_id\", \"1234\"))\n )\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc.get(\"/endpoint\") {\n with(opaqueToken()\n .attributes { attrs -> attrs[\"user_id\"] = \"1234\" }\n )\n}\n----\n======\n\n[[testing-opaque-token-principal]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Configuring Claims", "heading_level": 2, "file_order": 172, "section_index": 17, "content_hash": "dc9ac194e5328beeafd5d7636cfae7439e3e251789f7cac715ffdb9f0ede6a86", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:2d1795ed285b9d5a07072de2cf692993b1cda49fdec1a0b55246150fec0c22fe", "content": "There are additional methods, too, for further configuring the authentication; it simply depends on what data your controller expects.\n\nOne such is `principal(OAuth2AuthenticatedPrincipal)`, which you can use to configure the complete `OAuth2AuthenticatedPrincipal` instance that underlies the `BearerTokenAuthentication`\n\nIt's handy if you:\n1. Have your own implementation of `OAuth2AuthenticatedPrincipal`, or\n2. Want to specify a different principal name\n\nFor example, let's say that your authorization server sends the principal name in the `user_name` attribute instead of the `sub` attribute.\nIn that case, you can configure an `OAuth2AuthenticatedPrincipal` by hand:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nMap<String, Object> attributes = Collections.singletonMap(\"user_name\", \"foo_user\");\nOAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal(\n (String) attributes.get(\"user_name\"),\n attributes,\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\"));\n\nmvc\n .perform(get(\"/endpoint\")\n .with(opaqueToken().principal(principal))\n );\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nval attributes: Map<String, Any> = Collections.singletonMap(\"user_name\", \"foo_user\")\nval principal: OAuth2AuthenticatedPrincipal = DefaultOAuth2AuthenticatedPrincipal(\n attributes[\"user_name\"] as String?,\n attributes,\n AuthorityUtils.createAuthorityList(\"SCOPE_message:read\")\n)\n\nmvc.get(\"/endpoint\") {\n with(opaqueToken().principal(principal))\n}\n----\n======\n\nNote that as an alternative to using `opaqueToken()` test support, you can also mock the `OpaqueTokenIntrospector` bean itself with a `@MockBean` annotation.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc", "title": "oauth2", "heading": "Additional Configurations", "heading_level": 2, "file_order": 172, "section_index": 18, "content_hash": "2d1795ed285b9d5a07072de2cf692993b1cda49fdec1a0b55246150fec0c22fe", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/oauth2.adoc"}}
{"id": "sha256:5c2dffae3b2db1f384310050bf776e5730eeb30de4eaadd1eea7005996387ddf", "content": "Spring MVC Test also provides a `RequestBuilder` interface that can be used to create the `MockHttpServletRequest` used in your test.\nSpring Security provides a few `RequestBuilder` implementations that can be used to make testing easier.\nIn order to use Spring Security's `RequestBuilder` implementations ensure the following static import is used:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.*;\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestBuilders.*\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/request-builders.adoc", "title": "SecurityMockMvcRequestBuilders", "heading": "SecurityMockMvcRequestBuilders", "heading_level": 1, "file_order": 173, "section_index": 0, "content_hash": "5c2dffae3b2db1f384310050bf776e5730eeb30de4eaadd1eea7005996387ddf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/request-builders.adoc"}}
{"id": "sha256:79ce7c55e40d4dc41d346b467dc5e649ce5876686354b0bf89463068da0a7517", "content": "[[test-mockmvc-smmrpp]]\nSpring MVC Test provides a convenient interface (`RequestPostProcessor`) that you can use to modify a request.\nSpring Security provides a number of `RequestPostProcessor` implementations that make testing easier.\nTo use Spring Security's `RequestPostProcessor` implementations, use the following static import:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*;\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/request-post-processors.adoc", "title": "request-post-processors", "heading": "request-post-processors", "heading_level": 1, "file_order": 174, "section_index": 0, "content_hash": "79ce7c55e40d4dc41d346b467dc5e649ce5876686354b0bf89463068da0a7517", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/request-post-processors.adoc"}}
{"id": "sha256:67dcc1dd9b9a77c1db4eb81cf67ca5cf47ea5a24534e16ba15f9278929a04894", "content": "Spring Security provides a few ``ResultHandler``s implementations.\nIn order to use Spring Security's ``ResultHandler``s implementations ensure the following static import is used:\n\n[source,java]\n----\nimport static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultHandlers.*;\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/result-handlers.adoc", "title": "SecurityMockMvcResultHandlers", "heading": "SecurityMockMvcResultHandlers", "heading_level": 1, "file_order": 175, "section_index": 0, "content_hash": "67dcc1dd9b9a77c1db4eb81cf67ca5cf47ea5a24534e16ba15f9278929a04894", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/result-handlers.adoc"}}
{"id": "sha256:1fe5e265b0bfc4207ba66acb9e358eeb1eb2c3df06675ab72dba6018931bf0f1", "content": "Often times we want to query a repository to see if some `MockMvc` request actually persisted in the database.\nIn some cases our repository query uses the xref:features/integrations/data.adoc[Spring Data Integration] to filter the results based on current user's username or any other property.\nLet's see an example:\n\nA repository interface:\n[source,java]\n----\nprivate interface MessageRepository extends JpaRepository<Message, Long> {\n\t@Query(\"SELECT m.content FROM Message m WHERE m.sentBy = ?#{ principal?.name }\")\n\tList<String> findAllUserMessages();\n}\n----\n\nOur test scenario:\n\n[source,java]\n----\nmvc\n\t.perform(post(\"/message\")\n .content(\"New Message\")\n .contentType(MediaType.TEXT_PLAIN)\n\t)\n\t.andExpect(status().isOk());\n\nList<String> userMessages = messageRepository.findAllUserMessages();\nassertThat(userMessages).hasSize(1);\n----\n\nThis test won't pass because after our request finishes, the `SecurityContextHolder` will be cleared out by the filter chain.\nWe can then export the `TestSecurityContextHolder` to our `SecurityContextHolder` and use it as we want:\n\n[source,java]\n----\nmvc\n\t.perform(post(\"/message\")\n .content(\"New Message\")\n .contentType(MediaType.TEXT_PLAIN)\n\t)\n\t.andDo(exportTestSecurityContext())\n\t.andExpect(status().isOk());\n\nList<String> userMessages = messageRepository.findAllUserMessages();\nassertThat(userMessages).hasSize(1);\n----\n\n[NOTE]\n====\nRemember to clear the `SecurityContextHolder` between your tests, or it may leak amongst them\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/result-handlers.adoc", "title": "SecurityMockMvcResultHandlers", "heading": "Exporting the SecurityContext", "heading_level": 2, "file_order": 175, "section_index": 1, "content_hash": "1fe5e265b0bfc4207ba66acb9e358eeb1eb2c3df06675ab72dba6018931bf0f1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/result-handlers.adoc"}}
{"id": "sha256:aa8d32228af247e703798090615de8208c6fc8fd636ba7e486a27f622b9bf72e", "content": "At times it is desirable to make various security related assertions about a request.\nTo accommodate this need, Spring Security Test support implements Spring MVC Test's `ResultMatcher` interface.\nIn order to use Spring Security's `ResultMatcher` implementations ensure the following static import is used:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nimport static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.*;\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.*\n\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/result-matchers.adoc", "title": "SecurityMockMvcResultMatchers", "heading": "SecurityMockMvcResultMatchers", "heading_level": 1, "file_order": 176, "section_index": 0, "content_hash": "aa8d32228af247e703798090615de8208c6fc8fd636ba7e486a27f622b9bf72e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/result-matchers.adoc"}}
{"id": "sha256:f56e8ebb4c2fd44ee683165985264b2e4f28888ef2916935029d82c533009483", "content": "At times it may be valuable to assert that there is no authenticated user associated with the result of a `MockMvc` invocation.\nFor example, you might want to test submitting an invalid username and password and verify that no user is authenticated.\nYou can easily do this with Spring Security's testing support using something like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(formLogin().password(\"invalid\"))\n\t.andExpect(unauthenticated());\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc\n .perform(formLogin().password(\"invalid\"))\n .andExpect { unauthenticated() }\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/result-matchers.adoc", "title": "SecurityMockMvcResultMatchers", "heading": "Unauthenticated Assertion", "heading_level": 2, "file_order": 176, "section_index": 1, "content_hash": "f56e8ebb4c2fd44ee683165985264b2e4f28888ef2916935029d82c533009483", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/result-matchers.adoc"}}
{"id": "sha256:587df0986a5fef883b80e832aedf1034885eb6d80e90ac60382ef03a89983c83", "content": "It is often times that we must assert that an authenticated user exists.\nFor example, we may want to verify that we authenticated successfully.\nWe could verify that a form based login was successful with the following snippet of code:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(formLogin())\n\t.andExpect(authenticated());\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc\n .perform(formLogin())\n .andExpect { authenticated() }\n----\n======\n\nIf we wanted to assert the roles of the user, we could refine our previous code as shown below:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(formLogin().user(\"admin\"))\n\t.andExpect(authenticated().withRoles(\"USER\",\"ADMIN\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc\n .perform(formLogin())\n .andExpect { authenticated().withRoles(\"USER\",\"ADMIN\") }\n----\n======\n\nAlternatively, we could verify the username:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(formLogin().user(\"admin\"))\n\t.andExpect(authenticated().withUsername(\"admin\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc\n .perform(formLogin().user(\"admin\"))\n .andExpect { authenticated().withUsername(\"admin\") }\n----\n======\n\nWe can also combine the assertions:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(formLogin().user(\"admin\"))\n\t.andExpect(authenticated().withUsername(\"admin\").withRoles(\"USER\", \"ADMIN\"));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc\n .perform(formLogin().user(\"admin\"))\n .andExpect { authenticated().withUsername(\"admin\").withRoles(\"USER\", \"ADMIN\") }\n----\n======\n\nWe can also make arbitrary assertions on the authentication\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\nmvc\n\t.perform(formLogin())\n\t.andExpect(authenticated().withAuthentication(auth ->\n assertThat(auth).isInstanceOf(UsernamePasswordAuthenticationToken.class)));\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nmvc\n .perform(formLogin())\n .andExpect {\n authenticated().withAuthentication { auth ->\n assertThat(auth).isInstanceOf(UsernamePasswordAuthenticationToken::class.java) }\n }\n }\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/result-matchers.adoc", "title": "SecurityMockMvcResultMatchers", "heading": "Authenticated Assertion", "heading_level": 2, "file_order": 176, "section_index": 2, "content_hash": "587df0986a5fef883b80e832aedf1034885eb6d80e90ac60382ef03a89983c83", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/result-matchers.adoc"}}
{"id": "sha256:0d2fbf05d6dd144945dc1b802f4df7e995f9e60940cd5fe65506e3783b918b6c", "content": "[[test-mockmvc-setup]]\n\n[NOTE]\n====\nSpring Security's testing support requires spring-test-4.1.3.RELEASE or greater.\n====\n\nTo use Spring Security with Spring MVC Test, add the Spring Security `FilterChainProxy` as a `Filter`.\nYou also need to add Spring Security's `TestSecurityContextHolderPostProcessor` to support xref:servlet/test/mockmvc/authentication.adoc#test-mockmvc-withmockuser[Running as a User in Spring MVC Test with Annotations].\nTo do so, use Spring Security's `SecurityMockMvcConfigurers.springSecurity()`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n\nimport static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*;\n\n@ExtendWith(SpringExtension.class)\n@ContextConfiguration(classes = SecurityConfig.class)\n@WebAppConfiguration\npublic class CsrfShowcaseTests {\n\n\t@Autowired\n\tprivate WebApplicationContext context;\n\n\tprivate MockMvc mvc;\n\n\t@BeforeEach\n\tpublic void setup() {\n mvc = MockMvcBuilders\n .webAppContextSetup(context)\n .apply(springSecurity()) // <1>\n .build();\n\t}\n\t// ...\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@ExtendWith(SpringExtension::class)\n@ContextConfiguration(classes = [SecurityConfig::class])\n@WebAppConfiguration\nclass CsrfShowcaseTests {\n\n @Autowired\n private lateinit var context: WebApplicationContext\n\n private lateinit var mvc: MockMvc\n\n @BeforeEach\n fun setup() {\n mvc = MockMvcBuilders\n .webAppContextSetup(context)\n .apply<DefaultMockMvcBuilder>(springSecurity()) // <1>\n .build()\n }\n // ...\n}\n----\n======\n<1> `SecurityMockMvcConfigurers.springSecurity()` will perform all of the initial setup we need to integrate Spring Security with Spring MVC Test", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/mockmvc/setup.adoc", "title": "setup", "heading": "setup", "heading_level": 1, "file_order": 177, "section_index": 0, "content_hash": "0d2fbf05d6dd144945dc1b802f4df7e995f9e60940cd5fe65506e3783b918b6c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/mockmvc/setup.adoc"}}
{"id": "sha256:1e1dbdf1fa9800f77701fb44cb13928bff38e57df986117feae231f1124f255c", "content": "[[test]]\n\nThis section describes the testing support provided by Spring Security.\n\nTo use the Spring Security test support, you must include `spring-security-test-{spring-security-version}.jar` as a dependency of your project.\n\nAt a high level Spring Security's test support provides integration for:", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 178, "section_index": 0, "content_hash": "1e1dbdf1fa9800f77701fb44cb13928bff38e57df986117feae231f1124f255c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/index.adoc"}}
{"id": "sha256:3e38908310e14e6b4783f19508d718fba820158c85b5e2e707f7541f1cb3b3ee", "content": "[[test-method]]\n\nThis section demonstrates how to use Spring Security's Test support to test method-based security.\nWe first introduce a `MessageService` that requires the user to be authenticated to be able to access it:\n\ninclude-code::./HelloMessageService[tag=authenticated,indent=0]\n\nThe result of `getMessage` is a `String` that says \"`Hello`\" to the current Spring Security `Authentication`.\nThe following listing shows example output:\n\n[source,text]\n----\nHello org.springframework.security.authentication.UsernamePasswordAuthenticationToken@ca25360: Principal: org.springframework.security.core.userdetails.User@36ebcb: Username: user; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_USER; Credentials: [PROTECTED]; Authenticated: true; Details: null; Granted Authorities: ROLE_USER\n----\n\n[[test-method-setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/method.adoc", "title": "method", "heading": "method", "heading_level": 1, "file_order": 179, "section_index": 0, "content_hash": "3e38908310e14e6b4783f19508d718fba820158c85b5e2e707f7541f1cb3b3ee", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/method.adoc"}}
{"id": "sha256:01ca9fe28c65d7b4ecec9a47a89db6524f2d63797d18fd1f04f63259974176e7", "content": "Before we can use the Spring Security test support, we must perform some setup:\n\ninclude-code::./WithMockUserTests[tag=setup,indent=0]\n\n<1> `@ExtendWith` instructs the spring-test module that it should create an `ApplicationContext`. For additional information, refer to the {spring-framework-reference-url}testing.html#testcontext-junit-jupiter-extension[Spring reference].\n<2> `@ContextConfiguration` instructs the spring-test the configuration to use to create the `ApplicationContext`. Since no configuration is specified, the default configuration locations will be tried. This is no different than using the existing Spring Test support. For additional information, refer to the {spring-framework-reference-url}testing.html#spring-testing-annotation-contextconfiguration[Spring Reference].\n\n[NOTE]\n====\nSpring Security hooks into Spring Test support through the `WithSecurityContextTestExecutionListener`, which ensures that our tests are run with the correct user.\nIt does this by populating the `SecurityContextHolder` prior to running our tests.\nIf you use reactive method security, you also need `ReactorContextTestExecutionListener`, which populates `ReactiveSecurityContextHolder`.\nAfter the test is done, it clears out the `SecurityContextHolder`.\nIf you need only Spring Security related support, you can replace `@ContextConfiguration` with `@SecurityTestExecutionListeners`.\n====\n\nRemember, we added the `@PreAuthorize` annotation to our `HelloMessageService`, so it requires an authenticated user to invoke it.\nIf we run the tests, we expect the following test will pass:\n\ninclude-code::./WithMockUserSampleTests[tag=snippet,indent=0]\n\n[[test-method-withmockuser]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/method.adoc", "title": "method", "heading": "Security Test Setup", "heading_level": 2, "file_order": 179, "section_index": 1, "content_hash": "01ca9fe28c65d7b4ecec9a47a89db6524f2d63797d18fd1f04f63259974176e7", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/method.adoc"}}
{"id": "sha256:92d58a83978cc16925a2a24f89de1f6b06b6d396e23b2f02aa8c227d48e9241e", "content": "The question is \"How could we most easily run the test as a specific user?\"\nThe answer is to use `@WithMockUser`.\nThe following test will be run as a user with the username \"user\", the password \"password\", and the roles \"ROLE_USER\".\n\ninclude-code::./WithMockUserTests[tag=mock-user,indent=0]\n\nSpecifically the following is true:\n\n* The user with a username of `user` does not have to exist, since we mock the user object.\n* The `Authentication` that is populated in the `SecurityContext` is of type `UsernamePasswordAuthenticationToken`.\n* The principal on the `Authentication` is Spring Security's `User` object.\n* The `User` has a username of `user`.\n* The `User` has a password of `password`.\n* A single `GrantedAuthority` named `ROLE_USER` is used.\n\nThe preceding example is handy, because it lets us use a lot of defaults.\nWhat if we wanted to run the test with a different username?\nThe following test would run with a username of `customUser` (again, the user does not need to actually exist):\n\ninclude-code::./WithMockUserTests[tag=custom-user,indent=0]\n\nWe can also easily customize the roles.\nFor example, the following test is invoked with a username of `admin` and roles of `ROLE_USER` and `ROLE_ADMIN`.\n\ninclude-code::./WithMockUserTests[tag=custom-roles,indent=0]\n\nIf we do not want the value to automatically be prefixed with `ROLE_` we can use the `authorities` attribute.\nFor example, the following test is invoked with a username of `admin` and the `USER` and `ADMIN` authorities.\n\ninclude-code::./WithMockUserTests[tag=custom-authorities,indent=0]\n\nIt can be a bit tedious to place the annotation on every test method.\nInstead, we can place the annotation at the class level. Then every test uses the specified user.\nThe following example runs every test with a user whose username is `admin`, whose password is `password`, and who has the `ROLE_USER` and `ROLE_ADMIN` roles:\n\ninclude-code::./WithMockUserClassTests[tag=snippet,indent=0]\n\nIf you use JUnit 5's `@Nested` test support, you can also place the annotation on the enclosing class to apply to all nested classes.\nThe following example runs every test with a user whose username is `admin`, whose password is `password`, and who has the `ROLE_USER` and `ROLE_ADMIN` roles for both test methods.\n\ninclude-code::./WithMockUserNestedTests[tag=snippet,indent=0]\n\nBy default, the `SecurityContext` is set during the `TestExecutionListener.beforeTestMethod` event.\nThis is the equivalent of happening before JUnit's `@Before`.\nYou can change this to happen during the `TestExecutionListener.beforeTestExecution` event, which is after JUnit's `@Before` but before the test method is invoked:\n\n[source,java]\n----\n@WithMockUser(setupBefore = TestExecutionEvent.TEST_EXECUTION)\n----\n\n[[test-method-withanonymoususer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/method.adoc", "title": "method", "heading": "@WithMockUser", "heading_level": 2, "file_order": 179, "section_index": 2, "content_hash": "92d58a83978cc16925a2a24f89de1f6b06b6d396e23b2f02aa8c227d48e9241e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/method.adoc"}}
{"id": "sha256:725e6d283e22352e91f1bda10920fcb113113d39aa9b5ae3e2a0c8d59e897f9b", "content": "Using `@WithAnonymousUser` allows running as an anonymous user.\nThis is especially convenient when you wish to run most of your tests with a specific user but want to run a few tests as an anonymous user.\nThe following example runs `withMockUser1` and `withMockUser2` by using <<test-method-withmockuser,@WithMockUser>> and `anonymous` as an anonymous user:\n\ninclude-code::./WithUserClassLevelAuthenticationTests[tag=snippet,indent=0]\n\nBy default, the `SecurityContext` is set during the `TestExecutionListener.beforeTestMethod` event.\nThis is the equivalent of happening before JUnit's `@Before`.\nYou can change this to happen during the `TestExecutionListener.beforeTestExecution` event, which is after JUnit's `@Before` but before the test method is invoked:\n\n[source,java]\n----\n@WithAnonymousUser(setupBefore = TestExecutionEvent.TEST_EXECUTION)\n----\n\n[[test-method-withuserdetails]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/method.adoc", "title": "method", "heading": "@WithAnonymousUser", "heading_level": 2, "file_order": 179, "section_index": 3, "content_hash": "725e6d283e22352e91f1bda10920fcb113113d39aa9b5ae3e2a0c8d59e897f9b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/method.adoc"}}
{"id": "sha256:caf8bb8bd6279bfd613f5b522912a96be2ddc080cf4cf7de065a2af6381c625f", "content": "While `@WithMockUser` is a convenient way to get started, it may not work in all instances.\nFor example, some applications expect the `Authentication` principal to be of a specific type.\nThis is done so that the application can refer to the principal as the custom type and reduce coupling on Spring Security.\n\nThe custom principal is often returned by a custom `UserDetailsService` that returns an object that implements both `UserDetails` and the custom type.\nFor situations like this, it is useful to create the test user by using a custom `UserDetailsService`.\nThat is exactly what `@WithUserDetails` does.\n\nAssuming we have a `UserDetailsService` exposed as a bean, the following test is invoked with an `Authentication` of type `UsernamePasswordAuthenticationToken` and a principal that is returned from the `UserDetailsService` with the username of `user`:\n\ninclude-code::./WithUserDetailsTests[tag=user-details,indent=0]\n\nWe can also customize the username used to lookup the user from our `UserDetailsService`.\nFor example, this test can be run with a principal that is returned from the `UserDetailsService` with the username of `customUsername`:\n\ninclude-code::./WithUserDetailsTests[tag=user-details-custom-username,indent=0]\n\nWe can also provide an explicit bean name to look up the `UserDetailsService`.\nThe following test looks up the username of `customUsername` by using the `UserDetailsService` with a bean name of `myUserDetailsService`:\n\ninclude-code::./WithCustomUserDetailsTests[tag=custom-user-details-service,indent=0]\n\nAs we did with `@WithMockUser`, we can also place our annotation at the class level so that every test uses the same user.\nHowever, unlike `@WithMockUser`, `@WithUserDetails` requires the user to exist.\n\nBy default, the `SecurityContext` is set during the `TestExecutionListener.beforeTestMethod` event.\nThis is the equivalent of happening before JUnit's `@Before`.\nYou can change this to happen during the `TestExecutionListener.beforeTestExecution` event, which is after JUnit's `@Before` but before the test method is invoked:\n\n[source,java]\n----\n@WithUserDetails(setupBefore = TestExecutionEvent.TEST_EXECUTION)\n----\n\n[[test-method-withsecuritycontext]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/method.adoc", "title": "method", "heading": "@WithUserDetails", "heading_level": 2, "file_order": 179, "section_index": 4, "content_hash": "caf8bb8bd6279bfd613f5b522912a96be2ddc080cf4cf7de065a2af6381c625f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/method.adoc"}}
{"id": "sha256:12a2b3216a973ec0264281aed02a66dda3789f2f9f2b90e00566bc9335cc5840", "content": "We have seen that `@WithMockUser` is an excellent choice if we do not use a custom `Authentication` principal.\nNext, we discovered that `@WithUserDetails` lets us use a custom `UserDetailsService` to create our `Authentication` principal but requires the user to exist.\nWe now see an option that allows the most flexibility.\n\nWe can create our own annotation that uses the `@WithSecurityContext` to create any `SecurityContext` we want.\nFor example, we might create an annotation named `@WithMockCustomUser`:\n\ninclude-code::./WithMockCustomUser[tag=snippet,indent=0]\n\nYou can see that `@WithMockCustomUser` is annotated with the `@WithSecurityContext` annotation.\nThis is what signals to Spring Security test support that we intend to create a `SecurityContext` for the test.\nThe `@WithSecurityContext` annotation requires that we specify a `SecurityContextFactory` to create a new `SecurityContext`, given our `@WithMockCustomUser` annotation.\nThe following listing shows our `WithMockCustomUserSecurityContextFactory` implementation:\n\ninclude-code::./WithMockCustomUserSecurityContextFactory[tag=snippet,indent=0]\n\nWe can now annotate a test class or a test method with our new annotation and Spring Security's `WithSecurityContextTestExecutionListener` to ensure that our `SecurityContext` is populated appropriately.\n\nWhen creating your own `WithSecurityContextFactory` implementations, it is nice to know that they can be annotated with standard Spring annotations.\nFor example, the `WithUserDetailsSecurityContextFactory` uses the `@Autowired` annotation to acquire the `UserDetailsService`:\n\ninclude-code::./WithUserDetailsSecurityContextFactory[tag=snippet,indent=0]\n\nBy default, the `SecurityContext` is set during the `TestExecutionListener.beforeTestMethod` event.\nThis is the equivalent of happening before JUnit's `@Before`.\nYou can change this to happen during the `TestExecutionListener.beforeTestExecution` event, which is after JUnit's `@Before` but before the test method is invoked:\n\n[source,java]\n----\n@WithSecurityContext(setupBefore = TestExecutionEvent.TEST_EXECUTION)\n----\n\n[[test-method-meta-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/method.adoc", "title": "method", "heading": "@WithSecurityContext", "heading_level": 2, "file_order": 179, "section_index": 5, "content_hash": "12a2b3216a973ec0264281aed02a66dda3789f2f9f2b90e00566bc9335cc5840", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/method.adoc"}}
{"id": "sha256:6dd02e1a1a24e44b8d32e2ca67ff7ed13c9ee84cdc439dc13d648385e8dad6ef", "content": "If you reuse the same user within your tests often, it is not ideal to have to repeatedly specify the attributes.\nFor example, if you have many tests related to an administrative user with a username of `admin` and roles of `ROLE_USER` and `ROLE_ADMIN`, you have to write:\n\ninclude-code::./WithMockUserTests[tag=snippet,indent=0]\n\nRather than repeating this everywhere, we can use a meta annotation.\nFor example, we could create a meta annotation named `WithMockAdmin`:\n\ninclude-code::./WithMockAdmin[tag=snippet,indent=0]\n\nNow we can use `@WithMockAdmin` in the same way as the more verbose `@WithMockUser`.\n\nMeta annotations work with any of the testing annotations described above.\nFor example, this means we could create a meta annotation for `@WithUserDetails(\"admin\")` as well.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/test/method.adoc", "title": "method", "heading": "Test Meta Annotations", "heading_level": 2, "file_order": 179, "section_index": 6, "content_hash": "6dd02e1a1a24e44b8d32e2ca67ff7ed13c9ee84cdc439dc13d648385e8dad6ef", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/test/method.adoc"}}
{"id": "sha256:a907ed404b331f039a923026dc478870c7c688ed67dbf7b75032026cc2e9c208", "content": "[[servlet-architecture]]\n\nThis section discusses Spring Security's high-level architecture within Servlet based applications.\nWe build on this high-level understanding within the xref:servlet/authentication/index.adoc#servlet-authentication[Authentication], xref:servlet/authorization/index.adoc#servlet-authorization[Authorization], and xref:servlet/exploits/index.adoc#servlet-exploits[Protection Against Exploits] sections of the reference.\n\n[[servlet-filters-review]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "architecture", "heading_level": 1, "file_order": 180, "section_index": 0, "content_hash": "a907ed404b331f039a923026dc478870c7c688ed67dbf7b75032026cc2e9c208", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:8effa5db1c0227d6426a3baef964e312ffe549bb6b839d32c1af0752b1506547", "content": "Spring Security's Servlet support is based on Servlet Filters, so it is helpful to look at the role of Filters generally first.\nThe following image shows the typical layering of the handlers for a single HTTP request.\n\n.FilterChain\n[[servlet-filterchain-figure]]\n[.invert-dark]\nimage::{figures}/filterchain.png[]\n\nThe client sends a request to the application, and the container creates a `FilterChain`, which contains the `Filter` instances and `Servlet` that should process the `HttpServletRequest`, based on the path of the request URI.\nIn a Spring MVC application, the `Servlet` is an instance of {spring-framework-reference-url}web.html#mvc-servlet[`DispatcherServlet`].\nAt most, one `Servlet` can handle a single `HttpServletRequest` and `HttpServletResponse`.\nHowever, more than one `Filter` can be used to:\n\n* Prevent downstream `Filter` instances or the `Servlet` from being invoked.\nIn this case, the `Filter` typically writes the `HttpServletResponse`.\n* Modify the `HttpServletRequest` or `HttpServletResponse` used by the downstream `Filter` instances and the `Servlet`.\n\nThe power of the `Filter` comes from the `FilterChain` that is passed into it.\n\n.`FilterChain` Usage Example\ninclude-code::./FilterChainUsage[tag=dofilter,indent=0]\n\nSince a `Filter` impacts only downstream `Filter` instances and the `Servlet`, the order in which each `Filter` is invoked is extremely important.\n\n[[servlet-delegatingfilterproxy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "A Review of Filters", "heading_level": 2, "file_order": 180, "section_index": 1, "content_hash": "8effa5db1c0227d6426a3baef964e312ffe549bb6b839d32c1af0752b1506547", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:79e4c4511e2b116c2d4af9d89f296f04d99a8d6cfb36ab26d173b5108ea002d5", "content": "Spring provides a `Filter` implementation named {spring-framework-api-url}org/springframework/web/filter/DelegatingFilterProxy.html[`DelegatingFilterProxy`] that allows bridging between the Servlet container's lifecycle and Spring's `ApplicationContext`.\nThe Servlet container allows registering `Filter` instances by using its own standards, but it is not aware of Spring-defined Beans.\nYou can register `DelegatingFilterProxy` through the standard Servlet container mechanisms but delegate all the work to a Spring Bean that implements `Filter`.\n\nHere is a picture of how `DelegatingFilterProxy` fits into the <<servlet-filters-review,`Filter` instances and the `FilterChain`>>.\n\n.DelegatingFilterProxy\n[[servlet-delegatingfilterproxy-figure]]\n[.invert-dark]\nimage::{figures}/delegatingfilterproxy.png[]\n\n`DelegatingFilterProxy` looks up __Bean Filter~0~__ from the `ApplicationContext` and then invokes __Bean Filter~0~__.\nThe following listing shows pseudo code of `DelegatingFilterProxy`:\n\n.`DelegatingFilterProxy` Pseudo Code\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\npublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {\n\tFilter delegate = getFilterBean(someBeanName); // <1>\n\tdelegate.doFilter(request, response); // <2>\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nfun doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) {\n\tval delegate: Filter = getFilterBean(someBeanName) // <1>\n\tdelegate.doFilter(request, response) // <2>\n}\n----\n======\n<1> Lazily get Filter that was registered as a Spring Bean.\nFor the example in <<servlet-delegatingfilterproxy-figure>> `delegate` is an instance of __Bean Filter~0~__.\n<2> Delegate work to the Spring Bean.\n\nAnother benefit of `DelegatingFilterProxy` is that it allows delaying looking up `Filter` bean instances.\nThis is important because the container needs to register the `Filter` instances before the container can start up.\nHowever, Spring typically uses a `ContextLoaderListener` to load the Spring Beans, which is not done until after the `Filter` instances need to be registered.\n\n[[servlet-filterchainproxy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "DelegatingFilterProxy", "heading_level": 2, "file_order": 180, "section_index": 2, "content_hash": "79e4c4511e2b116c2d4af9d89f296f04d99a8d6cfb36ab26d173b5108ea002d5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:8662bfcdf0125f1ac9d58c215d5ea69277f6366dc646d433a29df320fe7737c3", "content": "Spring Security's Servlet support is contained within `FilterChainProxy`.\n`FilterChainProxy` is a special `Filter` provided by Spring Security that allows delegating to many `Filter` instances through <<servlet-securityfilterchain,`SecurityFilterChain`>>.\nSince `FilterChainProxy` is a Bean, it is typically wrapped in a <<servlet-delegatingfilterproxy>>.\n\nThe following image shows the role of `FilterChainProxy`.\n\n.FilterChainProxy\n[[servlet-filterchainproxy-figure]]\n[.invert-dark]\nimage::{figures}/filterchainproxy.png[]\n\n[[servlet-securityfilterchain]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "FilterChainProxy", "heading_level": 2, "file_order": 180, "section_index": 3, "content_hash": "8662bfcdf0125f1ac9d58c215d5ea69277f6366dc646d433a29df320fe7737c3", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:749597ebcf12e10be0587c7fd795f1210d0d9f8050fc4f01768ec85039280543", "content": "javadoc:org.springframework.security.web.SecurityFilterChain[] is used by <<servlet-filterchainproxy>> to determine which Spring Security `Filter` instances should be invoked for the current request.\n\nThe following image shows the role of `SecurityFilterChain`.\n\n.SecurityFilterChain\n[[servlet-securityfilterchain-figure]]\n[.invert-dark]\nimage::{figures}/securityfilterchain.png[]\n\nThe <<servlet-security-filters,Security Filters>> in `SecurityFilterChain` are typically Beans, but they are registered with `FilterChainProxy` instead of <<servlet-delegatingfilterproxy>>.\n`FilterChainProxy` provides a number of advantages to registering directly with the Servlet container or <<servlet-delegatingfilterproxy>>.\nFirst, it provides a starting point for all of Spring Security's Servlet support.\nFor that reason, if you try to troubleshoot Spring Security's Servlet support, adding a debug point in `FilterChainProxy` is a great place to start.\n\nSecond, since `FilterChainProxy` is central to Spring Security usage, it can perform tasks that are not viewed as optional.\nFor example, it clears out the `SecurityContext` to avoid memory leaks.\nIt also applies Spring Security's xref:servlet/exploits/firewall.adoc#servlet-httpfirewall[`HttpFirewall`] to protect applications against certain types of attacks.\n\nIn addition, it provides more flexibility in determining when a `SecurityFilterChain` should be invoked.\nIn a Servlet container, `Filter` instances are invoked based upon the URL alone.\nHowever, `FilterChainProxy` can determine invocation based upon anything in the `HttpServletRequest` by using the `RequestMatcher` interface.\n\nThe following image shows multiple `SecurityFilterChain` instances:\n\n.Multiple SecurityFilterChain\n[[servlet-multi-securityfilterchain-figure]]\n[.invert-dark]\nimage::{figures}/multi-securityfilterchain.png[]\n\nIn the <<servlet-multi-securityfilterchain-figure>> figure, `FilterChainProxy` decides which `SecurityFilterChain` should be used.\nOnly the first `SecurityFilterChain` that matches is invoked.\nIf a URL of `/api/messages/` is requested, it first matches on the `SecurityFilterChain~0~` pattern of `+/api/**+`, so only `SecurityFilterChain~0~` is invoked, even though it also matches on ``SecurityFilterChain~n~``.\nIf a URL of `/messages/` is requested, it does not match on the `SecurityFilterChain~0~` pattern of `+/api/**+`, so `FilterChainProxy` continues trying each `SecurityFilterChain`.\nAssuming that no other `SecurityFilterChain` instances match, `SecurityFilterChain~n~` is invoked.\n\nNotice that `SecurityFilterChain~0~` has only three security `Filter` instances configured.\nHowever, `SecurityFilterChain~n~` has four security `Filter` instances configured.\nIt is important to note that each `SecurityFilterChain` can be unique and can be configured in isolation.\nIn fact, a `SecurityFilterChain` might have zero security `Filter` instances if the application wants Spring Security to ignore certain requests.\n\n[[servlet-security-filters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "SecurityFilterChain", "heading_level": 2, "file_order": 180, "section_index": 4, "content_hash": "749597ebcf12e10be0587c7fd795f1210d0d9f8050fc4f01768ec85039280543", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:5c7fcde6b7557e0af2865e3b11ca7db18677968d23ebe26b1dd4834bc84b7512", "content": "The Security Filters are inserted into the <<servlet-filterchainproxy>> with the <<servlet-securityfilterchain>> API.\nThose filters can be used for a number of different purposes, like\nxref:servlet/exploits/index.adoc[exploit protection], xref:servlet/authentication/index.adoc[authentication], xref:servlet/authorization/index.adoc[authorization], and more.\nThe filters are executed in a specific order to guarantee that they are invoked at the right time, for example, the `Filter` that performs authentication should be invoked before the `Filter` that performs authorization.\nIt is typically not necessary to know the ordering of Spring Security's ``Filter``s.\nHowever, there are times that it is beneficial to know the ordering, if you want to know them, you can check the {gh-url}/config/src/main/java/org/springframework/security/config/annotation/web/builders/FilterOrderRegistration.java[`FilterOrderRegistration` code].\n\nThese security filters are most often declared using an javadoc:org.springframework.security.config.annotation.web.builders.HttpSecurity[`HttpSecurity`] instance.\nTo exemplify the above paragraph, let's consider the following security configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n @Bean\n public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n .csrf(Customizer.withDefaults())\n .httpBasic(Customizer.withDefaults())\n .formLogin(Customizer.withDefaults())\n .authorizeHttpRequests((authorize) -> authorize\n .anyRequest().authenticated()\n );\n\n return http.build();\n }\n\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\nimport org.springframework.security.config.web.servlet.invoke\n\n@Configuration\n@EnableWebSecurity\nclass SecurityConfig {\n\n @Bean\n fun filterChain(http: HttpSecurity): SecurityFilterChain {\n http {\n csrf { }\n httpBasic { }\n formLogin { }\n authorizeHttpRequests {\n authorize(anyRequest, authenticated)\n }\n }\n return http.build()\n }\n\n}\n----\n======\n\nThe above configuration will result in the following `Filter` ordering:\n\n[cols=\"1,1\", options=\"header\"]\n|====\n| Filter | Added by\n| xref:servlet/exploits/csrf.adoc[CsrfFilter] | `HttpSecurity#csrf`\n| xref:servlet/authentication/passwords/basic.adoc[BasicAuthenticationFilter] | `HttpSecurity#httpBasic`\n| xref:servlet/authentication/passwords/form.adoc#servlet-authentication-form[UsernamePasswordAuthenticationFilter] | `HttpSecurity#formLogin`\n| xref:servlet/authorization/authorize-http-requests.adoc[AuthorizationFilter] | `HttpSecurity#authorizeHttpRequests`\n|====\n\n1. First, the `CsrfFilter` is invoked to protect against xref:servlet/exploits/csrf.adoc[CSRF attacks].\n2. Second, xref:servlet/authentication/architecture.adoc[the authentication filters] are invoked to authenticate the request.\n3. Third, xref:servlet/authorization/authorize-http-requests.adoc[the `AuthorizationFilter`] is invoked to authorize the request.\n\n[NOTE]\n====\nThere might be other `Filter` instances that are not listed above.\nIf you want to see the list of filters invoked for a particular request, you can <<servlet-print-filters,print them>>.\n====\n\n[[servlet-print-filters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "Security Filters", "heading_level": 2, "file_order": 180, "section_index": 5, "content_hash": "5c7fcde6b7557e0af2865e3b11ca7db18677968d23ebe26b1dd4834bc84b7512", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:99f2aed36cebf4beb04179f2ed415e7befef5e1985f48cb986b807152936c18f", "content": "Often times, it is useful to see the list of security ``Filter``s that are invoked for a particular request.\nFor example, you want to make sure that the <<adding-custom-filter,filter you have added>> is in the list of the security filters.\n\nThe list of filters is printed at DEBUG level on the application startup, so you can see something like the following on the console output for example:\n\n[source,text,role=\"terminal\"]\n----\n2023-06-14T08:55:22.321-03:00 DEBUG 76975 --- [ main] o.s.s.web.DefaultSecurityFilterChain : Will secure any request with [ DisableEncodeUrlFilter, WebAsyncManagerIntegrationFilter, SecurityContextHolderFilter, HeaderWriterFilter, CsrfFilter, LogoutFilter, UsernamePasswordAuthenticationFilter, DefaultLoginPageGeneratingFilter, DefaultLogoutPageGeneratingFilter, BasicAuthenticationFilter, RequestCacheAwareFilter, SecurityContextHolderAwareRequestFilter, AnonymousAuthenticationFilter, ExceptionTranslationFilter, AuthorizationFilter]\n----\n\nAnd that will give a pretty good idea of the security filters that are configured for <<servlet-securityfilterchain,each filter chain>>.\n\nBut that is not all, you can also configure your application to print the invocation of each individual filter for each request.\nThat is helpful to see if the filter you have added is invoked for a particular request or to check where an exception is coming from.\nTo do that, you can configure your application to <<servlet-logging,log the security events>>.\n\n[[adding-custom-filter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "Printing the Security Filters", "heading_level": 3, "file_order": 180, "section_index": 6, "content_hash": "99f2aed36cebf4beb04179f2ed415e7befef5e1985f48cb986b807152936c18f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:582ae8cb0508c8e3cbe32b875aeb55ec366aa593ebc750d300eb3a11ab9917eb", "content": "Most of the time, the default <<servlet-security-filters>> are enough to provide security to your application.\nHowever, there might be times that you want to add a custom `Filter` to the <<servlet-securityfilterchain>>.\n\njavadoc:org.springframework.security.config.annotation.web.builders.HttpSecurity[] comes with three methods for adding filters:\n\n* `#addFilterBefore(Filter, Class<?>)` adds your filter before another filter\n* `#addFilterAfter(Filter, Class<?>)` adds your filter after another filter\n* `#addFilterAt(Filter, Class<?>)` replaces another filter with your filter", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "Adding Filters to the Filter Chain", "heading_level": 3, "file_order": 180, "section_index": 7, "content_hash": "582ae8cb0508c8e3cbe32b875aeb55ec366aa593ebc750d300eb3a11ab9917eb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:238e7fd292ff9066bc119acedb7712ba1bb2344450251474f5e32ef66f9c7a21", "content": "If you are creating a filter of your own, you will need to determine its location in the filter chain.\nPlease take a look at the following key events that occur in the filter chain:\n\n1. xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[`SecurityContext`] is loaded from the session\n2. Request is protected from common exploits; xref:features/exploits/headers.adoc[secure headers], xref:servlet/integrations/cors.adoc[CORS], xref:servlet/exploits/csrf.adoc[CSRF]\n3. Request is xref:servlet/authentication/architecture.adoc[authenticated]\n4. Request is xref:servlet/authorization/architecture.adoc[authorized]\n\nConsider which events you need to have happened in order to locate your filter.\nThe following is a rule of thumb:\n\n[cols=\"1,1,1\"]\n|===\n| If your filter is a(n) | Then place it after | As these events have already occurred\n\n| exploit protection filter\n| SecurityContextHolderFilter\n| 1\n\n| authentication filter\n| LogoutFilter\n| 1, 2\n\n| authorization filter\n| AnonymousAuthenticationFilter\n| 1, 2, 3\n|===\n\n[TIP]\nMost commonly, applications add a custom authentication.\nThis means they should be placed after xref:servlet/authentication/logout.adoc[`LogoutFilter`].\n\nFor example, let's say that you want to add a `Filter` that gets a tenant id header and check if the current user has access to that tenant.\n\nFirst, let's create the `Filter`:\n\n[source,java]\n----\nimport java.io.IOException;\n\nimport jakarta.servlet.Filter;\nimport jakarta.servlet.FilterChain;\nimport jakarta.servlet.ServletException;\nimport jakarta.servlet.ServletRequest;\nimport jakarta.servlet.ServletResponse;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport org.springframework.security.access.AccessDeniedException;\n\npublic class TenantFilter implements Filter {\n\n @Override\n public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n HttpServletRequest request = (HttpServletRequest) servletRequest;\n HttpServletResponse response = (HttpServletResponse) servletResponse;\n\n String tenantId = request.getHeader(\"X-Tenant-Id\"); <1>\n boolean hasAccess = isUserAllowed(tenantId); <2>\n if (hasAccess) {\n filterChain.doFilter(request, response); <3>\n return;\n }\n throw new AccessDeniedException(\"Access denied\"); <4>\n }\n\n}\n\n----\n\nThe sample code above does the following:\n\n<1> Get the tenant id from the request header.\n<2> Check if the current user has access to the tenant id.\n<3> If the user has access, then invoke the rest of the filters in the chain.\n<4> If the user does not have access, then throw an `AccessDeniedException`.\n\n[TIP]\n====\nInstead of implementing `Filter`, you can extend from {spring-framework-api-url}org/springframework/web/filter/OncePerRequestFilter.html[OncePerRequestFilter] which is a base class for filters that are only invoked once per request and provides a `doFilterInternal` method with the `HttpServletRequest` and `HttpServletResponse` parameters.\n====\n\nNow, you need to add the filter to the <<servlet-securityfilterchain>>.\nThe previous description already gives us a clue on where to add the filter, since we need to know the current user, we need to add it after the authentication filters.\n\nBased on the rule of thumb, add it after xref:servlet/authentication/anonymous.adoc[ `AnonymousAuthenticationFilter`], the last authentication filter in the chain, like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n http\n // ...\n .addFilterAfter(new TenantFilter(), AnonymousAuthenticationFilter.class); <1>\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun filterChain(http: HttpSecurity): SecurityFilterChain {\n http\n // ...\n .addFilterAfter(TenantFilter(), AnonymousAuthenticationFilter::class.java) <1>\n return http.build()\n}\n----\n======\n\n<1> Use `HttpSecurity#addFilterAfter` to add the `TenantFilter` after the `AnonymousAuthenticationFilter`.\n\nBy adding the filter after the xref:servlet/authentication/anonymous.adoc[`AnonymousAuthenticationFilter`] we are making sure that the `TenantFilter` is invoked after the authentication filters.\n\nAnd that's it, now the `TenantFilter` will be invoked in the filter chain and will check if the current user has access to the tenant id.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "Adding a Custom Filter", "heading_level": 4, "file_order": 180, "section_index": 8, "content_hash": "238e7fd292ff9066bc119acedb7712ba1bb2344450251474f5e32ef66f9c7a21", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:414c715fd3618ed27ec5967d849a2afc3e8402590ac50c1c95614960b4ce544b", "content": "When you declare a `Filter` as a Spring bean, either by annotating it with `@Component` or by declaring it as a bean in your configuration, Spring Boot automatically {spring-boot-reference-url}reference/web/servlet.html#web.servlet.embedded-container.servlets-filters-listeners.beans[registers it with the embedded container].\nThat may cause the filter to be invoked twice, once by the container and once by Spring Security and in a different order.\n\nBecause of that, filters are often not Spring beans.\n\nHowever, if your filter needs to be a Spring bean (to take advantage of dependency injection, for example) you can tell Spring Boot to not register it with the container by declaring a `FilterRegistrationBean` bean and setting its `enabled` property to `false`:\n\n[source,java]\n----\n@Bean\npublic FilterRegistrationBean<TenantFilter> tenantFilterRegistration(TenantFilter filter) {\n FilterRegistrationBean<TenantFilter> registration = new FilterRegistrationBean<>(filter);\n registration.setEnabled(false);\n return registration;\n}\n----\n\nThis makes so that `HttpSecurity` is the only one adding it.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "Declaring Your Filter as a Bean", "heading_level": 4, "file_order": 180, "section_index": 9, "content_hash": "414c715fd3618ed27ec5967d849a2afc3e8402590ac50c1c95614960b4ce544b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:c573da60507f55158f5f1fb2c7d72d5409063426c9c4a9b7f836c1f0b5cbe06d", "content": "Generally, you can use a filter's DSL method to configure Spring Security's filters.\nFor example, the simplest way to add `BasicAuthenticationFilter` is by asking the DSL to do it:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n\thttp\n .httpBasic(Customizer.withDefaults())\n // ...\n\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun filterChain(http: HttpSecurity): SecurityFilterChain {\n\thttp {\n httpBasic { }\n // ...\n\t}\n\n\treturn http.build()\n}\n----\n======\n\nHowever, in the event that you want to construct a Spring Security filter yourself, you specify it in the DSL using `addFilterAt` like so:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n\tBasicAuthenticationFilter basic = new BasicAuthenticationFilter();\n\t// ... configure\n\n\thttp\n // ...\n .addFilterAt(basic, BasicAuthenticationFilter.class);\n\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun filterChain(http: HttpSecurity): SecurityFilterChain {\n\tval basic = BasicAuthenticationFilter()\n\t// ... configure\n\n\thttp\n // ...\n .addFilterAt(basic, BasicAuthenticationFilter::class.java)\n\n\treturn http.build()\n}\n----\n======\n\nNote that if that filter has already been added, then Spring Security will throw an exception.\nFor example, calling xref:servlet/authentication/passwords/basic.adoc[ `HttpSecurity#httpBasic`] adds a `BasicAuthenticationFilter` for you.\nSo, the following arrangement fails since there are two calls that are both trying to add `BasicAuthenticationFilter`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n\tBasicAuthenticationFilter basic = new BasicAuthenticationFilter();\n\t// ... configure\n\n\thttp\n .httpBasic(Customizer.withDefaults())\n // ... on no! BasicAuthenticationFilter is added twice!\n .addFilterAt(basic, BasicAuthenticationFilter.class);\n\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun filterChain(http: HttpSecurity): SecurityFilterChain {\n\tval basic = BasicAuthenticationFilter()\n\t// ... configure\n\n\thttp {\n httpBasic { }\n\t}\n\n\t// ... on no! BasicAuthenticationFilter is added twice!\n http.addFilterAt(basic, BasicAuthenticationFilter::class.java)\n\n\treturn http.build()\n}\n----\n======\n\nIn this case, remove the call to `httpBasic` since you are constructing `BasicAuthenticationFilter` yourself.\n\n[TIP]\n====\nIn the event that you are unable to reconfigure `HttpSecurity` to not add a certain filter, you can typically disable the Spring Security filter by calling its DSL's `disable` method like so:\n\n[source,java]\n----\n.httpBasic((basic) -> basic.disable())\n----\n====\n\n[[servlet-exceptiontranslationfilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "Customizing a Spring Security Filter", "heading_level": 4, "file_order": 180, "section_index": 10, "content_hash": "c573da60507f55158f5f1fb2c7d72d5409063426c9c4a9b7f836c1f0b5cbe06d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:86957376282382a2a42a040585b0ee7ac15bebe1fe929884fddce355ebfb9e2d", "content": "The javadoc:org.springframework.security.web.access.ExceptionTranslationFilter[] allows translation of javadoc:org.springframework.security.access.AccessDeniedException[] and javadoc:org.springframework.security.core.AuthenticationException[] into HTTP responses.\n\n`ExceptionTranslationFilter` is inserted into the <<servlet-filterchainproxy>> as one of the <<servlet-security-filters>>.\n\nThe following image shows the relationship of `ExceptionTranslationFilter` to other components:\n\n[.invert-dark]\nimage::{figures}/exceptiontranslationfilter.png[]\n\n* image:{icondir}/number_1.png[] First, the `ExceptionTranslationFilter` invokes `FilterChain.doFilter(request, response)` to invoke the rest of the application.\n* image:{icondir}/number_2.png[] If the user is not authenticated or it is an `AuthenticationException`, then __Start Authentication__.\n** The xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[SecurityContextHolder] is cleared out.\n** The `HttpServletRequest` is <<savedrequests,saved>> so that it can be used to replay the original request once authentication is successful.\n** The `AuthenticationEntryPoint` is used to request credentials from the client.\nFor example, it might redirect to a log in page or send a `WWW-Authenticate` header.\n* image:{icondir}/number_3.png[] Otherwise, if it is an `AccessDeniedException`, then __Access Denied__.\nThe `AccessDeniedHandler` is invoked to handle access denied.\n\n[NOTE]\n====\nIf the application does not throw an `AccessDeniedException` or an `AuthenticationException`, then `ExceptionTranslationFilter` does not do anything.\n====\n\nThe pseudocode for `ExceptionTranslationFilter` looks something like this:\n\n.ExceptionTranslationFilter pseudocode\n[source,java]\n----\ntry {\n\tfilterChain.doFilter(request, response); // <1>\n} catch (AccessDeniedException | AuthenticationException ex) {\n\tif (!authenticated || ex instanceof AuthenticationException) {\n startAuthentication(); // <2>\n\t} else {\n accessDenied(); // <3>\n\t}\n}\n----\n<1> As described in <<servlet-filters-review>>, invoking `FilterChain.doFilter(request, response)` is the equivalent of invoking the rest of the application.\nThis means that if another part of the application, (xref:servlet/authorization/authorize-http-requests.adoc[`AuthorizationFilter`] or method security) throws an `AuthenticationException` or `AccessDeniedException` it is caught and handled here.\n<2> If the user is not authenticated or it is an `AuthenticationException`, __Start Authentication__.\n<3> Otherwise, __Access Denied__\n\n[[savedrequests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "Handling Security Exceptions", "heading_level": 2, "file_order": 180, "section_index": 11, "content_hash": "86957376282382a2a42a040585b0ee7ac15bebe1fe929884fddce355ebfb9e2d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:aaa4e6e1db0f5b96df31b9c1b369b082488d3de9b8b59218e31717ab58c3f569", "content": "As illustrated in <<servlet-exceptiontranslationfilter>>, when a request has no authentication and is for a resource that requires authentication, there is a need to save the request for the authenticated resource to re-request after authentication is successful.\nIn Spring Security this is done by saving the `HttpServletRequest` using a <<requestcache,`RequestCache`>> implementation.\n\n[[requestcache]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "Saving Requests Between Authentication", "heading_level": 2, "file_order": 180, "section_index": 12, "content_hash": "aaa4e6e1db0f5b96df31b9c1b369b082488d3de9b8b59218e31717ab58c3f569", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:59e271b825f3ce4f4a16ac8a7f1e5d698c335366262f020f2d81a2474302c224", "content": "The `HttpServletRequest` is saved in the javadoc:org.springframework.security.web.savedrequest.RequestCache[].\nWhen the user successfully authenticates, the `RequestCache` is used to replay the original request.\nThe <<requestcacheawarefilter,`RequestCacheAwareFilter`>> uses the `RequestCache` to get the saved `HttpServletRequest` after the user authenticates, while the `ExceptionTranslationFilter` uses the `RequestCache` to save the `HttpServletRequest` after it detects `AuthenticationException`, before redirecting the user to the login endpoint.\n\nBy default, an `HttpSessionRequestCache` is used.\nThe code below demonstrates how to customize the `RequestCache` implementation that is used to check the `HttpSession` for a saved request if the parameter named `continue` is present.\n\n.`RequestCache` Only Checks for Saved Requests if `continue` Parameter Present\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nDefaultSecurityFilterChain springSecurity(HttpSecurity http) throws Exception {\n\tHttpSessionRequestCache requestCache = new HttpSessionRequestCache();\n\trequestCache.setMatchingRequestParameterName(\"continue\");\n\thttp\n\t\t// ...\n\t\t.requestCache((cache) -> cache\n\t\t\t.requestCache(requestCache)\n\t\t);\n\treturn http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun springSecurity(http: HttpSecurity): SecurityFilterChain {\n    val httpRequestCache = HttpSessionRequestCache()\n    httpRequestCache.setMatchingRequestParameterName(\"continue\")\n    http {\n        requestCache {\n            requestCache = httpRequestCache\n        }\n    }\n    return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http auto-config=\"true\">\n\t<!-- ... -->\n\t<request-cache ref=\"requestCache\"/>\n</http>\n\n<b:bean id=\"requestCache\" class=\"org.springframework.security.web.savedrequest.HttpSessionRequestCache\"\n\tp:matchingRequestParameterName=\"continue\"/>\n----\n======\n\n[[requestcache-prevent-saved-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "RequestCache", "heading_level": 3, "file_order": 180, "section_index": 13, "content_hash": "59e271b825f3ce4f4a16ac8a7f1e5d698c335366262f020f2d81a2474302c224", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:9c8f542f7bdfa82d67ce1912987e0068d40b27e0da3211a01f971b0abf5e84db", "content": "There are a number of reasons you may want to not store the user's unauthenticated request in the session.\nYou may want to offload that storage onto the user's browser or store it in a database.\nOr you may want to shut off this feature since you always want to redirect the user to the home page instead of the page they tried to visit before login.\n\nTo do that, you can use the javadoc:org.springframework.security.web.savedrequest.NullRequestCache[NullRequestCache] implementation.\n\n.Prevent the Request From Being Saved\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nSecurityFilterChain springSecurity(HttpSecurity http) throws Exception {\n RequestCache nullRequestCache = new NullRequestCache();\n http\n // ...\n .requestCache((cache) -> cache\n .requestCache(nullRequestCache)\n );\n return http.build();\n}\n----\n\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nopen fun springSecurity(http: HttpSecurity): SecurityFilterChain {\n val nullRequestCache = NullRequestCache()\n http {\n requestCache {\n requestCache = nullRequestCache\n }\n }\n return http.build()\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<http auto-config=\"true\">\n\t<!-- ... -->\n\t<request-cache ref=\"nullRequestCache\"/>\n</http>\n\n<b:bean id=\"nullRequestCache\" class=\"org.springframework.security.web.savedrequest.NullRequestCache\"/>\n----\n======\n\n[[requestcacheawarefilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "Prevent the Request From Being Saved", "heading_level": 4, "file_order": 180, "section_index": 14, "content_hash": "9c8f542f7bdfa82d67ce1912987e0068d40b27e0da3211a01f971b0abf5e84db", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:8f6d58ee2509a2aa04b70464605dfd71f83c441b498f3980ce343af118cda4fb", "content": "The javadoc:org.springframework.security.web.savedrequest.RequestCacheAwareFilter[] uses the <<requestcache,`RequestCache`>> to replay the original request.\n\n[[servlet-logging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "RequestCacheAwareFilter", "heading_level": 3, "file_order": 180, "section_index": 15, "content_hash": "8f6d58ee2509a2aa04b70464605dfd71f83c441b498f3980ce343af118cda4fb", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:4ac7d6ad5a92e3d1810f71618eae1ac87f903e492ed3cb172b3bf3829ff157ba", "content": "Spring Security provides comprehensive logging of all security related events at the DEBUG and TRACE level.\nThis can be very useful when debugging your application because for security measures Spring Security does not add any detail of why a request has been rejected to the response body.\nIf you come across a 401 or 403 error, it is very likely that you will find a log message that will help you understand what is going on.\n\nLet's consider an example where a user tries to make a `POST` request to a resource that has xref:servlet/exploits/csrf.adoc[CSRF protection] enabled without the CSRF token.\nWith no logs, the user will see a 403 error with no explanation of why the request was rejected.\nHowever, if you enable logging for Spring Security, you will see a log message like this:\n\n[source,text]\n----\n2023-06-14T09:44:25.797-03:00 DEBUG 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Securing POST /hello\n2023-06-14T09:44:25.797-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Invoking DisableEncodeUrlFilter (1/15)\n2023-06-14T09:44:25.798-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Invoking WebAsyncManagerIntegrationFilter (2/15)\n2023-06-14T09:44:25.800-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Invoking SecurityContextHolderFilter (3/15)\n2023-06-14T09:44:25.801-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Invoking HeaderWriterFilter (4/15)\n2023-06-14T09:44:25.802-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy : Invoking CsrfFilter (5/15)\n2023-06-14T09:44:25.814-03:00 DEBUG 76975 --- [nio-8080-exec-1] o.s.security.web.csrf.CsrfFilter : Invalid CSRF token found for http://localhost:8080/hello\n2023-06-14T09:44:25.814-03:00 DEBUG 76975 --- [nio-8080-exec-1] o.s.s.w.access.AccessDeniedHandlerImpl : Responding with 403 status code\n2023-06-14T09:44:25.814-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.s.w.header.writers.HstsHeaderWriter : Not injecting HSTS header since it did not match request to [Is Secure]\n----\n\nIt becomes clear that the CSRF token is missing and that is why the request is being denied.\n\nTo configure your application to log all the security events, you can add the following to your application:\n\n====\n.application.properties in Spring Boot\n[source,properties,role=\"primary\"]\n----\nlogging.level.org.springframework.security=TRACE\n----\n.logback.xml\n[source,xml,role=\"secondary\"]\n----\n<configuration>\n <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n <!-- ... -->\n </appender>\n <!-- ... -->\n <logger name=\"org.springframework.security\" level=\"trace\" additivity=\"false\">\n <appender-ref ref=\"Console\" />\n </logger>\n</configuration>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/architecture.adoc", "title": "architecture", "heading": "Logging", "heading_level": 2, "file_order": 180, "section_index": 16, "content_hash": "4ac7d6ad5a92e3d1810f71618eae1ac87f903e492ed3cb172b3bf3829ff157ba", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/architecture.adoc"}}
{"id": "sha256:d969727f1b4bc44513e11e051fade6855945da7d4b88e7a1dc455c1a6e77caf0", "content": "[[servlet-hello]]\n\nThis section covers the minimum setup for how to use Spring Security with {spring-boot-reference-url}[Spring Boot] and then points you to next steps after that.\n\n[NOTE]\n====\nThe completed starter application can be found {gh-samples-url}/servlet/spring-boot/java/hello-security[in our samples repository].\nFor your convenience, you can download a minimal Spring Boot + Spring Security application https://start.spring.io/starter.zip?type=maven-project&language=java&packaging=jar&jvmVersion=1.8&groupId=example&artifactId=hello-security&name=hello-security&description=Hello%20Security&packageName=example.hello-security&dependencies=web,security[prepared by Spring Initializr].\n====\n\n[[servlet-hello-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/getting-started.adoc", "title": "getting-started", "heading": "getting-started", "heading_level": 1, "file_order": 181, "section_index": 0, "content_hash": "d969727f1b4bc44513e11e051fade6855945da7d4b88e7a1dc455c1a6e77caf0", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/getting-started.adoc"}}
{"id": "sha256:e4c548d5297cd2411f8d60e32094825794af80af74751339314965ba99516c3b", "content": "You first need to add Spring Security to your application's classpath; two ways to do this are to xref:getting-spring-security.adoc#getting-maven-boot[use Maven] or xref:getting-spring-security.adoc#getting-gradle-boot[Gradle].\n\n[[servlet-hello-starting]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/getting-started.adoc", "title": "getting-started", "heading": "Updating Dependencies", "heading_level": 2, "file_order": 181, "section_index": 1, "content_hash": "e4c548d5297cd2411f8d60e32094825794af80af74751339314965ba99516c3b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/getting-started.adoc"}}
{"id": "sha256:936ec22903e6f374195a87335ffa8ddd9aba161c93ad20c8caf62ae89d782c08", "content": "With Spring Security <<servlet-hello-dependencies,on the classpath>>, you can now {spring-boot-reference-url}reference/using/running-your-application.html[run the Spring Boot application].\nThe following snippet shows some of the output that indicates that Spring Security is enabled in your application:\n\n.Running Spring Boot Application\n[tabs]\n======\nMaven::\n+\n[source,bash,role=\"primary\"]\n----\n$ ./mvnw spring-boot:run\n...\nINFO 23689 --- [ restartedMain] .s.s.UserDetailsServiceAutoConfiguration :\n\nUsing generated security password: 8e557245-73e2-4286-969a-ff57fe326336\n\n...\n----\n\nGradle::\n+\n[source,bash,role=\"secondary\"]\n----\n$ ./gradlew :bootRun\n...\nINFO 23689 --- [ restartedMain] .s.s.UserDetailsServiceAutoConfiguration :\n\nUsing generated security password: 8e557245-73e2-4286-969a-ff57fe326336\n\n...\n----\n\nJar::\n+\n[source,bash,role=\"secondary\"]\n----\n$ java -jar target/myapplication-0.0.1.jar\n...\nINFO 23689 --- [ restartedMain] .s.s.UserDetailsServiceAutoConfiguration :\n\nUsing generated security password: 8e557245-73e2-4286-969a-ff57fe326336\n\n...\n----\n======\n\nNow that you have it running, you might try hitting an endpoint to see what happens.\nIf you hit an endpoint without credentials like so:\n\n.Querying a Secured Boot Application\n[source,bash]\n----\n$ curl -i http://localhost:8080/some/path\nHTTP/1.1 401\n...\n----\n\nthen Spring Security denies access with a `401 Unauthorized`.\n\n[TIP]\nIf you provide the same URL in a browser, it will redirect to a default login page.\n\nAnd if you hit an endpoint with credentials (found in the console output) as follows:\n\n.Querying with Credentials\n[source,bash]\n----\n$ curl -i -u user:8e557245-73e2-4286-969a-ff57fe326336 http://localhost:8080/some/path\nHTTP/1.1 404\n...\n----\n\nthen Spring Boot will service the request, returning a `404 Not Found` in this case since `/some/path` doesn't exist.\n\nFrom here, you can:\n\n* Better understand <<servlet-hello-auto-configuration,what Spring Boot enables in Spring Security by default>>\n* Read about <<security-use-cases,common use cases>> that Spring Security helps with\n* Start configuring xref:servlet/authentication/index.adoc[authentication]\n\n[[servlet-hello-auto-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/getting-started.adoc", "title": "getting-started", "heading": "Starting Hello Spring Security Boot", "heading_level": 2, "file_order": 181, "section_index": 2, "content_hash": "936ec22903e6f374195a87335ffa8ddd9aba161c93ad20c8caf62ae89d782c08", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/getting-started.adoc"}}
{"id": "sha256:2d816ff521d6de29c7667809aced935be19573512ccf07548ebbe65033abd358", "content": "The default arrangement of Spring Boot and Spring Security affords the following behaviors at runtime:\n\n* Requires an authenticated user xref:servlet/authorization/authorize-http-requests.adoc[for any endpoint] (including Boot's `/error` endpoint)\n* xref:servlet/authentication/passwords/user-details-service.adoc[Registers a default user] with a generated password at startup (the password is logged to the console; in the preceding example, the password is `8e557245-73e2-4286-969a-ff57fe326336`)\n* Protects xref:servlet/authentication/passwords/password-encoder.adoc[password storage with BCrypt] as well as others\n* Provides form-based xref:servlet/authentication/passwords/form.adoc[login] and xref:servlet/authentication/logout.adoc[logout] flows\n* Authenticates xref:servlet/authentication/passwords/form.adoc[form-based login] as well as xref:servlet/authentication/passwords/basic.adoc[HTTP Basic]\n* Provides content negotiation; for web requests, redirects to the login page; for service requests, returns a `401 Unauthorized`\n* xref:servlet/exploits/csrf.adoc[Mitigates CSRF] attacks\n* xref:servlet/authentication/session-management.adoc#ns-session-fixation[Mitigates Session Fixation] attacks\n* Writes xref:servlet/exploits/headers.adoc#servlet-headers-hsts[Strict-Transport-Security] to https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security[ensure HTTPS]\n* Writes xref:servlet/exploits/headers.adoc#servlet-headers-content-type-options[X-Content-Type-Options] to mitigate https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-content-type-options[sniffing attacks]\n* Writes xref:servlet/exploits/headers.adoc#servlet-headers-cache-control[Cache Control headers] that protect authenticated resources\n* Writes xref:servlet/exploits/headers.adoc#servlet-headers-frame-options[X-Frame-Options] to mitigate https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-frame-options[Clickjacking]\n* Integrates with xref:servlet/integrations/servlet-api.adoc[``HttpServletRequest``'s authentication methods]\n* Publishes xref:servlet/authentication/events.adoc[authentication success and failure events]\n\nIt can be helpful to understand how Spring Boot is coordinating with Spring Security to achieve this.\nTaking a look at {spring-boot-api-url}org/springframework/boot/security/autoconfigure/SecurityAutoConfiguration.html[Boot's security auto configuration], it does the following (simplified for illustration):\n\n.Spring Boot Security Auto Configuration\n[source,java]\n----\n@EnableWebSecurity <1>\n@Configuration\npublic class DefaultSecurityConfig {\n @Bean\n @ConditionalOnMissingBean(UserDetailsService.class)\n InMemoryUserDetailsManager inMemoryUserDetailsManager() { <2>\n String generatedPassword = // ...;\n return new InMemoryUserDetailsManager(User.withUsername(\"user\")\n .password(generatedPassword).roles(\"USER\").build());\n }\n\n @Bean\n @ConditionalOnMissingBean(AuthenticationEventPublisher.class)\n DefaultAuthenticationEventPublisher defaultAuthenticationEventPublisher(ApplicationEventPublisher delegate) { <3>\n return new DefaultAuthenticationEventPublisher(delegate);\n }\n}\n----\n1. Adds the `@EnableWebSecurity` annotation. (Among other things, this publishes xref:servlet/architecture.adoc#servlet-securityfilterchain[Spring Security's default `Filter` chain] as a `@Bean`)\n2. Publishes a xref:servlet/authentication/passwords/user-details-service.adoc[`UserDetailsService`] `@Bean` with a username of `user` and a randomly generated password that is logged to the console\n3. Publishes an xref:servlet/authentication/events.adoc[`AuthenticationEventPublisher`] `@Bean` for publishing authentication events\n\n[NOTE]\nSpring Boot adds any `Filter` published as a `@Bean` to the application's filter chain.\nThis means that using `@EnableWebSecurity` in conjunction with Spring Boot automatically registers Spring Security's filter chain for every request.\n\n[[security-use-cases]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/getting-started.adoc", "title": "getting-started", "heading": "Runtime Expectations", "heading_level": 2, "file_order": 181, "section_index": 3, "content_hash": "2d816ff521d6de29c7667809aced935be19573512ccf07548ebbe65033abd358", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/getting-started.adoc"}}
{"id": "sha256:1e48b223c83e1e0efb63d666336546f3e1fc0b06372ab5577e3187dc6dee4433", "content": "There are a number of places that you may want to go from here.\nTo figure out what's next for you and your application, consider these common use cases that Spring Security is built to address:\n\n* I am building a REST API, and I need to xref:servlet/oauth2/resource-server/jwt.adoc[authenticate a JWT] or xref:servlet/oauth2/resource-server/opaque-token.adoc[other bearer token]\n* I am building a Web Application, API Gateway, or BFF and\n** I need to xref:servlet/oauth2/login/core.adoc[login using OAuth 2.0 or OIDC]\n** I need to xref:servlet/saml2/login/index.adoc[login using SAML 2.0]\n** I need to xref:servlet/authentication/cas.adoc[login using CAS]\n* I need to manage\n** Users in xref:servlet/authentication/passwords/ldap.adoc[LDAP] or xref:servlet/authentication/passwords/ldap.adoc#_active_directory[Active Directory], with xref:servlet/integrations/data.adoc[Spring Data], or with xref:servlet/authentication/passwords/jdbc.adoc[JDBC]\n** xref:servlet/authentication/passwords/storage.adoc[Passwords]\n\nIn case none of those match what you are looking for, consider thinking about your application in the following order:\n\n1. *Protocol*: First, consider the protocol your application will use to communicate.\nFor servlet-based applications, Spring Security supports HTTP as well as xref:servlet/integrations/websocket.adoc[Websockets].\n2. *Authentication*: Next, consider how users will xref:servlet/authentication/index.adoc[authenticate] and if that authentication will be stateful or stateless\n3. *Authorization*: Then, consider how you will determine xref:servlet/authorization/index.adoc[what a user is authorized to do]\n4. *Defense*: Finally, xref:servlet/exploits/csrf.adoc#csrf-considerations[integrate with Spring Security's default protections] and consider xref:servlet/exploits/headers.adoc[which additional protections you need]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/getting-started.adoc", "title": "getting-started", "heading": "Security Use Cases", "heading_level": 2, "file_order": 181, "section_index": 4, "content_hash": "1e48b223c83e1e0efb63d666336546f3e1fc0b06372ab5577e3187dc6dee4433", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/getting-started.adoc"}}
{"id": "sha256:51878a8f5248bd0a647331d50c2eecbf59d21fbe9661a8b8292fec3f47f9892b", "content": "[[servlet-applications]]\n\nSpring Security integrates with the Servlet Container by using a standard Servlet `Filter`. This means it works with any application that runs in a Servlet Container. More concretely, you do not need to use Spring in your Servlet-based application to take advantage of Spring Security.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/servlet/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 182, "section_index": 0, "content_hash": "51878a8f5248bd0a647331d50c2eecbf59d21fbe9661a8b8292fec3f47f9892b", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/servlet/index.adoc"}}
{"id": "sha256:98a93a8d90b3da6afb59e642c92b3ebd824076422db3f1ff9264ecb6f8df9d85", "content": "[[community]]\n\nWelcome to the Spring Security Community!\nThis section discusses how you can make the most of our vast community.\n\n[[community-help]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/community.adoc", "title": "community", "heading": "community", "heading_level": 1, "file_order": 183, "section_index": 0, "content_hash": "98a93a8d90b3da6afb59e642c92b3ebd824076422db3f1ff9264ecb6f8df9d85", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/community.adoc"}}
{"id": "sha256:4792296a17c192a6afb7cfb8198aa650599be35be147afeb06c187c204e57e85", "content": "If you need help with Spring Security, we are here to help.\nThe following are some of the best ways to get help:\n\n* Read through this documentation.\n* Try one of our many xref:samples.adoc#samples[sample applications].\n* Ask a question on https://stackoverflow.com/questions/tagged/spring-security[https://stackoverflow.com] with the `spring-security` tag.\n* Report bugs and enhancement requests at https://github.com/spring-projects/spring-security/issues\n\n[[community-becoming-involved]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/community.adoc", "title": "community", "heading": "Getting Help", "heading_level": 2, "file_order": 183, "section_index": 1, "content_hash": "4792296a17c192a6afb7cfb8198aa650599be35be147afeb06c187c204e57e85", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/community.adoc"}}
{"id": "sha256:6eeb83233e6d07b86fcf8618061a71661a96cc3c7928e68360f49ea8339514fe", "content": "We welcome your involvement in the Spring Security project.\nThere are many ways to contribute, including answering questions on Stack Overflow, writing new code, improving existing code, assisting with documentation, developing samples or tutorials, reporting bugs, or simply making suggestions.\nFor more information, see our https://github.com/spring-projects/spring-security/blob/main/CONTRIBUTING.adoc[Contributing] documentation.\n\n[[community-source]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/community.adoc", "title": "community", "heading": "Becoming Involved", "heading_level": 2, "file_order": 183, "section_index": 2, "content_hash": "6eeb83233e6d07b86fcf8618061a71661a96cc3c7928e68360f49ea8339514fe", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/community.adoc"}}
{"id": "sha256:fcb2fc875c44be00cc106ba74614f8af7ceeda9759be725fa8ccca696af23c9a", "content": "You can find Spring Security's source code on GitHub at https://github.com/spring-projects/spring-security/\n\n[[community-license]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/community.adoc", "title": "community", "heading": "Source Code", "heading_level": 2, "file_order": 183, "section_index": 3, "content_hash": "fcb2fc875c44be00cc106ba74614f8af7ceeda9759be725fa8ccca696af23c9a", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/community.adoc"}}
{"id": "sha256:6c5231cf6c7f059cd88bd2d8cb7fb34782f879afb64040c490ce8c6cb3600646", "content": "Spring Security is Open Source software released under the https://www.apache.org/licenses/LICENSE-2.0.html[Apache 2.0 license].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/community.adoc", "title": "community", "heading": "Apache 2 License", "heading_level": 2, "file_order": 183, "section_index": 4, "content_hash": "6c5231cf6c7f059cd88bd2d8cb7fb34782f879afb64040c490ce8c6cb3600646", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/community.adoc"}}
{"id": "sha256:71e96cdfcea61a2254aaaee7a9966dd09c46265899908df8ff078402c131afdf", "content": "You can follow https://twitter.com/SpringSecurity[@SpringSecurity] and the https://twitter.com/SpringSecurity/lists/team[Spring Security team] on Twitter to stay up to date with the latest news.\nYou can also follow https://twitter.com/SpringCentral[@SpringCentral] to keep up to date with the entire Spring portfolio.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/community.adoc", "title": "community", "heading": "Social Media", "heading_level": 2, "file_order": 183, "section_index": 5, "content_hash": "71e96cdfcea61a2254aaaee7a9966dd09c46265899908df8ff078402c131afdf", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/community.adoc"}}
{"id": "sha256:44105f181305f6df45d67390a487dbea3f2163e6a0c736d5df63b41697d70ce1", "content": "[[getting]]\n[[getting-gradle]]\n\nThis section describes how to get the Spring Security binaries.\nSee xref:community.adoc#community-source[Source Code] for how to obtain the source code.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/getting-spring-security.adoc", "title": "getting-spring-security", "heading": "getting-spring-security", "heading_level": 1, "file_order": 184, "section_index": 0, "content_hash": "44105f181305f6df45d67390a487dbea3f2163e6a0c736d5df63b41697d70ce1", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/getting-spring-security.adoc"}}
{"id": "sha256:e91395626436791890cb8023b47b552ae2a3bc10026ddf59ee19d666c5f01a85", "content": "Spring Security versions are formatted as MAJOR.MINOR.PATCH such that:\n\n* MAJOR versions may contain breaking changes.\nTypically, these are done to provide improved security to match modern security practices.\n* MINOR versions contain enhancements but are considered passive updates.\n* PATCH level should be perfectly compatible, forwards and backwards, with the possible exception of changes that fix bugs.\n\n[[maven]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/getting-spring-security.adoc", "title": "getting-spring-security", "heading": "Release Numbering", "heading_level": 2, "file_order": 184, "section_index": 1, "content_hash": "e91395626436791890cb8023b47b552ae2a3bc10026ddf59ee19d666c5f01a85", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/getting-spring-security.adoc"}}
{"id": "sha256:ecccc71c850316c2ff9d4d524cdd90d8b3e577472ae5b80bc228c929109080f5", "content": "As most open source projects, Spring Security deploys its dependencies as Maven artifacts, which makes them compatible with both Maven and Gradle. The following sections demonstrate how to integrate Spring Security with these build tools, with examples for Spring Boot and standalone usage.\n\n[[getting-maven-boot]]\n[[getting-gradle-boot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/getting-spring-security.adoc", "title": "getting-spring-security", "heading": "Usage", "heading_level": 2, "file_order": 184, "section_index": 2, "content_hash": "ecccc71c850316c2ff9d4d524cdd90d8b3e577472ae5b80bc228c929109080f5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/getting-spring-security.adoc"}}
{"id": "sha256:b6c5160edf6d438098a7dcec76f275136376780b6ee7ed7c78b76e8c0e714d2d", "content": "Spring Boot provides a `spring-boot-starter-security` starter that aggregates Spring Security-related dependencies.\nThe simplest and preferred way to use the starter is to use https://docs.spring.io/initializr/docs/current/reference/html/[Spring Initializr] by using an IDE integration in (https://joshlong.com/jl/blogPost/tech_tip_geting_started_with_spring_boot.html[Eclipse] or https://www.jetbrains.com/help/idea/spring-boot.html#d1489567e2[IntelliJ], https://github.com/AlexFalappa/nb-springboot/wiki/Quick-Tour[NetBeans]) or through https://start.spring.io.\nAlternatively, you can manually add the starter, as the following example shows:\n\n[tabs]\n======\nMaven::\n+\n.pom.xml\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<dependencies>\n\t<!-- ... other dependency elements ... -->\n\t<dependency>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-security</artifactId>\n\t</dependency>\n</dependencies>\n----\n\nGradle::\n+\n.build.gradle\n[source,groovy]\n[subs=\"verbatim,attributes\"]\n----\ndependencies {\n\timplementation \"org.springframework.boot:spring-boot-starter-security\"\n}\n----\n======\n\nSince Spring Boot provides a Maven BOM to manage dependency versions, you do not need to specify a version.\nIf you wish to override the Spring Security version, you can do so with a build property as shown below:\n\n[tabs]\n======\nMaven::\n+\n.pom.xml\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<properties>\n\t<!-- ... -->\n\t<spring-security.version>{spring-security-version}</spring-security.version>\n</properties>\n----\n\nGradle::\n+\n.build.gradle\n[source,groovy]\n[subs=\"verbatim,attributes\"]\n----\next['spring-security.version']='{spring-security-version}'\n----\n======\n\nSince Spring Security makes breaking changes only in major releases, you can safely use a newer version of Spring Security with Spring Boot.\nHowever, at times, you may need to update the version of Spring Framework as well.\nYou can do so by adding a build property like so:\n\n[tabs]\n======\nMaven::\n+\n.pom.xml\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<properties>\n\t<!-- ... -->\n\t<spring.version>{spring-core-version}</spring.version>\n</properties>\n----\n\nGradle::\n+\n.build.gradle\n[source,groovy]\n[subs=\"verbatim,attributes\"]\n----\next['spring.version']='{spring-core-version}'\n----\n======\n\nIf you use additional features (such as LDAP, OAuth 2, and others), you need to also include the appropriate xref:modules.adoc#modules[Project Modules and Dependencies].\n\n[[getting-maven-no-boot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/getting-spring-security.adoc", "title": "getting-spring-security", "heading": "Spring Boot", "heading_level": 3, "file_order": 184, "section_index": 3, "content_hash": "b6c5160edf6d438098a7dcec76f275136376780b6ee7ed7c78b76e8c0e714d2d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/getting-spring-security.adoc"}}
{"id": "sha256:49a86a61950a016581a83e75d904d657d963a5c4d44303f7f981268d011e7188", "content": "When you use Spring Security without Spring Boot, the preferred way is to use Spring Security's BOM to ensure that a consistent version of Spring Security is used throughout the entire project.\n\n[tabs]\n======\nMaven::\n+\n.pom.xml\n[source,xml,ubs=\"verbatim,attributes\"]\n----\n<dependencyManagement>\n\t<dependencies>\n <!-- ... other dependency elements ... -->\n <dependency>\n <groupId>org.springframework.security</groupId>\n <artifactId>spring-security-bom</artifactId>\n <version>{spring-security-version}</version>\n <type>pom</type>\n <scope>import</scope>\n </dependency>\n\t</dependencies>\n</dependencyManagement>\n----\n\nGradle::\n+\n.build.gradle\n[source,groovy]\n[subs=\"verbatim,attributes\"]\n----\nplugins {\n\tid \"io.spring.dependency-management\" version \"1.0.6.RELEASE\"\n}\n\ndependencyManagement {\n\timports {\n mavenBom 'org.springframework.security:spring-security-bom:{spring-security-version}'\n\t}\n}\n----\n======\n\n[TIP]\nSpring provides a https://github.com/spring-gradle-plugins/dependency-management-plugin[`Dependency Management Plugin`] for Gradle\n\nA minimal Spring Security Maven set of dependencies typically looks like the following example:\n\n[tabs]\n======\nMaven::\n+\n.pom.xml\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<dependencies>\n\t<!-- ... other dependency elements ... -->\n\t<dependency>\n <groupId>org.springframework.security</groupId>\n <artifactId>spring-security-web</artifactId>\n\t</dependency>\n\t<dependency>\n <groupId>org.springframework.security</groupId>\n <artifactId>spring-security-config</artifactId>\n\t</dependency>\n</dependencies>\n----\n\nGradle::\n+\n.build.gradle\n[source,groovy]\n[subs=\"verbatim,attributes\"]\n----\ndependencies {\n\timplementation \"org.springframework.security:spring-security-web\"\n\timplementation \"org.springframework.security:spring-security-config\"\n}\n----\n======\n\nIf you use additional features (such as LDAP, OAuth 2, and others), you need to also include the appropriate xref:modules.adoc#modules[Project Modules and Dependencies].\n\nSpring Security builds against Spring Framework {spring-core-version} but should generally work with any newer version of Spring Framework 5.x.\nMany users are likely to run afoul of the fact that Spring Security's transitive dependencies resolve Spring Framework {spring-core-version}, which can cause strange classpath problems.\nThe easiest way to resolve this is to use the `spring-framework-bom` within the `<dependencyManagement>` section of your `pom.xml` or your `dependencyManagement` section of your `build.gradle`.\n\n[tabs]\n======\nMaven::\n+\n.pom.xml\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<dependencyManagement>\n\t<dependencies>\n <!-- ... other dependency elements ... -->\n <dependency>\n <groupId>org.springframework</groupId>\n <artifactId>spring-framework-bom</artifactId>\n <version>{spring-core-version}</version>\n <type>pom</type>\n <scope>import</scope>\n </dependency>\n\t</dependencies>\n</dependencyManagement>\n----\n\nGradle::\n+\n.build.gradle\n[source,groovy]\n[subs=\"verbatim,attributes\"]\n----\nplugins {\n\tid \"io.spring.dependency-management\" version \"1.0.6.RELEASE\"\n}\n\ndependencyManagement {\n\timports {\n mavenBom 'org.springframework:spring-framework-bom:{spring-core-version}'\n\t}\n}\n----\n======\n\n[TIP]\nSpring provides a https://github.com/spring-gradle-plugins/dependency-management-plugin[`Dependency Management Plugin`] for Gradle\n\nThe preceding example ensures that all the transitive dependencies of Spring Security use the Spring {spring-core-version} modules.\n\n[NOTE]\n====\nThis approach uses Maven's \"`bill of materials`\" (BOM) concept and is only available in Maven 2.0.9+.\nFor additional details about how dependencies are resolved, see https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html[Maven's Introduction to the Dependency Mechanism documentation].\n====\n\n[[maven-repositories]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/getting-spring-security.adoc", "title": "getting-spring-security", "heading": "Standalone Usage (Without Spring Boot)", "heading_level": 3, "file_order": 184, "section_index": 4, "content_hash": "49a86a61950a016581a83e75d904d657d963a5c4d44303f7f981268d011e7188", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/getting-spring-security.adoc"}}
{"id": "sha256:51066e7e85105c008b895479fdc8d93edc58b5ae987313fc5352be83c236b0af", "content": "All https://github.com/spring-projects/spring-security/wiki/Release-Schedule-Guidelines[GA releases] are deployed to Maven Central, so you need not declare additional Maven repositories in your build configuration.\n\nFor Gradle using the `mavenCentral()` repository is sufficient for GA releases.\n\n.build.gradle\n[source,groovy]\n----\nrepositories {\n\tmavenCentral()\n}\n----\n\nIf you use a SNAPSHOT version, you need to ensure that you have the Spring Snapshot repository defined:\n\n[tabs]\n======\nMaven::\n+\n.pom.xml\n[source,xml]\n----\n<repositories>\n\t<!-- ... possibly other repository elements ... -->\n\t<repository>\n <id>spring-snapshot</id>\n <name>Spring Snapshot Repository</name>\n <url>https://repo.spring.io/snapshot</url>\n\t</repository>\n</repositories>\n----\n\nGradle::\n+\n.build.gradle\n[source,groovy]\n----\nrepositories {\n\tmaven { url 'https://repo.spring.io/snapshot' }\n}\n----\n======\n\nIf you use a milestone or release candidate version, you need to ensure that you have the Spring Milestone repository defined, as the following example shows:\n\n[tabs]\n======\nMaven::\n+\n.pom.xml\n[source,xml]\n----\n<repositories>\n\t<!-- ... possibly other repository elements ... -->\n\t<repository>\n <id>spring-milestone</id>\n <name>Spring Milestone Repository</name>\n <url>https://repo.spring.io/milestone</url>\n\t</repository>\n</repositories>\n----\n\nGradle::\n+\n.build.gradle\n[source,groovy]\n----\nrepositories {\n\tmaven { url 'https://repo.spring.io/milestone' }\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/getting-spring-security.adoc", "title": "getting-spring-security", "heading": "Maven Repositories", "heading_level": 3, "file_order": 184, "section_index": 5, "content_hash": "51066e7e85105c008b895479fdc8d93edc58b5ae987313fc5352be83c236b0af", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/getting-spring-security.adoc"}}
{"id": "sha256:3dd60831f5afe64b2f940596925cb7843802842d45dfebe69a14371b0a6b4437", "content": "[NOTE]\n====\nSpring Security's documentation can be https://docs.spring.io/spring-security/reference/spring-security-docs.zip[downloaded] as a zip file.\n====\n\nSpring Security is a framework that provides xref:features/authentication/index.adoc[authentication], xref:features/authorization/index.adoc[authorization], and xref:features/exploits/index.adoc[protection against common attacks].\nWith first class support for securing both xref:servlet/index.adoc[imperative] and xref:reactive/index.adoc[reactive] applications, it is the de-facto standard for securing Spring-based applications.\n\nFor a complete list of features, see the xref:features/index.adoc[Features] section of the reference.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/index.adoc", "title": "Spring Security", "heading": "Spring Security", "heading_level": 1, "file_order": 185, "section_index": 0, "content_hash": "3dd60831f5afe64b2f940596925cb7843802842d45dfebe69a14371b0a6b4437", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:6961ae7798a777657a5dc019563208e519416801470ebf10e404ae7bb4c8a731", "content": "If you are ready to start securing an application see the Getting Started sections for xref:servlet/getting-started.adoc[servlet] and xref:reactive/getting-started.adoc[reactive]. These sections will walk you through creating your first Spring Security applications.\n\nIf you want to understand how Spring Security works, you can refer to the xref:servlet/architecture.adoc[Architecture] section.\n\nIf you are already familiar with Spring Security or are upgrading, check out https://docs.spring.io/spring-security/reference/whats-new.html[what's new in the latest release].\n\nIf you have any questions, there is a wonderful xref:community.adoc[community] that would love to help you!", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/index.adoc", "title": "Spring Security", "heading": "Getting Started", "heading_level": 2, "file_order": 185, "section_index": 1, "content_hash": "6961ae7798a777657a5dc019563208e519416801470ebf10e404ae7bb4c8a731", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:4e474f5a5698a2214867b13b583987d62afd3cadf0dce3fbfdd3c1df08995a93", "content": "[[modules]]\nIn Spring Security 3.0, the codebase was sub-divided into separate jars which more clearly separate different functionality areas and third-party dependencies.\nIf you use Maven to build your project, these are the modules you should add to your `pom.xml`.\nEven if you do not use Maven, we recommend that you consult the `pom.xml` files to get an idea of third-party dependencies and versions.\nAnother good idea is to examine the libraries that are included in the sample applications.\n\nThis section provides a reference of the modules in Spring Security and the additional dependencies that they require in order to function in a running application.\nWe do not include dependencies that are used only when building or testing Spring Security itself.\nNor do we include transitive dependencies that are required by external dependencies.\n\nThe version of Spring required is listed on the project website, so the specific versions are omitted for Spring dependencies in the examples.\nNote that some of the dependencies listed as \"`optional`\" in the examples may still be required for other non-security functionality in a Spring application\nAlso dependencies listed as \"`optional`\" may not actually be marked as such in the project's Maven POM files if they are used in most applications.\nThey are \"`optional`\" only in the sense that you do not need them unless you use the specified functionality.\n\nWhere a module depends on another Spring Security module, the non-optional dependencies of the module it depends on are also assumed to be required and are not listed separately.\n\n[[spring-security-core]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "modules", "heading_level": 1, "file_order": 186, "section_index": 0, "content_hash": "4e474f5a5698a2214867b13b583987d62afd3cadf0dce3fbfdd3c1df08995a93", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:fa34bc726f9638a54219443d301cfdd837dd6a6f5f5da5bbae27c6e64793abd9", "content": "This module contains core authentication and access-control classes and interfaces, remoting support, and basic provisioning APIs.\nIt is required by any application that uses Spring Security.\nIt supports standalone applications, remote clients, method (service layer) security, and JDBC user provisioning.\nIt contains the following top-level packages:\n\n* `org.springframework.security.core`\n* `org.springframework.security.access`\n* `org.springframework.security.authentication`\n* `org.springframework.security.provisioning`\n\n.Core Dependencies\n|===\n| Dependency | Version | Description\n\n| ehcache\n| 1.6.2\n| Required if the Ehcache-based user cache implementation is used (optional).\n\n| spring-aop\n|\n| Method security is based on Spring AOP\n\n| spring-beans\n|\n| Required for Spring configuration\n\n| spring-expression\n|\n| Required for expression-based method security (optional)\n\n| spring-jdbc\n|\n| Required if using a database to store user data (optional).\n\n| spring-tx\n|\n| Required if using a database to store user data (optional).\n\n| aspectjrt\n| 1.6.10\n| Required if using AspectJ support (optional).\n\n| jsr250-api\n| 1.0\n| Required if you are using JSR-250 method-security annotations (optional).\n|===\n\n[[spring-security-remoting]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "Core -- `spring-security-core.jar`", "heading_level": 2, "file_order": 186, "section_index": 1, "content_hash": "fa34bc726f9638a54219443d301cfdd837dd6a6f5f5da5bbae27c6e64793abd9", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:f7beb51ae33ee047d25c5842610cea3d83c40a598a1e2a25a4d7fb6fa6eb67f6", "content": "This module provides integration with Spring Remoting.\nYou do not need this unless you are writing a remote client that uses Spring Remoting.\nThe main package is `org.springframework.security.remoting`.\n\n.Remoting Dependencies\n|===\n| Dependency | Version | Description\n\n| spring-security-core\n|\n|\n\n| spring-web\n|\n| Required for clients which use HTTP remoting support.\n|===\n\n[[spring-security-web]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "Remoting -- `spring-security-remoting.jar`", "heading_level": 2, "file_order": 186, "section_index": 2, "content_hash": "f7beb51ae33ee047d25c5842610cea3d83c40a598a1e2a25a4d7fb6fa6eb67f6", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:429ba9dae82103b32a0f130253f9c854a2d31d135afc081d50877230850de311", "content": "This module contains filters and related web-security infrastructure code.\nIt contains anything with a servlet API dependency.\nYou need it if you require Spring Security web authentication services and URL-based access-control.\nThe main package is `org.springframework.security.web`.\n\n.Web Dependencies\n|===\n| Dependency | Version | Description\n\n| spring-security-core\n|\n|\n\n| spring-web\n|\n| Required for clients that use HTTP remoting support.\n\n| spring-jdbc\n|\n| Required for a JDBC-based persistent remember-me token repository (optional).\n\n| spring-tx\n|\n| Required by remember-me persistent token repository implementations (optional).\n|===\n\n[[spring-security-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "Web -- `spring-security-web.jar`", "heading_level": 2, "file_order": 186, "section_index": 3, "content_hash": "429ba9dae82103b32a0f130253f9c854a2d31d135afc081d50877230850de311", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:386d766b137af913b5760f8b80fd9cebac32637c2ab6ce2a3e9b7e5049e1ea3c", "content": "This module contains the security namespace parsing code and Java configuration code.\nYou need it if you use the Spring Security XML namespace for configuration or Spring Security's Java Configuration support.\nThe main package is `org.springframework.security.config`.\nNone of the classes are intended for direct use in an application.\n\n.Config Dependencies\n|===\n| Dependency | Version | Description\n\n| spring-security-core\n|\n|\n\n| spring-security-web\n|\n| Required if you are using any web-related namespace configuration (optional).\n\n| spring-security-ldap\n|\n| Required if you are using the LDAP namespace options (optional).\n\n| aspectjweaver\n| 1.6.10\n| Required if using the protect-pointcut namespace syntax (optional).\n|===\n\n[[spring-security-ldap]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "Config -- `spring-security-config.jar`", "heading_level": 2, "file_order": 186, "section_index": 4, "content_hash": "386d766b137af913b5760f8b80fd9cebac32637c2ab6ce2a3e9b7e5049e1ea3c", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:78bc4f1d71616408730667c753a9e31708bf1de447e8620a949b65194fbc618e", "content": "This module provides LDAP authentication and provisioning code.\nIt is required if you need to use LDAP authentication or manage LDAP user entries.\nThe top-level package is `org.springframework.security.ldap`.\n\n.LDAP Dependencies\n|===\n| Dependency | Version | Description\n\n| spring-security-core\n|\n|\n\n| spring-ldap-core\n| 1.3.0\n| LDAP support is based on Spring LDAP.\n\n| spring-tx\n|\n| Data exception classes are required.\n\n| com.unboundid:unboundid-ldapsdk\n|\n| Required if using an embedded LDAP server\n\n| ldapsdk\n| 4.1\n| Mozilla LdapSDK.\nUsed for decoding LDAP password policy controls if you are using password-policy functionality with OpenLDAP, for example.\n|===\n\n[[spring-security-oauth2-core]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "LDAP -- `spring-security-ldap.jar`", "heading_level": 2, "file_order": 186, "section_index": 5, "content_hash": "78bc4f1d71616408730667c753a9e31708bf1de447e8620a949b65194fbc618e", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:38fffc0d3351dcfcff9fe5731ecd2ed4fdb45a6bd91c442654ac11d5d27c3b63", "content": "`spring-security-oauth2-core.jar` contains core classes and interfaces that provide support for the OAuth 2.0 Authorization Framework and for OpenID Connect Core 1.0.\nIt is required by applications that use OAuth 2.0 or OpenID Connect Core 1.0, such as client, resource server, and authorization server.\nThe top-level package is `org.springframework.security.oauth2.core`.\n\n[[spring-security-oauth2-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "OAuth 2.0 Core -- `spring-security-oauth2-core.jar`", "heading_level": 2, "file_order": 186, "section_index": 6, "content_hash": "38fffc0d3351dcfcff9fe5731ecd2ed4fdb45a6bd91c442654ac11d5d27c3b63", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:bfe09f4059b2cea7dbd01a8e1c7895d8b957969500a3df27cd3304b51da892ee", "content": "`spring-security-oauth2-client.jar` contains Spring Security's client support for OAuth 2.0 Authorization Framework and OpenID Connect Core 1.0.\nIt is required by applications that use OAuth 2.0 or OpenID Connect Core 1.0, such as the client, the resource server, and the authorization server.\nThe top-level package is `org.springframework.security.oauth2.core`.\n\n[[spring-security-oauth2-jose]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "OAuth 2.0 Client -- `spring-security-oauth2-client.jar`", "heading_level": 2, "file_order": 186, "section_index": 7, "content_hash": "bfe09f4059b2cea7dbd01a8e1c7895d8b957969500a3df27cd3304b51da892ee", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:6ed004b11d28f81b56e7fdc09570012f8319703fc4630d024d3ebd4fe8c56bb4", "content": "`spring-security-oauth2-jose.jar` contains Spring Security's support for the JOSE (Javascript Object Signing and Encryption) framework.\nThe JOSE framework is intended to provide a method to securely transfer claims between parties.\nIt is built from a collection of specifications:\n\n* JSON Web Token (JWT)\n* JSON Web Signature (JWS)\n* JSON Web Encryption (JWE)\n* JSON Web Key (JWK)\n\nIt contains the following top-level packages:\n\n* `org.springframework.security.oauth2.jwt`\n* `org.springframework.security.oauth2.jose`\n\n[[spring-security-oauth2-resource-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "OAuth 2.0 JOSE -- `spring-security-oauth2-jose.jar`", "heading_level": 2, "file_order": 186, "section_index": 8, "content_hash": "6ed004b11d28f81b56e7fdc09570012f8319703fc4630d024d3ebd4fe8c56bb4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:662f673956f839d40ee31172f50932b7a1553b02f3f2aba289d3a1925a0a54e5", "content": "`spring-security-oauth2-resource-server.jar` contains Spring Security's support for OAuth 2.0 Resource Servers.\nIt is used to protect APIs by using OAuth 2.0 Bearer Tokens.\nThe top-level package is `org.springframework.security.oauth2.server.resource`.\n\n[[spring-security-acl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "OAuth 2.0 Resource Server -- `spring-security-oauth2-resource-server.jar`", "heading_level": 2, "file_order": 186, "section_index": 9, "content_hash": "662f673956f839d40ee31172f50932b7a1553b02f3f2aba289d3a1925a0a54e5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:5cddbf96b4866e445070fadd936a4a039d256ccaf1200a98ba693b01d9f1b5c5", "content": "This module contains a specialized domain object ACL implementation.\nIt is used to apply security to specific domain object instances within your application.\nThe top-level package is `org.springframework.security.acls`.\n\n.ACL Dependencies\n|===\n| Dependency | Version | Description\n\n| spring-security-core\n|\n|\n\n| ehcache\n| 1.6.2\n| Required if the Ehcache-based ACL cache implementation is used (optional if you use your own implementation).\n\n| spring-jdbc\n|\n| Required if you are using the default JDBC-based AclService (optional if you implement your own).\n\n| spring-tx\n|\n| Required if you are using the default JDBC-based AclService (optional if you implement your own).\n|===\n\n[[spring-security-cas]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "ACL -- `spring-security-acl.jar`", "heading_level": 2, "file_order": 186, "section_index": 10, "content_hash": "5cddbf96b4866e445070fadd936a4a039d256ccaf1200a98ba693b01d9f1b5c5", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:1062cf64fa08ab810b842bdd0305d38de79877c4f923d969a999b3b579f1f83d", "content": "This module contains Spring Security's CAS client integration.\nYou should use it if you want to use Spring Security web authentication with a CAS single sign-on server.\nThe top-level package is `org.springframework.security.cas`.\n\n.CAS Dependencies\n|===\n| Dependency | Version | Description\n\n| spring-security-core\n|\n|\n\n| spring-security-web\n|\n|\n\n| cas-client-core\n| 3.1.12\n| The JA-SIG CAS Client.\nThis is the basis of the Spring Security integration.\n\n| ehcache\n| 1.6.2\n| Required if you are using the Ehcache-based ticket cache (optional).\n|===\n\n[[spring-security-test]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "CAS -- `spring-security-cas.jar`", "heading_level": 2, "file_order": 186, "section_index": 11, "content_hash": "1062cf64fa08ab810b842bdd0305d38de79877c4f923d969a999b3b579f1f83d", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:dc0e9b3f334669c8ca9622a468253fa0d0c2129b71c86ef17638a4fdde73f19f", "content": "This module contains support for testing with Spring Security.\n\n[[spring-security-taglibs]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "Test -- `spring-security-test.jar`", "heading_level": 2, "file_order": 186, "section_index": 12, "content_hash": "dc0e9b3f334669c8ca9622a468253fa0d0c2129b71c86ef17638a4fdde73f19f", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:48483d998b05f8024686546c56424f38c31d264c1fe0656f5cddbadccf485be4", "content": "Provides Spring Security's JSP tag implementations.\n\n.Taglib Dependencies\n|===\n| Dependency | Version | Description\n\n| spring-security-core\n|\n|\n\n| spring-security-web\n|\n|\n\n| spring-security-acl\n|\n| Required if you are using the `accesscontrollist` tag or `hasPermission()` expressions with ACLs (optional).\n\n| spring-expression\n|\n| Required if you are using SPEL expressions in your tag access constraints.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/modules.adoc", "title": "modules", "heading": "Taglibs -- `spring-security-taglibs.jar`", "heading_level": 2, "file_order": 186, "section_index": 13, "content_hash": "48483d998b05f8024686546c56424f38c31d264c1fe0656f5cddbadccf485be4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/modules.adoc"}}
{"id": "sha256:9345ca583dc2585a2944df98f141bfd0023417408bd57e66e55b6e418df656c8", "content": "[[prerequisites]]\n\nSpring Security requires a Java 17 or higher Runtime Environment.\n\nAs Spring Security aims to operate in a self-contained manner, you do not need to place any special configuration files in your Java Runtime Environment.\nIn particular, you do not need to configure a special Java Authentication and Authorization Service (JAAS) policy file or place Spring Security in common classpath locations.\n\nSimilarly, if you use an EJB Container or Servlet Container, you do not need to put any special configuration files anywhere nor include Spring Security in a server classloader.\nAll the required files are contained within your application.\n\nThis design offers maximum deployment time flexibility, as you can copy your target artifact (be it a JAR, WAR, or EAR) from one system to another and it immediately works.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/prerequisites.adoc", "title": "prerequisites", "heading": "prerequisites", "heading_level": 1, "file_order": 187, "section_index": 0, "content_hash": "9345ca583dc2585a2944df98f141bfd0023417408bd57e66e55b6e418df656c8", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/prerequisites.adoc"}}
{"id": "sha256:eb01d5387c582f59da8d53942721f0b25cad4b721ce4346e4d31df64a79d1295", "content": "[[samples]]\n\nSpring Security includes many {gh-samples-url}[samples] applications.\n\n[NOTE]\n====\nThese samples are being migrated to a separate project, however, you can still find\nthe not migrated samples in an older branch of the {gh-old-samples-url}[Spring Security repository].\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "samples", "heading_level": 1, "file_order": 188, "section_index": 0, "content_hash": "eb01d5387c582f59da8d53942721f0b25cad4b721ce4346e4d31df64a79d1295", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:e66d43e848c1369840c83e12a7ab099d10c5f3849cd5aa60fb2d66498f3452a4", "content": "[[new]]\n\nThis is a placeholder for updates to Spring Security 7.1", "metadata": {"source_type": "repo_asciidoc", "project": "spring-security", "path": "docs/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "whats-new", "heading_level": 1, "file_order": 189, "section_index": 0, "content_hash": "e66d43e848c1369840c83e12a7ab099d10c5f3849cd5aa60fb2d66498f3452a4", "source_url": "https://github.com/spring-projects/spring-security/blob/73b055baa90f4c7304ed8d458e08f003713fc131/docs/modules/ROOT/pages/whats-new.adoc"}}
