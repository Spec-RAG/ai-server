{"id": "sha256:df1bbc92d7aac9bb562b2fb286e67007f10284523e458043ce749934aedc37c3", "content": "[[dependencies]]\n\nIf you want to use Spring Vault in your project, declare a dependency to the `spring-vault-core` artifact.\n\n.Declaring a dependency to Spring Vault\n====\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<dependencies>\n <dependency>\n <groupId>org.springframework.vault</groupId>\n <artifactId>spring-vault-core</artifactId>\n <version>{version}</version>\n </dependency>\n\n <dependency>\n <groupId>tools.jackson.core</groupId>\n <artifactId>jackson-databind</artifactId>\n <version>${jackson-databind.version}</version>\n </dependency>\n</dependencies>\n----\n====\n\nThe easiest way to find compatible versions of Spring Vault dependencies is by inspecting the properties section of link:https://github.com/spring-projects/spring-vault/blob/main/pom.xml[`spring-vault-parent`].\nWe generally recommend upgrading to the latest dependency of Jackson 3, your HTTP clients and your Cloud provider SDK.\n\nNOTE: Spring Vault 4.0 supports Jackson 3 and Jackson 2.\nMake sure to declare a Jackson dependency as Spring Vault does not include Jackson transitively for easier opt-in.\nWhen both Jackson 2 and Jackson 3 are on the classpath, Spring Vault will use Jackson 3 aligning with Spring Framework 7 preferences.\nSpring Vault also assumes the usage of Jackson 3 in the HTTP client.\n\n[[dependencies.spring-framework]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/introduction/dependencies.adoc", "title": "dependencies", "heading": "dependencies", "heading_level": 1, "file_order": 0, "section_index": 0, "content_hash": "df1bbc92d7aac9bb562b2fb286e67007f10284523e458043ce749934aedc37c3", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/introduction/dependencies.adoc"}}
{"id": "sha256:8c4a4366a84bf1e031584c722835083a66737eefc07e233a8372cadecd54f8d4", "content": "The current version of Spring Vault requires Spring Framework in version\n{springVersion} or newer.\nThe modules might also work with an older bugfix version of that minor version.\nHowever, using the most recent version within that generation is highly recommended.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/introduction/dependencies.adoc", "title": "dependencies", "heading": "Spring Framework", "heading_level": 2, "file_order": 0, "section_index": 1, "content_hash": "8c4a4366a84bf1e031584c722835083a66737eefc07e233a8372cadecd54f8d4", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/introduction/dependencies.adoc"}}
{"id": "sha256:a8c5bcb12e8ace1c868fc3e2d7ea3efb354293e4381284c95100719779845275", "content": "[[vault.core.getting-started]]\n\nSpring Vault support requires Vault 0.6 or higher and Java SE 17 or higher.\nAn easy way to bootstrap setting up a working environment is to create a Spring based project in https://spring.io/tools/sts[STS].\n\nFirst you need to set up a running Vault server.\nRefer to the https://www.vaultproject.io/intro/[Vault] for an explanation on how to start up a Vault instance.\n\nTo create a Spring project in STS go to File -> New ->\nSpring Template Project -> Simple Spring Utility Project ->\npress Yes when prompted.\nThen enter a project and a package name such as `org.spring.vault.example`.\n\nThen add the following to `pom.xml` dependencies section.\n\n.Adding Spring Vault dependency\n====\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<dependencies>\n\n <!-- other dependency elements omitted -->\n\n <dependency>\n <groupId>org.springframework.vault</groupId>\n <artifactId>spring-vault-core</artifactId>\n <version>{version}</version>\n </dependency>\n\n</dependencies>\n----\n====\n\nIf you are using a SNAPSHOT, you will also need to add the location of the Spring Snapshot repository to your maven `pom.xml` which is at the same level of your `<dependencies/>` element.\n\n====\n[source,xml]\n----\n<repositories>\n <repository>\n <id>spring-snapshot</id>\n <name>Spring Maven SNAPSHOT Repository</name>\n <url>https://repo.spring.io/snapshot</url>\n </repository>\n</repositories>\n----\n====\n\nThe repository is also https://repo.spring.io/snapshot/org/springframework/vault/[browseable here].\n\nCreate a simple `Secrets` class to persist:\n\n.Mapped data object\n====\n[source,java]\n----\npackage org.spring.vault.example;\n\npublic class Secrets {\n\n String username;\n String password;\n\n public String getUsername() {\n return username;\n }\n\n public String getPassword() {\n return password;\n }\n}\n----\n====\n\nAnd a main application to run\n\n.Example application using Spring Vault\n====\n[source,java]\n----\npackage org.springframework.vault.example;\n\nimport org.springframework.vault.authentication.TokenAuthentication;\nimport org.springframework.vault.client.VaultEndpoint;\nimport org.springframework.vault.core.VaultTemplate;\nimport org.springframework.vault.support.VaultResponseSupport;\n\npublic class VaultApp {\n\n public static void main(String[] args) {\n\n VaultTemplate vaultTemplate = new VaultTemplate(VaultClient.create(\"https://localhost:8200/v1\"),\n new TokenAuthentication(\"00000000-0000-0000-0000-000000000000\"));\n\n Secrets secrets = new Secrets();\n secrets.username = \"hello\";\n secrets.password = \"world\";\n\n vaultTemplate.write(\"secret/myapp\", secrets);\n\n VaultResponseSupport<Secrets> response = vaultTemplate.read(\"secret/myapp\", Secrets.class);\n System.out.println(response.getData().getUsername());\n\n vaultTemplate.delete(\"secret/myapp\");\n }\n}\n----\n====\n\nEven in this simple example, there are few things to take notice of\n\n* You can instantiate the central class of Spring Vault,\n<<vault.core.template,`VaultTemplate`>>, using the `org.springframework.vault.client.VaultClient`\nobject and the `ClientAuthentication`.\nYou are not required to spin up a Spring Context to use Spring Vault.\n* Vault is expected to be configured with a root token of\n`00000000-0000-0000-0000-000000000000` to run this application.\n* The mapper works against standard POJO objects without the need for any additional metadata (though you can optionally provide that information).\n* Mapping conventions can use field access.\nNotice the `Secrets` class has only getters.\n* If the constructor argument names match the field names of the stored document, they will be used to instantiate the object.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/introduction/getting-started.adoc", "title": "getting-started", "heading": "getting-started", "heading_level": 1, "file_order": 1, "section_index": 0, "content_hash": "a8c5bcb12e8ace1c868fc3e2d7ea3efb354293e4381284c95100719779845275", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/introduction/getting-started.adoc"}}
{"id": "sha256:b462bbd9920f2f551d40eba3a74a3db041bbf6847881142cc91712f8604c5ea5", "content": "[[vault.introduction]]\n\nThis section explains introductory topics such as how to get started and the new and noteworthy changes for each release.\n\nThe Vault support contains a wide range of features which are summarized below.\n\n* Spring configuration support using Java based @Configuration classes\n* xref:vault/imperative-template.adoc[`VaultTemplate`] helper class that increases productivity performing common Vault operations and its xref:vault/reactive-template.adoc[reactive variant].\nIncludes integrated object mapping between Vault responses and POJOs.\n* xref:vault/propertysource.adoc[`@VaultPropertySource`] support to mount Vault secrets engines as property sources.\n* xref:vault/vault-repositories.adoc[Vault repositories] to interact with Vault as data source using Spring Data repositories.\n\nFor most tasks, you will find yourself using `VaultTemplate` that leverages the rich communication functionality. `VaultTemplate` is the place to look for accessing functionality such as reading data from Vault or issuing administrative commands. `VaultTemplate` also provides callback methods so that it is easy for you to get a hold of the low-level API artifacts such as `RestTemplate` to communicate directly with Vault.\n\n`VaultTemplate` is built on top of javadoc:org.springframework.vault.client.VaultClient[] as low-level HTTP interface (internally using `RestClient`) providing a tailored fluent API towards Vault's functionality. `VaultClient` can be configured with javadoc:org.springframework.vault.client.VaultEndpoint[] for convenient usage with relative paths along with namespace support.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/introduction/introduction.adoc", "title": "introduction", "heading": "introduction", "heading_level": 1, "file_order": 2, "section_index": 0, "content_hash": "b462bbd9920f2f551d40eba3a74a3db041bbf6847881142cc91712f8604c5ea5", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/introduction/introduction.adoc"}}
{"id": "sha256:e3df77843574051225071433bf132793fd7b7b96bc332fb781cea355c9b03c49", "content": "[[vault.vaultproject]]\n\nSecurity and working with secrets is a concern of every developer working with databases, user credentials or API keys.\nVault steps in by providing a secure storage combined with access control, revocation, key rolling and auditing.\nIn short: Vault is a service for securely accessing and storing secrets.\nA secret is anything that you want to tightly control access to, such as API keys, passwords, certificates, and more.\n\nThe jumping off ground for learning about Vault is https://www.vaultproject.io[www.vaultproject.io].\nHere is a list of useful resources:\n\n* The manual introduces Vault and contains links to getting started guides, reference documentation and tutorials.\n\n* The online shell provides a convenient way to interact with a Vault instance in combination with the online tutorial.\n\n* https://learn.hashicorp.com/collections/vault/getting-started[Getting Started with Vault]\n\n* https://www.vaultproject.io/docs[HashiCorp Vault Documentation]\n\nSpring Vault provides client-side support for accessing, storing and revoking secrets.\nWith https://www.vaultproject.io[HashiCorp's Vault] you have a central place to manage external secret data for applications across all environments.\nVault can manage static and dynamic secrets such as application data, username/password for remote applications/resources and provide credentials for external services such as MySQL, PostgreSQL, Apache Cassandra, Consul, AWS and more.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/introduction/knowing-vault.adoc", "title": "knowing-vault", "heading": "knowing-vault", "heading_level": 1, "file_order": 3, "section_index": 0, "content_hash": "e3df77843574051225071433bf132793fd7b7b96bc332fb781cea355c9b03c49", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/introduction/knowing-vault.adoc"}}
{"id": "sha256:b8c24fa957b823b0feb908bd1c508c3a62a8508f5d341d8e44b054af8039f9e5", "content": "[[vault.core.authentication]]\n\nDifferent organizations have different requirements for security\nand authentication. Vault reflects that need by shipping multiple authentication\nmethods. Spring Vault supports multiple authentications mechanisms.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "authentication", "heading_level": 1, "file_order": 4, "section_index": 0, "content_hash": "b8c24fa957b823b0feb908bd1c508c3a62a8508f5d341d8e44b054af8039f9e5", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:ccdaae36d89144138693482f11f2972f7a89f6b36c28f73811a231875b67cd72", "content": "Obtaining first-time access to a secured system is known as secure introduction.\nAny client requires ephemeral or permanent credentials to access Vault. Externalizing credentials\nis a good pattern to keep code maintainability high but comes at a risk of increased disclosure.\n\nDisclosure of login credentials to any party allows login to Vault and access secrets that\nare permitted by the underlying role. Picking the appropriate client authentication and\ninjecting credentials into the application is subject to risk evaluation.\n\nSpring's {spring-framework-docs}/core/beans/environment.html#beans-property-source-abstraction[PropertySource abstraction] is a natural fit\nto keep configuration outside the application code. You can use system properties, environment\nvariables or property files to store login credentials. Each approach comes with its own properties.\nKeep in mind that the command line and environment properties can be introspected with appropriate\nOS access levels.\n\n.Externalizing `vault.token` to a properties file\n====\n[source, java]\n----\n@PropertySource(\"configuration.properties\")\n@Configuration\npublic class Config extends AbstractVaultConfiguration {\n\n @Override\n public ClientAuthentication clientAuthentication() {\n return new TokenAuthentication(getEnvironment().getProperty(\"vault.token\"));\n }\n}\n----\n====\n\nNOTE: Spring allows multiple ways to obtain `Environment`. When using `VaultPropertySource`, injection via `@Autowired Environment environment` will not provide the `Environment` as the environment bean is still in construction and autowiring comes at a later stage. Your configuration class should rather implement `ApplicationContextAware` and obtain the `Environment` from `ApplicationContext`.\n\nSee https://github.com/spring-projects/spring-vault/blob/master/spring-vault-core/src/test/java/org/springframework/vault/demo/SecurePropertyUsage.java[`SecurePropertyUsage.java`]\nfor a sample on referencing properties in components and other property sources.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "Externalizing login credentials", "heading_level": 2, "file_order": 4, "section_index": 1, "content_hash": "ccdaae36d89144138693482f11f2972f7a89f6b36c28f73811a231875b67cd72", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:9af87c9c75e3e60aa642ed427ad672be1c2d78fe85e1a83fb57ba07dd539bc30", "content": "The javadoc:org.springframework.vault.authentication.ClientAuthentication[] interface enables authentication against Vault and returns a `VaultToken` for authenticated Vault requests.\n\nImplementations are typically stateless and thread-safe, using `VaultClient` for authentication requests.\nMost authentication methods also implement javadoc:org.springframework.vault.authentication.AuthenticationStepsFactory[] for <<vault.authentication.steps,composable authentication>> in reactive/non-blocking reactive arrangements.\n\nTypically, an authentication mechanism requires configuration options specific to its method and a xref:vault/vault-client.adoc[`VaultClient`] to request the token by providing method-specific credentials.\nFor example, <<vault.authentication.approle>> retrieves all necessary credentials directly from Vault.\n\nSome authentication mechanisms depend on external credentials or tokens, particularly those relying on trusted environments (AWS, GCP, Azure compute instances).\nBuilt-in mechanisms accept either `RestClient` or transport-specific clients (such as Google IAM `TransportChannelProvider`).\n\nNOTE: When providing `RestClient` for authentication, configure it with Vault's base URL as authentication mechanisms use relative paths only.\nWhile `RestClient` allows customization of timeouts and SSL settings, we recommend using a separate `VaultClient` to avoid unintended configuration sharing between external communication and authentication requests.\n\n[[vault.authentication.token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "`ClientAuthentication` Interface", "heading_level": 2, "file_order": 4, "section_index": 2, "content_hash": "9af87c9c75e3e60aa642ed427ad672be1c2d78fe85e1a83fb57ba07dd539bc30", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:173ad313850839940e8cb3a42dbb4b4b4c390183957029468fa817ce04e2c978", "content": "Tokens are the core method for authentication within Vault.\nToken authentication requires a static token to be provided.\n\nNOTE: Token authentication is the default authentication method.\nIf a token is disclosed an unintended party, it gains access to Vault and\ncan access secrets for the intended client.\n\nTypically, Token authentication is used in scenarios in which the token is created and renewed\nexternally (such as https://github.com/hashicorp/vault-service-broker[HashiCorp Vault service broker]).\nDepending on the actual setup, you may or may not want token renewal and revocation.\nSee <<vault.authentication.session,`LifecycleAwareSessionManager`>> for details about TTL and token revocation.\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n return new TokenAuthentication(\"…\");\n }\n\n // …\n}\n----\n====\n\nSee also:\n\n* https://www.vaultproject.io/docs/concepts/tokens.html[Vault Documentation: Tokens]\n* https://www.vaultproject.io/docs/auth/token.html[Vault Documentation: Using the Token auth method]\n\n[[vault.authentication.approle]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "Token authentication", "heading_level": 2, "file_order": 4, "section_index": 3, "content_hash": "173ad313850839940e8cb3a42dbb4b4b4c390183957029468fa817ce04e2c978", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:d25df0e70ccf8bd42657d5e6bfa3e82f546d7abee63f64b1182d5f5aeaf3568c", "content": "https://www.vaultproject.io/docs/auth/app-id.html[AppRole] allows machine\nauthentication. AppRole authentication consists of two hard to guess (secret)\ntokens: RoleId and SecretId.\n\nSpring Vault supports AppRole authentication by providing either RoleId only\nor together with a provided SecretId and fetching RoleId/SecretId from Vault\n(push and pull modes with response unwrapping).\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n AppRoleAuthenticationOptions options = AppRoleAuthenticationOptions.builder()\n .roleId(RoleId.provided(\"…\"))\n .secretId(SecretId.wrapped(VaultToken.of(\"…\")))\n .build();\n\n return new AppRoleAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\nSpring Vault also support full pull mode: If RoleId and SecretId are not provided,\nSpring Vault will retrieve them using the role name and an initial token. The\ninitial token may be associated with a TTL and usage limit.\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n VaultToken initialToken = VaultToken.of(\"…\");\n AppRoleAuthenticationOptions options = AppRoleAuthenticationOptions.builder()\n .appRole(\"…\")\n .roleId(RoleId.pull(initialToken))\n .secretId(SecretId.pull(initialToken))\n .build();\n\n return new AppRoleAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\nSee also: https://www.vaultproject.io/docs/auth/approle.html[Vault Documentation: Using the AppRole auth method]\n\n[[vault.authentication.awsec2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "AppRole authentication", "heading_level": 2, "file_order": 4, "section_index": 4, "content_hash": "d25df0e70ccf8bd42657d5e6bfa3e82f546d7abee63f64b1182d5f5aeaf3568c", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:ef1a63029e1f512298b1aefa3eec27b603e551b1ac0b8f1e61436cf7c609aadb", "content": "The https://www.vaultproject.io/docs/auth/aws-ec2.html[aws-ec2]\nauth method provides a secure introduction mechanism\nfor AWS EC2 instances, allowing automated retrieval of a Vault token.\nUnlike most Vault authentication methods, this method\ndoes not require first-deploying, or provisioning security-sensitive\ncredentials (tokens, username/password, client certificates, etc.).\nInstead, it treats AWS as a Trusted Third Party and uses the\ncryptographically signed dynamic metadata information that uniquely\nrepresents each EC2 instance.\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n return new AwsEc2Authentication(vaultClient());\n }\n\n // …\n}\n----\n====\n\nAWS-EC2 authentication enables nonce by default to follow\nthe Trust On First Use (TOFU) principle. Any unintended party that\ngains access to the PKCS#7 identity metadata can authenticate\nagainst Vault.\n\nDuring the first login, Spring Vault generates a nonce that is stored in the auth method aside the instance Id.\nRe-authentication requires the same nonce to be sent. Any other\nparty does not have the nonce and can raise an alert in Vault for\nfurther investigation.\n\nThe nonce is kept in memory and is lost during application restart.\n\nSince Spring Vault 3.2, AWS-EC2 authentication supports request/response\n(IMDSv1) metadata retrieval and the session-based variant (IMDSv2).\n\nAWS-EC2 authentication roles are optional and default to the AMI.\nYou can configure the authentication role by setting\nit in `AwsEc2AuthenticationOptions`.\n\nSee also: https://www.vaultproject.io/docs/auth/aws-ec2.html[Vault Documentation: Using the AWS-EC2 auth method]\n\n[[vault.authentication.awsiam]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "AWS-EC2 authentication", "heading_level": 2, "file_order": 4, "section_index": 5, "content_hash": "ef1a63029e1f512298b1aefa3eec27b603e551b1ac0b8f1e61436cf7c609aadb", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:3c900b7843a03ade6b8995a0b481bb2249a7b6675cf89b4ded740b84c66ba10c", "content": "The https://www.vaultproject.io/docs/auth/aws.html[aws]\nauth method allows Vault login by using existing AWS IAM credentials.\n\nAWS IAM authentication creates a signed HTTP request that is\nexecuted by Vault to get the identity of the signer using AWS STS\n`GetCallerIdentity` method. AWSv4 signatures require IAM credentials.\n\nIAM credentials can be obtained from either the runtime environment\nor supplied externally. Runtime environments such as AWS-EC2,\nLambda and ECS with assigned IAM principals do not require client-specific\nconfiguration of credentials but can obtain these from its metadata source.\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n AwsIamAuthenticationOptions options = AwsIamAuthenticationOptions.builder()\n .credentials(new BasicAWSCredentials(…)).build();\n\n return new AwsIamAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\n.Using AWS-EC2 instance profile as credentials source\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n AwsIamAuthenticationOptions options = AwsIamAuthenticationOptions.builder()\n .credentialsProvider(InstanceProfileCredentialsProvider.getInstance()).build();\n\n return new AwsIamAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\n`AwsIamAuthentication` requires the AWS Java SDK dependency (`com.amazonaws:aws-java-sdk-core`)\nas the authentication implementation uses AWS SDK types for credentials and request signing.\n\nYou can configure the authentication via `AwsIamAuthenticationOptions`.\n\nSee also:\n\n* https://www.vaultproject.io/docs/auth/aws.html[Vault Documentation: Using the AWS auth method]\n* https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html[AWS Documentation: STS GetCallerIdentity]\n\n[[vault.authentication.azuremsi]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "AWS-IAM authentication", "heading_level": 2, "file_order": 4, "section_index": 6, "content_hash": "3c900b7843a03ade6b8995a0b481bb2249a7b6675cf89b4ded740b84c66ba10c", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:9f4f361392ec333463e608707166ac3bb7d5d77fade9292efe5c6d219cbdfa5a", "content": "The https://www.vaultproject.io/docs/auth/azure.html[azure]\nauth method provides a secure introduction mechanism\nfor Azure VM instances, allowing automated retrieval of a Vault token.\nUnlike most Vault authentication methods, this method\ndoes not require first-deploying, or provisioning security-sensitive\ncredentials (tokens, username/password, client certificates, etc.).\nInstead, it treats Azure as a Trusted Third Party and uses the\nmanaged service identity and instance metadata information that can be\nbound to a VM instance.\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n AzureMsiAuthenticationOptions options = AzureMsiAuthenticationOptions.builder()\n .role(…).build();\n\n return new AzureMsiAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\nAzure authentication requires details about the VM environment (subscription Id,\nresource group name, VM name). These details can be either configured through\n`AzureMsiAuthenticationOptionsBuilder`.\nIf left unconfigured, `AzureMsiAuthentication` queries Azure's instance metadata service to\nobtain these details.\n\nSee also:\n\n* https://www.vaultproject.io/docs/auth/azure.html[Vault Documentation: Using the Azure auth method]\n* https://docs.microsoft.com/en-us/azure/active-directory/managed-service-identity/overview[Azure Documentation: Managed Service Identity]\n\n[[vault.authentication.gcpgce]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "Azure (MSI) authentication", "heading_level": 2, "file_order": 4, "section_index": 7, "content_hash": "9f4f361392ec333463e608707166ac3bb7d5d77fade9292efe5c6d219cbdfa5a", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:7a523a3fb5a7a1fd05571af5517fc3c470f51a186d8032d8484cde0eacf5f6d0", "content": "The https://www.vaultproject.io/docs/auth/gcp.html[gcp]\nauth method allows Vault login by using existing GCP (Google Cloud Platform) IAM and GCE credentials.\n\nGCP GCE (Google Compute Engine) authentication creates a signature in the form of a\nJSON Web Token (JWT) for a service account. A JWT for a Compute Engine instance\nis obtained from the GCE metadata service using https://cloud.google.com/compute/docs/instances/verifying-instance-identity[Instance identification].\nThis API creates a JSON Web Token that can be used to confirm the instance identity.\n\nUnlike most Vault authentication methods, this method\ndoes not require first-deploying, or provisioning security-sensitive\ncredentials (tokens, username/password, client certificates, etc.).\nInstead, it treats GCP as a Trusted Third Party and uses the\ncryptographically signed dynamic metadata information that uniquely\nrepresents each GCP service account.\n\nYou can configure the authentication via `GcpComputeAuthenticationOptions`.\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n GcpComputeAuthenticationOptions options = GcpComputeAuthenticationOptions.builder()\n .role(…).build();\n\n GcpComputeAuthentication authentication = new GcpComputeAuthentication(options,\n vaultClient());\n }\n\n // …\n}\n----\n====\n\nSee also:\n\n* https://www.vaultproject.io/docs/auth/gcp.html[Vault Documentation: Using the GCP auth method]\n* https://cloud.google.com/compute/docs/instances/verifying-instance-identity[GCP Documentation: Verifying the Identity of Instances]\n\n[[vault.authentication.gcpiam]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "GCP-GCE authentication", "heading_level": 2, "file_order": 4, "section_index": 8, "content_hash": "7a523a3fb5a7a1fd05571af5517fc3c470f51a186d8032d8484cde0eacf5f6d0", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:6112c3ac287c3d355615ac4ee1fb240cd4d9ad7b049631144c4604fce6f33511", "content": "The https://www.vaultproject.io/docs/auth/gcp.html[gcp]\nauth method allows Vault login by using existing GCP (Google Cloud Platform) IAM and GCE credentials.\n\nGCP IAM authentication creates a signature in the form of a JSON Web Token (JWT)\nfor a service account. A JWT for a service account is obtained by\ncalling GCP IAM's https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signJwt[`projects.serviceAccounts.signJwt`] API. The caller authenticates against GCP IAM and proves thereby its identity.\nThis Vault auth method treats GCP as a Trusted Third Party.\n\nIAM credentials can be obtained from either the runtime environment\nor supplied externally as e.g. JSON. JSON is the preferred form as it\ncarries the project id and service account identifier required for calling\n``projects.serviceAccounts.signJwt``.\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n GcpIamCredentialsAuthenticationOptions options = GcpIamCredentialsAuthenticationOptions.builder()\n .role(…).credential(GoogleCredentials.getApplicationDefault()).build();\n\n GcpIamCredentialsAuthentication authentication = new GcpIamCredentialsAuthentication(options,\n vaultClient());\n }\n\n // …\n}\n----\n====\n\n`GcpIamCredentialsAuthenticationOptions` requires the Google Cloud Java SDK dependency\n(`com.google.cloud:google-cloud-iamcredentials`)\nas the authentication implementation uses Google APIs for credentials and JWT signing.\n\nYou can configure the authentication via `GcpIamCredentialsAuthenticationOptions`.\n\nNOTE: Google credentials require an OAuth 2 token maintaining the token lifecycle. All API\nis synchronous therefore, `GcpIamCredentialsAuthentication` does not support `AuthenticationSteps` which is\nrequired for reactive usage.\n\nNOTE: `GcpIamCredentialsAuthentication` uses the https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signJwt[IAM Credentials API] and is a replacement using the for the deprecated `GcpIamAuthentication` using the deprecated https://cloud.google.com/iam/docs/reference/rest/v1/projects.serviceAccounts/signJwt[IAM API].\n\nSee also:\n\n* https://www.vaultproject.io/docs/auth/gcp.html[Vault Documentation: Using the GCP auth method]\n* https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signJwt\n* https://cloud.google.com/iam/docs/reference/rest/v1/projects.serviceAccounts/signJwt (deprecated)\n\n[[vault.authentication.github]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "GCP-IAM authentication", "heading_level": 2, "file_order": 4, "section_index": 9, "content_hash": "6112c3ac287c3d355615ac4ee1fb240cd4d9ad7b049631144c4604fce6f33511", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:7d6cdc7f4000cfff9bb583da2eed2ca5ad25ba54a70e6621e70f6fa6cc6b7aed", "content": "The https://www.vaultproject.io/docs/auth/github.html[github]\nauth method provides an authentication mechanism based on GitHub tokens.\nVault does not support an OAuth workflow to generate GitHub tokens,\nso it does not act as a GitHub application.\n\nThe authentication mechanism requires a GitHub token (or a supplier)\nto pass on the token to Vault which then authenticates against your GitHub\naccount.\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n GitHubAuthentication options = GitHubAuthentication.builder()\n .token(…).build();\n\n return new GitHubAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\nSee also:\n\n* https://www.vaultproject.io/api-docs/auth/github[Vault Documentation: GitHub auth method]\n\n[[vault.authentication.pcf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "GitHub Authentication", "heading_level": 2, "file_order": 4, "section_index": 10, "content_hash": "7d6cdc7f4000cfff9bb583da2eed2ca5ad25ba54a70e6621e70f6fa6cc6b7aed", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:c46c30b02f85dd7254db6dd4b2ed6348166b163a1ad36ad72b57510cc335d651", "content": "The https://www.vaultproject.io/docs/auth/pcf.html[pcf]\nauth method allows Vault login for PCF instances.\nIt leverages https://content.pivotal.io/blog/new-in-pcf-2-1-app-container-identity-assurance-via-automatic-cert-rotation[PCF's App and Container Identity Assurance].\n\nPCF authentication uses the instance key and certificate to create a signature that is validated by Vault.\nIf the signature matches, and potentially bound organization/space/application Id's match, Vault issues an appropriately-scoped token.\n\nInstance credentials are available from files at `CF_INSTANCE_CERT` and\n`CF_INSTANCE_KEY` variables.\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n PcfAuthenticationOptions options = PcfAuthenticationOptions.builder()\n .role(…).build();\n\n PcfAuthentication authentication = new PcfAuthentication(options,\n vaultClient());\n }\n\n // …\n}\n----\n====\n\n`PcfAuthenticationOptions` requires the https://www.bouncycastle.org/latest_releases.html[BouncyCastle]\nlibrary for creating RSA-PSS signatures.\n\nYou can configure the authentication via `PcfAuthenticationOptions`.\n\nSee also:\n\n* https://www.vaultproject.io/docs/auth/pcf.html[Vault Documentation:\nUsing the PCF auth method]\n\n[[vault.authentication.clientcert]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "PCF authentication", "heading_level": 2, "file_order": 4, "section_index": 11, "content_hash": "c46c30b02f85dd7254db6dd4b2ed6348166b163a1ad36ad72b57510cc335d651", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:36bdf8e98680f57c14b1b34a5bb666f3848a285c274392911f3335c5dbbc8e55", "content": "The `cert` auth method allows authentication using SSL/TLS client\ncertificates that are either signed by a CA or self-signed.\n\nTo enable `cert` authentication you need to:\n\n1. Use SSL, see <<vault.client-ssl>>\n2. Configure a Java `Keystore` that contains the client\ncertificate and the private key\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n ClientCertificateAuthenticationOptions options = ClientCertificateAuthenticationOptions.builder()\n .path(…).build();\n\n return new ClientCertificateAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\nSee also: https://www.vaultproject.io/docs/auth/cert.html[Vault Documentation: Using the Cert auth method]\n\n[[vault.authentication.cubbyhole]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "TLS certificate authentication", "heading_level": 2, "file_order": 4, "section_index": 12, "content_hash": "36bdf8e98680f57c14b1b34a5bb666f3848a285c274392911f3335c5dbbc8e55", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:36060a59955f7de393b5e121477a8b536cd19430d1c97331c2d5ee4f82883268", "content": "Cubbyhole authentication uses Vault primitives to provide a secured authentication\nworkflow. Cubbyhole authentication uses tokens as primary login method.\nAn ephemeral token is used to obtain a second, login VaultToken from Vault's Cubbyhole secrets engine.\nThe login token is usually longer-lived and used to\ninteract with Vault. The login token can be retrieved either from a wrapped\nresponse or from the `data` section.\n\n*Creating a wrapped token*\n\nNOTE: Response Wrapping for token creation requires Vault 0.6.0 or higher.\n\n.Crating and storing tokens\n====\n[source,shell]\n----\n$ vault token-create -wrap-ttl=\"10m\"\nKey Value\n--- -----\nwrapping_token: 397ccb93-ff6c-b17b-9389-380b01ca2645\nwrapping_token_ttl: 0h10m0s\nwrapping_token_creation_time: 2016-09-18 20:29:48.652957077 +0200 CEST\nwrapped_accessor: 46b6aebb-187f-932a-26d7-4f3d86a68319\n----\n====\n\n.Wrapped token response usage\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n CubbyholeAuthenticationOptions options = CubbyholeAuthenticationOptions\n .builder()\n .initialToken(VaultToken.of(\"…\"))\n .wrapped()\n .build();\n\n return new CubbyholeAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\n*Using stored tokens*\n\n.Crating and storing tokens\n====\n[source,shell]\n----\n$ vault token create\nKey Value\n--- -----\ntoken f9e30681-d46a-cdaf-aaa0-2ae0a9ad0819\ntoken_accessor 4eee9bd9-81bb-06d6-af01-723c54a72148\ntoken_duration 0s\ntoken_renewable false\ntoken_policies [root]\n\n$ vault token create -use-limit=2 -orphan -no-default-policy -policy=none\nKey Value\n--- -----\ntoken 895cb88b-aef4-0e33-ba65-d50007290780\ntoken_accessor e84b661c-8aa8-2286-b788-f258f30c8325\ntoken_duration 0s\ntoken_renewable false\ntoken_policies [none]\n\n$ export VAULT_TOKEN=895cb88b-aef4-0e33-ba65-d50007290780\n$ vault write cubbyhole/token token=f9e30681-d46a-cdaf-aaa0-2ae0a9ad0819\n----\n====\n\n.Stored token response usage\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n CubbyholeAuthenticationOptions options = CubbyholeAuthenticationOptions\n .builder()\n .initialToken(VaultToken.of(\"…\"))\n .path(\"cubbyhole/token\")\n .build();\n\n return new CubbyholeAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\n*Remaining TTL/Renewability*\n\nTokens retrieved from Cubbyhole associated with a non-zero TTL start their TTL at the\ntime of token creation. That time is not necessarily identical with application\nstartup. To compensate for the initial delay, Cubbyhole authentication performs a\nself lookup for tokens associated with a non-zero TTL to retrieve the remaining TTL.\nCubbyhole authentication will not self-lookup wrapped tokens without a TTL because a\nzero TTL indicates there is no TTL associated.\n\nNon-wrapped tokens do not provide details regarding renewability and TTL by just\nretrieving the token. A self-lookup will lookup renewability and the remaining TTL.\n\nSee also:\n\n* https://www.vaultproject.io/docs/concepts/tokens.html[Vault Documentation: Tokens]\n* https://www.vaultproject.io/docs/secrets/cubbyhole/index.html[Vault Documentation: Cubbyhole Secrets Engine]\n* https://www.vaultproject.io/docs/concepts/response-wrapping.html[Vault Documentation: Response Wrapping]\n\n[[vault.authentication.jwt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "Cubbyhole authentication", "heading_level": 2, "file_order": 4, "section_index": 13, "content_hash": "36060a59955f7de393b5e121477a8b536cd19430d1c97331c2d5ee4f82883268", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:20e528cc3668c1cfae1c18274afe124c415730bb0e7203b837a957cdf5738370", "content": "Configuring JWT authentication requires the token or a JWT supplier.\nYou can configure the authentication via `JwtAuthenticationOptions`.\n\nOn the Vault side you can configure the JWT auth method by enabling the JWT auth method and creating a role.\nYou can either use `oidc_discovery_url`, `jwks_url` or `jwt_validation_pubkeys` to configure the JWT auth method.\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n JwtAuthenticationOptions options = JwtAuthenticationOptions.builder()\n .role(…).jwt(…).path(…).build();\n\n return new JwtAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\nSee also:\n\n* https://developer.hashicorp.com/vault/docs/auth/jwt[Vault Documentation: Using the JWT auth method]\n\n[[vault.authentication.kubernetes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "JWT authentication", "heading_level": 2, "file_order": 4, "section_index": 14, "content_hash": "20e528cc3668c1cfae1c18274afe124c415730bb0e7203b837a957cdf5738370", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:379e47ebdaeba49c62b80e73b6d5af847457fe15b56c75f71b1152a9811fd08c", "content": "Vault supports since 0.8.3 https://www.vaultproject.io/docs/auth/kubernetes.html[kubernetes]-based authentication using Kubernetes tokens.\n\nUsing Kubernetes authentication requires a Kubernetes Service Account Token,\nusually mounted at `/var/run/secrets/kubernetes.io/serviceaccount/token`.\nThe file contains the token which is read and sent to Vault.\nVault verifies its validity using Kubernetes' API during login.\n\nConfiguring Kubernetes authentication requires at least the role name to be provided:\n\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n KubernetesAuthenticationOptions options = KubernetesAuthenticationOptions.builder()\n .role(…).jwtSupplier(…).build();\n\n return new KubernetesAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\nYou can configure the authentication via `KubernetesAuthenticationOptions`.\n\nSee also:\n\n* https://www.vaultproject.io/docs/auth/kubernetes.html[Vault Documentation: Using the Kubernetes auth method]\n* https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[Kubernetes Documentation: Configure Service Accounts for Pods]\n\n[[vault.authentication.userpass]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "Kubernetes authentication", "heading_level": 2, "file_order": 4, "section_index": 15, "content_hash": "379e47ebdaeba49c62b80e73b6d5af847457fe15b56c75f71b1152a9811fd08c", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:cd779a9f46cd25d19b67094b3b7dd550aeff917a7f2467195a30b3dc8857a2f8", "content": "Username/Password is typically a end-user authentication scheme.\nUsing username and password is supported by multiple Vault authentication methods:\n\n* Username and Password (`userpass`)\n* LDAP (`ldap`)\n* Okta (`okta`, supports additionaly time-based one-time tokens)\n* RADIUS (`radius`)\n\n`UserPasswordAuthenticationOptions` can be used with all above mentioned authentication methods as the Login API is similar across all mechanisms.\nPlease ensure to use the appropriate auth mount path when configuring `UserPasswordAuthenticationOptions`.\n\n.Configuring `UserPasswordAuthentication`\n====\n[source,java]\n----\n@Configuration\nclass AppConfig extends AbstractVaultConfiguration {\n\n // …\n\n @Override\n public ClientAuthentication clientAuthentication() {\n\n UserPasswordAuthenticationOptions options = UserPasswordAuthenticationOptions.builder()\n .username(…).password(…).build();\n\n return new UserPasswordAuthentication(options, vaultClient());\n }\n\n // …\n}\n----\n====\n\nSee also:\n\n* https://www.vaultproject.io/api-docs/auth/userpass[Vault Documentation: Using the Userpass auth method]\n* https://www.vaultproject.io/api-docs/auth/ldap[Vault Documentation: Using the LDAP auth method]\n* https://www.vaultproject.io/api-docs/auth/radius[Vault Documentation: Using the RADIUS auth method]\n* https://www.vaultproject.io/api-docs/auth/okta[Vault Documentation: Using the Okta auth method]\n\n[[vault.authentication.steps]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "Username/Password authentication", "heading_level": 2, "file_order": 4, "section_index": 16, "content_hash": "cd779a9f46cd25d19b67094b3b7dd550aeff917a7f2467195a30b3dc8857a2f8", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:942e94ef287dec26e218cbaa83835d528ca935702189d70c675037e63286f6f9", "content": "`ClientAuthentication` objects describe the authentication flow and perform the actual\nauthentication steps. Pre-composed authentications are easy to use and to configure with\na tight binding to synchronous execution.\n\nThe composition of authentication methods and reusing common steps, such as posting login\npayload to Vault or retrieving authentication input from an HTTP source is not intended\nwith `ClientAuthentication` objects.\n\nAuthentication steps provide reusability of common authentication activity.\nSteps created via `AuthenticationSteps` describe an authentication flow in a functional\nstyle leaving the actual authentication execution to specific executors.\n\n.Stored token authentication flow.\n====\n[source,java]\n----\nAuthenticationSteps.just(VaultToken.of(…)); <1>\n----\n<1> Creates `AuthenticationSteps` from just a `VaultToken`.\n====\n\nA single-step authentication flow can be created from a single input. Flows declaring\nmultiple authentication steps start with a `Supplier` or `HttpRequest` that provide an\nauthentication state object which can be used to map or post to Vault for login.\n\n.AppRole authentication flow\n====\n[source,java]\n----\nAuthenticationSteps.fromSupplier( <1>\n\n () -> getAppRoleLogin(options.getRoleId(), options.getSecretId())) <2>\n\n .login(\"auth/{mount}/login\", options.getPath()); <3>\n----\n<1> Start declaring `AuthenticationSteps` accepting a `Supplier<T>`.\nThe state object type depends on the `Supplier` response type which can be mapped in a later step.\n<2> The actual `Supplier` implementation.\nCreating a `Map` in this case.\n<3> Perform a Vault login by posting the state object (`Map`) to a Vault endpoint for Vault token creation.\nNote that template variables are subject to URL escaping.\n====\n\nAuthentication flows require an executor to perform the actual login. We provide two executors\nfor different execution models:\n\n* `AuthenticationStepsExecutor` as a drop-in replacement for synchronous `ClientAuthentication`.\n* `AuthenticationStepsOperator` for reactive execution.\n\nMany ``ClientAuthentication``'s come with static factory methods to create `AuthenticationSteps`\nfor their authentication-specific options:\n\n.Synchronous `AuthenticationSteps` execution\n====\n[source,java]\n----\nCubbyholeAuthenticationOptions options = …\nVaultClient vaultClient = …\nRestClient restClient = …\n\nAuthenticationSteps steps = CubbyholeAuthentication.createAuthenticationSteps(options);\n\nAuthenticationStepsExecutor executor = new AuthenticationStepsExecutor(steps, vaultClient, restClient);\n\nVaultToken token = executor.login();\n----\n====\n\n[[vault.authentication.session]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "Authentication Steps", "heading_level": 2, "file_order": 4, "section_index": 17, "content_hash": "942e94ef287dec26e218cbaa83835d528ca935702189d70c675037e63286f6f9", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:ae4bb78e571b3c7d9e9cd4775a88cae66a9a895a5da1b69e7be07f3e7a6d470d", "content": "Vault's tokens can be associated with a time to live. Tokens obtained by an authentication method\nare intended to be used as long as the session is active and should not expire while the application is active.\n\nSpring Vault provides with javadoc:org.springframework.vault.authentication.LifecycleAwareSessionManager[] a session manager that can renew the token until it reaches its terminal TTL to then perform another login to obtain the next token which is associated with the session.\n\nDepending on the authentication method, a login can create two kinds of tokens:\n\n* javadoc:org.springframework.vault.support.VaultToken[]: Generic token encapsulating the actual token.\n* javadoc:org.springframework.vault.authentication.LoginToken[]: Token associated with renewability/TTL.\n\nAuthentication methods such as javadoc:org.springframework.vault.authentication.TokenAuthentication[] just create a `VaultToken` which does not carry any renewability/TTL details. javadoc:org.springframework.vault.authentication.LifecycleAwareSessionManager[] will run a self-lookup on the token to retrieve renewability and TTL from Vault.\n`VaultToken` are renewed periodically if self-lookup is enabled. Note that `VaultToken` are never revoked, only `LoginToken` are revoked.\n\nAuthentication methods creating `LoginToken` directly (all login-based authentication methods) already provide all necessary details to set up token renewal. Tokens obtained from a login are revoked by `LifecycleAwareSessionManager` if the session manager is shut down.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/authentication.adoc", "title": "authentication", "heading": "Token Lifecycle", "heading_level": 2, "file_order": 4, "section_index": 18, "content_hash": "ae4bb78e571b3c7d9e9cd4775a88cae66a9a895a5da1b69e7be07f3e7a6d470d", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/authentication.adoc"}}
{"id": "sha256:5c72a84d5a4deff14c3ff5f39384a013c71f9a4bf2aa00843b41963a1fd6dc6c", "content": "[[vault.core.client.support]]\n\nSpring Vault supports various HTTP clients to access Vault's HTTP API. Spring Vault uses\njavadoc:org.springframework.vault.client.VaultClient[] as primary interface accessing Vault.\n`VaultClient` is designed to be extensible and allows to plug in different HTTP clients based on a design similar to {spring-framework-docs}/integration/rest-clients.html#rest-restclient[`RestClient`].\nDedicated client support originates from <<vault.client-ssl,customized SSL configuration>>\nthat is scoped only to Spring Vault's client components.\n\nSpring Vault supports following HTTP imperative clients:\n\n* Java's builtin `HttpClient` (default client if no other is available)\n* Apache Http Components\n* Reactor Netty\n* Jetty\n\nSpring Vault's reactive integration supports the following reactive HTTP clients:\n\n* Java's builtin reactive `HttpClient` (default client if no other is available)\n* Apache Http Components\n* Reactor Netty\n* Jetty\n\nUsing a specific client requires the according dependency to be available on the classpath\nso Spring Vault can use the available client for communicating with Vault.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/client-support.adoc", "title": "client-support", "heading": "client-support", "heading_level": 1, "file_order": 5, "section_index": 0, "content_hash": "5c72a84d5a4deff14c3ff5f39384a013c71f9a4bf2aa00843b41963a1fd6dc6c", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/client-support.adoc"}}
{"id": "sha256:0de2970f41feb92c19f2177881d3cd3756964cb9cf93b95f04d7f0b599def13c", "content": "Java's builtin `HttpClient` is available out-of-the-box since Java 11 without additional\ndependencies.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/client-support.adoc", "title": "client-support", "heading": "Java's built-in `HttpClient`", "heading_level": 2, "file_order": 5, "section_index": 1, "content_hash": "0de2970f41feb92c19f2177881d3cd3756964cb9cf93b95f04d7f0b599def13c", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/client-support.adoc"}}
{"id": "sha256:392364d89570af6aed072b976d1d4f29bc13ec9a68f3f71f53d3f9f26ae8d9a3", "content": "You can use external clients to access Vault's API. Simply add one of the following\ndependencies to your project.\n\n.Apache Http Components Dependency\n====\n[source, xml]\n----\n<dependency>\n <groupId>org.apache.httpcomponents.client5</groupId>\n <artifactId>httpclient5</artifactId>\n</dependency>\n----\n====\n\nNOTE: Apache HttpClient's https://hc.apache.org/httpcomponents-client-5.2.x/logging.html[wire logging] can be enabled through logging configuration. Make sure to not accidentally enable wire logging as logs may expose traffic (tokens and secrets) between your application and Vault in plain text.\n\n.Reactor Netty\n====\n[source, xml]\n----\n<dependency>\n <groupId>io.projectreactor.netty</groupId>\n <artifactId>reactor-netty</artifactId>\n</dependency>\n----\n====\n\n.Apache Http Components Reactive Dependency\n====\n[source, xml]\n----\n<dependency>\n <groupId>org.apache.httpcomponents.core5</groupId>\n <artifactId>httpcore5-reactive</artifactId>\n</dependency>\n----\n====\n\n.Jetty\n====\n[source, xml]\n----\n<dependency>\n <groupId>org.eclipse.jetty</groupId>\n <artifactId>jetty-reactive-httpclient</artifactId>\n</dependency>\n----\n====\n\n[[vault.client-ssl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/client-support.adoc", "title": "client-support", "heading": "External Clients", "heading_level": 2, "file_order": 5, "section_index": 2, "content_hash": "392364d89570af6aed072b976d1d4f29bc13ec9a68f3f71f53d3f9f26ae8d9a3", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/client-support.adoc"}}
{"id": "sha256:f1c1dc74ccf242ae7eba8ba7ba26293bbc2296f57c80dc5f6fd2070a5f219416", "content": "SSL can be configured using javadoc:org.springframework.vault.support.SslConfiguration[] by setting various properties.\nYou can set either `javax.net.ssl.trustStore` to configure\nJVM-wide SSL settings or configure `SslConfiguration`\nto set SSL settings only for Spring Vault.\n\n====\n[source,java]\n----\n\nSslConfiguration sslConfiguration = SslConfiguration.create( <1>\n new FileSystemResource(\"client-cert.jks\"), \"changeit\".toCharArray(),\n new FileSystemResource(\"truststore.jks\"), \"changeit\".toCharArray());\n\nSslConfiguration.forTrustStore(new FileSystemResource(\"keystore.jks\"), <2>\n \"changeit\".toCharArray())\n\nSslConfiguration.forKeyStore(new FileSystemResource(\"keystore.jks\"), <3>\n \"changeit\".toCharArray())\n\nSslConfiguration.forKeyStore(new FileSystemResource(\"keystore.jks\"), <4>\n \"changeit\".toCharArray(),\n KeyConfiguration.of(\"key-password\".toCharArray(),\n \"my-key-alias\"))\n----\n<1> Full configuration.\n<2> Configuring only trust store settings.\n<3> Configuring only key store settings.\n<4> Configuring only key store settings with providing a key-configuration.\n====\n\nPlease note that providing javadoc:org.springframework.vault.support.SslConfiguration[] can be only applied when Apache Http Components is on your class-path.\n\nThe SSL configuration supports also PEM-encoded certificates as alternative to a Java Key Store.\n\n====\n[source,java]\n----\nKeyStoreConfiguration keystore = KeyStoreConfiguration\n .of(new ClassPathResource(\"ca.pem\")).withStoreType(\"PEM\");\nSslConfiguration configuration = SslConfiguration.forTrustStore(keystore);\n----\n====\n\nPEM files may contain one or more certificates (blocks of `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`).\nCertificates added to the underlying `KeyStore` use the full subject name as alias.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/client-support.adoc", "title": "client-support", "heading": "Vault Client SSL configuration", "heading_level": 2, "file_order": 5, "section_index": 3, "content_hash": "f1c1dc74ccf242ae7eba8ba7ba26293bbc2296f57c80dc5f6fd2070a5f219416", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/client-support.adoc"}}
{"id": "sha256:f27ab0c25dfac3d12a990d793cb608e2d05f44ddc6d6729ad955042fc54b5f4e", "content": "[[vault.credential-rotation]]\n\nVault's comprehensive credential rotation allows for automatic renewal and rotation of secrets, such as database credentials.\nBy binding secret validity to an application instance lifecycle, your applications maintain access to valid credentials without manual intervention.\nA compromised credential remains valid only for a limited time, with isolated impact to a single application instance.\n\nWhen a secret carries a lease, Spring Vault renews that lease before expiration, keeping credentials valid throughout the application lifecycle.\n\nThe following sections cover the credential rotation infrastructure used by components such as xref:vault/propertysource.adoc[].\n\n[[vault.credential-rotation.secret-lease-container]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/credential-rotation.adoc", "title": "credential-rotation", "heading": "credential-rotation", "heading_level": 1, "file_order": 6, "section_index": 0, "content_hash": "f27ab0c25dfac3d12a990d793cb608e2d05f44ddc6d6729ad955042fc54b5f4e", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/credential-rotation.adoc"}}
{"id": "sha256:e38c9d3717f0eb0694a4cb7b41e5856daadbcf9de94b0f39a48a67b5c52b091c", "content": "`SecretLeaseContainer` manages the lifecycle of leased secrets.\nIt renews leases before expiration and rotates credentials when necessary, listening for lease events and triggering appropriate actions.\n\nAs a Spring `Lifecycle` component, the container supports dynamic secret management during application runtime.\nIt accepts javadoc:org.springframework.vault.core.lease.domain.RequestedSecret[] instances representing secrets under management.\n\n.Setting up a `SecretLeaseContainer`\n====\n[source,java]\n----\nSecretLeaseContainer container = new SecretLeaseContainer(vaultOperations, <1>\n taskScheduler);\n\nRequestedSecret requestedSecret = container <2>\n .requestRotatingSecret(\"mysql/creds/my-role\");\n\ncontainer.addLeaseListener(new LeaseListenerAdapter() { <3>\n\n @Override\n public void onLeaseEvent(SecretLeaseEvent secretLeaseEvent) {\n if (requestedSecret.equals(secretLeaseEvent.getSource())) {\n if (secretLeaseEvent instanceof SecretLeaseCreatedEvent) {\n // …\n }\n if (secretLeaseEvent instanceof SecretLeaseExpiredEvent) {\n // …\n }\n }\n }\n});\ncontainer.afterPropertiesSet();\ncontainer.start(); // events are triggered after starting the container\n----\n\n<1> Initialize with `VaultOperations` and a `TaskScheduler` for renewal scheduling.\n<2> Request a rotating secret from a Vault path.\n<3> Register a `LeaseListener` for lease events.\nRegistration order matters: Listeners added after container startup or secret requests may miss early events.\nSet up listeners before starting the container to capture all events.\n====\n\nNOTE: A `SecretLaseContainer` is registered when your configuration class is a subclass of `AbstractVaultConfiguration` that is typically applicable for non-Spring Boot applications.\nWhen using Spring Boot, consider https://github.com/spring-cloud/spring-cloud-vault[Spring Cloud Vault], which handles registration through auto-configuration.\n\n[[vault.credential-rotation.secret-lease-container.events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/credential-rotation.adoc", "title": "credential-rotation", "heading": "SecretLeaseContainer", "heading_level": 2, "file_order": 6, "section_index": 1, "content_hash": "e38c9d3717f0eb0694a4cb7b41e5856daadbcf9de94b0f39a48a67b5c52b091c", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/credential-rotation.adoc"}}
{"id": "sha256:9c8e25467997eec78275fb8b05345ccfb1137fd8c8b6deb9806ea4712cb9af6f", "content": "**Regular Events**\n\n* javadoc:org.springframework.vault.core.lease.event.AfterSecretLeaseRenewedEvent[]: Lease renewed successfully.\n* javadoc:org.springframework.vault.core.lease.event.AfterSecretLeaseRevocationEvent[]: Lease revoked successfully.\n* javadoc:org.springframework.vault.core.lease.event.BeforeSecretLeaseRevocationEvent[]: Before lease revocation, allowing pre-revocation actions.\n* javadoc:org.springframework.vault.core.lease.event.SecretLeaseCreatedEvent[]: New lease created, typically on initial request.\n* javadoc:org.springframework.vault.core.lease.event.SecretLeaseRotatedEvent[]: Specialization of `SecretLeaseCreatedEvent` for secret rotation after lease expiration.\n* javadoc:org.springframework.vault.core.lease.event.SecretLeaseExpiredEvent[]: Lease detected as expired, either by TTL expiration or expiry `Predicate<Lease>` evaluation.\n* javadoc:org.springframework.vault.core.lease.event.SecretNotFoundEvent[]: Secret not found at the Vault path during initial request or renewal.\n\n**Error Events**\n\n* javadoc:org.springframework.vault.core.lease.event.SecretLeaseErrorEvent[]: Vault error response or I/O error during communication.\n\nUsing `SecretLeaseContainer` directly with its listeners allows for fine-grained control over the lifecycle of secrets and handling of lease events.\nIn typical application scenarios, you might want to use a higher-level abstraction that simplifies the management of secrets and their leases.\n\n[[vault.credential-rotation.secret-lease-container.secret-registrar]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/credential-rotation.adoc", "title": "credential-rotation", "heading": "Events", "heading_level": 3, "file_order": 6, "section_index": 2, "content_hash": "9c8e25467997eec78275fb8b05345ccfb1137fd8c8b6deb9806ea4712cb9af6f", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/credential-rotation.adoc"}}
{"id": "sha256:f4065ed4d43cbc6509c49cecd68e44ab44cd2a0dfe1cc0d33933442b9450fe9a", "content": "The javadoc:org.springframework.vault.core.lease.ManagedSecret[] API offers declarative secret lifecycle management. `ManagedSecret` is a higher-level abstraction that registers with `SecretLeaseContainer` and handles lease events on your behalf.\nAs an implementation of javadoc:org.springframework.vault.core.lease.SecretRegistrar[], registrar beans are registered with the container before startup through `AbstractVaultConfiguration`.\n\n.Registering a `ManagedSecret`\n====\n[source,java]\n----\n@Configuration\nclass MyConfiguration {\n\n @Bean\n ManagedSecret mysqlCredentials(HikariDataSource dataSource) {\n return ManagedSecret.rotating(\"mysql/creds/my-role\", secrets -> secrets.as(UsernamePassword::from)\n .applyTo((username, password) -> {\n connectionPool.setUsername(username);\n connectionPool.setPassword(password);\n }));\n }\n}\n----\n====\n\nManaged Secrets allow a direct connection between the secret management and the application components that use the secrets making it easier to propagate credentials to the application components when secrets are requested or rotated.\nNote that the `SecretLeaseContainers` lifecycle nature typically defers the availability of secrets until the container is started and secrets are requested and that can be different from using components that require credentials during `InitializingBean.afterPropertiesSet()` or `@PostConstruct` phase.\n`AbstractVaultConfiguration` deliberately starts the container already during the bean creation to allow for early credentials access.\nYou should in any case ensure dependency ordering of your components to ensure proper initialization and availability of secrets when needed.\n\n[[vault.credential-rotation.secret-lease-container.ttl-tuning]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/credential-rotation.adoc", "title": "credential-rotation", "heading": "ManagedSecret and SecretRegistrar", "heading_level": 3, "file_order": 6, "section_index": 3, "content_hash": "f4065ed4d43cbc6509c49cecd68e44ab44cd2a0dfe1cc0d33933442b9450fe9a", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/credential-rotation.adoc"}}
{"id": "sha256:b643196371d96fe1125bc96b0ac3a72be7437a833f07e710032cfcc915078b48", "content": "Lease renewal and rotation are subject to TTL (Time To Live) and therefore directly related to timing.\n`SecretLeaseContainer` uses an expiry threshold (default 1 minute) to determine whether a lease is considered expired.\nThe minimum renewal TTL (default 10 seconds) prevents excessive renewal requests in short succession.\nRenewal and rotation times are calculated based on lease TTL duration and the local system clock (specifically `TaskScheduler` clock).\n\nYou can configure a custom expiry `Predicate<Lease>` function for lease expiration determination.\n\n[[vault.credential-rotation.secret-lease-container.session]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/credential-rotation.adoc", "title": "credential-rotation", "heading": "TTL Tuning", "heading_level": 3, "file_order": 6, "section_index": 4, "content_hash": "b643196371d96fe1125bc96b0ac3a72be7437a833f07e710032cfcc915078b48", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/credential-rotation.adoc"}}
{"id": "sha256:80501072f5995c7a7d50066fed4e0a2f7cc12126af87b2ee5e50fd691ca68415", "content": "Vault revokes leases associated with a session token when that token expires or is revoked.\nWhen your Vault session expires (hitting Max TTL), any leases issued within that session are also revoked.\n`SessionLeaseContainer` provides an `AuthenticationListener` through `getAuthenticationListener()` and `getAuthenticationErrorListener()` for registration with your `SessionManager`, allowing secret restart after successful re-login.\n\n[[vault.credential-rotation.certificate-container]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/credential-rotation.adoc", "title": "credential-rotation", "heading": "Token Renewal and Session Management", "heading_level": 3, "file_order": 6, "section_index": 5, "content_hash": "80501072f5995c7a7d50066fed4e0a2f7cc12126af87b2ee5e50fd691ca68415", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/credential-rotation.adoc"}}
{"id": "sha256:c1e7123b1dad39a33889515d7a2e2ee5b2b67b4f0abf758533db3e488e6513cf", "content": "`CertificateContainer` manages certificates issued by Vault's PKI secrets engine.\nCertificates are typically not associated with a lease (in fact, avoiding leases is a performance optimization recommendation) and therefore, they do not require renewal, but they can be rotated when they expire.\nCertificate rotation is effectively a re-issuance.\n\nVault PKI serves several certificate types:\n\n* X.509 Certificate Bundles\n** TLS encryption\n** Client authentication\n* X.509 Certificates\n** Trust Anchors\n\nThe container is a Spring `Lifecycle` component that can be started and stopped, allowing for dynamic management of certificates during application runtime.\nIt accepts javadoc:org.springframework.vault.core.certificate.domain.RequestedCertificate[] instances, which represent the certificate that need to be managed.\nThe following code example shows how to set up a `CertificateContainer` and listen for events:\n\n.Setting up a `CertificateContainer`\n====\n[source,java]\n----\nCertificateContainer container = new CertificateContainer(vaultOperations.opsForPki()); <1>\n\nRequestedCertificate cert = container\n .register(RequestedCertificate.trustAnchor(\"vault-ca\")); <2>\n\nRequestedCertificate bundle = RequestedCertificateBundle.issue(\"www.example.com\", <3>\n \"testrole\", VaultCertificateRequest.builder()\n .commonName(\"www.example.com\")\n .ttl(Duration.ofHours(12)).build());\n\ncontainer.addCertificateListener(new CertificateListenerAdapter() { <4>\n @Override\n public void onCertificateEvent(CertificateEvent event) {\n if (cert.equals(event.getSource())) {\n if (event instanceof CertificateBundleIssuedEvent) {\n // Certificate bundle issued initially or rotated\n }\n if (event instanceof CertificateObtainedEvent) {\n // initial certificate obtained\n }\n }\n }\n});\n\ncontainer.afterPropertiesSet();\ncontainer.start(); // events are triggered after starting the container\n----\n\n<1> Initialize with `VaultPkiOperations`.\nWithout a provided `TaskScheduler`, the container creates a default instance.\n<2> Request an issuer certificate through `RequestedCertificate` (Supports default or named issuers).\n<3> Request a managed certificate bundle through `RequestedCertificateBundle` with a certificate request.\n<4> Register a `CertificateListener` for certificate events.\nRegistration order matters: listeners added after container startup or certificate requests may miss early events.\nSet up listeners before starting the container to capture all events.\n====\n\nNOTE: A `CertificateContainer` is registered when your configuration class is a subclass of `AbstractVaultConfiguration` that is typically applicable for non-Spring Boot applications.\nWhen using Spring Boot, cconsider https://github.com/spring-cloud/spring-cloud-vault[Spring Cloud Vault], which handles registration through auto-configuration.\n\n[[vault.credential-rotation.certificate-container.events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/credential-rotation.adoc", "title": "credential-rotation", "heading": "CertificateContainer", "heading_level": 2, "file_order": 6, "section_index": 6, "content_hash": "c1e7123b1dad39a33889515d7a2e2ee5b2b67b4f0abf758533db3e488e6513cf", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/credential-rotation.adoc"}}
{"id": "sha256:cee8e7b63143157cf8549b5ad87ce588c8e95333a8374fe6666db95cc0ce6220", "content": "**Regular Events**\n\n* javadoc:org.springframework.vault.core.certificate.event.CertificateObtainedEvent[]: Certificate issued.\n* javadoc:org.springframework.vault.core.certificate.event.CertificateRotatedEvent[]: Specialization of `CertificateObtainedEvent` for certificate rotation.\n* javadoc:org.springframework.vault.core.certificate.event.CertificateBundleIssuedEvent[]: Specialization of `CertificateObtainedEvent` for certificate bundle issuance.\n* javadoc:org.springframework.vault.core.certificate.event.CertificateBundleRotatedEvent[]: Specialization of `CertificateBundleIssuedEvent` for certificate bundle rotation.\n* javadoc:org.springframework.vault.core.certificate.event.CertificateExpiredEvent[]: Certificate detected as expired.\n\n**Error Events**\n\n* javadoc:org.springframework.vault.core.certificate.event.CertificateErrorEvent[]: In case of a Vault error response or an I/O error during Vault communication.\n\nUsing `CertificateContainer` directly with its listeners allows for fine-grained control over the lifecycle of certificates and handling of events.\nIn typical application scenarios, you might want to use a higher-level abstraction that simplifies the management of certificates.\n\n[[vault.credential-rotation.certificate-container.certificate-registrar]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/credential-rotation.adoc", "title": "credential-rotation", "heading": "Events", "heading_level": 3, "file_order": 6, "section_index": 7, "content_hash": "cee8e7b63143157cf8549b5ad87ce588c8e95333a8374fe6666db95cc0ce6220", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/credential-rotation.adoc"}}
{"id": "sha256:f40723336e04089bb3cd79efbe4201f470bd11453cede043357ce8515eb985d2", "content": "The javadoc:org.springframework.vault.core.certificate.ManagedCertificate[] API offers declarative certificate lifecycle management. `ManagedCertificate` is a higher-level abstraction that registers with `CertificateContainer` and handles certificate events on your behalf.\nIt is an implementation of javadoc:org.springframework.vault.core.certificate.CertificateRegistrar[].\nRegistrar beans are detected by `AbstractVaultConfiguration` and registered with the `CertificateContainer` before container startup.\n\n.Registering a `ManagedCertificate`\n====\n[source,java]\n----\n@Configuration\nclass MyConfiguration {\n\n @Bean\n ManagedCertificate serverCertificate(SslBundles bundles) {\n VaultCertificateRequest request = VaultCertificateRequest.builder()\n .commonName(\"www.example.com\")\n .ttl(Duration.ofHours(12)).build();\n return ManagedCertificate.issue(\"my-bundle\", \"my-role\", request, bundle -> {\n bundles.register(\"my-bundle\", bundle.createKeyStore(\"my-alias\"));\n });\n }\n}\n----\n====\n\nManaged Certificates allow a direct connection between the certificate management and the application components that use the certificates making it easier to propagate credentials to the application components.\nNote that the `CertificateContainer` lifecycle nature typically defers the availability of certificates until the container is started and certificates are requested and that can be different from using components that require credentials during `InitializingBean.afterPropertiesSet()` or `@PostConstruct` phase.\n`AbstractVaultConfiguration` deliberately starts the container already during the bean creation to allow for early certificate access.\nYou should in any case ensure dependency ordering of your components to ensure proper initialization and availability of certificates when needed.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/credential-rotation.adoc", "title": "credential-rotation", "heading": "ManagedCertificate and CertificateRegistrar", "heading_level": 3, "file_order": 6, "section_index": 8, "content_hash": "f40723336e04089bb3cd79efbe4201f470bd11453cede043357ce8515eb985d2", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/credential-rotation.adoc"}}
{"id": "sha256:5fff65ebd89d5a054f03ace1c126e59899e72e4db9171b505e04e0d2ae72d9c1", "content": "[[vault.core.template]]\n\nThe class javadoc:org.springframework.vault.core.VaultTemplate[], located in the package `org.springframework.vault.core`,\nis the central class of the Spring's Vault support providing a rich feature set to\ninteract with Vault. The template offers convenience operations to read, write and\ndelete data in Vault and provides a mapping between your domain objects and Vault data.\n\nNOTE: Once configured, javadoc:org.springframework.vault.core.VaultTemplate[] is thread-safe and can be reused across\nmultiple instances.\n\nThe mapping between Vault documents and domain classes is done by delegating to\nxref:vault/vault-client.adoc[`VaultClient`]. Spring Web support provides the mapping infrastructure.\n\nThe javadoc:org.springframework.vault.core.VaultTemplate[] class implements the interface\njavadoc:org.springframework.vault.core.VaultOperations[].\nIn as much as possible, the methods on javadoc:org.springframework.vault.core.VaultOperations[] are named after methods\navailable on the Vault API to make the API familiar to existing Vault developers\nwho are used to the API and CLI. For example, you will find methods such as\n\"write\", \"delete\", \"read\", and \"revoke\".\nThe design goal was to make it as easy as possible to transition between\nthe use of the Vault API and `VaultOperations`. A major difference in between\nthe two APIs is that `VaultOperations` can be passed domain objects instead of\nJSON Key-Value pairs.\n\nPaths used in `VaultTemplate` (and interfaces accessible from there) are considered\nrelative to the `VaultEndpoint`. Paths that are fully-qualified URI's can be used\nto access Vault cluster members in an authenticated context. To prevent unwanted\nfull URI access, make sure to sanitize paths before passing them to `VaultTemplate`.\n\nNOTE: The preferred way to reference the operations on javadoc:org.springframework.vault.core.VaultTemplate[] instance\nis via its interface javadoc:org.springframework.vault.core.VaultOperations[].\n\nWhile there are many convenience methods on `VaultTemplate` to help you easily\nperform common tasks if you should need to access the Vault API directly to access\nfunctionality not explicitly exposed by the `VaultTemplate` you can use one of\nseveral execute callback methods to access underlying APIs. The execute callbacks\nwill give you a reference to a `VaultClient` object.\nPlease see the section <<vault.core.executioncallback,Execution Callbacks>> for more information.\n\nNow let's look at a examples of how to work with Vault in the context of the Spring container.\n\n[[vault.core.template.beans]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/imperative-template.adoc", "title": "imperative-template", "heading": "imperative-template", "heading_level": 1, "file_order": 7, "section_index": 0, "content_hash": "5fff65ebd89d5a054f03ace1c126e59899e72e4db9171b505e04e0d2ae72d9c1", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/imperative-template.adoc"}}
{"id": "sha256:ac39bc5b3e1b455ddee603e166549597b98cad159b933e223ad649e23ae7415e", "content": "Using Spring Vault does not require a Spring Context. However, instances of `VaultTemplate` and\njavadoc:org.springframework.vault.authentication.SessionManager[] registered inside a managed context will participate\nin {spring-framework-docs}/core/beans/factory-nature.html[lifecycle events]\nprovided by the Spring IoC container. This is useful to dispose active Vault sessions upon\napplication shutdown. You also benefit from reusing the same `VaultTemplate`\ninstance across your application.\n\nSpring Vault comes with a supporting configuration class that provides bean definitions\nfor use inside a Spring context. Application configuration\nclasses typically extend from javadoc:org.springframework.vault.config.AbstractVaultConfiguration[] and are required to\nprovide additional details that are environment specific.\n\nExtending from javadoc:org.springframework.vault.config.AbstractVaultConfiguration[] requires to implement\n`VaultEndpoint vaultEndpoint()` and `ClientAuthentication clientAuthentication()`\nmethods.\n\n.Registering Spring Vault objects using Java based bean metadata\n====\n[source,java]\n----\n@Configuration\npublic class AppConfig extends AbstractVaultConfiguration {\n\n /**\n * Specify an endpoint for connecting to Vault.\n */\n @Override\n public VaultEndpoint vaultEndpoint() {\n return new VaultEndpoint(); <1>\n }\n\n /**\n * Configure a client authentication.\n * Please consider a more secure authentication method\n * for production use.\n */\n @Override\n public ClientAuthentication clientAuthentication() {\n return new TokenAuthentication(\"…\"); <2>\n }\n}\n----\n<1> Create a new javadoc:org.springframework.vault.client.VaultEndpoint[] that points by default to `\\https://localhost:8200`.\n<2> This sample uses javadoc:org.springframework.vault.authentication.TokenAuthentication[] to get started quickly.\nSee <<vault.core.authentication>> for details on supported authentication methods.\n====\n\n.Registering Spring Vault applying injected properties\n====\n[source,java]\n----\n@Configuration\npublic class AppConfig extends AbstractVaultConfiguration {\n\n @Value(\"${vault.uri}\")\n URI vaultUri;\n\n /**\n * Specify an endpoint that was injected as URI.\n */\n @Override\n public VaultEndpoint vaultEndpoint() {\n return VaultEndpoint.from(vaultUri); <1>\n }\n\n /**\n * Configure a Client Certificate authentication.\n * {@link RestOperations} can be obtained from {@link #restOperations()}.\n */\n @Override\n public ClientAuthentication clientAuthentication() {\n return new ClientCertificateAuthentication(restOperations()); <2>\n }\n}\n----\n<1> javadoc:org.springframework.vault.client.VaultEndpoint[] can be constructed using various factory methods such as\n`from(URI uri)` or `VaultEndpoint.create(String host, int port)`.\n<2> Dependencies for `ClientAuthentication` methods can be obtained either from\n`AbstractVaultConfiguration` or provided by your configuration.\n====\n\nNOTE: Creating a custom configuration class might be cumbersome in some cases.\nTake a look at javadoc:org.springframework.vault.config.EnvironmentVaultConfiguration[] that allows configuration by using\nproperties from existing property sources and Spring's `Environment`. Read more\nin <<vault.core.environment-vault-configuration>>.\n\n[[vault.core.template.sessionmanagement]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/imperative-template.adoc", "title": "imperative-template", "heading": "Registering and configuring Spring Vault beans", "heading_level": 2, "file_order": 7, "section_index": 1, "content_hash": "ac39bc5b3e1b455ddee603e166549597b98cad159b933e223ad649e23ae7415e", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/imperative-template.adoc"}}
{"id": "sha256:ca0c466526cef18af22012974cb7882d6a3152c73b6abbd144c7f01a7d7c6298", "content": "Spring Vault requires a `ClientAuthentication` to login and access Vault.\nSee <<vault.core.authentication>> on details regarding authentication.\nVault login should not occur on each authenticated Vault interaction but\nmust be reused throughout a session. This aspect is handled by a\n`SessionManager` implementation. A `SessionManager` decides how often it\nobtains a token, about revocation and renewal. Spring Vault comes with two implementations:\n\n* javadoc:org.springframework.vault.authentication.SimpleSessionManager[]: Just obtains tokens from the supplied\n`ClientAuthentication` without refresh and revocation\n* javadoc:org.springframework.vault.authentication.LifecycleAwareSessionManager[]: This `SessionManager` schedules token\nrenewal if a token is renewable and revoke a login token on disposal.\nRenewal is scheduled with an `AsyncTaskExecutor`. `LifecycleAwareSessionManager`\nis configured by default if using `AbstractVaultConfiguration`.\n\n[[vault.core.environment-vault-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/imperative-template.adoc", "title": "imperative-template", "heading": "Session Management", "heading_level": 2, "file_order": 7, "section_index": 2, "content_hash": "ca0c466526cef18af22012974cb7882d6a3152c73b6abbd144c7f01a7d7c6298", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/imperative-template.adoc"}}
{"id": "sha256:f3f15202c4531332904b048b06a961f55ed98478e755746e6ae403fc39e95dab", "content": "Spring Vault includes javadoc:org.springframework.vault.config.EnvironmentVaultConfiguration[] configure the Vault client from Spring's `Environment` and a set of predefined\nproperty keys.\njavadoc:org.springframework.vault.config.EnvironmentVaultConfiguration[] supports frequently applied configurations. Other configurations are supported by deriving from the most appropriate configuration class.\nInclude javadoc:org.springframework.vault.config.EnvironmentVaultConfiguration[] with `@Import(EnvironmentVaultConfiguration.class)` to existing\nJava-based configuration classes and supply configuration properties through any of Spring's ``PropertySource``s.\n\n.Using EnvironmentVaultConfiguration with a property file\n====\n\n.Java-based configuration class\n[source,java]\n----\n@PropertySource(\"vault.properties\")\n@Import(EnvironmentVaultConfiguration.class)\npublic class MyConfiguration{\n}\n----\n\n.vault.properties\n[source,properties]\n----\nvault.uri=https://localhost:8200\nvault.token=00000000-0000-0000-0000-000000000000\n----\n====\n\n**Property keys**\n\n* Vault URI: `vault.uri`\n* SSL Configuration\n** Keystore resource: `vault.ssl.key-store` (optional)\n** Keystore password: `vault.ssl.key-store-password` (optional)\n** Keystore type: `vault.ssl.key-store-type` (optional, typically `jks`, supports also `pem`)\n** Truststore resource: `vault.ssl.trust-store` (optional)\n** Truststore password: `vault.ssl.trust-store-password` (optional)\n** Truststore type: `vault.ssl.trust-store-type` (optional, typically `jks`, supports also `pem`)\n** Enabled SSL/TLS protocols: `vault.ssl.enabled-protocols` (since 2.3.2, optional, protocols separated with comma)\n** Enabled SSL/TLS cipher suites: `vault.ssl.enabled-cipher-suites` (since 2.3.2, optional, cipher suites separated with comma)\n* Authentication method: `vault.authentication` (defaults to `TOKEN`, supported authentication methods are: `TOKEN`, `APPROLE`, `AWS_EC2`, `AWS_IAM`, `AZURE`, `CERT`, `CUBBYHOLE`, `KUBERNETES`)\n\n**Authentication-specific property keys**\n\n**<<vault.authentication.token>>**\n\n* Vault Token: `vault.token`\n\n**<<vault.authentication.approle>>**\n\n* AppRole path: `vault.app-role.app-role-path` (defaults to `approle`)\n* RoleId: `vault.app-role.role-id`\n* SecretId: `vault.app-role.secret-id` (optional)\n\n**<<vault.authentication.awsec2>>**\n\n* AWS EC2 path: `vault.aws-ec2.aws-ec2-path` (defaults to `aws-ec2`)\n* Role: `vault.aws-ec2.role`\n* RoleId: `vault.aws-ec2.role-id` (*deprecated:* use `vault.aws-ec2.role` instead)\n* Identity Document URL: `vault.aws-ec2.identity-document` (defaults to `http://169.254.169.254/latest/dynamic/instance-identity/pkcs7`)\n\n**<<vault.authentication.awsiam>>**\n\n* Role: `vault.aws-iam.role`\n\n**<<vault.authentication.azuremsi>>**\n\n* Azure MSI path: `vault.azure-msi.azure-path` (defaults to `azure`)\n* Role: `vault.azure-msi.role`\n* Metadata Service URL: `vault.azure-msi.metadata-service` (defaults to `http://169.254.169.254/metadata/instance?api-version=2017-08-01`)\n* Identity TokenService URL: `vault.azure-msi.identity-token-service` (defaults to `http://169.254.169.254/metadata/identity/oauth2/token?resource=https://vault.hashicorp.com&api-version=2018-02-01`)\n\n**<<vault.authentication.clientcert>>**\n\nNo configuration options.\n\n**<<vault.authentication.cubbyhole>>**\n\n* Initial Vault Token: `vault.token`\n\n**<<vault.authentication.kubernetes>>**\n\n* Kubernetes path: `vault.kubernetes.kubernetes-path` (defaults to `kubernetes`)\n* Role: `vault.kubernetes.role`\n* Path to service account token file: `vault.kubernetes.service-account-token-file` (defaults to `/var/run/secrets/kubernetes.io/serviceaccount/token`)\n\n[[vault.core.executioncallback]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/imperative-template.adoc", "title": "imperative-template", "heading": "Using `EnvironmentVaultConfiguration`", "heading_level": 2, "file_order": 7, "section_index": 3, "content_hash": "f3f15202c4531332904b048b06a961f55ed98478e755746e6ae403fc39e95dab", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/imperative-template.adoc"}}
{"id": "sha256:3210a9f3fd12cfff10492627243478ff564ff51c325c244838bbb95f74c50be5", "content": "One common design feature of all Spring template classes is that all functionality is routed into one of the templates execute callback methods.\nThis helps ensure that exceptions and any resource management that maybe required are performed consistency.\nWhile this was of much greater need in the case of JDBC and JMS than with Vault, it still offers a single spot for access and logging to occur.\nAs such, using the execute callback is the preferred way to access the Vault API\nto perform uncommon operations that we've not exposed as methods on javadoc:org.springframework.vault.core.VaultTemplate[].\n\nHere is a list of execute callback methods.\n\n* `<T> T` *doWithVault* `(RestOperationsCallback<T> callback)` Executes the given\n`RestOperationsCallback`, allows to interact with Vault using `RestOperations` without requiring a session.\n\n* `<T> T` *doWithSession* `(RestOperationsCallback<T> callback)` Executes the given\n`RestOperationsCallback`, allows to interact with Vault in an authenticated session.\n\nHere is an example that uses the `ClientCallback` to initialize Vault:\n\n====\n[source,java]\n----\nvaultOperations.doWithVault(new RestOperationsCallback<VaultInitializationResponse>() {\n\n @Override\n public VaultInitializationResponse doWithRestOperations(RestOperations restOperations) {\n\n ResponseEntity<VaultInitializationResponse> exchange = restOperations\n .exchange(\"sys/init\", HttpMethod.PUT,\n new HttpEntity<Object>(request),\n VaultInitializationResponse.class);\n\n return exchange.getBody();\n }\n});\n\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/imperative-template.adoc", "title": "imperative-template", "heading": "Execution callbacks", "heading_level": 2, "file_order": 7, "section_index": 4, "content_hash": "3210a9f3fd12cfff10492627243478ff564ff51c325c244838bbb95f74c50be5", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/imperative-template.adoc"}}
{"id": "sha256:20de165f3f4895158a4ac8f5c8af14d0637ef00ac5c6fcf121de5b7fd9a0d802", "content": "[[vault.core.propertysupport]]\n\nVault can be used in many different ways. One specific use-case is using\nVault to store encrypted properties. Spring Vault supports Vault as property\nsource to obtain configuration properties using Spring's {spring-framework-docs}/core/beans/environment.html#beans-property-source-abstraction[PropertySource abstraction].\n\nNOTE: You can reference properties stored inside Vault in other property sources or use value injection with `@Value(…)`. Special attention is required when bootstrapping beans that require data stored inside of Vault. A javadoc:org.springframework.vault.core.env.VaultPropertySource[] must be initialized at that time to retrieve properties from Vault.\n\nNOTE: Spring Boot/Spring Cloud users can benefit from https://github.com/spring-cloud/spring-cloud-vault-config[Spring Cloud Vault]'s\nconfiguration integration that initializes various property sources during application startup.\n\nNOTE: Vault determines the mount path through Vault's `sys/internal/ui/mounts/…` endpoint. Make sure that your policy allows accessing that path, otherwise you won't be able to use Vault Property sources.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/propertysource.adoc", "title": "propertysource", "heading": "propertysource", "heading_level": 1, "file_order": 8, "section_index": 0, "content_hash": "20de165f3f4895158a4ac8f5c8af14d0637ef00ac5c6fcf121de5b7fd9a0d802", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/propertysource.adoc"}}
{"id": "sha256:0a43b92d180aca3dc529404a2e219c19c4052bed8b99aa1a359ca35da83b9ab4", "content": "Spring Vault provides a javadoc:org.springframework.vault.core.env.VaultPropertySource[] to be used with Vault to obtain\nproperties. It uses the nested `data` element to expose properties stored and\nencrypted in Vault.\n\n====\n[source,java]\n----\nConfigurableApplicationContext ctx = new GenericApplicationContext();\nMutablePropertySources sources = ctx.getEnvironment().getPropertySources();\nsources.addFirst(new VaultPropertySource(vaultTemplate, \"secret/my-application\"));\n----\n====\n\nIn the code above, javadoc:org.springframework.vault.core.env.VaultPropertySource[] has been added with highest precedence\nin the search. If it contains a ´foo` property, it will be detected and returned\nahead of any `foo` property in any other `PropertySource`.\n`MutablePropertySources` exposes a number of methods that allow for precise\nmanipulation of the set of property sources.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/propertysource.adoc", "title": "propertysource", "heading": "Registering `VaultPropertySource`", "heading_level": 2, "file_order": 8, "section_index": 1, "content_hash": "0a43b92d180aca3dc529404a2e219c19c4052bed8b99aa1a359ca35da83b9ab4", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/propertysource.adoc"}}
{"id": "sha256:21c7cb95da9821cb3b68148a90fdd4e91cb375e759937c39dcfd79e58123b762", "content": "The `@VaultPropertySource` annotation provides a convenient and declarative\nmechanism for adding a `PropertySource` to Spring's `Environment`\nto be used in conjunction with `@Configuration` classes.\n\n`@VaultPropertySource` takes a Vault path such as ``secret/my-application``\nand exposes the data stored at the node in a ``PropertySource``.\n`@VaultPropertySource` supports lease renewal for secrets associated with a lease (i. e. credentials from the `mysql` secrets engine) and credential rotation upon terminal\nlease expiration. Lease renewal is disabled by default.\n\n.Properties stored in Vault\n====\n[source,json]\n----\n{\n // …\n\n \"data\": {\n \"database\": {\n \"password\": ...\n },\n \"user.name\": ...,\n }\n\n // …\n}\n----\n====\n\n.Declaring a `@VaultPropertySource`\n====\n[source,java]\n----\n@Configuration\n@VaultPropertySource(\"secret/my-application\")\npublic class AppConfig {\n\n @Autowired Environment env;\n\n @Bean\n public TestBean testBean() {\n TestBean testBean = new TestBean();\n testBean.setUser(env.getProperty(\"user.name\"));\n testBean.setPassword(env.getProperty(\"database.password\"));\n return testBean;\n }\n}\n----\n====\n\n.Declaring a `@VaultPropertySource` with credential rotation and prefix\n====\n[source,java]\n----\n@Configuration\n@VaultPropertySource(value = \"aws/creds/s3-access\",\n propertyNamePrefix = \"aws.\",\n renewal = Renewal.ROTATE)\npublic class AppConfig {\n // provides aws.access_key and aws.secret_key properties\n}\n----\n====\n\nNOTE: Secrets obtained from `generic` secrets engines are associated with a TTL (`refresh_interval`) but not a lease Id.\nSpring Vault's ``PropertySource`` rotates generic secrets when reaching its TTL.\n\nNOTE: You can use `@VaultPropertySource` to obtain the newest secret version from the versioned Key-Value secrets backend.\nMake sure to not include the `data/` segment in the path.\n\nAny `${…}` placeholders present in a `@VaultPropertySource` path are resolved against the set of property sources already registered against the environment, as the following example shows:\n\n.Declaring a `@VaultPropertySource` path using placeholders\n====\n[source,java]\n----\n@Configuration\n@VaultPropertySource(value = \"aws/creds/${my.placeholder:fallback/value}\",\n propertyNamePrefix = \"aws.\",\n renewal = Renewal.ROTATE)\npublic class AppConfig {\n}\n----\n====\n\nAssuming that `my.placeholder` is present in one of the property sources already registered (for example, system properties or environment variables), the placeholder is resolved to the corresponding value.\nIf not, then `fallback/value` is used as a default.\nIf no default is specified and a property cannot be resolved, an `IllegalArgumentException` is thrown.\n\nIn certain situations, it may not be possible or practical to tightly control\nproperty source ordering when using `@VaultPropertySource` annotations.\nFor example, if the `@Configuration` classes above were registered via\ncomponent-scanning, the ordering is difficult to predict.\nIn such cases - and if overriding is important - it is recommended that the\nuser fall back to using the programmatic PropertySource API.\nSee https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/ConfigurableEnvironment.html[`ConfigurableEnvironment`] and\nhttps://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/env/MutablePropertySources.html[`MutablePropertySources`] for details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/propertysource.adoc", "title": "propertysource", "heading": "@VaultPropertySource", "heading_level": 2, "file_order": 8, "section_index": 2, "content_hash": "21c7cb95da9821cb3b68148a90fdd4e91cb375e759937c39dcfd79e58123b762", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/propertysource.adoc"}}
{"id": "sha256:58be6406c17fad0835dc6fd6123f45d402b3de9be60a0e9ad7f87c7ebf041210", "content": "[[vault.core.reactive.template]]\n\nThis section covers basic information on the reactive programming support using Spring Vault.\n\n[[vault.core.reactive.template.what-is-reactive]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/reactive-template.adoc", "title": "reactive-template", "heading": "reactive-template", "heading_level": 1, "file_order": 9, "section_index": 0, "content_hash": "58be6406c17fad0835dc6fd6123f45d402b3de9be60a0e9ad7f87c7ebf041210", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/reactive-template.adoc"}}
{"id": "sha256:484b0e13f6aa9fde09803a25e3a62e0d237d4d207f8434835897b1cbeae37d54", "content": "In plain terms reactive programming is about non-blocking applications that are\nasynchronous and event-driven and require a small number of threads to scale vertically\n(i.e. within the JVM) rather than horizontally (i.e. through clustering).\n\nA key aspect of reactive applications is the concept of backpressure which is a mechanism\nto ensure producers don’t overwhelm consumers. For example in a pipeline of reactive\ncomponents extending from the database to the HTTP response when the HTTP connection is\ntoo slow the data repository can also slow down or stop completely until network capacity frees up.\n\n[[vault.core.reactive.template.client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/reactive-template.adoc", "title": "reactive-template", "heading": "What is Reactive Programming?", "heading_level": 2, "file_order": 9, "section_index": 1, "content_hash": "484b0e13f6aa9fde09803a25e3a62e0d237d4d207f8434835897b1cbeae37d54", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/reactive-template.adoc"}}
{"id": "sha256:55ded1df4998482f9352e926bb90352eddad4cefaee3354bc66afeba629ce3a8", "content": "Spring Vault's reactive client support is built on top of <<vault.authentication.steps,composable authentication steps>> and Spring Vault's functional `ReactiveVaultClient` which features a fully non-blocking, event-driven HTTP client.\n\nIt exposes javadoc:org.springframework.vault.authentication.VaultTokenSupplier[] as supplier of javadoc:org.springframework.vault.support.VaultToken[] to authenticate HTTP requests\nand javadoc:org.springframework.vault.core.ReactiveVaultOperations[] as the primary entry point.\nThe core configuration of\n`VaultEndpoint`, `ClientOptions` and <<vault.client-ssl,SSL>> are reused across the\nvarious client implementation.\n\nThe class javadoc:org.springframework.vault.core.ReactiveVaultTemplate[], located in the package `org.springframework.vault.core`,\nis the central class of the Spring's reactive Vault support providing a rich feature set to\ninteract with Vault. The template offers convenience operations to read, write and\ndelete data in Vault and provides a mapping between your domain objects and Vault data.\n\nNOTE: Once configured, javadoc:org.springframework.vault.core.ReactiveVaultTemplate[] is thread-safe and can be reused across\nmultiple instances.\n\nThe mapping between Vault documents and domain classes is done by delegating to\n`WebClient` and its codecs.\n\nThe javadoc:org.springframework.vault.core.ReactiveVaultTemplate[] class implements the interface javadoc:org.springframework.vault.core.ReactiveVaultOperations[].\nIn as much as possible, the methods on javadoc:org.springframework.vault.core.ReactiveVaultOperations[] are named after methods\navailable on the Vault API to make the API familiar to existing Vault developers\nwho are used to the API and CLI. For example, you will find methods such as\n\"write\", \"delete\", and \"read\".\nThe design goal was to make it as easy as possible to transition between\nthe use of the Vault API and javadoc:org.springframework.vault.core.ReactiveVaultOperations[]. A major difference in between\nthe two APIs is that javadoc:org.springframework.vault.core.ReactiveVaultOperations[] can be passed domain objects instead of\nJSON Key-Value pairs.\n\nPaths used in `ReactiveVaultTemplate` (and interfaces accessible from there) are considered\nrelative to the `VaultEndpoint`. Paths that are fully-qualified URI's can be used\nto access Vault cluster members in an authenticated context. To prevent unwanted\nfull URI access, make sure to sanitize paths before passing them to `ReactiveVaultTemplate`.\n\nNOTE: The preferred way to reference the operations on javadoc:org.springframework.vault.core.ReactiveVaultTemplate[] instance\nis via its interface javadoc:org.springframework.vault.core.ReactiveVaultOperations[].\n\nFunctionality not explicitly exposed by the javadoc:org.springframework.vault.core.ReactiveVaultTemplate[] you can use one of\nseveral execute callback methods to access underlying APIs. The execute callbacks\nwill give you a reference to a `WebClient` object.\nPlease see the section <<vault.core.reactive.executioncallback,Execution Callbacks>> for more information.\n\nNow let's look at examples of how to work with Vault in the context of the Spring container.\n\n[[vault.core.reactive.template.beans]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/reactive-template.adoc", "title": "reactive-template", "heading": "Reactive Vault Client", "heading_level": 2, "file_order": 9, "section_index": 2, "content_hash": "55ded1df4998482f9352e926bb90352eddad4cefaee3354bc66afeba629ce3a8", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/reactive-template.adoc"}}
{"id": "sha256:3e9d5fad86f68934bcbd1fc3285d9200b5a07c279f93684e1094062f758aa67e", "content": "Using Spring Vault does not require a Spring Context. However, instances of\njavadoc:org.springframework.vault.core.ReactiveVaultTemplate[] and `VaultTokenSupplier` registered inside a managed context will participate\nin {spring-framework-docs}/core/beans/factory-nature.html[lifecycle events]\nprovided by the Spring IoC container. This is useful to dispose active Vault sessions upon\napplication shutdown. You also benefit from reusing the same javadoc:org.springframework.vault.core.ReactiveVaultTemplate[]\ninstance across your application.\n\nSpring Vault comes with a supporting configuration class that provides bean definitions\nfor use inside a Spring context. Application configuration\nclasses typically extend from javadoc:org.springframework.vault.config.AbstractVaultConfiguration[] and are required to\nprovide additional details that are environment specific.\n\nExtending from javadoc:org.springframework.vault.config.AbstractVaultConfiguration[] requires to implement\n` VaultEndpoint vaultEndpoint()` and `ClientAuthentication clientAuthentication()`\nmethods.\n\n.Registering Spring Vault objects using Java based bean metadata\n====\n[source,java]\n----\n@Configuration\npublic class AppConfig extends AbstractReactiveVaultConfiguration {\n\n /**\n * Specify an endpoint for connecting to Vault.\n */\n @Override\n public VaultEndpoint vaultEndpoint() {\n return new VaultEndpoint(); <1>\n }\n\n /**\n * Configure a client authentication.\n * Please consider a more secure authentication method\n * for production use.\n */\n @Override\n public ClientAuthentication clientAuthentication() {\n return new TokenAuthentication(\"…\"); <2>\n }\n}\n----\n<1> Create a new javadoc:org.springframework.vault.client.VaultEndpoint[] that points by default to `\\https://localhost:8200`.\n<2> This sample uses javadoc:org.springframework.vault.authentication.TokenAuthentication[] to get started quickly.\nSee <<vault.core.authentication>> for details on supported authentication methods.\n====\n\n[[vault.core.reactive.template.sessionmanagement]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/reactive-template.adoc", "title": "reactive-template", "heading": "Registering and configuring Spring Vault beans", "heading_level": 2, "file_order": 9, "section_index": 3, "content_hash": "3e9d5fad86f68934bcbd1fc3285d9200b5a07c279f93684e1094062f758aa67e", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/reactive-template.adoc"}}
{"id": "sha256:11017e50d8db3f0828573cc9bbb8bea8ce4bb898e12bba885e2335cf611e28ee", "content": "Spring Vault requires a token to authenticate Vault requests.\nSee <<vault.core.authentication>> on details regarding authentication.\nThe reactive client requires a non-blocking token supplier whose contract is defined\nin `VaultTokenSupplier`. Tokens can be static or obtained through a\n<<vault.authentication.steps,declared authentication flow>>.\nVault login should not occur on each authenticated Vault interaction but\nthe session token should be kept across a session.\nThis aspect is handled by a session manager implementing javadoc:org.springframework.vault.authentication.ReactiveSessionManager[], such as javadoc:org.springframework.vault.authentication.ReactiveLifecycleAwareSessionManager[].\n\n[[vault.core.reactive.executioncallback]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/reactive-template.adoc", "title": "reactive-template", "heading": "Session Management", "heading_level": 2, "file_order": 9, "section_index": 4, "content_hash": "11017e50d8db3f0828573cc9bbb8bea8ce4bb898e12bba885e2335cf611e28ee", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/reactive-template.adoc"}}
{"id": "sha256:d8e99eff1c1b0a2da0d778cf2533df9352e819542889c46d49350967e6f842fa", "content": "One common design feature of all Spring template classes is that all functionality\nis routed into one of the templates execute callback methods. This helps ensure\nthat exceptions and any resource management that maybe required are performed\nconsistency. While this was of much greater need in the case of JDBC and JMS\nthan with Vault, it still offers a single spot for access and logging to occur.\nAs such, using the execute callback is the preferred way to access the Vault API\nto perform uncommon operations that we've not exposed as methods on javadoc:org.springframework.vault.core.ReactiveVaultTemplate[].\n\nHere is a list of execute callback methods.\n\n* `<T> T` *doWithVault* `(Function<WebClient, ? extends T> clientCallback)` Composes a reactive\nsequence the given `WebClient`, allows to interact with Vault without a session context.\n\n* `<T> T` *doWithSession* `(Function<WebClient, ? extends T> clientCallback)` Composes a reactive\nsequence the given `WebClient`, allows to interact with Vault in an authenticated session.\n\nHere is an example that uses the callback to initialize Vault:\n\n====\n[source,java]\n----\nreactiveVaultOperations.doWithVault(webClient -> {\n\n return webClient.put()\n .uri(\"sys/init\")\n .syncBody(request)\n .retrieve()\n .toEntity(VaultInitializationResponse.class);\n});\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/reactive-template.adoc", "title": "reactive-template", "heading": "Execution callbacks", "heading_level": 2, "file_order": 9, "section_index": 5, "content_hash": "d8e99eff1c1b0a2da0d778cf2533df9352e819542889c46d49350967e6f842fa", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/reactive-template.adoc"}}
{"id": "sha256:e84888013b4798d73cd13e75c023018c7a1f8c8a42f5e79ad8f5a09ef028ddbb", "content": "[[vault.spring-security]]\n\nSpring Vault integrates with Spring Security by providing implementations for https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#spring-security-crypto-keygenerators[`BytesKeyGenerator`] and https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#spring-security-crypto-encryption[`BytesEncryptor`].\nBoth implementations use Vault's `transit` engine.\n\n.`VaultBytesKeyGenerator` example\n====\n[source,java]\n----\n\nVaultOperations operations = …;\nVaultBytesKeyGenerator generator = new VaultBytesKeyGenerator(operations);\n\nbyte[] key = generator.generateKey();\n----\n====\n\n.`VaultBytesEncryptor` example\n====\n[source,java]\n----\n\nVaultTransitOperations transit = …;\n\nVaultBytesEncryptor encryptor = new VaultBytesEncryptor(transit, \"my-key-name\");\n\nbyte[] ciphertext = encryptor.encrypt(plaintext);\n\nbyte[] result = encryptor.decrypt(ciphertext);\n----\n====\n\nVault encapsulates an entropy source that is decoupled from your JVM along with server-side key-management. This relieves the burden of proper encryption/decryption from application developers and pushes the burden onto the operators of Vault. Operators of Vault commonly include the security team at an organization, which means they can ensure that data is encrypted/decrypted properly. Additionally, since encrypt/decrypt operations must enter the audit log, any decryption event is recorded.\nThe engine also supports key rotation, which allows a new version of the named key to be generated.\nAll data encrypted with the key will use the newest version of the key; previously encrypted data can be decrypted using old versions of the key.\nAdministrators can control which previous versions of a key are available for decryption, to prevent an attacker gaining an old copy of ciphertext to be able to successfully decrypt it.\nVault is after all a networked service that incurs each operation with a latency. Components heavily using encryption or random bytes generation may experience a difference in throughput and performance.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/spring-security.adoc", "title": "spring-security", "heading": "spring-security", "heading_level": 1, "file_order": 10, "section_index": 0, "content_hash": "e84888013b4798d73cd13e75c023018c7a1f8c8a42f5e79ad8f5a09ef028ddbb", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/spring-security.adoc"}}
{"id": "sha256:a950bb864b882bd8f3b84257e39fbb92c0650047ec57c377592cffa52ed5ac7f", "content": "[[vault-client-access]]\n\nThe value provided by the Spring Vault framework is perhaps best shown by the sequence of actions outlined in the following table below.\nThe table shows which functionality Spring takes care of when choosing a specific client option:\n\n[cols=\"5\",options=\"header\"]\n|===\n\n| Client | HTTP Requests | Authentication | Vault Operations | Error Handling\n\n| {spring-framework-docs}/integration/rest-clients.html#rest-restclient[*RestClient*]\n| Low-level HTTP request access with full control over URIs, headers, and message conversion.\tYou manually construct requests and handle responses. javadoc:org.springframework.vault.client.VaultEndpoint[] can be configured through a `UriBuilderFactory` enabling relative path usage.\n| No built-in authentication support; you must manage tokens and headers yourself. | No direct Vault domain operations; you build requests for Vault endpoints manually.\n| `4xx`/`5xx` status translated to `HttpServerErrorException` respective `HttpClientErrorException`, `onStatus` lets you register custom handlers\n\n| <<vault-client,*VaultClient*>>\n| Vault-specific fluent HTTP client built on top of `RestClient`. Provides methods for common HTTP verbs and request construction along with javadoc:org.springframework.vault.client.VaultEndpoint[] support to decouple access to functionality through relative paths from actual Vault server configuration.\n| Convenience methods for setting tokens (`token(…)`) and namespaces (`namespace(…)`); easier to manage authentication headers and can be used with javadoc:org.springframework.vault.authentication.ClientAuthentication[] implementations to log into Vault.\n| Path-based request methods; Allows consuming Vault responses as javadoc:org.springframework.vault.support.VaultResponse[] through `ResponseSpec.body()` and `ResponseSpec.toEntity()` methods; supports response wrapping directly.\n| `4xx`/`5xx` status translated to `VaultClientResponseException`, `onStatus` lets you register custom handlers\n\n| xref:vault/imperative-template.adoc[*VaultTemplate*]\n| High-level abstraction for Vault operations. HTTP requests can be issued through client callbacks.\n| Support for simple javadoc:org.springframework.vault.authentication.ClientAuthentication[] and javadoc:org.springframework.vault.authentication.SessionManager[] implementations that handle token renewal and authentication.\n| Java API for several Vault domain operations (read, write, delete, list) supporting various secret backends (KV, Cubbyhole, PKI, Transit, etc.).\n| Built on top of `VaultClient`, translates HTTP errors into Spring Vault exceptions (e.g., `VaultException`).\n\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-client.adoc", "title": "vault-client", "heading": "vault-client", "heading_level": 1, "file_order": 11, "section_index": 0, "content_hash": "a950bb864b882bd8f3b84257e39fbb92c0650047ec57c377592cffa52ed5ac7f", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-client.adoc"}}
{"id": "sha256:c3220c23fd4dad8f0e781c2670dbc881ce5d9810317ca60d6782750265095fa5", "content": ".`RestClient`\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tRestClient client = RestClient.create();\n\n\tVaultResponse response = client.get()\n .uri(\"https://vault.example.com/v1/secret/my-secret\")\n .header(\"X-Vault-Token\", \"…\")\n .header(\"X-Vault-Namespace\", \"…\")\n .retrieve()\n .body(VaultResponse.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tval client = RestClient.create()\n\n\tval response = client.get()\n .uri(\"https://vault.example.com/v1/secret/my-secret\")\n .header(\"X-Vault-Token\", \"…\")\n .header(\"X-Vault-Namespace\", \"…\")\n .retrieve()\n .body<VaultResponse>()\n----\n======\n\n.`VaultClient`\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tVaultClient client = VaultClient.create(VaultEndpoint.create(\"vault.example.com\", 8200));\n\n\tVaultResponse response = client.get()\n .path(\"secret/my-secret\")\n .token(VaultToken.of(…))\n .namespace(…)\n .retrieve()\n .requiredBody();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tval client = VaultClient.create(VaultEndpoint.create(\"vault.example.com\", 8200))\n\n\tval response = client.get()\n .path(\"secret/my-secret\")\n .token(VaultToken.of(…))\n .namespace(…)\n .retrieve()\n .requiredBody()\n----\n======\n\n.`VaultTemplate`\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tVaultTemplate vaultOperations = new VaultTemplate(vaultClient, sessionManager);\n\tVaultResponse response = vaultOperations.read(\"secret/my-secret\");\n\t// or\n\tObject value = vaultOperations.readRequired(\"secret/my-secret\").getRequiredData().get(\"value\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tval vaultOperations = VaultTemplate(vaultClient, sessionManager)\n\tval response = vaultOperations.read(\"secret/my-secret\")\n\t// or\n\tval value = vaultOperations.readRequired(\"secret/my-secret\").getRequiredData()[\"value\"]\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-client.adoc", "title": "vault-client", "heading": "Client Examples", "heading_level": 2, "file_order": 11, "section_index": 1, "content_hash": "c3220c23fd4dad8f0e781c2670dbc881ce5d9810317ca60d6782750265095fa5", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-client.adoc"}}
{"id": "sha256:4102c788dbf2c69d5a99c74b58bd387177d8cedba57d90ac9b807145dba583fe", "content": "If you need the most flexibility and full control over the HTTP client (connection pooling, custom TLS keystore at the JVM level, wire logging for diagnostics), start with a properly configured `RestClient` or request factory.\nThis is the right choice for framework-level code or libraries that must adapt to many environments.\n\nFor most application code that uses Vault, `VaultClient` strikes the right balance: It provides a readable, fluent API along with easy request/response handling that resembles `RestClient` look-and-feel. Its safe defaults such as endpoint scoping and token helpers avoid common pitfalls.\n\nChoose `VaultTemplate` when you prefer working with Vault at a higher level of abstraction.\nIt reduces boilerplate and integrates with Spring's conversion and exception-translation patterns.\nUse it when your application performs secret CRUD operations and you want concise, intention-revealing code that provides a Java API for Vault.\n\n[[vault-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-client.adoc", "title": "vault-client", "heading": "Recommendations", "heading_level": 3, "file_order": 11, "section_index": 2, "content_hash": "4102c788dbf2c69d5a99c74b58bd387177d8cedba57d90ac9b807145dba583fe", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-client.adoc"}}
{"id": "sha256:dda96a40d7722ea5581b0ce16858ab7625afa83819ba1b88f0c053af506e30db", "content": "Spring Vault provides the following choices for making calls to Vault endpoints:\n\n* `VaultClient` -- synchronous client with a fluent API based on Spring Framework's {spring-framework-docs}/integration/rest-clients.html#rest-restclient[`RestClient`]\n* `ReactiveVaultClient` -- non-blocking, reactive client with fluent API based on Spring Framework's {spring-framework-docs}/integration/rest-clients.html#rest-webclient[`WebClient`]\n\n`VaultClient` is a synchronous HTTP client that provides a fluent API to perform requests.\nIt's reactive variant `ReactiveVaultClient` mirrors ``VaultClient``'s design for non-blocking access.\nGoing forward, the documentation shows `VaultClient`. Except for the reactive aspects, `ReactiveVaultClient` works the same way.\nIt serves as an abstraction over HTTP libraries, and handles conversion of HTTP request and response content to and from higher level Java objects build on top of `RestClient` respective `WebClient` for its reactive variant.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-client.adoc", "title": "vault-client", "heading": "`VaultClient` and `ReactiveVaultClient`", "heading_level": 2, "file_order": 11, "section_index": 3, "content_hash": "dda96a40d7722ea5581b0ce16858ab7625afa83819ba1b88f0c053af506e30db", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-client.adoc"}}
{"id": "sha256:57bf83408c9d8520173a05991dfd5d8879d113cc1456c10f3523f51bae7baa29", "content": "`VaultClient` has static `create` shortcut methods.\nIt also exposes a `builder()` with further options:\n\n- select the HTTP library to use, see {spring-framework-docs}/integration/rest-clients.html#rest-request-factories[Client Request Factories]\n- set a `VaultEndpoint` or `VaultEndpointProvider` to enable relative path usage and limit requests to the configured Vault server\n- set default request headers\n- customize the underlying `RestClient` (or `WebClient` for `ReactiveVaultClient`)\n\nOnce created, a `VaultClient` is safe to use in multiple threads.\n\nYou can register javadoc:org.springframework.vault.client.VaultClientCustomizer[] or its reactive variant javadoc:org.springframework.vault.client.ReactiveVaultClientCustomizer[] when using Spring Vault's configuration infrastructure to customize the `VaultClient` or `ReactiveVaultClient` instances created by Spring Vault.\n\nThe following example shows how to create or build a `VaultClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tVaultClient defaultClient = VaultClient.create();\n\n\tVaultClient customClient = VaultClient.builder()\n .endpoint(VaultEndpoint.create(\"vault.acme.com\", 8200))\n .requestFactory(new HttpComponentsClientHttpRequestFactory())\n .defaultHeader(\"My-Header\", \"Foo\")\n .configureRestClient(builder -> … )\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tval defaultClient = VaultClient.create()\n\n\tval customClient = VaultClient.builder()\n .endpoint(VaultEndpoint.create(\"vault.acme.com\", 8200))\n .requestFactory(HttpComponentsClientHttpRequestFactory())\n .defaultHeader(\"My-Header\", \"Foo\")\n .configureRestClient{ … }\n .build()\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-client.adoc", "title": "vault-client", "heading": "Create a `VaultClient`", "heading_level": 3, "file_order": 11, "section_index": 4, "content_hash": "57bf83408c9d8520173a05991dfd5d8879d113cc1456c10f3523f51bae7baa29", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-client.adoc"}}
{"id": "sha256:1dfea9d6f1add7451b16f0a70064144f235a925d97f5b8d83589b8005d475534", "content": "To perform a Vault request, first specify the HTTP method to use.\nUse the convenience methods like `get()`, `post()`, `delete()`, and others, or `method(HttpMethod)`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-client.adoc", "title": "vault-client", "heading": "Use the `VaultClient`", "heading_level": 3, "file_order": 11, "section_index": 5, "content_hash": "1dfea9d6f1add7451b16f0a70064144f235a925d97f5b8d83589b8005d475534", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-client.adoc"}}
{"id": "sha256:f9aedce074d51d10c827bd03de923193347e97e31a9a062f7fcca562a03ef130", "content": "Next, specify the request path with the `path` methods.\nThe path is typically specified as a `String`, with optional URI template variables.\nThe following shows how to perform a request:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tint id = 42;\n\tvaultClient.get()\n .path(\"secret/{id}\", id)\n // ...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval id = 42\n\tvaultClient.get()\n .path(\"secret/{id}\", id)\n // ...\n----\n======\n\nString URLs are encoded by default, but this can be changed by building a client with a custom `uriBuilderFactory`.\nThe URL can also be provided with a function or as a `java.net.URI`, both of which are not encoded. Using a `URI` allows accessing external servers.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-client.adoc", "title": "vault-client", "heading": "Request Path", "heading_level": 4, "file_order": 11, "section_index": 6, "content_hash": "f9aedce074d51d10c827bd03de923193347e97e31a9a062f7fcca562a03ef130", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-client.adoc"}}
{"id": "sha256:a1facbe760ddcc135248e9c8c592455fe3b29ebe3abee386586ae475358f2a82", "content": "If necessary, the Vault request can be manipulated by adding request headers with `header(String, String)` or `token(VaultToken)` and so on.\n\nThe request body itself can be set by `body(Object)`, which internally uses {spring-framework-docs}/web/webmvc/message-converters.html#message-converters[HTTP Message conversion].\nAlternatively, the request body can be set using a `ParameterizedTypeReference`, allowing you to use generics.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-client.adoc", "title": "vault-client", "heading": "Request headers and body", "heading_level": 4, "file_order": 11, "section_index": 7, "content_hash": "a1facbe760ddcc135248e9c8c592455fe3b29ebe3abee386586ae475358f2a82", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-client.adoc"}}
{"id": "sha256:4fc46611f5a072fc75ef7daee50700f9b06c32b681997b6038309676216b15f6", "content": "Once the request has been set up, it can be sent by chaining method calls after `retrieve()`.\nFor example, the response body can be accessed by using `retrieve().body(Class)` or `retrieve().body(ParameterizedTypeReference)` for parameterized types like lists. A convenience method `retrieve().body()` retuns the body using Vault's default response type javadoc:org.springframework.vault.support.VaultResponse[].\nThe `body` method converts the response contents into various types – for instance, bytes can be converted into a `String`, JSON can be converted into objects using Jackson.\n\nThe response can also be converted into a `ResponseEntity`, giving access to the response headers as well as the body, with `retrieve().toEntity(Class)`\n\nNOTE: Calling `retrieve()` by itself is a no-op and returns a `ResponseSpec`.\nApplications must invoke a terminal operation on the `ResponseSpec` to have any side effect.\nIf consuming the response has no interest for your use case, you can use `retrieve().toBodilessEntity()`.\n\nThis sample shows how `VaultClient` can be used to perform a simple `GET` request.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tVaultResponse result = vaultClient.get() <1>\n .path(\"secret/my-secret\") <2>\n .retrieve() <3>\n .requiredBody(); <4>\n\n\tSystem.out.println(result); <5>\n----\n<1> Set up a GET request\n<2> Specify the path on the Vault server\n<3> Retrieve the response\n<4> Convert the response into a `VaultResponse`\n<5> Print the result\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval result = vaultClient.get() <1>\n .path(\"secret/my-secret\") <2>\n .retrieve() <3>\n .requiredBody() <4>\n\n\tprintln(result) <5>\n----\n<1> Set up a GET request\n<2> Specify the path on the Vault server\n<3> Retrieve the response\n<4> Convert the response into a `VaultResponse`\n<5> Print the result\n======\n\nAccess to the response status code and headers is provided through `ResponseEntity`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tResponseEntity<VaultResponse> result = vaultClient.get() <1>\n .path(\"secret/my-secret\") <1>\n .retrieve()\n .toEntity(); <2>\n\n\tSystem.out.println(\"Response status: \" + result.getStatusCode()); <3>\n\tSystem.out.println(\"Response headers: \" + result.getHeaders()); <3>\n\tSystem.out.println(\"Contents: \" + result.getBody()); <3>\n----\n<1> Set up a GET request for the specified URL\n<2> Convert the response into a `ResponseEntity`\n<3> Print the result\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval result = vaultClient.get() <1>\n .path(\"secret/my-secret\") <1>\n .retrieve()\n .toEntity<String>() <2>\n\n\tprintln(\"Response status: \" + result.statusCode) <3>\n\tprintln(\"Response headers: \" + result.headers) <3>\n\tprintln(\"Contents: \" + result.body) <3>\n----\n<1> Set up a GET request for the specified URL\n<2> Convert the response into a `ResponseEntity`\n<3> Print the result\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-client.adoc", "title": "vault-client", "heading": "Retrieving the response", "heading_level": 4, "file_order": 11, "section_index": 8, "content_hash": "4fc46611f5a072fc75ef7daee50700f9b06c32b681997b6038309676216b15f6", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-client.adoc"}}
{"id": "sha256:8660717282a5d365fdedb34cb60070becc350caa55e6c3d92afb775df04a9d0c", "content": "By default, `VaultClient` throws a subclass of `VaultClientResponseException` when retrieving a response with a 4xx or 5xx status code.\nThis behavior can be overridden using `onStatus`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString result = vaultClient.get()\n .path(\"secret/this-path-does-not-exist\") <1>\n .retrieve()\n .onStatus(HttpStatusCode::is4xxClientError, (request, response) -> { <2>\n throw new MyCustomRuntimeException(response.getStatusCode(), response.getHeaders()); <3>\n })\n .body(String.class);\n----\n<1> Create a GET request for a URL that returns a 404 status code\n<2> Set up a status handler for all 4xx status codes\n<3> Throw a custom exception\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval result = vaultClient.get()\n .path(\"secret/this-path-does-not-exist\") <1>\n .retrieve()\n .onStatus(HttpStatusCode::is4xxClientError) { _, response -> <2>\n throw MyCustomRuntimeException(response.getStatusCode(), response.getHeaders()) } <3>\n .body<String>()\n----\n<1> Create a GET request for a URL that returns a 404 status code\n<2> Set up a status handler for all 4xx status codes\n<3> Throw a custom exception\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-client.adoc", "title": "vault-client", "heading": "Error handling", "heading_level": 4, "file_order": 11, "section_index": 9, "content_hash": "8660717282a5d365fdedb34cb60070becc350caa55e6c3d92afb775df04a9d0c", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-client.adoc"}}
{"id": "sha256:1a9da8ca1e119fc00043a8ddc5a27a6e387bf2db2b6882f988907bf0f8b29f40", "content": "[[vault.repositories]]\n\nWorking with javadoc:org.springframework.vault.core.VaultTemplate[] and responses mapped to Java classes allows basic data operations like read, write and delete.\nVault repositories apply Spring Data's repository concept on top of Vault.\nA Vault repository exposes basic CRUD functionality and supports query derivation with predicates constraining the identifier property, paging and sorting.\nVault repositories use the key/value secrets engine functionality to persist and query data.\nAs of version 2.4, Spring Vault can use additionally key/value version 2 secrets engine, the actual secrets engine version is discovered during runtime.\n\nNOTE: Deletes within versioned key/value secrets engine use the `DELETE` operation. Secrets are not destroyed through `CrudRepository.delete(…)`.\n\nNOTE: Vault Repositories determine the mount path through Vault's `sys/internal/ui/mounts/…` endpoint. Make sure that your policy allows accessing that path, otherwise you won't be able to use the repository abstraction.\n\nNOTE: Read more about Spring Data Repositories in the https://docs.spring.io/spring-data/commons/docs/current/reference/html/#repositories[Spring Data Commons reference documentation].\nThe reference documentation will give you an introduction to Spring Data repositories.\n\n[[vault.repositories.usage]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-repositories.adoc", "title": "vault-repositories", "heading": "vault-repositories", "heading_level": 1, "file_order": 12, "section_index": 0, "content_hash": "1a9da8ca1e119fc00043a8ddc5a27a6e387bf2db2b6882f988907bf0f8b29f40", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-repositories.adoc"}}
{"id": "sha256:a48c6562a201da909a4b9ce5303abf0d3ff249d5cccdb36ee9047999f58be631", "content": "To access domain entities stored in Vault you can leverage repository support that eases implementing those quite significantly.\n\n.Sample Credentials Entity\n====\n[source,java]\n----\n@Secret\nclass Credentials {\n\n @Id String id;\n String password;\n String socialSecurityNumber;\n Address address;\n}\n----\n====\n\nWe have a pretty simple domain object here.\nNote that it has a property named `id` annotated with\n`org.springframework.data.annotation.Id` and a `@Secret` annotation on its type.\nThose two are responsible for creating the actual key used to persist the object as JSON inside Vault.\n\nNOTE: Properties annotated with `@Id` as well as those named `id` are considered as the identifier properties.\nThose with the annotation are favored over others.\n\nThe next step is to declare a repository interface that uses the domain object.\n\n.Basic Repository Interface for `Credentials` entities\n====\n[source,java]\n----\ninterface CredentialsRepository extends CrudRepository<Credentials, String> {\n\n}\n----\n====\n\nAs our repository extends `CrudRepository` it provides basic CRUD and query methods.\nVault repositories require Spring Data components.\nMake sure to include `spring-data-commons` and `spring-data-keyvalue` artifacts in your class path.\n\nThe easiest way to achieve this, is by setting up dependency management and adding the artifacts to your `pom.xml`:\n\nThen add the following to `pom.xml` dependencies section.\n\n.Using the Spring Data BOM\n====\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<dependencyManagement>\n <dependencies>\n <dependency>\n <groupId>org.springframework.data</groupId>\n <artifactId>spring-data-bom</artifactId>\n <version>{springDataVersion}</version>\n <scope>import</scope>\n <type>pom</type>\n </dependency>\n </dependencies>\n</dependencyManagement>\n\n<dependencies>\n\n <!-- other dependency elements omitted -->\n\n <dependency>\n <groupId>org.springframework.vault</groupId>\n <artifactId>spring-vault-core</artifactId>\n <version>{version}</version>\n </dependency>\n\n <dependency>\n <groupId>org.springframework.data</groupId>\n <artifactId>spring-data-keyvalue</artifactId>\n <!-- Version inherited from the BOM -->\n </dependency>\n\n</dependencies>\n----\n====\n\nThe thing we need in between to glue things together is the according Spring configuration.\n\n.JavaConfig for Vault Repositories\n====\n[source,java]\n----\n@Configuration\n@EnableVaultRepositories\nclass ApplicationConfig {\n\n @Bean\n VaultTemplate vaultTemplate() {\n return new VaultTemplate(…);\n }\n}\n----\n====\n\nGiven the setup above we can go on and inject `CredentialsRepository` into our components.\n\n.Access to Person Entities\n====\n[source,java]\n----\n@Autowired CredentialsRepository repo;\n\nvoid basicCrudOperations() {\n\n Credentials creds = new Credentials(\"heisenberg\", \"327215\", \"AAA-GG-SSSS\");\n rand.setAddress(new Address(\"308 Negra Arroyo Lane\", \"Albuquerque\", \"New Mexico\", \"87104\"));\n\n repo.save(creds); <1>\n\n repo.findOne(creds.getId()); <2>\n\n repo.count(); <3>\n\n repo.delete(creds); <4>\n}\n----\n\n<1> Stores properties of `Credentials` inside Vault Hash with a key pattern `keyspace/id`, in this case `credentials/heisenberg`, in the key-value secret secrets engine.\n<2> Uses the provided id to retrieve the object stored at `keyspace/id`.\n<3> Counts the total number of entities available within the keyspace _credentials_ defined by `@Secret` on `Credentials`.\n<4> Removes the key for the given object from Vault.\n====\n\n[[vault.repositories.mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-repositories.adoc", "title": "vault-repositories", "heading": "Usage", "heading_level": 2, "file_order": 12, "section_index": 1, "content_hash": "a48c6562a201da909a4b9ce5303abf0d3ff249d5cccdb36ee9047999f58be631", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-repositories.adoc"}}
{"id": "sha256:62df6a65483eb62073804deb88dd8f578ce9a91ac0c354994d3408484338f049", "content": "Vault repositories store objects in Vault using JSON as interchange format.\nObject mapping between JSON and the entity is done by `VaultConverter`.\nThe converter reads and writes `SecretDocument` that contains the body from a `VaultResponse`. ``VaultResponse``s are read from Vault and the body is deserialized by Jackson into a `Map` of `String` and `Object`.\nThe default `VaultConverter` implementation reads the `Map` with nested values, `List` and `Map` objects and converts these to entities and vice versa.\n\nGiven the `Credentials` type from the previous sections the default mapping is as follows:\n\n====\n[source,json]\n----\n{\n \"_class\": \"org.example.Credentials\", <1>\n \"password\": \"327215\", <2>\n \"socialSecurityNumber\": \"AAA-GG-SSSS\",\n \"address\": { <3>\n \"street\": \"308 Negra Arroyo Lane\",\n \"city\": \"Albuquerque\",\n \"state\": \"New Mexico\",\n \"zip\": \"87104\"\n }\n}\n----\n\n<1> The `_class` attribute is included on root level as well as on any nested interface or abstract types.\n<2> Simple property values are mapped by path.\n<3> Properties of complex types are mapped as nested objects.\n====\n\nNOTE: The `@Id` property must be mapped to `String`.\n\n[cols=\"1,2,3\",options=\"header\"]\n.Default Mapping Rules\n|===\n| Type\n| Sample\n| Mapped Value\n\n| Simple Type +\n(eg. String)\n| String firstname = \"Walter\";\n| \"firstname\": \"Walter\"\n\n| Complex Type +\n(eg. Address)\n| Address adress = new Address(\"308 Negra Arroyo Lane\");\n| \"address\": { \"street\": \"308 Negra Arroyo Lane\" }\n\n| List +\nof Simple Type\n| List<String> nicknames = asList(\"walt\", \"heisenberg\");\n| \"nicknames\": [\"walt\", \"heisenberg\"]\n\n| Map +\nof Simple Type\n| Map<String, Integer> atts = asMap(\"age\", 51)\n| \"atts\" : {\"age\" : 51}\n\n| List +\nof Complex Type\n| List<Address> addresses = asList(new Address(\"308…\n| \"address\": [{ \"street\": \"308 Negra Arroyo Lane\" }, …]\n\n|===\n\nYou can customize the mapping behavior by registering a `Converter` in `VaultCustomConversions`.\nThose converters can take care of converting from/to a type such as `LocalDate` as well as `SecretDocument`\nwhereas the first one is suitable for converting simple properties and the last one complex types to their JSON representation.\nThe second option offers full control over the resulting `SecretDocument`.\nWriting objects to `Vault`\nwill delete the content and re-create the whole entry, so not mapped data will be lost.\n\n[[vault.repositories.queries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-repositories.adoc", "title": "vault-repositories", "heading": "Object to Vault JSON Mapping", "heading_level": 2, "file_order": 12, "section_index": 2, "content_hash": "62df6a65483eb62073804deb88dd8f578ce9a91ac0c354994d3408484338f049", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-repositories.adoc"}}
{"id": "sha256:7bc5e85f0bca7be171634124c86d8b8cd4033137e10d124bfef66fe60664b285", "content": "Query methods allow automatic derivation of simple queries from the method name.\nVault has no query engine but requires direct access of HTTP context paths.\nVault query methods translate Vault's API possibilities to queries.\nA query method execution lists children under a context path, applies filtering to the Id, optionally limits the Id stream with offset/limit and applies sorting after fetching the results.\n\n.Sample Repository Query Method\n====\n[source,java]\n----\ninterface CredentialsRepository extends CrudRepository<Credentials, String> {\n\n List<Credentials> findByIdStartsWith(String prefix);\n}\n----\n====\n\nNOTE: Query methods for Vault repositories support only queries with predicates on the `@Id` property.\n\nHere's an overview of the keywords supported for Vault.\n\n[cols=\"1,2\" options=\"header\"]\n.Supported keywords for query methods\n|===\n| Keyword\n| Sample\n\n| `After`, `GreaterThan`\n| `findByIdGreaterThan(String id)`\n\n| `GreaterThanEqual`\n| `findByIdGreaterThanEqual(String id)`\n\n| `Before`, `LessThan`\n| `findByIdLessThan(String id)`\n\n| `LessThanEqual`\n| `findByIdLessThanEqual(String id)`\n\n| `Between`\n| `findByIdBetween(String from, String to)`\n\n| `In`\n| `findByIdIn(Collection ids)`\n\n| `NotIn`\n| `findByIdNotIn(Collection ids)`\n\n| `Like`, `StartingWith`, `EndingWith`\n| `findByIdLike(String id)`\n\n| `NotLike`, `IsNotLike`\n| `findByIdNotLike(String id)`\n\n| `Containing`\n| `findByFirstnameContaining(String id)`\n\n| `NotContaining`\n| `findByFirstnameNotContaining(String name)`\n\n| `Regex`\n| `findByIdRegex(String id)`\n\n| `(No keyword)`\n| `findById(String name)`\n\n| `Not`\n| `findByIdNot(String id)`\n\n| `And`\n| `findByLastnameAndFirstname`\n\n| `Or`\n| `findByLastnameOrFirstname`\n\n| `Is,Equals`\n| `findByFirstname`,`findByFirstnameIs`,`findByFirstnameEquals`\n\n| `Top,First`\n| `findFirst10ByFirstname`,`findTop5ByFirstname`\n|===\n\n[[vault.repositories.sorting.paging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-repositories.adoc", "title": "vault-repositories", "heading": "Queries and Query Methods", "heading_level": 2, "file_order": 12, "section_index": 3, "content_hash": "7bc5e85f0bca7be171634124c86d8b8cd4033137e10d124bfef66fe60664b285", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-repositories.adoc"}}
{"id": "sha256:8d6ea67e11e91ae4312bebc89a342dfd7358d56c4f935bc4d5fb6d3960a0fec8", "content": "Query methods support sorting and paging by selecting in memory a sublist (offset/limit) Id's retrieved from a Vault context path.\nSorting has is not limited to a particular field, unlike query method predicates.\nUnpaged sorting is applied after Id filtering and all resulting secrets are fetched from Vault.\nThis way a query method fetches only results that are also returned as part of the result.\n\nUsing paging and sorting requires secret fetching before filtering the Id's which impacts performance.\nSorting and paging guarantees to return the same result even if the natural order of Id returned by Vault changes.\nTherefore, all Id's are fetched from Vault first, then sorting is applied and afterwards filtering and offset/limiting.\n\n.Paging and Sorting Repository\n====\n[source,java]\n----\ninterface CredentialsRepository extends PagingAndSortingRepository<Credentials, String> {\n\n List<Credentials> findTop10ByIdStartsWithOrderBySocialSecurityNumberDesc(String prefix);\n\n List<Credentials> findByIdStarts(String prefix, Pageable pageRequest);\n}\n----\n====\n\n[[vault.repositories.optimistic-locking]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-repositories.adoc", "title": "vault-repositories", "heading": "Sorting and Paging", "heading_level": 3, "file_order": 12, "section_index": 4, "content_hash": "8d6ea67e11e91ae4312bebc89a342dfd7358d56c4f935bc4d5fb6d3960a0fec8", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-repositories.adoc"}}
{"id": "sha256:dd1f6154066ff89c403ce44952db1c1a6e3b0821ce4766c64736e44c6637f2ef", "content": "Vaults key/value secrets engine version 2 can maintain versioned secrets.\nSpring Vault supports versioning through a version property in the domain model that are annotated with `@Version`.\nUsing optimistic locking makes sure updates are only applied to secrets with a matching version.\nTherefore, the actual value of the version property is added to the update request through the `cas` property.\nIf another operation altered the secret in the meantime, then an OptimisticLockingFailureException is thrown and the secret isn't updated.\n\nVersion properties must be numeric properties such as `int` or `long` and map to the `cas` property when updating secrets.\n\n.Sample Versioned Entity\n====\n[source,java]\n----\n@Secret\nclass VersionedCredentials {\n\n @Id String id;\n @Version int version;\n String password;\n String socialSecurityNumber;\n Address address;\n}\n----\n====\n\nThe following example shows these features:\n\n.Sample Versioned Entity\n====\n[source,java]\n----\nVersionedCredentialsRepository repo = …;\n\nVersionedCredentials credentials = repo.findById(\"sample-credentials\").get(); <1>\n\nVersionedCredentials concurrent = repo.findById(\"sample-credentials\").get(); <2>\n\ncredentials.setPassword(\"something-else\");\n\nrepos.save(credentials); <3>\n\nconcurrent.setPassword(\"concurrent change\");\n\nrepos.save(concurrent); // throws OptimisticLockingFailureException <4>\n\n----\n\n<1> Obtain a secret by its Id `sample-credentials`.\n<2> Obtain a second instance of the secret by its Id `sample-credentials`.\n<3> Update the secret and let Vault increment the version.\n<4> Update the second instance that uses the previous version.\nThe operation fails with an `OptimisticLockingFailureException` as the version was incremented in Vault in the meantime.\n====\n\nNOTE: When deleting versioned secrets, delete by Id deletes the most recent secret. Delete by entity deletes the secret at the provided version.\n\n[[vault.repositories.revision-repository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-repositories.adoc", "title": "vault-repositories", "heading": "Optimistic Locking", "heading_level": 2, "file_order": 12, "section_index": 5, "content_hash": "dd1f6154066ff89c403ce44952db1c1a6e3b0821ce4766c64736e44c6637f2ef", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-repositories.adoc"}}
{"id": "sha256:970e621854568db2a41224fdf7eb987ef5ded08a9ff71df60e65614d1c0c2e22", "content": "Key/Value version 2 secrets engine maintains versions of secrets that can be accessed by implementing https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/history/RevisionRepository.html[`RevisionRepository`] in your Vault repository interface declaration.\nRevision repositories define lookup methods to obtain revisions for a particular identifier.\nIdentifiers must be `String`.\n\n.Implementing `RevisionRepository`\n====\n[source,java]\n----\ninterface RevisionCredentialsRepository extends CrudRepository<Credentials, String>,\n RevisionRepository<Credentials, String, Integer> <1>\n{\n\n}\n----\n<1> The first type parameter (`Credentials`) denotes the entity type, the second (`String`) denotes the type of the id property, and the last one (`Integer`) is the type of the revision number. Vault supports only `String` identifiers and `Integer` revision numbers.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-repositories.adoc", "title": "vault-repositories", "heading": "Accessing versioned secrets", "heading_level": 2, "file_order": 12, "section_index": 6, "content_hash": "970e621854568db2a41224fdf7eb987ef5ded08a9ff71df60e65614d1c0c2e22", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-repositories.adoc"}}
{"id": "sha256:325eb056e4ad44873607dc2a697021458e750354d4a43009ccace0d28c54d606", "content": "You can now use the methods from `RevisionRepository` to query the revisions of the entity, as the following example shows:\n\n.Using `RevisionRepository`\n====\n[source,java]\n----\nRevisionCredentialsRepository repo = …;\n\nRevisions<Integer, Credentials> revisions = repo.findRevisions(\"my-secret-id\");\n\nPage<Revision<Integer, Credentials>> firstPageOfRevisions = repo.findRevisions(\"my-secret-id\", Pageable.ofSize(4));\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-repositories.adoc", "title": "vault-repositories", "heading": "Usage", "heading_level": 3, "file_order": 12, "section_index": 7, "content_hash": "325eb056e4ad44873607dc2a697021458e750354d4a43009ccace0d28c54d606", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-repositories.adoc"}}
{"id": "sha256:49cbfa0f25b9dfe752bb4285fe3c79de877beadec71f4551454908d2f12fbef8", "content": "[[vault.core.secret-engines]]\n\nSpring Vault ships with several extensions to support Vault's various secrets engines.\n\nSpecifically, Spring Vault ships with extensions for:\n\n* <<vault.core.backends.kv1>>\n* <<vault.core.backends.kv2>>\n* <<vault.core.backends.pki>>\n* <<vault.core.backends.token>>\n* Transform (Enterprise Feature)\n* <<vault.core.backends.transit>>\n* System Backend\n\nYou can use all other secrets engines through methods on `VaultTemplate` directly (`VaultTemplate.read(…)`, `VaultTemplate.write(…)`).\n\n[[vault.core.backends.kv1]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-secret-engines.adoc", "title": "vault-secret-engines", "heading": "vault-secret-engines", "heading_level": 1, "file_order": 13, "section_index": 0, "content_hash": "49cbfa0f25b9dfe752bb4285fe3c79de877beadec71f4551454908d2f12fbef8", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-secret-engines.adoc"}}
{"id": "sha256:7e8456135715aef6973447d4bf1f9ece7f5151a1d6beff6b8ac399063cd03fe1", "content": "The `kv` secrets engine is used to store arbitrary secrets within the configured physical storage for Vault.\n\nWhen running the `kv` secrets engine in a non-versioned way, only the most recently written value for a key is preserved.\nThe benefits of non-versioned kv is a reduced storage size for each key, since no additional metadata or history is stored.\nAdditionally, requests going to a secrets engine configured this way are more performant because there are fewer storage calls and no locking for any given request.\n\nSpring Vault ships with a dedicated Key-Value API to encapsulate differences between the individual Key-Value API implementations.\njavadoc:org.springframework.vault.core.VaultKeyValueOperations[] follows the Vault CLI design.\nThat's the primary command line tool for Vault providing commands such as `vault kv get`, `vault kv put` and so on.\n\nYou can use this API with both Key-Value engine versions by specifying the version and mount path.\nThe following example uses the Key-Value version 1:\n\n====\n[source,java,indent=0]\n----\n\t\tVaultOperations operations = new VaultTemplate(new VaultEndpoint());\n\t\tVaultKeyValueOperations keyValueOperations = operations.opsForKeyValue(\"secret\",\n\t\t\t\t\t\t\t\t\tVaultKeyValueOperationsSupport.KeyValueBackend.KV_1);\n\n\t\tkeyValueOperations.put(\"elvis\", Collections.singletonMap(\"password\", \"409-52-2002\"));\n\n\t\tVaultResponse read = keyValueOperations.get(\"elvis\");\n\t\tread.getRequiredData().get(\"social-security-number\");\n----\n====\n\njavadoc:org.springframework.vault.core.VaultKeyValueOperations[] supports all Key-Value operations such as `put`, `get`, `delete`, `list`.\n\nAlternatively, the API can be used through javadoc:org.springframework.vault.core.VaultTemplate[] because of its direct mapping and simple use, as keys and responses map directly to input and output keys.\nThe following example illustrates writing and reading a secret at `mykey`.\nThe `kv` secrets engine is mounted at `secret`:\n\n====\n[source,java,indent=0]\n----\n\t\tVaultOperations operations = new VaultTemplate(new VaultEndpoint());\n\n\t\toperations.write(\"secret/elvis\", Collections.singletonMap(\"social-security-number\", \"409-52-2002\"));\n\n\t\tVaultResponse read = operations.read(\"secret/elvis\");\n\t\tread.getRequiredData().get(\"social-security-number\");\n----\n====\n\nYou can find more details about the https://www.vaultproject.io/api-docs/secret/kv/kv-v1[Vault Key-Value version 1 API] in the Vault reference documentation.\n\nNOTE: Vault determines the mount path through Vault's `sys/internal/ui/mounts/…` endpoint. Make sure that your policy allows accessing that path, otherwise you won't be able to use the Key-Value API.\n\n[[vault.core.backends.kv2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-secret-engines.adoc", "title": "vault-secret-engines", "heading": "Key-Value Version 1 (\"unversioned secrets\")", "heading_level": 2, "file_order": 13, "section_index": 1, "content_hash": "7e8456135715aef6973447d4bf1f9ece7f5151a1d6beff6b8ac399063cd03fe1", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-secret-engines.adoc"}}
{"id": "sha256:178cde8ddd1591632c18aabd9d8a7b843d3c920c22b47fbd6eec4198263cb411", "content": "You can run the `kv` secrets engine in one of two versions.\nThis section explains using version 2. When running version 2 of the `kv` engine a key can retain a configurable number of versions.\nYou can retrieve the metadata and data of the older versions.\nAdditionally, you can use check-and-set operations to avoid unintentionally overwriting data.\n\nSimilar to <<vault.core.backends.kv1>>, Spring Vault ships with a dedicated Key-Value API to encapsulate differences between the individual Key-Value API implementations.\nSpring Vault ships with a dedicated Key-Value API to encapsulate differences between the individual Key-Value API implementations.\n`VaultKeyValueOperations` follows the Vault CLI design.\nThat is the primary command line tool for Vault, providing commands such as `vault kv get`, `vault kv put`, and so on.\n\nYou can use this API with both Key-Value engine versions by specifying the version and mount path.\nThe following example uses Key-Value version 2:\n\n====\n[source,java,indent=0]\n----\n\t\tVaultOperations operations = new VaultTemplate(new VaultEndpoint());\n\t\tVaultKeyValueOperations keyValueOperations = operations.opsForKeyValue(\"secret\",\n\t\t\t\t\t\t\t\t\tVaultKeyValueOperationsSupport.KeyValueBackend.KV_2);\n\n\t\tkeyValueOperations.put(\"elvis\", Collections.singletonMap(\"social-security-number\", \"409-52-2002\"));\n\n\t\tVaultResponse read = keyValueOperations.get(\"elvis\");\n\t\tread.getRequiredData().get(\"social-security-number\");\n----\n====\n\njavadoc:org.springframework.vault.core.VaultKeyValueOperations[] supports all Key-Value operations, such as `put`, `get`, `delete`, `list`.\n\nYou can also interact with the specifics of the versioned key-value API. This is useful if you want to obtain a specific secret or you need access to the metadata.\n\n====\n[source,java,indent=0]\n----\n\t\tVaultOperations operations = new VaultTemplate(new VaultEndpoint());\n\t\tVaultVersionedKeyValueOperations versionedOperations = operations.opsForVersionedKeyValue(\"secret\");\n\n\t\tVersioned.Metadata metadata = versionedOperations.put(\"elvis\",\t\t\t\t\t\t\t// <1>\n\t\t\t\t\t\t\tCollections.singletonMap(\"social-security-number\", \"409-52-2002\"));\n\n\t\tVersion version = metadata.getVersion();\t\t\t\t\t\t\t\t\t\t\t\t// <2>\n\n\t\tVersioned<Object> ssn = versionedOperations.get(\"elvis\", Version.from(42));\t\t\t\t// <3>\n\n\t\tVersioned<SocialSecurityNumber> mappedSsn = versionedOperations.get(\"elvis\",\t\t\t// <4>\n\t\t\t\t\t\t\t\t\t\t\t\t\tVersion.from(42), SocialSecurityNumber.class);\n\n\t\tVersioned<Map<String,String>> versioned = Versioned.create(Collections\t\t\t\t\t// <5>\n\t\t\t\t\t\t\t\t.singletonMap(\"social-security-number\", \"409-52-2002\"),\n\t\t\t\t\t\t\t\tVersion.from(42));\n\n\t\tversionedOperations.put(\"elvis\", version);\n----\n<1> Store secrets at `elvis` in that is available under the `secret/` mount.\n<2> Storing data in the versioned secrets engine returns metadata such as the version number.\n<3> The versioned Key-Value API allows retrieval of specific versions identified by the version number.\n<4> Versioned key-value secrets can be mapped into value objects.\n<5> When updating versioned secrets using CAS, the input must refer to the previously obtained version.\n====\n\nWhile using the `kv` v2 secrets engine through `VaultTemplate` is possible.\nIt is not the most convenient approach since the API offers a different approach to context paths and how input/output is represented.\nSpecifically, interaction with the actual secrets requires wrapping and unwrapping of the data section and introducing a `data/` path segment between the mount and the secrets key.\n\n====\n[source,java,indent=0]\n----\n\t\tVaultOperations operations = new VaultTemplate(new VaultEndpoint());\n\n\t\toperations.write(\"secret/data/elvis\", Collections.singletonMap(\"data\",\n\t\t\t\t\tCollections.singletonMap(\"social-security-number\", \"409-52-2002\")));\n\n\t\tVaultResponse read = operations.read(\"secret/data/ykey\");\n\t\tMap<String,String> data = (Map<String, String>) read.getRequiredData().get(\"data\");\n\t\tdata.get(\"social-security-number\");\n----\n====\n\nYou can find more details about the https://www.vaultproject.io/api-docs/secret/kv/kv-v2[Vault Key-Value version 2 API] in the Vault reference documentation.\n\nNOTE: Vault determines the mount path through Vault's `sys/internal/ui/mounts/…` endpoint. Make sure that your policy allows accessing that path, otherwise you won't be able to use the Key-Value API.\n\n[[vault.core.backends.pki]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-secret-engines.adoc", "title": "vault-secret-engines", "heading": "Key-Value Version 2 (\"versioned secrets\")", "heading_level": 2, "file_order": 13, "section_index": 2, "content_hash": "178cde8ddd1591632c18aabd9d8a7b843d3c920c22b47fbd6eec4198263cb411", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-secret-engines.adoc"}}
{"id": "sha256:11ec57a138fa14489046d52c292bc7a987ec3c771eb7d52c1b732fe7bf22ccaa", "content": "The `pki` secrets engine represents a secrets engine for certificates by implementing certificate authority operations.\n\nThe PKI secrets engine generates dynamic X.509 certificates.\nWith this secrets engine, services can get certificates without going through the usual manual process of generating a private key and CSR, submitting to a CA, and waiting for a verification and signing process to complete.\nVault's built-in authentication and authorization mechanisms provide the verification functionality.\n\nSpring Vault supports issuing, signing, revoking certificates, and CRL retrieval through `VaultPkiOperations`.\nAll other PKI functionality can be used through `VaultOperations`.\n\nThe following examples explain briefly the use of how to issue and revoke certificates:\n\n====\n[source,java,indent=0]\n----\n\t\tVaultOperations operations = new VaultTemplate(new VaultEndpoint());\n\t\tVaultPkiOperations pkiOperations = operations.opsForPki(\"pki\");\n\n\t\tVaultCertificateRequest request = VaultCertificateRequest.builder()\t\t\t\t\t\t\t\t// <1>\n\t\t\t\t\t.ttl(Duration.ofHours(48))\n\t\t\t\t\t.altNames(Arrays.asList(\"prod.dc-1.example.com\", \"prod.dc-2.example.com\"))\n\t\t\t\t\t.withIpSubjectAltName(\"1.2.3.4\")\n\t\t\t\t\t.commonName(\"hello.example.com\")\n\t\t\t\t\t.build();\n\n\t\tVaultCertificateResponse response = pkiOperations.issueCertificate(\"production\", request); \t\t// <2>\n\t\tCertificateBundle certificateBundle = response.getRequiredData();\n\n\t\tKeyStore keyStore = certificateBundle.createKeyStore(\"my-keystore\");\t\t\t\t\t\t\t// <3>\n\n\t\tKeySpec privateKey = certificateBundle.getPrivateKeySpec();\t\t\t\t\t\t\t\t\t\t// <4>\n\t\tX509Certificate certificate = certificateBundle.getX509Certificate();\n\t\tX509Certificate caCertificate = certificateBundle.getX509IssuerCertificate();\n\n\t\tpkiOperations.revoke(certificateBundle.getSerialNumber());\t\t\t\t\t\t\t\t\t\t// <5>\n----\n<1> Construct a certificate request by using the javadoc:org.springframework.vault.support.VaultCertificateRequest[] builder.\n<2> Request a certificate from Vault.\nVault acts as certificate authority and responds with a signed X.509 certificate.\nThe actual response is a javadoc:org.springframework.vault.support.CertificateBundle[].\n<3> You can obtain generated certificates directly as Java KeyStore that contains public and private keys as well as the issuer certificate. KeyStore has a wide range of uses, which makes this format suitable to configure (for example a HTTP client, a database driver, or an SSL-secured HTTP server).\n<4> javadoc:org.springframework.vault.support.CertificateBundle[] allows accessing the private key and the public and issuer certificates directly through the Java Cryptography Extension API.\n<5> Once a certificate is no longer in use (or it was compromised), you can revoke it through its serial number.\nVault includes the revoked certificate in its CRL.\n====\n\nYou can find more details about the https://www.vaultproject.io/api-docs/secret/pki[Vault PKI secrets API] in the Vault reference documentation.\n\n[[vault.core.backends.token]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-secret-engines.adoc", "title": "vault-secret-engines", "heading": "PKI (Public Key Infrastructure)", "heading_level": 2, "file_order": 13, "section_index": 3, "content_hash": "11ec57a138fa14489046d52c292bc7a987ec3c771eb7d52c1b732fe7bf22ccaa", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-secret-engines.adoc"}}
{"id": "sha256:99d55140dc1c7e4457cf040bfe1992eac3a480ad1b5914d81c89396be12cd5f4", "content": "This method is an authentication method that does not interact with actual secrets.\nRather, it gives access to access token management.\nYou can read more about <<vault.authentication.token,Token-based authentication>> in the <<vault.core.authentication, authentication methods chapter>>.\n\nThe `token` authentication method is built-in and automatically available at `/auth/token`.\nIt lets users authenticate using a token, as well to create new tokens, revoke secrets by token, and more.\n\nWhen any other auth method returns an identity, Vault core invokes the token method to create a new unique token for that identity.\n\nYou can also use the token store to bypass any other auth method. You can create tokens directly, as well as perform a variety of other operations on tokens, such as renewal and revocation.\n\nSpring Vault uses this backend to renew and revoke the session tokens supplied by the configured <<vault.core.authentication, authentication method>>.\n\nThe following examples show how to request, renew and revoke a Vault token from within your application:\n\n====\n[source,java,indent=0]\n----\n\t\tVaultOperations operations = new VaultTemplate(new VaultEndpoint());\n\t\tVaultTokenOperations tokenOperations = operations.opsForToken();\n\n\t\tVaultTokenResponse tokenResponse = tokenOperations.create();                          // <1>\n\t\tVaultToken justAToken = tokenResponse.getToken();\n\n\t\tVaultTokenRequest tokenRequest = VaultTokenRequest.builder().withPolicy(\"policy-for-myapp\")\n\t\t\t\t\t\t\t\t\t\t\t.displayName(\"Access tokens for myapp\")\n\t\t\t\t\t\t\t\t\t\t\t.renewable()\n\t\t\t\t\t\t\t\t\t\t\t.ttl(Duration.ofHours(1))\n\t\t\t\t\t\t\t\t\t\t\t.build();\n\n\t\tVaultTokenResponse appTokenResponse = tokenOperations.create(tokenRequest);          // <2>\n\t\tVaultToken appToken = appTokenResponse.getToken();\n\n\t\ttokenOperations.renew(appToken);                                                     // <3>\n\n\t\ttokenOperations.revoke(appToken);                                                    // <4>\n----\n<1> Create an token by applying role defaults.\n<2> Using the builder API, you can define fine-grained settings for the token to request.\nRequesting a token returns a `VaultToken`, which is used as value object for Vault tokens.\n<3> You can renew tokens through the Token API. Typically, that is done by `SessionManager` to keep track of the Vault session token.\n<4> Tokens can be revoked if needed through the Token API. Typically, that is done by `SessionManager` to keep track of the Vault session token.\n====\n\nYou can find more details about the https://www.vaultproject.io/api-docs/auth/token[Vault Token Auth Method API] in the Vault reference documentation.\n\n[[vault.core.backends.transit]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-secret-engines.adoc", "title": "vault-secret-engines", "heading": "Token Authentication Method", "heading_level": 2, "file_order": 13, "section_index": 4, "content_hash": "99d55140dc1c7e4457cf040bfe1992eac3a480ad1b5914d81c89396be12cd5f4", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-secret-engines.adoc"}}
{"id": "sha256:2e6073b33f8195e4f461b98dc3bbe5cc286cbddaa52e828091f9dc59a1a3dceb", "content": "The transit secrets engine handles cryptographic functions on data in-transit.\nVault does not store the data sent to this secrets engine.\nIt can also be seen as \"cryptography as a service\" or \"encryption as a service\".\nThe transit secrets engine can also sign and verify data, generate hashes and HMACs of data, and act as a random bytes source.\n\nThe primary use case for transit is to encrypt data from applications while still storing that encrypted data in some primary data store.\nThis relieves the burden of proper encryption and decryption from application developers and pushes the burden onto the operators of Vault.\n\nSpring Vault supports a wide range of Transit operations:\n\n* Key creation\n* Key reconfiguration\n* Encryption/Decryption/Rewrapping\n* HMAC computation\n* Signing and signature verification\n\nAll operations within `transit` are centered around keys.\nThe Transit engine supports the versioning of keys and https://www.vaultproject.io/docs/secrets/transit[a variety of key types].\nNote that the key type may impose a limitation on which operations can used.\n\nThe following examples shows how to create a key and how to encrypt and decrypt data:\n\n====\n[source,java,indent=0]\n----\n\t\tVaultOperations operations = new VaultTemplate(new VaultEndpoint());\n\t\tVaultTransitOperations transitOperations = operations.opsForTransit(\"transit\");\n\n\t\ttransitOperations.createKey(\"my-aes-key\", VaultTransitKeyCreationRequest.ofKeyType(\"aes128-gcm96\"));\t// <1>\n\n\t\tString ciphertext = transitOperations.encrypt(\"my-aes-key\", \"plaintext to encrypt\");\t\t\t\t\t// <2>\n\n\t\tString plaintext = transitOperations.decrypt(\"my-aes-key\", ciphertext);\t\t\t\t\t\t\t\t\t// <3>\n----\n<1> First, we need a key to begin with.\nEach key requires the type to be specified. `aes128-gcm96` supports encryption, decryption, key derivation, and convergent encryption, of which we need encryption and decryption for this example.\n<2> Next, we encrypt a `String` that contains the plain text that should be encrypted.\nThe input `String` uses the default `Charset` to encode the string into its binary representation.\nRequesting a token returns a `VaultToken`, which is used as value object for Vault tokens.\nThe `encrypt` method returns Base64-encoded ciphertext, typically starting with `vault:`.\n<3> To decrypt ciphertext into plain text, call the `decrypt` method.\nIt decrypts the ciphertext and returns a `String` that is decoded using the default charset.\n====\n\nThe preceeding example uses simple strings for cryptographic operations.\nWhile it is a simple approach, it bears the risk of charset misconfiguration and is not binary-safe.\nBinary safety is required when the plain text uses a binary representation for data such as images, compressed data, or binary data structures.\n\nTo encrypt and decrypt binary data, use the javadoc:org.springframework.vault.support.Plaintext[] and javadoc:org.springframework.vault.support.Ciphertext[] value objects that can hold binary values:\n\n====\n[source,java,indent=0]\n----\n\t\tbyte [] plaintext = \"plaintext to encrypt\".getBytes();\n\n\t\tCiphertext ciphertext = transitOperations.encrypt(\"my-aes-key\", Plaintext.of(plaintext));\t\t\t// <1>\n\n\t\tPlaintext decrypttedPlaintext = transitOperations.decrypt(\"my-aes-key\", ciphertext);\t\t\t\t// <2>\n----\n<1> Assuming a key `my-aes-key` is already in place, we're encrypting the javadoc:org.springframework.vault.support.Plaintext[] object.\nIn return, the `encrypt` method returns a javadoc:org.springframework.vault.support.Ciphertext[] object.\n<2> The javadoc:org.springframework.vault.support.Ciphertext[] object can be used directly for decryption and returns a javadoc:org.springframework.vault.support.Plaintext[] object.\n====\n\njavadoc:org.springframework.vault.support.Plaintext[] and javadoc:org.springframework.vault.support.Ciphertext[] come with a contextual object, javadoc:org.springframework.vault.support.VaultTransitContext[].\nIt is used to supply a nonce value for https://www.vaultproject.io/docs/secrets/transit#convergent-encryption[convergent encryption] and for a context value to make use of key derivation.\n\nTransit allows for signing plain text and verifying the signature for a given plain text.\nSign operations require an asymmetric key, typically using Elliptic Curve Cryptography or RSA.\n\nNOTE: Signatures use the public/private key split to ensure authenticity. +\nThe signer uses its private key to create a signature. Otherwise, anybody would be able to sign messages in your name.\nThe verifier uses the public key part to verify the signature. The actual signature is typically a hash value. +\n +\nInternally, the hash gets computed and encrypted using the private key to create the final signature. The verification decrypts the signature message, computes their own hash for the plain text and compares both hash values to check whether the signature is valid or not.\n\n====\n[source,java,indent=0]\n----\n\t\tbyte [] plaintext = \"plaintext to sign\".getBytes();\n\n\t\ttransitOperations.createKey(\"my-ed25519-key\", VaultTransitKeyCreationRequest.ofKeyType(\"ed25519\"));\t// <1>\n\n\t\tSignature signature = transitOperations.sign(\"my-ed25519-key\", Plaintext.of(plaintext));\t\t\t// <2>\n\n\t\tboolean valid = transitOperations.verify(\"my-ed25519-key\", Plaintext.of(plaintext), signature);\t\t// <3>\n----\n<1> Signing requires an asymmetric key. You can use any Elliptic Curve Cryptography or RSA key type. Once the key is created, you have all the prerequisites in place to create a signature.\n<2> The signature gets created for a plain text message. The returned javadoc:org.springframework.vault.support.Signature[] contains an ASCII-safe string that uses Base64 characters.\n<3> To verify the signature, the verification requires a javadoc:org.springframework.vault.support.Signature[] object and the plain text message. As the return value, you get whether the signature was valid or not.\n====\n\nYou can find more details about the https://www.vaultproject.io/api/secret/transit[Vault Transit Backend] in the Vault reference documentation.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault-secret-engines.adoc", "title": "vault-secret-engines", "heading": "Transit Backend", "heading_level": 2, "file_order": 13, "section_index": 5, "content_hash": "2e6073b33f8195e4f461b98dc3bbe5cc286cbddaa52e828091f9dc59a1a3dceb", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault-secret-engines.adoc"}}
{"id": "sha256:e2c77bf8f4655080bab300cd7b7a3af7b0642be83c3421394aafa052c39e2434", "content": "[[vault.reference]]\n\nThis chapter points out the specialties for Vault support.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/vault/vault.adoc", "title": "vault", "heading": "vault", "heading_level": 1, "file_order": 14, "section_index": 0, "content_hash": "e2c77bf8f4655080bab300cd7b7a3af7b0642be83c3421394aafa052c39e2434", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/vault/vault.adoc"}}
{"id": "sha256:05535978395da0acd64107c4144d1a167adbd8d32723ee16c417cf5c6d19c5ec", "content": "[[spring-vault-reference-documentation]]\n\n[horizontal]\nxref:introduction/introduction.adoc[Introduction] :: Introduction to Spring Vault\nxref:vault/vault.adoc[Vault Core Support] :: Vault Template and Repositories\nxref:vault/authentication.adoc[Authentication] :: Supported Authentication Methods\nxref:vault/propertysource.adoc[Vault Property Source] :: Mounting Vault Secrets Engines as Property Source\n\nMark Paluch\n\n(C) 2008-{copyright-year} VMware, Inc.\n\nCopies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-vault", "path": "antora/modules/ROOT/pages/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 15, "section_index": 0, "content_hash": "05535978395da0acd64107c4144d1a167adbd8d32723ee16c417cf5c6d19c5ec", "source_url": "https://github.com/spring-projects/spring-vault/blob/5be9ba3c291105823781b45520c6a32d459bd1a6/src/main/antora/modules/ROOT/pages/index.adoc"}}
