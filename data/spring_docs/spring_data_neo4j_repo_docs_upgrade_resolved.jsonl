{"id": "sha256:1fd47989949cb05dd0a51978f47ea4737c8830240391f9372f516888583e8af7", "content": "[[building-SDN]]\n\n[[building-SDN.requirements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/build.adoc", "title": "build", "heading": "build", "heading_level": 1, "file_order": 0, "section_index": 0, "content_hash": "1fd47989949cb05dd0a51978f47ea4737c8830240391f9372f516888583e8af7", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/build.adoc"}}
{"id": "sha256:0297e0e4ea1d90375253690dfd748d6fda61c6c2ad7eaed2fda9da9cf8a2269f", "content": "* JDK 17+ (Can be https://openjdk.java.net[OpenJDK] or https://www.oracle.com/technetwork/java/index.html[Oracle JDK])\n* Maven 3.8.5 (We provide the Maven wrapper, see `mvnw` respectively `mvnw.cmd` in the project root; the wrapper downloads the appropriate Maven version automatically)\n* A Neo4j 5.+ database, either\n** running locally\n** or indirectly via https://www.testcontainers.org[Testcontainers] and https://www.docker.com[Docker]\n\n[[building-SDN.jdk.version]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/build.adoc", "title": "build", "heading": "Requirements", "heading_level": 2, "file_order": 0, "section_index": 1, "content_hash": "0297e0e4ea1d90375253690dfd748d6fda61c6c2ad7eaed2fda9da9cf8a2269f", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/build.adoc"}}
{"id": "sha256:bfe1a7063213e93489b3a62079c9d2a9e1ca3dd9c6a4058016e3dfa17aa9a9d6", "content": "Choosing JDK 17 is a decision influenced by various aspects\n\n* SDN is a Spring Data project.\nSpring Data commons baseline is JDK 17 and so is Spring Framework's baseline.\nThus, it is only natural to keep the JDK 17 baseline.\n\n[[building-SDN.running-the-build]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/build.adoc", "title": "build", "heading": "About the JDK version", "heading_level": 3, "file_order": 0, "section_index": 2, "content_hash": "bfe1a7063213e93489b3a62079c9d2a9e1ca3dd9c6a4058016e3dfa17aa9a9d6", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/build.adoc"}}
{"id": "sha256:5a485cc33041c2e6bfde971773f4a492bcc8349fbf5adba594da78ef002ff2ad", "content": "The following sections are alternatives and roughly sorted by increased effort.\n\nAll builds require a local copy of the project:\n\n[source,console,subs=\"verbatim,attributes\"]\n[[checkout-SDN]]\n.Clone SDN\n----\n$ git clone git@github.com:spring-projects/spring-data-neo4j.git\n----\n\nBefore you proceed, verify your locally installed JDK version.\nThe output should be similar:\n\n[source,console,subs=\"verbatim,attributes\"]\n[[verify-jdk]]\n.Verify your JDK\n----\n$ java -version\njava version \"18.0.1\" 2022-04-19\nJava(TM) SE Runtime Environment (build 18.0.1+10-24)\nJava HotSpot(TM) 64-Bit Server VM (build 18.0.1+10-24, mixed mode, sharing)\n----\n\n[[building-SDN.docker]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/build.adoc", "title": "build", "heading": "Running the build", "heading_level": 2, "file_order": 0, "section_index": 3, "content_hash": "5a485cc33041c2e6bfde971773f4a492bcc8349fbf5adba594da78ef002ff2ad", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/build.adoc"}}
{"id": "sha256:860989927743e39de7df11b239aa838265696a98680d7b5eda0f0b93b5a34260", "content": "[[building-SDN.docker.default-image]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/build.adoc", "title": "build", "heading": "With Docker installed", "heading_level": 3, "file_order": 0, "section_index": 4, "content_hash": "860989927743e39de7df11b239aa838265696a98680d7b5eda0f0b93b5a34260", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/build.adoc"}}
{"id": "sha256:45c86de3647df16ceaf1e9c02984fa45f6c1ff19ab19ae329b7579d9594076e2", "content": "If you don't have https://en.wikipedia.org/wiki/Docker_(software)[Docker] installed, head over to https://www.docker.com/products/docker-desktop[Docker Desktop].\nIn short, Docker is a tool that helps you running lightweight software images using OS-level virtualization in so-called containers.\n\nOur build uses https://www.testcontainers.org/modules/databases/neo4j/[Testcontainers Neo4j] to bring up a database instance.\n\n[source,console,subs=\"verbatim,attributes\"]\n[[build-default-bash]]\n.Build with default settings on Linux / macOS\n----\n$ ./mvnw clean verify\n----\n\nOn a Windows machine, use\n\n[source,console,subs=\"verbatim,attributes\"]\n[[build-default-windows]]\n.Build with default settings on Windows\n----\n$ mvnw.cmd clean verify\n----\n\nThe output should be similar.\n\n[[building-SDN.docker.another-image]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/build.adoc", "title": "build", "heading": "Using the default image", "heading_level": 4, "file_order": 0, "section_index": 5, "content_hash": "45c86de3647df16ceaf1e9c02984fa45f6c1ff19ab19ae329b7579d9594076e2", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/build.adoc"}}
{"id": "sha256:16cfd4e977f048d450ff4f1f578433b07489e48b4643007615cc53e3e34eeeb1", "content": "The image version to use can be configured through an environmental variable like this:\n\n[source,console,subs=\"verbatim,attributes\"]\n[[build-other-image]]\n.Build using a different Neo4j Docker image\n----\n$ SDN_NEO4J_VERSION=5.3.0-enterprise SDN_NEO4J_ACCEPT_COMMERCIAL_EDITION=yes ./mvnw clean verify\n----\n\nHere we are using 5.3.0 enterprise and also accept the license agreement.\n\nConsult your operating system or shell manual on how to define environment variables if specifying them inline does not work for you.\n\n[[building-SDN.local-database]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/build.adoc", "title": "build", "heading": "Using another image", "heading_level": 4, "file_order": 0, "section_index": 6, "content_hash": "16cfd4e977f048d450ff4f1f578433b07489e48b4643007615cc53e3e34eeeb1", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/build.adoc"}}
{"id": "sha256:47d3e987dcfcd3d84b98c9f7184d4f563a6758ade0c2bc4ffe5c8375f13ef9ee", "content": "WARNING: Running against a locally running database *will* erase its complete content.\n\nBuilding against a locally running database is faster, as it does not restart a container each time.\nWe do this a lot during our development.\n\nYou can get a copy of Neo4j at our https://neo4j.com/download-center/#enterprise[download center] free of charge.\n\nPlease download the version applicable to your operating system and follow the instructions to start it.\nA required step is to open a browser and go to http://localhost:7474 after you started the database and change the default password from `neo4j` to something of your liking.\n\nAfter that, you can run a complete build by specifying the local `bolt` URL:\n\n[source,console,subs=\"verbatim,attributes\"]\n[[build-using-locally-running-database]]\n.Build using a locally running database\n----\n$ SDN_NEO4J_URL=bolt://localhost:7687 SDN_NEO4J_PASSWORD=verysecret ./mvnw clean verify\n----\n\n[[building-SDN.environment-variables]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/build.adoc", "title": "build", "heading": "Against a locally running database", "heading_level": 3, "file_order": 0, "section_index": 7, "content_hash": "47d3e987dcfcd3d84b98c9f7184d4f563a6758ade0c2bc4ffe5c8375f13ef9ee", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/build.adoc"}}
{"id": "sha256:6214e60447838f4e99cd7270209bd76eb0ccbe7599cd840a90868807b212bb73", "content": "[cols=\"3,1,3\",options=\"header\"]\n|===\n|Name|Default value|Meaning\n\n|`SDN_NEO4J_VERSION`\n|5.3.0\n|Version of the Neo4j docker image to use, see https://hub.docker.com/_/neo4j[Neo4j Docker Official Images]\n\n|`SDN_NEO4J_ACCEPT_COMMERCIAL_EDITION`\n|no\n|Some tests may require the enterprise edition of Neo4j.\nWe build and test against the enterprise edition internally, but we won't force you\nto accept the license if you don't want to.\n\n|`SDN_NEO4J_URL`\n|not set\n|Setting this environment allows connecting to a locally running Neo4j instance.\nWe use this a lot during development.\n\n|`SDN_NEO4J_PASSWORD`\n|not set\n|Password for the `neo4j` user of the instance configured with `SDN_NEO4J_URL`.\n\n|===\n\nNOTE: You need to set both `SDN_NEO4J_URL` and `SDN_NEO4J_PASSWORD` to use a local instance.\n\n[[building-SDN.checkstyle-and-co]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/build.adoc", "title": "build", "heading": "Summary of environment variables controlling the build", "heading_level": 2, "file_order": 0, "section_index": 8, "content_hash": "6214e60447838f4e99cd7270209bd76eb0ccbe7599cd840a90868807b212bb73", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/build.adoc"}}
{"id": "sha256:ff78cb4a1f53f1ec3fecd52e988026ce4045936802beaeb4b6dfa86a8edcdca1", "content": "There is no quality gate in place at the moment to ensure that the code/test ratio stays as is, but please consider adding tests to your contributions.\n\nWe have some rather mild checkstyle rules in place, enforcing more or less default Java formatting rules.\nYour build will break on formatting errors or something like unused imports.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/build.adoc", "title": "build", "heading": "Checkstyle and friends", "heading_level": 2, "file_order": 0, "section_index": 9, "content_hash": "ff78cb4a1f53f1ec3fecd52e988026ce4045936802beaeb4b6dfa86a8edcdca1", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/build.adoc"}}
{"id": "sha256:ea68da8af4e88ddfb8f584979b8cc70126741a04d9ea7c4ca77af3e946eda083", "content": "[[conversions]]\n\n[[build-in.conversions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/conversions.adoc", "title": "conversions", "heading": "conversions", "heading_level": 1, "file_order": 1, "section_index": 0, "content_hash": "ea68da8af4e88ddfb8f584979b8cc70126741a04d9ea7c4ca77af3e946eda083", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/conversions.adoc"}}
{"id": "sha256:57e3bd3acb00a8028b32a338d5125c3141437fba81c336ab4fca68e738a1a911", "content": "The Neo4j Converter has a few conventions for mapping objects when no additional mapping metadata is provided.\nThe conventions are:\n\n* The short Java class name is mapped to the primary label in the following manner:\nThe class `com.bigbank.SavingsAccount` maps to the `savingsAccount` primary label.\n* The converter uses any <<custom.conversions,Spring Converter>> registered with it to override the default mapping of object properties to node fields and values.\n* The fields of an object are used to convert to and from fields in the graph.\nPublic `JavaBean` properties are not used.\n* If you have a single non-zero-argument constructor whose constructor argument names match top-level property names of node, that constructor is used.\nOtherwise, the zero-argument constructor is used.\nIf there is more than one non-zero-argument constructor, an exception will be thrown.\n\nWe support a broad range of conversions out of the box.\nFind the list of supported cypher types in the official drivers manual: https://neo4j.com/docs/java-manual/current/cypher-workflow/#java-driver-type-mapping[Type mapping].\n\nPrimitive types of wrapper types are equally supported.\n\n[cols=\"3,3,1\",options=\"header\"]\n|===\n|Domain type|Cypher type|Maps directly to native type\n\n|`java.lang.Boolean`\n|Boolean\n|✔\n\n|`boolean[]`\n|List of Boolean\n|✔\n\n|`java.lang.Long`\n|Integer\n|✔\n\n|`long[]`\n|List of Integer\n|✔\n\n|`java.lang.Double`\n|Float\n|✔\n\n|`double[]`\n|List of Float\n|✔\n\n|`java.lang.String`\n|String\n|✔\n\n|`java.lang.String[]`\n|List of String\n|✔\n\n|`byte[]`\n|ByteArray\n|✔\n\n|`java.lang.Byte`\n|ByteArray with length 1\n|\n\n|`java.lang.Character`\n|String with length 1\n|\n\n|`char[]`\n|List of String with length 1\n|\n\n|`java.util.Date`\n|String formatted as ISO 8601 Date (`yyyy-MM-dd'T'HH:mm:ss.SSSZ`).\nNotice the `Z`: SDN will store all `java.util.Date` instances in `UTC`.\nIf you require the time zone, use a type that supports it (i.e. `ZoneDateTime`) or store the zone as a separate property.\n|\n\n|`java.lang.Float`\n|String\n|\n\n|`float[]`\n|List of String\n|\n\n|`java.lang.Integer`\n|Integer\n|\n\n|`int[]`\n|List of Integer\n|\n\n|`java.util.Locale`\n|String formatted as BCP 47 language tag\n|\n\n|`java.lang.Short`\n|Integer\n|\n\n|`short[]`\n|List of Integer\n|\n\n|`java.math.BigDecimal`\n|String\n|\n\n|`java.math.BigInteger`\n|String\n|\n\n|`java.time.LocalDate`\n|Date\n|✔\n\n|`java.time.OffsetTime`\n|Time\n|✔\n\n|`java.time.LocalTime`\n|LocalTime\n|✔\n\n|`java.time.ZonedDateTime`\n|DateTime\n|✔\n\n|`java.time.LocalDateTime`\n|LocalDateTime\n|✔\n\n|`java.time.OffsetDateTime`\n|DateTime\n|\n\n|`java.time.Instant`\n|DateTime\n|\n\n|`java.util.TimeZone`\n|String\n|\n\n|`java.time.ZoneId`\n|String\n|\n\n|`java.time.Period`\n|Duration\n|\n\n|`java.time.Duration`\n|Duration\n|\n\n|`org.neo4j.driver.types.IsoDuration`\n|Duration\n|✔\n\n|`org.neo4j.driver.types.Point`\n|Point\n|✔\n\n|`org.springframework.data.neo4j.types.GeographicPoint2d`\n|Point with CRS 4326\n|\n\n|`org.springframework.data.neo4j.types.GeographicPoint3d`\n|Point with CRS 4979\n|\n\n|`org.springframework.data.neo4j.types.CartesianPoint2d`\n|Point with CRS 7203\n|\n\n|`org.springframework.data.neo4j.types.CartesianPoint3d`\n|Point with CRS 9157\n|\n\n|`org.springframework.data.geo.Point`\n|Point with CRS 4326 and x/y corresponding to lat/long\n|\n\n|`org.springframework.data.domain.Vector`\n|persisted through `setNodeVectorProperty`\n|\n\n|Instances of `Enum`\n|String (The name value of the enum)\n|\n\n|Instances of `Enum[]`\n|List of String (The name value of the enum)\n|\n\n|`java.net.URL`\n|String\n|\n\n|`java.net.URI`\n|String\n|\n\n|`java.util.UUID`\n|String\n|\n\n|===\n\n[[build-in.conversions.vector]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/conversions.adoc", "title": "conversions", "heading": "Convention-based Mapping", "heading_level": 2, "file_order": 1, "section_index": 1, "content_hash": "57e3bd3acb00a8028b32a338d5125c3141437fba81c336ab4fca68e738a1a911", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/conversions.adoc"}}
{"id": "sha256:e395314e892c9e2cad986e56627c67f4ac0cf34c72611c06e87a0c6bcd5d1e53", "content": "Spring Data has its own type for vector representation `org.springframework.data.domain.Vector`.\nWhile this can be used as a wrapper around a `float` or `double` array, Spring Data Neo4j supports only the `double` variant right now.\nFrom a user perspective, it is possible to only define the `Vector` interface on the property definition and use either `double` or `float`.\nNeo4j will store both `double` and `float` variants as a 64-bit Cypher `FLOAT` value, which is consistent with values persisted through Cypher and the dedicated `setNodeVectorProperty` function that Spring Data Neo4j uses to persist the property.\n\nNOTE: Spring Data Neo4j only allows one `Vector` property to be present in an entity definition.\n\nNOTE: Please be aware that a persisted `float` value differs from a read back value due to the nature of floating numbers.\n\n[[custom.conversions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/conversions.adoc", "title": "conversions", "heading": "Vector type", "heading_level": 3, "file_order": 1, "section_index": 2, "content_hash": "e395314e892c9e2cad986e56627c67f4ac0cf34c72611c06e87a0c6bcd5d1e53", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/conversions.adoc"}}
{"id": "sha256:f7b34ddcaeae4c1404f40a45edd91d94a36edd6c70219993efcb0024fbc94dfc", "content": "[[custom.conversions.attribute.types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/conversions.adoc", "title": "conversions", "heading": "Custom conversions", "heading_level": 2, "file_order": 1, "section_index": 3, "content_hash": "f7b34ddcaeae4c1404f40a45edd91d94a36edd6c70219993efcb0024fbc94dfc", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/conversions.adoc"}}
{"id": "sha256:9d07fe19f26164c4a338d216f64eb1b81cbd12f65b243fd4be66aa99e78e6f9c", "content": "If you prefer to work with your own types in the entities or as parameters for `@Query` annotated methods, you can define and provide a custom converter implementation.\nFirst you have to implement a `GenericConverter` and register the types your converter should handle.\nFor entity property type converters you need to take care of converting your type to *and* from a Neo4j Java Driver `Value`.\nIf your converter is supposed to work only with custom query methods in the repositories, it is sufficient to provide the one-way conversion to the `Value` type.\n\n.Example of a custom converter implementation\n[source,java,indent=0]\n----\n/*\n * Copyright 2011-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.neo4j.documentation.repositories.conversion;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.neo4j.driver.Value;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.core.convert.TypeDescriptor;\nimport org.springframework.core.convert.converter.GenericConverter;\nimport org.springframework.data.neo4j.core.convert.Neo4jConversions;\n\n/**\n * @author Gerrit Meier\n */\n// tag::custom-converter.implementation[]\npublic class MyCustomTypeConverter implements GenericConverter {\n\n\t@Override\n\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\tSet<ConvertiblePair> convertiblePairs = new HashSet<>();\n\t\tconvertiblePairs.add(new ConvertiblePair(MyCustomType.class, Value.class));\n\t\tconvertiblePairs.add(new ConvertiblePair(Value.class, MyCustomType.class));\n\t\treturn convertiblePairs;\n\t}\n\n\t@Override\n\tpublic Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tif (MyCustomType.class.isAssignableFrom(sourceType.getType())) {\n\t\t\t// convert to Neo4j Driver Value\n\t\t\treturn convertToNeo4jValue(source);\n\t\t}\n\t\telse {\n\t\t\t// convert to MyCustomType\n\t\t\treturn convertToMyCustomType(source);\n\t\t}\n\t}\n\n\t// end::custom-converter.implementation[]\n\t// tag::custom-converter.neo4jConversions[]\n\t@Bean\n\tpublic Neo4jConversions neo4jConversions() {\n\t\tSet<GenericConverter> additionalConverters = Collections.singleton(new MyCustomTypeConverter());\n\t\treturn new Neo4jConversions(additionalConverters);\n\t}\n\t// end::custom-converter.neo4jConversions[]\n\n\tprivate Object convertToNeo4jValue(Object source) {\n\t\treturn null;\n\t}\n\n\tprivate Object convertToMyCustomType(Object source) {\n\t\treturn null;\n\t}\n\n\tprivate static final class MyCustomType {\n\n\t}\n\t// tag::custom-converter.implementation[]\n\n}\n// end::custom-converter.implementation[]\n----\n\nTo make SDN aware of your converter, it has to be registered in the `Neo4jConversions`.\nTo do this, you have to create a `@Bean` with the type `org.springframework.data.neo4j.core.convert.Neo4jConversions`.\nOtherwise, the `Neo4jConversions` will get created in the background with the internal default converters only.\n\n.Example of a custom converter implementation\n[source,java,indent=0]\n----\n/*\n * Copyright 2011-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.neo4j.documentation.repositories.conversion;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.neo4j.driver.Value;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.core.convert.TypeDescriptor;\nimport org.springframework.core.convert.converter.GenericConverter;\nimport org.springframework.data.neo4j.core.convert.Neo4jConversions;\n\n/**\n * @author Gerrit Meier\n */\n// tag::custom-converter.implementation[]\npublic class MyCustomTypeConverter implements GenericConverter {\n\n\t@Override\n\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\tSet<ConvertiblePair> convertiblePairs = new HashSet<>();\n\t\tconvertiblePairs.add(new ConvertiblePair(MyCustomType.class, Value.class));\n\t\tconvertiblePairs.add(new ConvertiblePair(Value.class, MyCustomType.class));\n\t\treturn convertiblePairs;\n\t}\n\n\t@Override\n\tpublic Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tif (MyCustomType.class.isAssignableFrom(sourceType.getType())) {\n\t\t\t// convert to Neo4j Driver Value\n\t\t\treturn convertToNeo4jValue(source);\n\t\t}\n\t\telse {\n\t\t\t// convert to MyCustomType\n\t\t\treturn convertToMyCustomType(source);\n\t\t}\n\t}\n\n\t// end::custom-converter.implementation[]\n\t// tag::custom-converter.neo4jConversions[]\n\t@Bean\n\tpublic Neo4jConversions neo4jConversions() {\n\t\tSet<GenericConverter> additionalConverters = Collections.singleton(new MyCustomTypeConverter());\n\t\treturn new Neo4jConversions(additionalConverters);\n\t}\n\t// end::custom-converter.neo4jConversions[]\n\n\tprivate Object convertToNeo4jValue(Object source) {\n\t\treturn null;\n\t}\n\n\tprivate Object convertToMyCustomType(Object source) {\n\t\treturn null;\n\t}\n\n\tprivate static final class MyCustomType {\n\n\t}\n\t// tag::custom-converter.implementation[]\n\n}\n// end::custom-converter.implementation[]\n----\n\nIf you need multiple converters in your application, you can add as many as you need in the `Neo4jConversions` constructor.\n\n[[custom.conversions.attribute.specific]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/conversions.adoc", "title": "conversions", "heading": "For attributes of a given type", "heading_level": 3, "file_order": 1, "section_index": 4, "content_hash": "9d07fe19f26164c4a338d216f64eb1b81cbd12f65b243fd4be66aa99e78e6f9c", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/conversions.adoc"}}
{"id": "sha256:8e96b1c5f35d313f10549eaf651afa7ac63f2dc7df2a83751be4cc3899af57c3", "content": "If you need conversions only for some specific attributes, we provide `@ConvertWith`.\nThis is an annotation that can be put on attributes of both entities (`@Node`) and relationship properties (`@RelationshipProperties`)\nIt defines a `Neo4jPersistentPropertyConverter` via the `converter` attribute\nand an optional `Neo4jPersistentPropertyConverterFactory` to construct the former.\nWith an implementation of `Neo4jPersistentPropertyConverter` all specific conversions for a given type can be addressed.\nIn addition, `@ConvertWith` also provides `converterRef` for referencing any Spring bean in the application context implementing\n`Neo4jPersistentPropertyConverter`. The referenced bean will be preferred over constructing a new converter.\n\nWe provide `@DateLong` and `@DateString` as meta-annotated annotations for backward compatibility with Neo4j-OGM schemes not using native types.\nThose are meta annotated annotations building on the concept above.\n\n[[custom.conversions.composite-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/conversions.adoc", "title": "conversions", "heading": "For specific attributes only", "heading_level": 3, "file_order": 1, "section_index": 5, "content_hash": "8e96b1c5f35d313f10549eaf651afa7ac63f2dc7df2a83751be4cc3899af57c3", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/conversions.adoc"}}
{"id": "sha256:2838b386becba7ea43befd80bfceeb3a94fa76d9d6478f2d17e3e8f93b4e4ea4", "content": "With `@CompositeProperty`, attributes of type `Map<String, Object>` or `Map<? extends Enum, Object>` can be stored as composite properties.\nAll entries inside the map will be added as properties to the node or relationship containing the property.\nEither with a configured prefix or prefixed with the name of the property.\nWhile we only offer that feature for maps out of the box, you can `Neo4jPersistentPropertyToMapConverter` and configure it\nas the converter to use on `@CompositeProperty`. A `Neo4jPersistentPropertyToMapConverter` needs to know how a given type can\nbe decomposed to and composed back from a map.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/conversions.adoc", "title": "conversions", "heading": "Composite properties", "heading_level": 4, "file_order": 1, "section_index": 6, "content_hash": "2838b386becba7ea43befd80bfceeb3a94fa76d9d6478f2d17e3e8f93b4e4ea4", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/conversions.adoc"}}
{"id": "sha256:b85dcf0d581953460ad5b9a643e36b20047f19c6ecc1e7b20ca3c4584dc3a599", "content": "[[custom-queries]]\n\nSpring Data Neo4j, like all the other Spring Data modules, allows you to specify custom queries in you repositories.\nThose come in handy if you cannot express the finder logic via derived query functions.\n\nBecause Spring Data Neo4j works heavily record-oriented under the hood, it is important to keep this in mind and not build up a result set with multiple records for the same \"root node\".\n\nTIP: Please have a look in the FAQ as well to learn about alternative forms of using custom queries from repositories, especially\nhow to use custom queries with custom mappings: xref:faq.adoc#faq.custom-queries-and-custom-mappings[Custom queries and custom mappings].\n\n[[custom-queries.for-relationships]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "custom-queries", "heading_level": 1, "file_order": 2, "section_index": 0, "content_hash": "b85dcf0d581953460ad5b9a643e36b20047f19c6ecc1e7b20ca3c4584dc3a599", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:0ce8e54e47c6f5d10dcba7c61cffb0b1666a132cf54e9c7dd6191e1313c3cba9", "content": "[[custom-queries.for-relationships.cartesian-product]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Queries with relationships", "heading_level": 2, "file_order": 2, "section_index": 1, "content_hash": "0ce8e54e47c6f5d10dcba7c61cffb0b1666a132cf54e9c7dd6191e1313c3cba9", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:0b2367e1293fca9d0d6748500ffa4814b9aa749531af0edb93c9da07836351ff", "content": "Assuming you have a query like `MATCH (m:Movie{title: 'The Matrix'})<-[r:ACTED_IN]-(p:Person) return m,r,p` that results into something like this:\n\n.Multiple records (shortened)\n----\n+------------------------------------------------------------------------------------------+\n| m | r | p |\n+------------------------------------------------------------------------------------------+\n| (:Movie) | [:ACTED_IN {roles: [\"Emil\"]}] | (:Person {name: \"Emil Eifrem\"}) |\n| (:Movie) | [:ACTED_IN {roles: [\"Agent Smith\"]}] | (:Person {name: \"Hugo Weaving}) |\n| (:Movie) | [:ACTED_IN {roles: [\"Morpheus\"]}] | (:Person {name: \"Laurence Fishburne\"}) |\n| (:Movie) | [:ACTED_IN {roles: [\"Trinity\"]}] | (:Person {name: \"Carrie-Anne Moss\"}) |\n| (:Movie) | [:ACTED_IN {roles: [\"Neo\"]}] | (:Person {name: \"Keanu Reeves\"}) |\n+------------------------------------------------------------------------------------------+\n----\n\nThe result from the mapping would be most likely unusable.\nIf this would get mapped into a list, it will contain duplicates for the `Movie` but this movie will only have one relationship.\n\n[[custom-queries.for-relationships.one.record]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Beware of the cartesian product", "heading_level": 3, "file_order": 2, "section_index": 2, "content_hash": "0b2367e1293fca9d0d6748500ffa4814b9aa749531af0edb93c9da07836351ff", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:7c5b50b585d2939e0a12e0d033ecc5e58e7af0c087a1429f376f037df26f98dd", "content": "To get the right object(s) back, it is required to _collect_ the relationships and related nodes in the query: `MATCH (m:Movie{title: 'The Matrix'})<-[r:ACTED_IN]-(p:Person) return m,collect(r),collect(p)`\n\n.Single record (shortened)\n----\n+------------------------------------------------------------------------+\n| m | collect(r) | collect(p) |\n+------------------------------------------------------------------------+\n| (:Movie) | [[:ACTED_IN], [:ACTED_IN], ...]| [(:Person), (:Person),...] |\n+------------------------------------------------------------------------+\n----\n\nWith this result as a single record it is possible for Spring Data Neo4j to add all related nodes correctly to the root node.\n\n[[custom-queries.for-relationships.long-paths]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Getting one record per root node", "heading_level": 3, "file_order": 2, "section_index": 3, "content_hash": "7c5b50b585d2939e0a12e0d033ecc5e58e7af0c087a1429f376f037df26f98dd", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:54fb578326e29fce3a294112814e0e776d45263ca0febad159caa7ba28d9c824", "content": "The example above assumes that you are only trying to fetch the first level of related nodes.\nThis is sometimes not enough and there are maybe nodes deeper in the graph that should also be part of the mapped instance.\nThere are two ways to achieve this: Database-side or client-side reduction.\n\nFor this the example from above should also contain `Movies` on the `Persons` that get returned with the initial `Movie`.\n\n.Example for 'The Matrix' and 'Keanu Reeves'\nimage::image$movie-graph-deep.png[]\n\n[[custom-queries.for-relationships.long-paths.database]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Reaching deeper into the graph", "heading_level": 3, "file_order": 2, "section_index": 4, "content_hash": "54fb578326e29fce3a294112814e0e776d45263ca0febad159caa7ba28d9c824", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:b62eb8c41f8c1491841ae34ce4efda58111bee04ef9a75636b7b3dbffa62f9b1", "content": "Keeping in mind that Spring Data Neo4j can only properly process record based, the result for one entity instance needs to be in one record.\nUsing https://neo4j.com/docs/cypher-manual/current/syntax/patterns/#cypher-pattern-path-variables[Cypher's path] capabilities is a valid option to fetch all branches in the graph.\n\n[source,cypher]\n.Naive path-based approach\n----\nMATCH p=(m:Movie{title: 'The Matrix'})<-[:ACTED_IN]-(:Person)-[:ACTED_IN*..0]->(:Movie)\nRETURN p;\n----\n\nThis will result in multiple paths that are not merged within one record.\nIt is possible to call `collect(p)` but Spring Data Neo4j does not understand the concept of paths in the mapping process.\nThus, nodes and relationships needs to get extracted for the result.\n\n[source,cypher]\n.Extracting nodes and relationships\n----\nMATCH p=(m:Movie{title: 'The Matrix'})<-[:ACTED_IN]-(:Person)-[:ACTED_IN*..0]->(:Movie)\nRETURN m, nodes(p), relationships(p);\n----\n\nBecause there are multiple paths that lead from 'The Matrix' to another movie, the result still won't be a single record.\nThis is where https://neo4j.com/docs/cypher-manual/current/functions/list/#functions-reduce[Cypher's reduce function] comes into play.\n\n[source,cypher]\n.Reducing nodes and relationships\n----\nMATCH p=(m:Movie{title: 'The Matrix'})<-[:ACTED_IN]-(:Person)-[:ACTED_IN*..0]->(:Movie)\nWITH collect(p) as paths, m\nWITH m,\nreduce(a=[], node in reduce(b=[], c in [aa in paths | nodes(aa)] | b + c) | case when node in a then a else a + node end) as nodes,\nreduce(d=[], relationship in reduce(e=[], f in [dd in paths | relationships(dd)] | e + f) | case when relationship in d then d else d + relationship end) as relationships\nRETURN m, relationships, nodes;\n----\n\nThe `reduce` function allows us to flatten the nodes and relationships from various paths.\nAs a result we will get a tuple similar to <<custom-queries.for-relationships.one.record>> but with a mixture of relationship types or nodes in the collections.\n\n[[custom-queries.for-relationships.long-paths.client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Database-side reduction", "heading_level": 4, "file_order": 2, "section_index": 5, "content_hash": "b62eb8c41f8c1491841ae34ce4efda58111bee04ef9a75636b7b3dbffa62f9b1", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:9796f3947feb4d13441f0557ed6fe1825a89a5d60011f437a3c6e964e8e0d1f4", "content": "If the reduction should happen on the client-side, Spring Data Neo4j enables you to map also lists of lists of relationships or nodes.\nStill, the requirement applies that the returned record should contain all information to hydrate the resulting entity instance correctly.\n\n[source,cypher]\n.Collect nodes and relationships from path\n----\nMATCH p=(m:Movie{title: 'The Matrix'})<-[:ACTED_IN]-(:Person)-[:ACTED_IN*..0]->(:Movie)\nRETURN m, collect(nodes(p)), collect(relationships(p));\n----\n\nThe additional `collect` statement creates lists in the format:\n----\n[[rel1, rel2], [rel3, rel4]]\n----\nThose lists will now get converted during the mapping process into a flat list.\n\nNOTE: Deciding if you want to go with client-side or database-side reduction depends on the amount of data that will get generated.\nAll the paths needs to get created in the database's memory first when the `reduce` function is used.\nOn the other hand a large amount of data that needs to get merged on the client-side results in a higher memory usage there.\n\n[[custom-query.paths]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Client-side reduction", "heading_level": 4, "file_order": 2, "section_index": 6, "content_hash": "9796f3947feb4d13441f0557ed6fe1825a89a5d60011f437a3c6e964e8e0d1f4", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:9748a59e3b1260de79af05dd20e211199e3e80af33d28e01f033a6cb99da2d87", "content": "Given are a graph that looks like this:\n\n[[custom-query.paths.g]]\n.graph with outgoing relationships\nimage::image$custom-query.paths.png[]\n\nand a domain model as shown in the <<custom-query.paths.dm,mapping>> (Constructors and accessors have been omitted for brevity):\n\n[[custom-query.paths.dm]]\n[source,java,indent=0,tabsize=4]\n.Domain model for a <<custom-query.paths.g>>.\n----\n/*\n * Copyright 2011-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.neo4j.integration.issues.gh2210;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.springframework.data.neo4j.core.schema.Id;\nimport org.springframework.data.neo4j.core.schema.Node;\nimport org.springframework.data.neo4j.core.schema.Relationship;\n\n/**\n * @author Michael J. Simons\n */\n// tag::custom-query.paths.dm[]\n@Node\npublic class SomeEntity {\n\n\t@Id\n\tprivate final Long number;\n\n\tprivate String name;\n\n\t@Relationship(type = \"SOME_RELATION_TO\", direction = Relationship.Direction.OUTGOING)\n\tprivate Set<SomeRelation> someRelationsOut = new HashSet<>();\n\n\t// end::custom-query.paths.dm[]\n\n\tSomeEntity(Long number) {\n\t\tthis.number = number;\n\t}\n\n\tpublic Long getNumber() {\n\t\treturn this.number;\n\t}\n\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n\tpublic Set<SomeRelation> getSomeRelationsOut() {\n\t\treturn this.someRelationsOut;\n\t}\n\t// tag::custom-query.paths.dm[]\n\n}\n// end::custom-query.paths.dm[]\n\n/*\n * Copyright 2011-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.neo4j.integration.issues.gh2210;\n\nimport org.springframework.data.neo4j.core.schema.RelationshipId;\nimport org.springframework.data.neo4j.core.schema.RelationshipProperties;\nimport org.springframework.data.neo4j.core.schema.TargetNode;\n\n/**\n * @author Michael J. Simons\n */\n// tag::custom-query.paths.dm[]\n@RelationshipProperties\npublic class SomeRelation {\n\n\t@RelationshipId\n\tprivate Long id;\n\n\tprivate String someData;\n\n\t@TargetNode\n\tprivate SomeEntity targetPerson;\n\n\t// end::custom-query.paths.dm[]\n\n\tpublic Long getId() {\n\t\treturn this.id;\n\t}\n\n\tpublic String getSomeData() {\n\t\treturn this.someData;\n\t}\n\n\tpublic SomeEntity getTargetPerson() {\n\t\treturn this.targetPerson;\n\t}\n\t// tag::custom-query.paths.dm[]\n\n}\n// end::custom-query.paths.dm[]\n----\n\nAs you see, the relationships are only outgoing. Generated finder methods (including `findById`) will always try to match\na root node to be mapped. From there on onwards, all related objects will be mapped. In queries that should return only one object,\nthat root object is returned. In queries that return many objects, all matching objects are returned. Out- and incoming relationships\nfrom those objects returned are of course populated.\n\nAssume the following Cypher query:\n\n[source,cypher]\n----\nMATCH p = (leaf:SomeEntity {number: $a})-[:SOME_RELATION_TO*]-(:SomeEntity)\nRETURN leaf, collect(nodes(p)), collect(relationships(p))\n----\n\nIt follows the recommendation from <<custom-queries.for-relationships.one.record>> and it works great for the leaf node\nyou want to match here. However: That is only the case in all scenarios that return 0 or 1 mapped objects.\nWhile that query will populate all relationships like before, it won't return all 4 objects.\n\nThis can be changed by returning the whole path:\n\n[source,cypher]\n----\nMATCH p = (leaf:SomeEntity {number: $a})-[:SOME_RELATION_TO*]-(:SomeEntity)\nRETURN p\n----\n\nHere we do want to use the fact that the path `p` actually returns 3 rows with paths to all 4 nodes. All 4 nodes will be\npopulated, linked together and returned.\n\n[[custom-queries.parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Using paths to populate and return a list of entities", "heading_level": 2, "file_order": 2, "section_index": 7, "content_hash": "9748a59e3b1260de79af05dd20e211199e3e80af33d28e01f033a6cb99da2d87", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:2041a51a2d9afb90b6859838a494846ec01a583c788aef55d9bd2fdd39b9107f", "content": "You do this exactly the same way as in a standard Cypher query issued in the Neo4j Browser or the Cypher-Shell,\nwith the `$` syntax (from Neo4j 4.0 on upwards, the old `$\\{foo\\}` syntax for Cypher parameters has been removed from the database).\n\n[source,java,indent=0]\n.ARepository.java\n----\npublic interface ARepository extends Neo4jRepository<AnAggregateRoot, String> {\n\n\t@Query(\"MATCH (a:AnAggregateRoot {name: $name}) RETURN a\") // <.>\n\tOptional<AnAggregateRoot> findByCustomQuery(String name);\n\n}\n----\n<.> Here we are referring to the parameter by its name.\nYou can also use `$0` etc. instead.\n\nNOTE: You need to compile your Java 8+ project with `-parameters` to make named parameters work without further annotations.\nThe Spring Boot Maven and Gradle plugins do this automatically for you.\nIf this is not feasible for any reason, you can either add\n`@Param` and specify the name explicitly or use the parameters index.\n\nMapped entities (everything with a `@Node`) passed as parameter to a function that is annotated with\na custom query will be turned into a nested map.\nThe following example represents the structure as Neo4j parameters.\n\nGiven are a `Movie`, `Vertex` and `Actor` classes annotated as shown in <<movie-model, the movie model>>:\n\n[[movie-model]]\n[source,java]\n.\"Standard\" movies model\n----\n@Node\npublic final class Movie {\n\n @Id\n private final String title;\n\n @Property(\"tagline\")\n private final String description;\n\n @Relationship(value = \"ACTED_IN\", direction = Direction.INCOMING)\n private final List<Actor> actors;\n\n @Relationship(value = \"DIRECTED\", direction = Direction.INCOMING)\n private final List<Person> directors;\n}\n\n@Node\npublic final class Person {\n\n @Id @GeneratedValue\n private final Long id;\n\n private final String name;\n\n private Integer born;\n\n @Relationship(\"REVIEWED\")\n private List<Movie> reviewed = new ArrayList<>();\n}\n\n@RelationshipProperties\npublic final class Actor {\n\n\t@RelationshipId\n\tprivate final Long id;\n\n @TargetNode\n private final Person person;\n\n private final List<String> roles;\n}\n\ninterface MovieRepository extends Neo4jRepository<Movie, String> {\n\n @Query(\"MATCH (m:Movie {title: $movie.__id__})\\n\"\n + \"MATCH (m) <- [r:DIRECTED|REVIEWED|ACTED_IN] - (p:Person)\\n\"\n + \"return m, collect(r), collect(p)\")\n Movie findByMovie(@Param(\"movie\") Movie movie);\n}\n----\n\nPassing an instance of `Movie` to the repository method above, will generate the following Neo4j map parameter:\n\n[source,json]\n----\n{\n \"movie\": {\n \"__labels__\": [\n \"Movie\"\n ],\n \"__id__\": \"The Da Vinci Code\",\n \"__properties__\": {\n \"ACTED_IN\": [\n {\n \"__properties__\": {\n \"roles\": [\n \"Sophie Neveu\"\n ]\n },\n \"__target__\": {\n \"__labels__\": [\n \"Person\"\n ],\n \"__id__\": 402,\n \"__properties__\": {\n \"name\": \"Audrey Tautou\",\n \"born\": 1976\n }\n }\n },\n {\n \"__properties__\": {\n \"roles\": [\n \"Sir Leight Teabing\"\n ]\n },\n \"__target__\": {\n \"__labels__\": [\n \"Person\"\n ],\n \"__id__\": 401,\n \"__properties__\": {\n \"name\": \"Ian McKellen\",\n \"born\": 1939\n }\n }\n },\n {\n \"__properties__\": {\n \"roles\": [\n \"Dr. Robert Langdon\"\n ]\n },\n \"__target__\": {\n \"__labels__\": [\n \"Person\"\n ],\n \"__id__\": 360,\n \"__properties__\": {\n \"name\": \"Tom Hanks\",\n \"born\": 1956\n }\n }\n },\n {\n \"__properties__\": {\n \"roles\": [\n \"Silas\"\n ]\n },\n \"__target__\": {\n \"__labels__\": [\n \"Person\"\n ],\n \"__id__\": 403,\n \"__properties__\": {\n \"name\": \"Paul Bettany\",\n \"born\": 1971\n }\n }\n }\n ],\n \"DIRECTED\": [\n {\n \"__labels__\": [\n \"Person\"\n ],\n \"__id__\": 404,\n \"__properties__\": {\n \"name\": \"Ron Howard\",\n \"born\": 1954\n }\n }\n ],\n \"tagline\": \"Break The Codes\",\n \"released\": 2006\n }\n }\n}\n----\n\nA node is represented by a map. The map will always contain `\\\\__id__` which is the mapped id property.\nUnder `\\\\__labels__` all labels, static and dynamic, will be available.\nAll properties - and type of relationships - appear in those maps as they would appear in the graph when the entity would\nhave been written by SDN.\nValues will have the correct Cypher type and won't need further conversion.\n\nTIP: All relationships are lists of maps. Dynamic relationships will be resolved accordingly.\n One-to-one relationships will also be serialized as singleton lists. So to access a one-to-one mapping\n between people, you would write this das `$person.\\\\__properties__.BEST_FRIEND[0].\\\\__target__.\\\\__id__`.\n\nIf an entity has a relationship with the same type to different types of others nodes, they will all appear in the same list.\nIf you need such a mapping and also have the need to work with those custom parameters, you have to unroll it accordingly.\nOne way to do this are correlated subqueries (Neo4j 4.1+ required).\n\n[[custom-queries.expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Parameters in custom queries", "heading_level": 2, "file_order": 2, "section_index": 8, "content_hash": "2041a51a2d9afb90b6859838a494846ec01a583c788aef55d9bd2fdd39b9107f", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:b3b7f52f9ac253236dcbfd1dcdad519f2bdf56b20d1a6066bbaa3616f0e236d0", "content": "[[custom-queries.spel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Value Expressions in custom queries", "heading_level": 2, "file_order": 2, "section_index": 9, "content_hash": "b3b7f52f9ac253236dcbfd1dcdad519f2bdf56b20d1a6066bbaa3616f0e236d0", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:25006e0c72a38bb78c9ece0055b27108d90a5c0d0dcf60f91cff914293546665", "content": "{springdocsurl}/core/expressions.html[Spring Expression Language (SpEL)] can be used in custom queries inside `:#{}`.\nThe colon here refers to a parameter and such an expression should be used where parameters make sense.\nHowever, when using our <<literal-extension,literal extension>> you can use SpEL expression in places where standard Cypher\nwon't allow parameters (such as for labels or relationship types).\nThis is the standard Spring Data way of defining a block of text inside a query that undergoes SpEL evaluation.\n\nThe following example basically defines the same query as above, but uses a `WHERE` clause to avoid even more curly braces:\n\n[source,java,indent=0]\n[[custom-queries-with-spel-parameter-example]]\n.ARepository.java\n----\npublic interface ARepository extends Neo4jRepository<AnAggregateRoot, String> {\n\n\t@Query(\"MATCH (a:AnAggregateRoot) WHERE a.name = :#{#pt1 + #pt2} RETURN a\")\n\tOptional<AnAggregateRoot> findByCustomQueryWithSpEL(String pt1, String pt2);\n\n}\n----\n\nThe SpEL blocked starts with `:#{` and then refers to the given `String` parameters by name (`#pt1`).\nDon't confuse this with the above Cypher syntax!\nThe SpEL expression concatenates both parameters into one single value that is eventually passed on to the xref:appendix/neo4j-client.adoc#neo4j-client[].\nThe SpEL block ends with `}`.\n\nSpEL also solves two additional problems. We provide two extensions that allow to pass in a `Sort` object into custom queries.\nRemember xref:faq.adoc#custom-queries-with-page-and-slice-examples[] from xref:faq.adoc#faq.custom-queries-with-page-and-slice[custom queries]?\nWith the `orderBy` extension you can pass in a `Pageable` with a dynamic sort to a custom query:\n\n[[custom-queries.spel.source]]\n[source,java]\n.orderBy-Extension\n----\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.neo4j.repository.Neo4jRepository;\nimport org.springframework.data.neo4j.repository.query.Query;\n\npublic interface MyPersonRepository extends Neo4jRepository<Person, Long> {\n\n @Query(\"\"\n + \"MATCH (n:Person) WHERE n.name = $name RETURN n \"\n + \":#{orderBy(#pageable)} SKIP $skip LIMIT $limit\" // <.>\n )\n Slice<Person> findSliceByName(String name, Pageable pageable);\n\n @Query(\"\"\n + \"MATCH (n:Person) WHERE n.name = $name RETURN n :#{orderBy(#sort)}\" // <.>\n )\n List<Person> findAllByName(String name, Sort sort);\n}\n----\n<.> A `Pageable` has always the name `pageable` inside the SpEL context.\n<.> A `Sort` has always the name `sort` inside the SpEL context.\n\n[[spel-extensions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Spring Expression Language in custom queries", "heading_level": 3, "file_order": 2, "section_index": 10, "content_hash": "25006e0c72a38bb78c9ece0055b27108d90a5c0d0dcf60f91cff914293546665", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:0115b66d6ff3a33e652e3f953a573b175adb6af2c5a66b767926e8debc26c76d", "content": "[[literal-extension]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Spring Expression Language extensions", "heading_level": 3, "file_order": 2, "section_index": 11, "content_hash": "0115b66d6ff3a33e652e3f953a573b175adb6af2c5a66b767926e8debc26c76d", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:7e876ea76be5009eec9cd68ff7b85b11d34d85a8a1f6ca31a03c91ddf0514bae", "content": "The `literal` extension can be used to make things like labels or relationship-types \"dynamic\" in custom queries.\nNeither labels nor relationship types can be parameterized in Cypher, so they must be given literal.\n\n[source,java]\n.literal-Extension\n----\ninterface BaseClassRepository extends Neo4jRepository<Inheritance.BaseClass, Long> {\n\n @Query(\"MATCH (n:`:#{literal(#label)}`) RETURN n\") // <.>\n List<Inheritance.BaseClass> findByLabel(String label);\n}\n----\n<.> The `literal` extension will be replaced with the literal value of the evaluated parameter.\n\nHere, the `literal` value has been used to match dynamically on a Label.\nIf you pass in `SomeLabel` as a parameter to the method, `MATCH (n:``SomeLabel``) RETURN n`\nwill be generated. Ticks have been added to correctly escape values. SDN won't do this\nfor you as this is probably not what you want in all cases.\n\n[[list-extensions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Literal extension", "heading_level": 4, "file_order": 2, "section_index": 12, "content_hash": "7e876ea76be5009eec9cd68ff7b85b11d34d85a8a1f6ca31a03c91ddf0514bae", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:20d25cee0dc99a5863a37de4e2863d487ac139664bc605d6d118641a15e7a21f", "content": "For more than one value there are `allOf` and `anyOf` in place that would render\neither a `&` or `|` concatenated list of all values.\n\n[source,java]\n.List extensions\n----\ninterface BaseClassRepository extends Neo4jRepository<Inheritance.BaseClass, Long> {\n\n @Query(\"MATCH (n:`:#{allOf(#label)}`) RETURN n\")\n List<Inheritance.BaseClass> findByLabels(List<String> labels);\n\n @Query(\"MATCH (n:`:#{anyOf(#label)}`) RETURN n\")\n List<Inheritance.BaseClass> findByLabels(List<String> labels);\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "List extensions", "heading_level": 4, "file_order": 2, "section_index": 13, "content_hash": "20d25cee0dc99a5863a37de4e2863d487ac139664bc605d6d118641a15e7a21f", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:c30d01ae05048aaeb7fd11e94316727c218a1b9a4cc4a57e6e550e588baa2be9", "content": "You already know how to map a Node to a domain object:\n\n[source,java]\n.A Node with many labels\n----\n@Node(primaryLabel = \"Bike\", labels = {\"Gravel\", \"Easy Trail\"})\npublic class BikeNode {\n @Id String id;\n\n String name;\n}\n----\n\nThis node has a couple of labels, and it would be rather error prone to repeat them all the time in custom queries: You might\nforget one or make a typo. We offer the following expression to mitigate this: `#{#staticLabels}`. Notice that this one does\n_not_ start with a colon! You use it on repository methods annotated with `@Query`:\n\n[source,java,indent=0,tabsize=4]\n.`#{#staticLabels}` in action\n----\npublic interface BikeRepository extends Neo4jRepository<Bike, String> {\n\n\t@Query(\"MATCH (n:#{#staticLabels}) WHERE n.id = $nameOrId OR n.name = $nameOrId RETURN n\")\n\tOptional<Bike> findByNameOrId(@Param(\"nameOrId\") String nameOrId);\n}\n----\n\nThis query will resolve to\n\n[source,cypher]\n----\nMATCH (n:`Bike`:`Gravel`:`Easy Trail`) WHERE n.id = $nameOrId OR n.name = $nameOrId RETURN n\n----\n\nNotice how we used standard parameter for the `nameOrId`: In most cases there is no need to complicate things here by\nadding a SpEL expression.\n\n[[custom-queries.propertyplaceholder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Referring to Labels", "heading_level": 3, "file_order": 2, "section_index": 14, "content_hash": "c30d01ae05048aaeb7fd11e94316727c218a1b9a4cc4a57e6e550e588baa2be9", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:d4d07bb3dc0f6ff5f5c300dceb60a997368ffef72649082be987593704224c44", "content": "Spring's property placeholders can be used in custom queries inside `${}`.\n\n[source,java,indent=0]\n[[custom-queries-with-property-placeholder-example]]\n.ARepository.java\n----\n\t@Query(\"MATCH (a:AnAggregateRoot) WHERE a.name = :${foo} RETURN a\")\n\tOptional<AnAggregateRoot> findByCustomQueryWithPropertyPlaceholder();\n----\n\nIn the example above, if the property `foo` would be set to `bar` then the `$\\{foo\\}` block would be resolved to `bar`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/custom-queries.adoc", "title": "custom-queries", "heading": "Property Placeholder resolution in custom queries", "heading_level": 3, "file_order": 2, "section_index": 15, "content_hash": "d4d07bb3dc0f6ff5f5c300dceb60a997368ffef72649082be987593704224c44", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/custom-queries.adoc"}}
{"id": "sha256:490e9e11df27a3bff4b48704064d44e3e4a922861dc4c44648b1619c20935f06", "content": "[[sdn-appendix]]\n[appendix]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 3, "section_index": 0, "content_hash": "490e9e11df27a3bff4b48704064d44e3e4a922861dc4c44648b1619c20935f06", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/index.adoc"}}
{"id": "sha256:9e9301c1030993f2a81e1a7da584f4ea6e515affcfb4904809210716a7435a9b", "content": "[[logging]]\n\nSpring Data Neo4j provides multiple loggers for https://neo4j.com/docs/status-codes/current/notifications/all-notifications/[Cypher notifications], starting with version 7.1.5.\nThe logger `org.springframework.data.neo4j.cypher` includes all statements that were invoked by Spring Data Neo4j and all notifications sent from the server.\nTo exclude or elevate some categories, the following loggers are in place:\n\n* `org.springframework.data.neo4j.cypher.performance`\n* `org.springframework.data.neo4j.cypher.hint`\n* `org.springframework.data.neo4j.cypher.unrecognized`\n* `org.springframework.data.neo4j.cypher.unsupported`\n* `org.springframework.data.neo4j.cypher.deprecation`\n* `org.springframework.data.neo4j.cypher.generic`\n* `org.springframework.data.neo4j.cypher.security`\n* `org.springframework.data.neo4j.cypher.topology`", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/logging.adoc", "title": "logging", "heading": "logging", "heading_level": 1, "file_order": 4, "section_index": 0, "content_hash": "9e9301c1030993f2a81e1a7da584f4ea6e515affcfb4904809210716a7435a9b", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/logging.adoc"}}
{"id": "sha256:f2cc945143390cc7be4f4839ef58d5254600bef0d73fa0a02b73dcd85ba89a49", "content": "[[Migrating]]\n\n[[migrating.known-issues]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/migrating.adoc", "title": "migrating", "heading": "migrating", "heading_level": 1, "file_order": 5, "section_index": 0, "content_hash": "f2cc945143390cc7be4f4839ef58d5254600bef0d73fa0a02b73dcd85ba89a49", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/migrating.adoc"}}
{"id": "sha256:b2172ac232c3e709b5d91fb55b1330e6ac41b9d57a7c2157985c28ce23c10a4b", "content": "SDN+OGM has had quite a history over the years and we understand that migrating big application systems is neither fun nor something that provides immediate profit.\nThe main issues we observed when migrating from older versions of Spring Data Neo4j to newer ones are roughly in order the following:\n\nHaving skipped more than one major upgrade::\nWhile Neo4j-OGM can be used stand-alone, Spring Data Neo4j cannot.\nIt depends to large extend on the Spring Data and therefore, on the Spring Framework itself, which eventually affects large parts of your application.\nDepending on how the application has been structured, that is, how much the any of the framework part leaked into your business code, the more you have to adapt your application.\nIt gets worse when you have more than one Spring Data module in your application, if you accessed a relational database in the same service layer as your graph database.\nUpdating two object mapping frameworks is not fun.\nRelying on an embedded database configured through Spring Data itself::\nThe embedded database in a SDN+OGM project is configured by Neo4j-OGM.\nSay you want to upgrade from Neo4j 3.0 to 3.5, you can't without upgrading your whole application.\nWhy is that?\nAs you chose to embed a database into your application, you tied yourself into the modules that configure this embedded database.\nTo have another, embedded database version, you have to upgrade the module that configured it, because the old one does not support the new database.\nAs there is always a Spring Data version corresponding to Neo4j-OGM, you would have to upgrade that as well.\nSpring Data however depends on Spring Framework and then the arguments from the first bullet apply.\nBeing unsure about which building blocks to include::\nIt's not easy to get the terms right.\nWe wrote the building blocks of an SDN+OGM setting https://michael-simons.github.io/neo4j-examples-and-tips/what_are_the_building_blocks_of_sdn_and_ogm.html[here].\nIt may be so that all of them have been added by coincidence and you're dealing with a lot of conflicting dependencies.\n\nTIP: Backed by those observations, we recommend to make sure you're using only the Bolt or http transport in your current application before switching from SDN+OGM to SDN.\nThus, your application and the access layer of your application is to a large extent independent of the database's version.\nFrom that state, consider moving from SDN+OGM to SDN.\n\n[[migrating.preparation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/migrating.adoc", "title": "migrating", "heading": "Known issues with past SDN+OGM migrations", "heading_level": 2, "file_order": 5, "section_index": 1, "content_hash": "b2172ac232c3e709b5d91fb55b1330e6ac41b9d57a7c2157985c28ce23c10a4b", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/migrating.adoc"}}
{"id": "sha256:5392af47bee6f743fa0cd5185670c806ff59b0a02ef95b848d4601d8400ec556", "content": "NOTE: The _Lovelace_ release train corresponds to SDN 5.1.x and OGM 3.1.x, while the _Moore_ is SDN 5.2.x and OGM 3.2.x.\n\nFirst, you must make sure that your application runs against Neo4j in server mode over the Bolt protocol, which means work in two of three cases:\n\n[[migrating.embedded]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/migrating.adoc", "title": "migrating", "heading": "Prepare the migration from SDN+OGM Lovelace or SDN+OGM Moore to SDN", "heading_level": 2, "file_order": 5, "section_index": 2, "content_hash": "5392af47bee6f743fa0cd5185670c806ff59b0a02ef95b848d4601d8400ec556", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/migrating.adoc"}}
{"id": "sha256:0e65168a755fcf36ab137d54f5210d46e3c201aa3c9c136f215947af6424a8bc", "content": "You have added `org.neo4j:neo4j-ogm-embedded-driver` and `org.neo4j:neo4j` to you project and starting the database via OGM facilities.\nThis is no longer supported and you have to set up a standard Neo4j server (both standalone and cluster are supported).\n\nThe above dependencies have to be removed.\n\nMigrating from the embedded solution is probably the toughest migration, as you need to set up a server, too.\nIt is however the one that gives you much value in itself:\nIn the future, you will be able to upgrade the database itself without having to consider your application framework, and your data access framework as well.\n\n[[migrating.http]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/migrating.adoc", "title": "migrating", "heading": "You're on embedded", "heading_level": 3, "file_order": 5, "section_index": 3, "content_hash": "0e65168a755fcf36ab137d54f5210d46e3c201aa3c9c136f215947af6424a8bc", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/migrating.adoc"}}
{"id": "sha256:d7b0c829e12923434a51e3510ea474dd248173cec78fd0532095acb5ba790107", "content": "You have added `org.neo4j:neo4j-ogm-http-driver` and configured an url like `http://user:password@localhost:7474`.\nThe dependency has to be replaced with `org.neo4j:neo4j-ogm-bolt-driver` and you need to configure a Bolt url like `bolt://localhost:7687` or use the new `neo4j://` scheme, which takes care of routing, too.\n\n[[migrating.bolt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/migrating.adoc", "title": "migrating", "heading": "You're using the HTTP transport", "heading_level": 3, "file_order": 5, "section_index": 4, "content_hash": "d7b0c829e12923434a51e3510ea474dd248173cec78fd0532095acb5ba790107", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/migrating.adoc"}}
{"id": "sha256:717bd383a54f8df9bbece969424714375782de935a2f554078089e14b03be60f", "content": "A default SDN+OGM project uses `org.neo4j:neo4j-ogm-bolt-driver` and thus indirectly, the pure Java Driver.\nYou can keep your existing URL.\n\n[[migrating.migrating]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/migrating.adoc", "title": "migrating", "heading": "You're already using Bolt indirectly", "heading_level": 3, "file_order": 5, "section_index": 5, "content_hash": "717bd383a54f8df9bbece969424714375782de935a2f554078089e14b03be60f", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/migrating.adoc"}}
{"id": "sha256:3d23eeb39c0d336d96f58df45f3663564a26c0ff06b4ac90d555831fa25970f1", "content": "Once you have made sure, that your SDN+OGM application works over Bolt as expected, you can start migrating to SDN.\n\n* Remove all `org.neo4j:neo4j-ogm-*` dependencies\n* Configuring SDN through a `org.neo4j.ogm.config.Configuration` bean is not supported, instead of, all configuration of the driver goes through our new Java driver starter.\nYou will especially have to adapt the properties for the url and authentication, see <<migrating-auth>>\n\nTIP: You cannot configure SDN through XML.\nIn case you did this with your SDN+OGM application, make sure you learn about annotation-driven or functional configuration of Spring Applications.\nThe easiest choice these days is Spring Boot.\nWith our starter in place, all the necessary bits apart from the connection URL and the authentication is already configured for you.\n\n[source,properties]\n[[migrating-auth]]\n.Old and new properties compared\n----\n# Old\nspring.data.neo4j.embedded.enabled=false # No longer supported\nspring.data.neo4j.uri=bolt://localhost:7687\nspring.data.neo4j.username=neo4j\nspring.data.neo4j.password=secret\n\n# New\nspring.neo4j.uri=bolt://localhost:7687\nspring.neo4j.authentication.username=neo4j\nspring.neo4j.authentication.password=secret\n----\n\nWARNING: Those new properties might change in the future again when SDN and the driver eventually fully replace the old setup.\n\nAnd finally, add the new dependency, see xref:getting-started.adoc[Getting started] for both Gradle and Maven.\n\nYou're then ready to replace annotations:\n\n[cols=\"2*\",options=\"header\"]\n|===\n\n|Old\n|New\n\n|`org.neo4j.ogm.annotation.NodeEntity`\n|`org.springframework.data.neo4j.core.schema.Node`\n\n|`org.neo4j.ogm.annotation.GeneratedValue`\n|`org.springframework.data.neo4j.core.schema.GeneratedValue`\n\n|`org.neo4j.ogm.annotation.Id`\n|`org.springframework.data.neo4j.core.schema.Id`\n\n|`org.neo4j.ogm.annotation.Property`\n|`org.springframework.data.neo4j.core.schema.Property`\n\n|`org.neo4j.ogm.annotation.Relationship`\n|`org.springframework.data.neo4j.core.schema.Relationship`\n\n|`org.springframework.data.neo4j.annotation.EnableBookmarkManagement`\n|No replacement, not needed\n\n|`org.springframework.data.neo4j.annotation.UseBookmark`\n|No replacement, not needed\n\n|`org.springframework.data.neo4j.annotation.QueryResult`\n|Use xref:repositories/projections.adoc[projections]; arbitrary result mapping not supported anymore\n\n|===\n\nNOTE: Several Neo4j-OGM annotations have not yet a corresponding annotation in SDN, some will never have.\nWe will add to the list above as we support additional features.\n\n[[migrating.bookmarks]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/migrating.adoc", "title": "migrating", "heading": "Migrating", "heading_level": 2, "file_order": 5, "section_index": 6, "content_hash": "3d23eeb39c0d336d96f58df45f3663564a26c0ff06b4ac90d555831fa25970f1", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/migrating.adoc"}}
{"id": "sha256:68e1e9bb0f7dcaceeebb309f0ada36e6b2884ff91db482f1f680a420143e7d2c", "content": "Both `@EnableBookmarkManagement` and `@UseBookmark` as well as the `org.springframework.data.neo4j.bookmark.BookmarkManager`\ninterface and its only implementation `org.springframework.data.neo4j.bookmark.CaffeineBookmarkManager` are gone and are not needed anymore.\n\nSDN uses bookmarks for all transactions, without configuration.\nYou can remove the bean declaration of `CaffeineBookmarkManager` as well as the dependency to `com.github.ben-manes.caffeine:caffeine`.\n\nIf you absolutely must, you can disable the automatic bookmark management by following xref:faq.adoc#faq.bookmarks.noop[these instructions].\n\n[[migrating.autoindex]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/migrating.adoc", "title": "migrating", "heading": "Bookmark management", "heading_level": 3, "file_order": 5, "section_index": 7, "content_hash": "68e1e9bb0f7dcaceeebb309f0ada36e6b2884ff91db482f1f680a420143e7d2c", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/migrating.adoc"}}
{"id": "sha256:e4bb5d758f4680c4f933542725c1d28436b9f7184ba8008d4e2e6e281d56d716", "content": "SDN 5.3 and prior provided the \"Automatic index manager\" from Neo4j-OGM.\n\n`@Index`, `@CompositeIndex` and `@Required` have been removed without replacement.\nWhy?\nWe think that creating the schema - even for a schemaless database - is not part of the domain modelling.\nYou could argue that an SDN model is the schema, but than we would answer that we even prefer a https://en.wikipedia.org/wiki/Command–query_separation[Command-query separation],\nmeaning that we would rather define separate read and write models.\nThose come in very handy for writing \"boring\" things and reading graph-shaped answers.\n\nApart from that, some of those annotations respectively their values are tied to specific Neo4j editions or versions, which makes them\nhard to maintain.\n\nThe best argument however is going to production: While all tools that generate a schema are indeed helpful during development, even more so with databases that enforces a strict scheme,\nthey tend to be not so nice in production: How do you handle different versions of your application running at the same time?\nVersion A asserting the indexes that have been created by a newer version B?\n\nWe think it's better to take control about this upfront and recommend using controlled database migrations, based on a tool like https://www.liquigraph.org[Liquigraph] or https://github.com/michael-simons/neo4j-migrations[Neo4j migrations].\nThe latter has been seen in use with SDN inside the JHipster project.\nBoth projects have in common that they store the current version of the schema within the database and make sure that a schema matches expectations before things are being updated.\n\nMigrating off from previous Neo4j-OGM annotations affects `@Index`, `@CompositeIndex` and `@Required` and an example for those is given here in <<indexed.class>>:\n\n[[indexed.class]]\n[source,java]\n.A class making use of Neo4j-OGM automatic index manager\n----\nimport org.neo4j.ogm.annotation.CompositeIndex;\nimport org.neo4j.ogm.annotation.GeneratedValue;\nimport org.neo4j.ogm.annotation.Id;\nimport org.neo4j.ogm.annotation.Index;\nimport org.neo4j.ogm.annotation.Required;\n\n@CompositeIndex(properties = {\"tagline\", \"released\"})\npublic class Movie {\n\n @Id @GeneratedValue Long id;\n\n @Index(unique = true)\n private String title;\n\n private String description;\n\n private String tagline;\n\n @Required\n private Integer released;\n}\n----\n\nIt's annotations are equivalent to the following scheme in Cypher (as of Neo4j 4.2):\n\n[source,cypher]\n.Example Cypher based migration\n----\nCREATE CONSTRAINT movies_unique_title ON (m:Movie) ASSERT m.title IS UNIQUE;\nCREATE CONSTRAINT movies_released_exists ON (m:Movie) ASSERT EXISTS (m.released);\nCREATE INDEX movies_tagline_released_idx FOR (m:Movie) ON (m.tagline, m.released);\n----\n\nUsing `@Index` without `unique = true` is equivalent to `CREATE INDEX movie_title_index FOR (m:Movie) ON (m.title)`.\nNote that a unique index already implies an index.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/migrating.adoc", "title": "migrating", "heading": "Automatic creation of constraints and indexes", "heading_level": 3, "file_order": 5, "section_index": 8, "content_hash": "e4bb5d758f4680c4f933542725c1d28436b9f7184ba8008d4e2e6e281d56d716", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/migrating.adoc"}}
{"id": "sha256:d3c45933c605be18f602c640a2bb005294c7dcb570525a6493c75a7400e2f814", "content": "[[neo4j-client]]\n\nSpring Data Neo4j comes with a Neo4j Client, providing a thin layer on top of Neo4j's Java driver.\n\nWhile the https://github.com/neo4j/neo4j-java-driver[plain Java driver] is a very versatile tool providing an asynchronous API in addition to the imperative and reactive versions, it doesn't integrate with Spring application level transactions.\n\nSDN uses the driver through the concept of an idiomatic client as directly as possible.\n\nThe client has the following main goals\n\n. Integrate into Springs transaction management, for both imperative and reactive scenarios\n. Participate in JTA-Transactions if necessary\n. Provide a consistent API for both imperative and reactive scenarios\n. Don't add any mapping overhead\n\nSDN relies on all those features and uses them to fulfill its entity mapping features.\n\nHave a look at the xref:introduction-and-preface/building-blocks.adoc#sdn-building-blocks[SDN building blocks] for where both the imperative and reactive Neo4 clients are positioned in our stack.\n\nThe Neo4j Client comes in two flavors:\n\n* `org.springframework.data.neo4j.core.Neo4jClient`\n* `org.springframework.data.neo4j.core.ReactiveNeo4jClient`\n\nWhile both versions provide an API using the same vocabulary and syntax, they are not API compatible.\nBoth versions feature the same, fluent API to specify queries, bind parameters and extract results.\n\n[[neo4j-client.imperative.reactive]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/neo4j-client.adoc", "title": "neo4j-client", "heading": "neo4j-client", "heading_level": 1, "file_order": 6, "section_index": 0, "content_hash": "d3c45933c605be18f602c640a2bb005294c7dcb570525a6493c75a7400e2f814", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/neo4j-client.adoc"}}
{"id": "sha256:51c035238db1e702d5cb543f59a8142d2c52d8b62095e6b26df29254d93031ae", "content": "Interactions with a Neo4j Client usually ends with a call to\n\n* `fetch().one()`\n* `fetch().first()`\n* `fetch().all()`\n* `run()`\n\nThe imperative version will interact at this moment with the database and get the requested results or summary, wrapped in an `Optional<>` or a `Collection`.\n\nThe reactive version will in contrast return a publisher of the requested type.\nInteraction with the database and retrieval of the results will not happen until the publisher is subscribed to.\nThe publisher can only be subscribed once.\n\n[[neo4j-client.instance]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/neo4j-client.adoc", "title": "neo4j-client", "heading": "Imperative or reactive?", "heading_level": 2, "file_order": 6, "section_index": 1, "content_hash": "51c035238db1e702d5cb543f59a8142d2c52d8b62095e6b26df29254d93031ae", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/neo4j-client.adoc"}}
{"id": "sha256:b810d8cbef0a6ad507e4d9bf99a9e3d96bc3b33e44ce422463ecd370acac2066", "content": "As with most things in SDN, both clients depend on a configured driver instance.\n\n[[neo4j-client-create-imperative-client]]\n[source,java]\n.Creating an instance of the imperative Neo4j client\n----\nimport org.neo4j.driver.AuthTokens;\nimport org.neo4j.driver.Driver;\nimport org.neo4j.driver.GraphDatabase;\n\nimport org.springframework.data.neo4j.core.Neo4jClient;\n\npublic class Demo {\n\n public static void main(String...args) {\n\n Driver driver = GraphDatabase\n .driver(\"neo4j://localhost:7687\", AuthTokens.basic(\"neo4j\", \"secret\"));\n\n Neo4jClient client = Neo4jClient.create(driver);\n }\n}\n----\n\nThe driver can only open a reactive session against a 4.0 database and will fail with an exception on any lower version.\n\n[[neo4j-client-create-reactive-client]]\n[source,java]\n.Creating an instance of the reactive Neo4j client\n----\nimport org.neo4j.driver.AuthTokens;\nimport org.neo4j.driver.Driver;\nimport org.neo4j.driver.GraphDatabase;\n\nimport org.springframework.data.neo4j.core.ReactiveNeo4jClient;\n\npublic class Demo {\n\n public static void main(String...args) {\n\n Driver driver = GraphDatabase\n .driver(\"neo4j://localhost:7687\", AuthTokens.basic(\"neo4j\", \"secret\"));\n\n ReactiveNeo4jClient client = ReactiveNeo4jClient.create(driver);\n }\n}\n----\n\nNOTE: Make sure you use the same driver instance for the client as you used for providing a `Neo4jTransactionManager` or `ReactiveNeo4jTransactionManager`\nin case you have enabled transactions.\nThe client won't be able to synchronize transactions if you use another instance of a driver.\n\nOur Spring Boot starter provide a ready to use bean of the Neo4j Client that fits the environment (imperative or reactive) and you usually don't have to configure your own instance.\n\n[[neo4j-client.usage]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/neo4j-client.adoc", "title": "neo4j-client", "heading": "Getting an instance of the client", "heading_level": 2, "file_order": 6, "section_index": 2, "content_hash": "b810d8cbef0a6ad507e4d9bf99a9e3d96bc3b33e44ce422463ecd370acac2066", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/neo4j-client.adoc"}}
{"id": "sha256:c51429bbc05fb0a07b84804260271e41f5102d7ee4d7f42d9af465dfe673d616", "content": "[[neo4j-client-selecting-the-target-database]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/neo4j-client.adoc", "title": "neo4j-client", "heading": "Usage", "heading_level": 2, "file_order": 6, "section_index": 3, "content_hash": "c51429bbc05fb0a07b84804260271e41f5102d7ee4d7f42d9af465dfe673d616", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/neo4j-client.adoc"}}
{"id": "sha256:77e00ec94ec0891f43fb3ac995a790d654704406f5805b96632891d9b33dc738", "content": "The Neo4j client is well prepared to be used with the multidatabase features of Neo4j 4.0. The client uses the default database unless you specify otherwise.\nThe fluent API of the client allows to specify the target database exactly once, after the declaration of the query to execute.\n<<neo4j-client-reactive-selecting-the-target-database>> demonstrates it with the reactive client:\n\n[[neo4j-client-reactive-selecting-the-target-database]]\n[source,java]\n.Selecting the target database\n----\nFlux<Map<String, Object>> allActors = client\n\t.query(\"MATCH (p:Person) RETURN p\")\n\t.in(\"neo4j\") // <.>\n\t.fetch()\n\t.all();\n----\n<.> Select the target database in which the query is to be executed.\n\n[[neo4j-client.specifying.queryies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/neo4j-client.adoc", "title": "neo4j-client", "heading": "Selecting the target database", "heading_level": 3, "file_order": 6, "section_index": 4, "content_hash": "77e00ec94ec0891f43fb3ac995a790d654704406f5805b96632891d9b33dc738", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/neo4j-client.adoc"}}
{"id": "sha256:b7072b5a1439d1c2352468696568d0c4d9e1c237e8290d7817fc663181bc5625", "content": "The interaction with the clients starts with a query.\nA query can be defined by a plain `String` or a `Supplier<String>`.\nThe supplier will be evaluated as late as possible and can be provided by any query builder.\n\n[[neo4j-client-specifying-queries.example]]\n[source,java]\n.Specifying a query\n----\nMono<Map<String, Object>> firstActor = client\n\t.query(() -> \"MATCH (p:Person) RETURN p\")\n\t.fetch()\n\t.first();\n----\n\n[[neo4j-client.retrieving.results]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/neo4j-client.adoc", "title": "neo4j-client", "heading": "Specifying queries", "heading_level": 3, "file_order": 6, "section_index": 5, "content_hash": "b7072b5a1439d1c2352468696568d0c4d9e1c237e8290d7817fc663181bc5625", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/neo4j-client.adoc"}}
{"id": "sha256:8235117e87b3b79efcf222c34c4e9cb51572e38dfb191f84884bff634c605587", "content": "As the previous listings shows, the interaction with the client always ends with a call to `fetch` and how many results shall be received.\nBoth reactive and imperative client offer\n\n`one()`:: Expect exactly one result from the query\n`first()`:: Expect results and return the first record\n`all()`:: Retrieve all records returned\n\nThe imperative client returns `Optional<T>` and `Collection<T>` respectively, while the reactive client returns `Mono<T>` and `Flux<T>`, the later one being executed only if subscribed to.\n\nIf you don't expect any results from your query, then use `run()` after specifying the query.\n\n[[neo4j-client-reactive-get-result-summaries]]\n[source,java]\n.Retrieving result summaries in a reactive way\n----\nMono<ResultSummary> summary = reactiveClient\n .query(\"MATCH (m:Movie) where m.title = 'Aeon Flux' DETACH DELETE m\")\n .run();\n\nsummary\n .map(ResultSummary::counters)\n .subscribe(counters ->\n System.out.println(counters.nodesDeleted() + \" nodes have been deleted\")\n ); // <.>\n----\n<.> The actual query is triggered here by subscribing to the publisher.\n\nPlease take a moment to compare both listings and understand the difference when the actual query is triggered.\n\n[[neo4j-client-imperative-get-result-summaries]]\n[source,java]\n.Retrieving result summaries in an imperative way\n----\nResultSummary resultSummary = imperativeClient\n\t.query(\"MATCH (m:Movie) where m.title = 'Aeon Flux' DETACH DELETE m\")\n\t.run(); // <.>\n\nSummaryCounters counters = resultSummary.counters();\nSystem.out.println(counters.nodesDeleted() + \" nodes have been deleted\")\n----\n<.> Here the query is immediately triggered.\n\n[[neo4j-client.mapping.parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/neo4j-client.adoc", "title": "neo4j-client", "heading": "Retrieving results", "heading_level": 3, "file_order": 6, "section_index": 6, "content_hash": "8235117e87b3b79efcf222c34c4e9cb51572e38dfb191f84884bff634c605587", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/neo4j-client.adoc"}}
{"id": "sha256:d519e4b538124be930c136c3dd8f4eb5832d5aa4072cf56346fdd7c2ca33cb10", "content": "Queries can contain named parameters (`$someName`) and the Neo4j client makes it easy to bind values to them.\n\nNOTE: The client doesn't check whether all parameters are bound or whether there are too many values.\nThat is left to the driver.\nHowever, the client prevents you from using a parameter name twice.\n\nYou can either bind simple types that the Java driver understands without conversion or complex classes.\nFor complex classes you need to provide a binder function as shown in <<neo4j-client-binder,this listing>>.\nPlease have a look at the https://neo4j.com/docs/driver-manual/current/cypher-workflow/#driver-type-mapping[drivers manual], to see which simple types are supported.\n\n[[neo4j-client-mapping-simple-types]]\n[source,java]\n.Mapping simple types\n----\nMap<String, Object> parameters = new HashMap<>();\nparameters.put(\"name\", \"Li.*\");\n\nFlux<Map<String, Object>> directorAndMovies = client\n\t.query(\n \"MATCH (p:Person) - [:DIRECTED] -> (m:Movie {title: $title}), (p) - [:WROTE] -> (om:Movie) \" +\n \"WHERE p.name =~ $name \" +\n \" AND p.born < $someDate.year \" +\n \"RETURN p, om\"\n\t)\n\t.bind(\"The Matrix\").to(\"title\") // <.>\n\t.bind(LocalDate.of(1979, 9, 21)).to(\"someDate\")\n\t.bindAll(parameters) // <.>\n\t.fetch()\n\t.all();\n----\n<.> There's a fluent API for binding simple types.\n<.> Alternatively parameters can be bound via a map of named parameters.\n\nSDN does a lot of complex mapping and it uses the same API that you can use from the client.\n\nYou can provide a `Function<T, Map<String, Object>>` for any given domain object like an owner of bicycles in <<neo4j-client-domain-example>>\nto the Neo4j Client to map those domain objects to parameters the driver can understand.\n\n[[neo4j-client-domain-example]]\n[source,java]\n.Example of a domain type\n----\npublic class Director {\n\n private final String name;\n\n private final List<Movie> movies;\n\n Director(String name, List<Movie> movies) {\n this.name = name;\n this.movies = new ArrayList<>(movies);\n }\n\n public String getName() {\n return name;\n }\n\n public List<Movie> getMovies() {\n return Collections.unmodifiableList(movies);\n }\n}\n\npublic class Movie {\n\n private final String title;\n\n public Movie(String title) {\n this.title = title;\n }\n\n public String getTitle() {\n return title;\n }\n}\n----\n\nThe mapping function has to fill in all named parameters that might occur in the query like <<neo4j-client-binder>> shows:\n\n[[neo4j-client-binder]]\n[source,java]\n.Using a mapping function for binding domain objects\n----\nDirector joseph = new Director(\"Joseph Kosinski\",\n Arrays.asList(new Movie(\"Tron Legacy\"), new Movie(\"Top Gun: Maverick\")));\n\nMono<ResultSummary> summary = client\n .query(\"\"\n + \"MERGE (p:Person {name: $name}) \"\n + \"WITH p UNWIND $movies as movie \"\n + \"MERGE (m:Movie {title: movie}) \"\n + \"MERGE (p) - [o:DIRECTED] -> (m) \"\n )\n .bind(joseph).with(director -> { // <.>\n Map<String, Object> mappedValues = new HashMap<>();\n List<String> movies = director.getMovies().stream()\n .map(Movie::getTitle).collect(Collectors.toList());\n mappedValues.put(\"name\", director.getName());\n mappedValues.put(\"movies\", movies);\n return mappedValues;\n })\n .run();\n----\n<.> The `with` method allows for specifying the binder function.\n\n[[neo4j-client.result-objects]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/neo4j-client.adoc", "title": "neo4j-client", "heading": "Mapping parameters", "heading_level": 3, "file_order": 6, "section_index": 7, "content_hash": "d519e4b538124be930c136c3dd8f4eb5832d5aa4072cf56346fdd7c2ca33cb10", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/neo4j-client.adoc"}}
{"id": "sha256:77fa7ad8bf86896837d30b11f6be445f9cf1edc2d590f80967445c9d92d63da3", "content": "Both clients return collections or publishers of maps (`Map<String, Object>`).\nThose maps correspond exactly with the records that a query might have produced.\n\nIn addition, you can plug in your own `BiFunction<TypeSystem, Record, T>` through `fetchAs` to reproduce your domain object.\n\n[[neo4j-client-reader]]\n[source,java]\n.Using a mapping function for reading domain objects\n----\nMono<Director> lily = client\n .query(\"\"\n + \" MATCH (p:Person {name: $name}) - [:DIRECTED] -> (m:Movie)\"\n + \"RETURN p, collect(m) as movies\")\n .bind(\"Lilly Wachowski\").to(\"name\")\n .fetchAs(Director.class).mappedBy((TypeSystem t, Record record) -> {\n List<Movie> movies = record.get(\"movies\")\n .asList(v -> new Movie((v.get(\"title\").asString())));\n return new Director(record.get(\"name\").asString(), movies);\n })\n .one();\n----\n\n`TypeSystem` gives access to the types the underlying Java driver used to fill the record.\n\n[[neo4j-client.result-objects.mapping-functions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/neo4j-client.adoc", "title": "neo4j-client", "heading": "Working with result objects", "heading_level": 3, "file_order": 6, "section_index": 8, "content_hash": "77fa7ad8bf86896837d30b11f6be445f9cf1edc2d590f80967445c9d92d63da3", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/neo4j-client.adoc"}}
{"id": "sha256:13a5f10f408a5dc7bb0601d13e06bc6f602d35eac933ef0bca118b913ee093b9", "content": "If you know that the result of the query will contain nodes that have entity definitions in your application,\nyou can use the injectable `MappingContext` to retrieve their mapping functions and apply them during the mapping.\n\n[[neo4j-client-reader.mapping-function]]\n[source,java]\n.Using an existing mapping function\n----\nBiFunction<TypeSystem, MapAccessor, Movie> mappingFunction = neo4jMappingContext.getRequiredMappingFunctionFor(Movie.class);\nMono<Director> lily = client\n .query(\"\"\n + \" MATCH (p:Person {name: $name}) - [:DIRECTED] -> (m:Movie)\"\n + \"RETURN p, collect(m) as movies\")\n .bind(\"Lilly Wachowski\").to(\"name\")\n .fetchAs(Director.class).mappedBy((TypeSystem t, Record record) -> {\n List<Movie> movies = record.get(\"movies\")\n .asList(movie -> mappingFunction.apply(t, movie));\n return new Director(record.get(\"name\").asString(), movies);\n })\n .one();\n----\n\n[[neo4j-client.interacting.driver.directly]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/neo4j-client.adoc", "title": "neo4j-client", "heading": "Using domain-aware mapping functions", "heading_level": 4, "file_order": 6, "section_index": 9, "content_hash": "13a5f10f408a5dc7bb0601d13e06bc6f602d35eac933ef0bca118b913ee093b9", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/neo4j-client.adoc"}}
{"id": "sha256:dc8889e33a6648b63a294e3f084241549459a0cabd75ef85fc8380ceb2669ddb", "content": "In case you don't want or don't like the opinionated \"client\" approach of the `Neo4jClient` or the `ReactiveNeo4jClient`, you can have the client delegate all interactions with the database to your code.\nThe interaction after the delegation is slightly different with the imperative and reactive versions of the client.\n\nThe imperative version takes in a `Function<StatementRunner, Optional<T>>` as a callback.\nReturning an empty optional is ok.\n\n[[neo4j-client-imperative-delegating]]\n[source,java]\n.Delegate database interaction to an imperative `StatementRunner`\n----\nOptional<Long> result = client\n .delegateTo((StatementRunner runner) -> {\n // Do as many interactions as you want\n long numberOfNodes = runner.run(\"MATCH (n) RETURN count(n) as cnt\")\n .single().get(\"cnt\").asLong();\n return Optional.of(numberOfNodes);\n })\n // .in(\"aDatabase\") // <.>\n .run();\n----\n<.> The database selection as described in <<neo4j-client-selecting-the-target-database>> is optional.\n\nThe reactive version receives a `RxStatementRunner`.\n\n[[neo4j-client-reactive-delegating]]\n[source,java]\n.Delegate database interaction to a reactive `RxStatementRunner`\n----\nMono<Integer> result = client\n .delegateTo((RxStatementRunner runner) ->\n Mono.from(runner.run(\"MATCH (n:Unused) DELETE n\").summary())\n .map(ResultSummary::counters)\n .map(SummaryCounters::nodesDeleted))\n // .in(\"aDatabase\") // <.>\n .run();\n----\n<.> Optional selection of the target database.\n\nNote that in both <<neo4j-client-imperative-delegating>> and <<neo4j-client-reactive-delegating>> the types of the runner have only been stated to provide more clarity to reader of this manual.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/neo4j-client.adoc", "title": "neo4j-client", "heading": "Interacting directly with the driver while using managed transactions", "heading_level": 3, "file_order": 6, "section_index": 10, "content_hash": "dc8889e33a6648b63a294e3f084241549459a0cabd75ef85fc8380ceb2669ddb", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/neo4j-client.adoc"}}
{"id": "sha256:dff1ada7239a2f8b232ec34f77ee9a4b6f77bf858ab75dc05414d736f175e005", "content": "[[query-creation]]\n\nThis chapter is about the technical creation of queries when using SDN's abstraction layers.\nThere will be some simplifications because we do not discuss every possible case but stick with the general idea behind it.\n\n[[query-creation.save]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/query-creation.adoc", "title": "query-creation", "heading": "query-creation", "heading_level": 1, "file_order": 7, "section_index": 0, "content_hash": "dff1ada7239a2f8b232ec34f77ee9a4b6f77bf858ab75dc05414d736f175e005", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/query-creation.adoc"}}
{"id": "sha256:bdf1f00c69d65f92659bdae9cb304e1e86866368ab8d03b5ad5eebad6d98cbde", "content": "Beside the `find/load` operations the `save` operation is one of the most used when working with data.\nA save operation call in general issues multiple statements against the database to ensure that the resulting graph model matches the given Java model.\n\n. A union statement will get created that either creates a node, if the node's identifier cannot be found, or updates the node's property if the node itself exists.\n+\n(`OPTIONAL MATCH (hlp:Person) WHERE id(hlp) = ${neo4jId} WITH hlp WHERE hlp IS NULL CREATE (n:Person) SET n = ${neo4jProperties} RETURN id(n) UNION MATCH (n) WHERE id(n) = ${neo4jId} SET n = ${neo4jProperties} RETURN id(n)`)\n\n. If the entity is *not* new all relationships of the first found type at the domain model will get removed from the database.\n+\n(`MATCH (startNode)-[rel:Has]->(:Hobby) WHERE id(startNode) = $fromId DELETE rel`)\n\n. The related entity will get created in the same way as the root entity.\n+\n(`OPTIONAL MATCH (hlp:Hobby) WHERE id(hlp) = ${neo4jId} WITH hlp WHERE hlp IS NULL CREATE (n:Hobby) SET n = ${neo4jProperties} RETURN id(n) UNION MATCH (n) WHERE id(n) = ${neo4jId} SET n = ${neo4jProperties} RETURN id(n)`)\n\n. The relationship itself will get created\n+\n(`MATCH (startNode) WHERE id(startNode) = $fromId MATCH (endNode) WHERE id(endNode) = 631 MERGE (startNode)-[:Has]->(endNode)`)\n\n. If the related entity also has relationships to other entities, the same procedure as in 2. will get started.\n\n. For the next defined relationship on the root entity start with 2. but replace _first_ with _next_.\n\nWARNING: As you can see SDN does its best to keep your graph model in sync with the Java world.\nThis is one of the reasons why we really advise you to not load, manipulate and save sub-graphs as this might cause relationships to get removed from the database.\n\n[[query-creation.save.multiple-entities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/query-creation.adoc", "title": "query-creation", "heading": "Save", "heading_level": 2, "file_order": 7, "section_index": 1, "content_hash": "bdf1f00c69d65f92659bdae9cb304e1e86866368ab8d03b5ad5eebad6d98cbde", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/query-creation.adoc"}}
{"id": "sha256:5687d1add1c672851ce215029e759515eef2906d6ab573c603cbcbc871ae7ece", "content": "The `save` operation is overloaded with the functionality for accepting multiple entities of the same type.\nIf you are working with generated id values or make use of optimistic locking, every entity will result in a separate `CREATE` call.\n\nIn other cases SDN will create a parameter list with the entity information and provide it with a `MERGE` call.\n\n`UNWIND ${neo4jEntities} AS entity MERGE (n:Person {customId: entity.${neo4jId}}) SET n = entity.{neo4jProperties} RETURN collect(n.customId) AS ${neo4jIds}`\n\nand the parameters look like\n\n`:params {{neo4jEntities}: [{{neo4jId}: 'aa', {neo4jProperties}: {name: \"PersonName\", theId: \"aa\"}}, {{neo4jId} 'bb', {neo4jProperties}: {name: \"AnotherPersonName\", theId: \"bb\"}}]}`\n\n[[query-creation.load]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/query-creation.adoc", "title": "query-creation", "heading": "Multiple entities", "heading_level": 3, "file_order": 7, "section_index": 2, "content_hash": "5687d1add1c672851ce215029e759515eef2906d6ab573c603cbcbc871ae7ece", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/query-creation.adoc"}}
{"id": "sha256:8795cf8f3373a3d2a3137b3a49e0a7d217a2648a80d50d480caa272127f20707", "content": "The `load` documentation will not only show you how the _MATCH_ part of the query looks like but also how the data gets returned.\n\nThe simplest kind of load operation is a `findById` call.\nIt will match all nodes with the label of the type you queried for and does a filter on the id value.\n\n`MATCH (n:Person) WHERE id(n) = 1364`\n\nIf there is a custom id provided SDN will use the property you have defined as the id.\n\n`MATCH (n:Person) WHERE n.customId = 'anId'`\n\nThe data to return is defined as a https://neo4j.com/docs/cypher-manual/current/syntax/maps/#cypher-map-projection[map projection].\n\n`RETURN n{.first_name, .personNumber, {neo4jInternalId}: id(n), {neo4jLabels}: labels(n)}`\n\nAs you can see there are two special fields in there: The `{neo4jInternalId}` and the `{neo4jLabels}`.\nBoth are critical when it comes to mapping the data to Java objects.\nThe value of the `{neo4jInternalId}` is either `id(n)` or the provided custom id but in the mapping process one known field to refer to has to exist.\nThe `{neo4jLabels}` ensures that all defined labels on this node can be found and mapped.\nThis is needed for situations when inheritance is used and you query not for the concrete classes or have relationships defined that only define a super-type.\n\nTalking about relationships: If you have defined relationships in your entity, they will get added to the returned map as https://neo4j.com/docs/cypher-manual/4.0/syntax/lists/#cypher-pattern-comprehension[pattern comprehensions].\nThe above return part will then look like:\n\n`RETURN n{.first_name, ..., Person_Has_Hobby: [(n)-[:Has]->(n_hobbies:Hobby)|n_hobbies{{neo4jInternalId}: id(n_hobbies), .name, {neo4jLabels}: labels(n_hobbies)}]}`\n\nThe map projection and pattern comprehension used by SDN ensures that only the properties and relationships you have defined are getting queried.\n\nIn cases where you have self-referencing nodes or creating schemas that potentially lead to cycles in the data that gets returned,\nSDN falls back to a cascading / data-driven query creation.\nStarting with an initial query that looks for the specific node and considering the conditions,\nit steps through the resulting nodes and, if their relationships are also mapped, would create further queries on the fly.\nThis query creation and execution loop will continue until no query finds new relationships or nodes.\nThe way of the creation can be seen analogue to the save/update process.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/query-creation.adoc", "title": "query-creation", "heading": "Load", "heading_level": 2, "file_order": 7, "section_index": 3, "content_hash": "8795cf8f3373a3d2a3137b3a49e0a7d217a2648a80d50d480caa272127f20707", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/query-creation.adoc"}}
{"id": "sha256:b510535013284c47ca92e24fe3db92e442d4fa0d73675277810447ade2170fc8", "content": "[[spatial-types]]\n\nSpring Data Neo4j supports the following spatial types\n\n[[spatial-types.conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/spatial-types.adoc", "title": "spatial-types", "heading": "spatial-types", "heading_level": 1, "file_order": 8, "section_index": 0, "content_hash": "b510535013284c47ca92e24fe3db92e442d4fa0d73675277810447ade2170fc8", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/spatial-types.adoc"}}
{"id": "sha256:f556cb894cdc28f3e9afedc562f5ca788f5eb80083cd54c781c57656b76b282c", "content": "* Spring Data common's `Point` (*must* be a WGS 84-2D/SRID 4326 point in the database)\n* `GeographicPoint2d` (WGS84 2D/SRID 4326)\n* `GeographicPoint3d` (WGS84 3D/SRID 4979)\n* `CartesianPoint2d` (Cartesian 2D/SRID 7203)\n* `CartesianPoint3d` (Cartesian 3D/SRID 9157)\n\n[[spatial-types.derived-finder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/spatial-types.adoc", "title": "spatial-types", "heading": "Supported conversions", "heading_level": 2, "file_order": 8, "section_index": 1, "content_hash": "f556cb894cdc28f3e9afedc562f5ca788f5eb80083cd54c781c57656b76b282c", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/spatial-types.adoc"}}
{"id": "sha256:524bfa6c41922d8b1e561877f62e31f70389aa61c3eb3710acf86e992748a74f", "content": "If you are using the native Neo4j Java driver `org.neo4j.driver.types.Point` type,\nyou can make use of the following keywords and parameter types in derived finder methods.\n\nQuery inside an area:\n\n* `findBy[...]Within(org.springframework.data.geo.Circle circle)`\n* `findBy[...]Within(org.springframework.data.geo.Box box)`\n* `findBy[...]Within(org.springframework.data.neo4j.repository.query.BoundingBox boundingBox)`\n\nNOTE: You could also use a `org.springframework.data.geo.Polygon` but would need to pass it into a `BoundingBox` by calling `BoundingBox#of`.\n\nQuery near a certain point:\n\n* `findBy[...]Near(org.neo4j.driver.types.Point point)` - returns result sorted by distance to the given point ascending\n* `findBy[...]Near(Point point, org.springframework.data.geo.Distance max)`\n* `findBy[...]Near(Point point, org.springframework.data.domain.Range<Distance> between)`\n* `findBy[...]Near(Range<Distance> between, Point p)`", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/appendix/spatial-types.adoc", "title": "spatial-types", "heading": "Derived finder keywords", "heading_level": 2, "file_order": 8, "section_index": 2, "content_hash": "524bfa6c41922d8b1e561877f62e31f70389aa61c3eb3710acf86e992748a74f", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/appendix/spatial-types.adoc"}}
{"id": "sha256:bb866265160da8d4f98e6224c4424964466f584d8b621ae7937fc20d0fa2b2ae", "content": "[[building-blocks]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/introduction-and-preface/building-blocks.adoc", "title": "building-blocks", "heading": "building-blocks", "heading_level": 1, "file_order": 9, "section_index": 0, "content_hash": "bb866265160da8d4f98e6224c4424964466f584d8b621ae7937fc20d0fa2b2ae", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/introduction-and-preface/building-blocks.adoc"}}
{"id": "sha256:767d422f20ac3b79fdbad43f5eac6a13484184fd67052849b369c54eaeca0c26", "content": "SDN consists of composable building blocks.\nIt builds on top of the https://github.com/neo4j/neo4j-java-driver[Neo4j Java Driver].\nThe instance of the Java driver is provided through Spring Boot's automatic configuration itself.\nAll configuration options of the driver are accessible in the namespace `spring.neo4j`.\nThe driver bean provides imperative, asynchronous and reactive methods to interact with Neo4j.\n\nYou can use all transaction methods the driver provides on that bean such as https://neo4j.com/docs/driver-manual/4.0/terminology/#term-auto-commit[auto-commit transactions],\nhttps://neo4j.com/docs/driver-manual/4.0/terminology/#term-transaction-function[transaction functions] and unmanaged transactions.\nBe aware that those transactions are not tight to an ongoing Spring transaction.\n\nIntegration with Spring Data and Spring's platform or reactive transaction manager starts at the xref:appendix/neo4j-client.adoc#neo4j-client[Neo4j Client].\nThe client is part of SDN is configured through a separate starter, `{artifactIdStarter}`.\nThe configuration namespace of that starter is `spring.data.neo4j`.\n\nThe client is mapping agnostic.\nIt doesn't know about your domain classes, and you are responsible for mapping a result to an object suiting your needs.\n\nThe next higher level of abstraction is the Neo4j Template.\nIt is aware of your domain, and you can use it to query arbitrary domain objects.\nThe template comes in handy in scenarios with a large number of domain classes or custom queries for which you don't want to create an additional repository abstraction each.\n\nThe highest level of abstraction is a Spring Data repository.\n\nAll abstractions of SDN come in both imperative and reactive fashions.\nIt is not recommended mixing both programming styles in the same application.\nThe reactive infrastructure requires a Neo4j 4.0+ database.\n\n[[sdn-building-blocks]]\n.SDN building blocks\nimage::image$sdn-buildingblocks.png[]\n\nThe template mechanism is similar to the templates of others stores.\nFind some more information about it in xref:faq.adoc#template-support[our FAQ].\nThe Neo4j Client as such is unique to SDN.\nYou will find its documentation in the xref:appendix/neo4j-client.adoc#neo4j-client[appendix].\n\n[[sdn-packages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/introduction-and-preface/building-blocks.adoc", "title": "building-blocks", "heading": "Overview", "heading_level": 2, "file_order": 9, "section_index": 1, "content_hash": "767d422f20ac3b79fdbad43f5eac6a13484184fd67052849b369c54eaeca0c26", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/introduction-and-preface/building-blocks.adoc"}}
{"id": "sha256:360cf0419a5c7be0e88e4205ab9a217f47667546ba22043019e5bb4d9b110ca7", "content": "[%header,cols=2*]\n|===\n|Package\n|Description\n\n|`org.springframework.data.neo4j.config`\n|\ninclude::example$config/package-info.java[tags=intent,indent=0]\n\n|`org.springframework.data.neo4j.core`\n|\ninclude::example$core/package-info.java[tags=intent,indent=0]\n\n|`org.springframework.data.neo4j.core.convert`\n|\ninclude::example$core/convert/package-info.java[tags=intent,indent=0]\n\n|`org.springframework.data.neo4j.core.support`\n|\ninclude::example$core/support/package-info.java[tags=intent,indent=0]\n\n|`org.springframework.data.neo4j.core.transaction`\n|\ninclude::example$core/transaction/package-info.java[tags=intent,indent=0]\n\n|`org.springframework.data.neo4j.repository`\n|\ninclude::example$repository/package-info.java[tags=intent,indent=0]\n\n|`org.springframework.data.neo4j.repository.config`\n|\ninclude::example$repository/config/package-info.java[tags=intent,indent=0]\n\n|`org.springframework.data.neo4j.repository.support`\n|\ninclude::example$repository/support/package-info.java[tags=intent,indent=0]\n\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/introduction-and-preface/building-blocks.adoc", "title": "building-blocks", "heading": "On the package level", "heading_level": 2, "file_order": 9, "section_index": 2, "content_hash": "360cf0419a5c7be0e88e4205ab9a217f47667546ba22043019e5bb4d9b110ca7", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/introduction-and-preface/building-blocks.adoc"}}
{"id": "sha256:c8933b2b456b8ab6f6a8b0842d87f04dbe533e66870a6e5d95c2d8746191d8d6", "content": "[[introduction]]\n\nThis documentation tries to bridge between a broad spectrum of possible users:\n\n* People new to all the Spring ecosystem, including Spring Framework, Spring Data, the concrete module (in this case Spring Data Neo4j)\nand Neo4j.\n* Experienced Neo4j developers that are new to Spring Data and want to make best use of their Neo4j knowledge but are unfamiliar\nwith declarative transactions for example and how to incorporate the latter with Neo4j cluster requirements.\n* Experienced Spring Data developers who are new to this specific module and Neo4j and need to learn how the building blocks\ninteract together. While the programming paradigm of this module is very much in line with Spring Data JDBC, Mongo and others,\nthe query language (Cypher), transactional and clustering behaviour is different and can't be abstracted away.\n\nHere's how we address those different needs:\n\nA lot of Neo4j specific questions can be found in the xref:faq.adoc#faq[Frequently Asked Questions]. These questions are\nparticular relevant for people who well aware of Neo4j specific requirements and want to know how to address them\nwith Spring Data Neo4j.\n\nIf you are already familiar with the core concepts of Spring Data, head straight to xref:getting-started.adoc#getting-started[getting-started].\nThis chapter will walk you through different options of configuring an application to connect to a Neo4j instance and how to model your domain.\n\nIn most cases, you will need a domain.\nGo to xref:object-mapping/metadata-based-mapping.adoc#mapping.annotations[mapping] to learn about how to map nodes and relationships to your domain model.\n\nAfter that, you will need some means to query the domain.\nChoices are Neo4j repositories, the Neo4j Template or on a lower level, the Neo4j Client.\nAll of them are available in a reactive fashion as well.\nApart from the paging mechanism, all the features of standard repositories are available in the reactive variant.\n\nIf you come from older versions of Spring Data Neo4j - which are usually abbreviated SDN+OGM or SDN5 -\nyou will most likely be interested in the xref:introduction-and-preface/preface-sdn.adoc#preface.sdn[introduction to SDN] and especially in the relationship\nxref:faq.adoc#faq.sdn-related-to-ogm[between SDN+OGM and the current SDN]. In the same chapter, you will find out about the\nxref:introduction-and-preface/building-blocks.adoc#building-blocks[building blocks] of SDN.\n\nTo learn more about the general concepts of repositories, head over to xref:repositories.adoc#repositories[repositories].\n\nYou can of course read on, continuing with the preface, and a gentle getting started guide.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/introduction-and-preface/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 10, "section_index": 0, "content_hash": "c8933b2b456b8ab6f6a8b0842d87f04dbe533e66870a6e5d95c2d8746191d8d6", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/introduction-and-preface/index.adoc"}}
{"id": "sha256:cafef482a57968884ccdd2ce55116f5a28f18ecb6c1cb1b039157455a68f0b76", "content": "[[new-and-noteworthy]]\n\n* https://github.com/spring-projects/spring-data-commons/wiki/Spring-Data-2023.1-(Vaughan)-Release-Notes#spring-data-neo4j---72[Release notes for Spring Data Neo4j version 7.2]\n* https://github.com/spring-projects/spring-data-commons/wiki/Spring-Data-2023.0-(Ullman)-Release-Notes#spring-data-neo4j---71[Release notes for Spring Data Neo4j version 7.1]\n* https://github.com/spring-projects/spring-data-commons/wiki/Spring-Data-2022.0-(Turing)-Release-Notes#spring-data-neo4j--70[Release notes for Spring Data Neo4j version 7.0]\n* https://github.com/spring-projects/spring-data-commons/wiki/Spring-Data-2021.2-(Raj)-Release-Notes#spring-data-neo4j---63[Release notes for Spring Data Neo4j version 6.3]\n* https://github.com/spring-projects/spring-data-commons/wiki/Spring-Data-2021.1-(Q)-Release-Notes#spring-data-neo4j---62[Release notes for Spring Data Neo4j version 6.2]\n\nFor more detailed and technical information, please refer to the https://github.com/spring-projects/spring-data-neo4j/releases[change log].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/introduction-and-preface/new-and-noteworthy.adoc", "title": "new-and-noteworthy", "heading": "new-and-noteworthy", "heading_level": 1, "file_order": 11, "section_index": 0, "content_hash": "cafef482a57968884ccdd2ce55116f5a28f18ecb6c1cb1b039157455a68f0b76", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/introduction-and-preface/new-and-noteworthy.adoc"}}
{"id": "sha256:0132b83785b6116863a34ea60739298d99eeb5b9e4e92ecc8b4f7f7df532426b", "content": "[[preface.neo4j]]\n\nA graph database is a storage engine that specializes in storing and retrieving vast networks of information.\nIt efficiently stores data as nodes with relationships to other or even the same nodes, thus allowing high-performance retrieval and querying of those structures.\nProperties can be added to both nodes and relationships.\nNodes can be labelled by zero or more labels, relationships are always directed and named.\n\nGraph databases are well suited for storing most kinds of domain models.\nIn almost all domains, there are certain things connected to other things.\nIn most other modeling approaches, the relationships between things are reduced to a single link without identity and attributes.\nGraph databases allow to keep the rich relationships that originate from the domain equally well-represented in the database without resorting to also modeling the relationships as \"things\".\nThere is very little \"impedance mismatch\" when putting real-life domains into a graph database.\n\nhttps://neo4j.com/[Neo4j] is an open source NoSQL graph database.\nIt is a fully transactional database (ACID) that stores data structured as graphs consisting of nodes, connected by relationships.\nInspired by the structure of the real world, it allows for high query performance on complex data, while remaining intuitive and simple for the developer.\n\nThe starting point for learning about Neo4j is https://neo4j.com/[neo4j.com].\nHere is a list of useful resources:\n\n* The https://neo4j.com/docs/[Neo4j documentation] introduces Neo4j and contains links to getting started guides, reference documentation and tutorials.\n* The https://neo4j.com/sandbox/[online sandbox] provides a convenient way to interact with a Neo4j instance in combination with the online https://neo4j.com/developer/get-started/[tutorial].\n* Neo4j https://neo4j.com/developer/java/[Java Bolt Driver]\n* Several https://neo4j.com/books/[books] available for purchase and https://www.youtube.com/neo4j[videos] to watch.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/introduction-and-preface/preface-neo4j.adoc", "title": "preface-neo4j", "heading": "preface-neo4j", "heading_level": 1, "file_order": 12, "section_index": 0, "content_hash": "0132b83785b6116863a34ea60739298d99eeb5b9e4e92ecc8b4f7f7df532426b", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/introduction-and-preface/preface-neo4j.adoc"}}
{"id": "sha256:05ab899f5afde8a978a8b5362991b9db1cd92a8000a35233adf5d176236585dd", "content": "[[preface.spring-data]]\n\nSpring Data uses Spring Framework's {spring-framework-docs}/core.html[core] functionality, such as the {spring-framework-docs}/core.html#beans[IoC] container,\n{spring-framework-docs}/core.html#core-convert[type conversion system],\n{spring-framework-docs}/core.html#expressions[expression language],\n{spring-framework-docs}/integration.html#jmx[JMX integration], and portable {spring-framework-docs}/data-access.html#dao-exceptions[DAO exception hierarchy].\nWhile it is not necessary to know all the Spring APIs, understanding the concepts behind them is.\nAt a minimum, the idea behind IoC should be familiar.\n\nTo learn more about Spring, you can refer to the comprehensive documentation that explains in detail the Spring Framework.\nThere are a lot of articles, blog entries and books on the matter - take a look at the Spring Framework https://spring.io/docs[home page ] for more information.\n\nThe beauty of Spring Data is that it applies the same programming model to a variety of different stores, such as JPA, JDBC\nMongo and others. For that reason, parts of the general Spring Data documentations are included in this document, especially the\ngeneral chapter about xref:repositories.adoc#repositories[working with Spring Data repositories]. Make sure to have a look at that if you haven't\nworked with a Spring Data module in the past.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/introduction-and-preface/preface-sd.adoc", "title": "preface-sd", "heading": "preface-sd", "heading_level": 1, "file_order": 13, "section_index": 0, "content_hash": "05ab899f5afde8a978a8b5362991b9db1cd92a8000a35233adf5d176236585dd", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/introduction-and-preface/preface-sd.adoc"}}
{"id": "sha256:8a11b1c39ad9a3ce8f4facb9d51fc123158030bf96ef80898b2730598aa3ac4e", "content": "[[preface.sdn]]\n\nSpring Data Neo4j or in short SDN is the next-generation https://spring.io/projects/spring-data[Spring Data] module, created and maintained by https://neo4j.com[Neo4j, Inc.] in close collaboration with https://www.vmware.com/[VMware's] Spring Data Team.\nIt supports all officially supported releases of Neo4j, including Neo4j AuraDB.\nThe Spring Data Neo4j project applies aforementioned Spring Data concepts to the development of solutions using the Neo4j graph data store.\n\nSDN relies completely on the https://github.com/neo4j/neo4j-java-driver[Neo4j Java Driver], without introducing another \"driver\" or \"transport\" layer between the mapping framework and the driver. The Neo4j Java Driver - sometimes dubbed Bolt or the Bolt driver - is used as a protocol much like JDBC is with relational databases.\n\nSDN is an Object-Graph-Mapping (OGM) library.\nAn OGM maps nodes and relationships in the graph to objects and references in a domain model.\nObject instances are mapped to nodes while object references are mapped using relationships, or serialized to properties (e.g. references to a Date).\nJVM primitives are mapped to node or relationship properties.\nAn OGM abstracts the database and provides a convenient way to persist your domain model in the graph and query it without having to use low level drivers directly.\nIt also provides the flexibility to the developer to supply custom queries where the queries generated by SDN are insufficient.\n\nSDN is the *official successor* to prior SDN version 5, to which this documentation refers as SDN+OGM.\nSDN version 5 used a separate object mapping framework, much in the way Spring Data JPA relates to JPA.\nThat separate layer aka Neo4j-OGM (Neo4j Object Graph Mapper) is now contained in this module itself.\nSpring Data Neo4j itself is an object mapper, dedicated to be used in Spring and Spring Boot applications and in some supported Jakarta EE environments.\nIt does not require or support a separate implementation of an object mapper.\n\nNoteworthy features that differentiate the current SDN version from prior SDN+OGM are\n\n* SDN is a complete OGM on its own\n* Full support for immutable entities and thus full support for Kotlin's data classes\n* Full support for the reactive programming model in the Spring Framework itself and Spring Data\n* Neo4j client and reactive client feature, resurrecting the idea of a template over the plain driver, easing database access\n\nWe provide _repositories_ as a high-level abstraction for storing and querying documents as well as templates and clients for generic domain access or generic query execution.\nAll of them are integrated with Spring's application transactions.\n\nThe core functionality of the Neo4j support can be used directly, through either the `Neo4jClient` or the `Neo4jTemplate` or the reactive variants thereof.\nAll of them provide integration with Spring's application level transactions.\nOn a lower level, you can grab the Bolt driver instance, but than you have to manage your own transactions in these cases.\n\nNOTE: You still can use Neo4j-OGM, even in modern Spring Boot applications.\n But you *cannot* use it with SDN 6+.\n If you tried you would have two different sets of entities in two different - and unrelated - persistence context.\n Hence, if you want to stick to Neo4j-OGM 3.2.x, you would use the Java driver instantiated by Spring Boot and pass it onto a Neo4j-OGM session.\n Neo4j-OGM 3.2.x is still supported, and we recommend its use in frameworks such as Quarkus.\n In a Spring Boot application however your primary choice should be SDN.\n\nPlease make sure you read the xref:faq.adoc#faq[Frequently Asked Questions] where we address many reoccurring questions about our mapping decisions but also how interaction with Neo4j cluster instances such as https://neo4j.com/cloud/platform/aura-graph-database/[Neo4j AuraDB] and on-premise cluster deployments can be significantly improved.\n\nConcepts that are important to understand are Neo4j Bookmarks, https://medium.com/neo4j/try-and-then-retry-there-can-be-failure-30bf336383da[the potential need] for incorporating a proper retry mechanism such as https://github.com/spring-projects/spring-retry[Spring Retry] or https://github.com/resilience4j/resilience4j[Resilience4j] (we recommend the latter, as this knowledge is applicable outside Spring, too) and the importance of read-only vs write queries in the context of Neo4j cluster.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/introduction-and-preface/preface-sdn.adoc", "title": "preface-sdn", "heading": "preface-sdn", "heading_level": 1, "file_order": 14, "section_index": 0, "content_hash": "8a11b1c39ad9a3ce8f4facb9d51fc123158030bf96ef80898b2730598aa3ac4e", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/introduction-and-preface/preface-sdn.adoc"}}
{"id": "sha256:ad95f3b256bb78ccfe78e75ae64fb484ea7903b7c92429459917c657a802e940", "content": "[[mapping.id-handling]]\n\n[[mapping.id-handling.internal-id]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/mapping-ids.adoc", "title": "mapping-ids", "heading": "mapping-ids", "heading_level": 1, "file_order": 15, "section_index": 0, "content_hash": "ad95f3b256bb78ccfe78e75ae64fb484ea7903b7c92429459917c657a802e940", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/mapping-ids.adoc"}}
{"id": "sha256:dde1d5d7267b99f56924f45cd2ae1cc75fd5dce369e7a4b55c4f88d9060b5f24", "content": "The easiest way to give your domain classes a unique identifier is the combination of `@Id` and `@GeneratedValue`\non a field of type `String` or `Long` (preferable the object, not the scalar `long`, as literal `null` is the better indicator whether an instance is new or not):\n\n.Mutable MovieEntity with internal Neo4j id\n====\n[source,java]\n----\n@Node(\"Movie\")\npublic class MovieEntity {\n\n\t@Id @GeneratedValue\n\tprivate Long id;\n\n\tprivate String name;\n\n\tpublic MovieEntity(String name) {\n this.name = name;\n\t}\n}\n----\n====\n\nYou don't need to provide a setter for the field, SDN will use reflection to assign the field, but use a setter if there is one.\nIf you want to create an immutable entity with an internally generated id, you have to provide a _wither_.\n\n.Immutable MovieEntity with internal Neo4j id\n====\n[source,java]\n----\n@Node(\"Movie\")\npublic class MovieEntity {\n\n\t@Id @GeneratedValue\n\tprivate final Long id; // <.>\n\n\tprivate String name;\n\n\tpublic MovieEntity(String name) { // <.>\n this(null, name);\n\t}\n\n\tprivate MovieEntity(Long id, String name) { // <.>\n this.id = id;\n this.name = name;\n\t}\n\n\tpublic MovieEntity withId(Long id) { // <.>\n if (this.id.equals(id)) {\n return this;\n } else {\n return new MovieEntity(id, this.title);\n }\n\t}\n}\n----\n<.> Immutable final id field indicating a generated value\n<.> Public constructor, used by the application and Spring Data\n<.> Internally used constructor\n<.> This is a so-called _wither_ for the `id`-attribute.\nIt creates a new entity and set's the field accordingly, without modifying the original entity, thus making it immutable.\n====\n\nYou either have to provide a setter for the id attribute or something like a _wither_, if you want to have\n\n* Advantages: It is pretty clear that the id attribute is the surrogate business key, it takes no further effort or configuration to use it.\n* Disadvantage: It is tied to Neo4js internal database id, which is not unique to our application entity only over a database lifetime.\n* Disadvantage: It takes more effort to create an immutable entity\n\n[[mapping.id-handling.external-id]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/mapping-ids.adoc", "title": "mapping-ids", "heading": "Using the internal Neo4j id", "heading_level": 2, "file_order": 15, "section_index": 1, "content_hash": "dde1d5d7267b99f56924f45cd2ae1cc75fd5dce369e7a4b55c4f88d9060b5f24", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/mapping-ids.adoc"}}
{"id": "sha256:65235da81cbf3d694a1e69bd6cf7fb9d9f3788f10152c7dada11e34001ed85f1", "content": "The `@GeneratedValue` annotation can take a class implementing `org.springframework.data.neo4j.core.schema.IdGenerator` as parameter.\nSDN provides `InternalIdGenerator` (the default) and `UUIDStringGenerator` out of the box.\nThe latter generates new UUIDs for each entity and returns them as `java.lang.String`.\nAn application entity using that would look like this:\n\n.Mutable MovieEntity with externally generated surrogate key\n====\n[source,java]\n----\n@Node(\"Movie\")\npublic class MovieEntity {\n\n\t@Id @GeneratedValue(UUIDStringGenerator.class)\n\tprivate String id;\n\n\tprivate String name;\n}\n----\n====\n\nWe have to discuss two separate things regarding advantages and disadvantages.\nThe assignment itself and the UUID-Strategy.\nA https://en.wikipedia.org/wiki/Universally_unique_identifier[universally unique identifier] is meant to be unique for practical purposes.\nTo quote Wikipedia:\n“Thus, anyone can create a UUID and use it to identify something with near certainty that the identifier does not duplicate one that has already been, or will be, created to identify something else.” Our strategy uses Java internal UUID mechanism, employing a cryptographically strong pseudo random number generator.\nIn most cases that should work fine, but your mileage might vary.\n\nThat leaves the assignment itself:\n\n* Advantage: The application is in full control and can generate a unique key that is just unique enough for the purpose of the application.\nThe generated value will be stable and there won’t be a need to change it later on.\n* Disadvantage: The generated strategy is applied on the application side of things.\nIn those days most applications will be deployed in more than one instance to scale nicely.\nIf your strategy is prone to generate duplicates then inserts will fail as the uniqueness property of the primary key will be violated.\nSo while you don’t have to think about a unique business key in this scenario, you have to think more what to generate.\n\nYou have several options to roll out your own ID generator.\nOne is a POJO implementing a generator:\n\n.Naive sequence generator\n====\n[source,java]\n----\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.springframework.data.neo4j.core.schema.IdGenerator;\nimport org.springframework.util.StringUtils;\n\npublic class TestSequenceGenerator implements IdGenerator<String> {\n\n\tprivate final AtomicInteger sequence = new AtomicInteger(0);\n\n\t@Override\n\tpublic String generateId(String primaryLabel, Object entity) {\n return StringUtils.uncapitalize(primaryLabel) +\n \"-\" + sequence.incrementAndGet();\n\t}\n}\n----\n====\n\nAnother option is to provide an additional Spring Bean like this:\n\n.Neo4jClient based ID generator\n====\n[source,java]\n----\n@Component\nclass MyIdGenerator implements IdGenerator<String> {\n\n\tprivate final Neo4jClient neo4jClient;\n\n\tpublic MyIdGenerator(Neo4jClient neo4jClient) {\n this.neo4jClient = neo4jClient;\n\t}\n\n\t@Override\n\tpublic String generateId(String primaryLabel, Object entity) {\n return neo4jClient.query(\"YOUR CYPHER QUERY FOR THE NEXT ID\") // <.>\n .fetchAs(String.class).one().get();\n\t}\n}\n----\n<.> Use exactly the query or logic your need.\n====\n\nThe generator above would be configured as a bean reference like this:\n\n.Mutable MovieEntity using a Spring Bean as Id generator\n====\n[source,java]\n----\n@Node(\"Movie\")\npublic class MovieEntity {\n\n\t@Id @GeneratedValue(generatorRef = \"myIdGenerator\")\n\tprivate String id;\n\n\tprivate String name;\n}\n----\n====\n\n[[mapping.id-handling.business-key]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/mapping-ids.adoc", "title": "mapping-ids", "heading": "Use externally provided surrogate keys", "heading_level": 2, "file_order": 15, "section_index": 2, "content_hash": "65235da81cbf3d694a1e69bd6cf7fb9d9f3788f10152c7dada11e34001ed85f1", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/mapping-ids.adoc"}}
{"id": "sha256:6f5a912e834289784936653f3375c1f73afac248bd748beac657a58453bb68a1", "content": "We have been using a business key in the complete example's `MovieEntity` and xref:object-mapping/metadata-based-mapping.adoc#mapping.complete-example.person[`PersonEntity`].\nThe name of the person is assigned at construction time, both by your application and while being loaded through Spring Data.\n\nThis is only possible, if you find a stable, unique business key, but makes great immutable domain objects.\n\n* Advantages: Using a business or natural key as primary key is natural.\nThe entity in question is clearly identified, and it feels most of the time just right in the further modelling of your domain.\n* Disadvantages: Business keys as primary keys will be hard to update once you realise that the key you found is not as stable as you thought.\nOften it turns out that it can change, even when promised otherwise.\nApart from that, finding identifier that are truly unique for a thing is hard.\n\nPlease keep in mind that a business key is always set on the domain entity before Spring Data Neo4j processes it.\nThis means that it cannot determine if the entity was new or not (it always assumes that the entity is new),\nunless also a xref:object-mapping/metadata-based-mapping.adoc#mapping.annotations.version[`@Version` field] is provided.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/mapping-ids.adoc", "title": "mapping-ids", "heading": "Using a business key", "heading_level": 2, "file_order": 15, "section_index": 3, "content_hash": "6f5a912e834289784936653f3375c1f73afac248bd748beac657a58453bb68a1", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/mapping-ids.adoc"}}
{"id": "sha256:bcab298df5efe528a9cf6778faee06b7f5207b7aa78d540f6ba5b25894337131", "content": "[[mapping.annotations]]\n\nTo take full advantage of the object mapping functionality inside SDN, you should annotate your mapped objects with the `@Node` annotation.\nAlthough it is not necessary for the mapping framework to have this annotation (your POJOs are mapped correctly, even without any annotations), it lets the classpath scanner find and pre-process your domain objects to extract the necessary metadata.\nIf you do not use this annotation, your application takes a slight performance hit the first time you store a domain object, because the mapping framework needs to build up its internal metadata model so that it knows about the properties of your domain object and how to persist them.\n\n[[mapping.annotations.overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "metadata-based-mapping", "heading_level": 1, "file_order": 16, "section_index": 0, "content_hash": "bcab298df5efe528a9cf6778faee06b7f5207b7aa78d540f6ba5b25894337131", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:c51ab52731a2abfc77ec0f7c556cbf87c4a57f73113d502c6fbf76cc2d9072e2", "content": "[[mapping.annotations.overview.from.sdn]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "Mapping Annotation Overview", "heading_level": 2, "file_order": 16, "section_index": 1, "content_hash": "c51ab52731a2abfc77ec0f7c556cbf87c4a57f73113d502c6fbf76cc2d9072e2", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:34a46b7b98960e17852a69dd764930202dbf8714b82408a9e89cb6e6192d06d5", "content": "* `@Node`: Applied at the class level to indicate this class is a candidate for mapping to the database.\n* `@Id`: Applied at the field level to mark the field used for identity purpose.\n* `@GeneratedValue`: Applied at the field level together with `@Id` to specify how unique identifiers should be generated.\n* `@Property`: Applied at the field level to modify the mapping from attributes to properties.\n* `@CompositeProperty`: Applied at the field level on attributes of type Map that shall be read back as a composite. See xref:appendix/conversions.adoc#custom.conversions.composite-properties[Composite properties].\n* `@Relationship`: Applied at the field level to specify the details of a relationship.\n* `@DynamicLabels`: Applied at the field level to specify the source of dynamic labels.\n* `@RelationshipProperties`: Applied at the class level to indicate this class as the target for properties of a relationship.\n* `@TargetNode`: Applied on a field of a class annotated with `@RelationshipProperties` to mark the target of that relationship from the perspective of the other end.\n\nThe following annotations are used to specify conversions and ensure backwards compatibility with OGM.\n\n* `@DateLong`\n* `@DateString`\n* `@ConvertWith`\n\nSee xref:appendix/conversions.adoc#custom.conversions.attribute.specific[Conversions] for more information on that.\n\n[[mapping.annotations.overview.from.commons]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "From SDN", "heading_level": 3, "file_order": 16, "section_index": 2, "content_hash": "34a46b7b98960e17852a69dd764930202dbf8714b82408a9e89cb6e6192d06d5", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:b5972d81c18f1f3c2dff01ff5418f85517db0e66d983ae193261c4cdcf24f589", "content": "* `@org.springframework.data.annotation.Id` same as `@Id` from SDN, in fact, `@Id` is annotated with Spring Data Common's Id-annotation.\n* `@CreatedBy`: Applied at the field level to indicate the creator of a node.\n* `@CreatedDate`: Applied at the field level to indicate the creation date of a node.\n* `@LastModifiedBy`: Applied at the field level to indicate the author of the last change to a node.\n* `@LastModifiedDate`: Applied at the field level to indicate the last modification date of a node.\n* `@PersistenceCreator`: Applied at one constructor to mark it as the preferred constructor when reading entities.\n* `@Persistent`: Applied at the class level to indicate this class is a candidate for mapping to the database.\n* `@Version`: Applied at field level it is used for optimistic locking and checked for modification on save operations.\nThe initial value is zero which is bumped automatically on every update.\n* `@ReadOnlyProperty`: Applied at field level to mark a property as read only. The property will be hydrated during database reads,\nbut not be subject to writes. When used on relationships be aware that no related entity in that collection will be persisted\nif not related otherwise.\n\nHave a look at xref:auditing.adoc[] for all annotations regarding auditing support.\n\n[[mapping.annotations.node]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "From Spring Data commons", "heading_level": 3, "file_order": 16, "section_index": 3, "content_hash": "b5972d81c18f1f3c2dff01ff5418f85517db0e66d983ae193261c4cdcf24f589", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:1b1985b83fec3a4926b03a108a4a1fb1568ec46da93f377aca6f96ee3f9f34a5", "content": "The `@Node` annotation is used to mark a class as a managed domain class, subject to the classpath scanning by the mapping context.\n\nTo map an Object to nodes in the graph and vice versa, we need a label to identify the class to map to and from.\n\n`@Node` has an attribute `labels` that allows you to configure one or more labels to be used when reading and writing instances of the annotated class.\nThe `value` attribute is an alias for `labels`.\nIf you don't specify a label, then the simple class name will be used as the primary label.\nIn case you want to provide multiple labels, you could either:\n\n. Supply an array to the `labels` property.\nThe first element in the array will be considered as the primary label.\n. Supply a value for `primaryLabel` and put the additional labels in `labels`.\n\nThe primary label should always be the most concrete label that reflects your domain class.\n\nFor each instance of an annotated class that is written through a repository or through the Neo4j template, one node in the graph with at least the primary label will be written.\nVice versa, all nodes with the primary label will be mapped to the instances of the annotated class.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "The basic building block: `@Node`", "heading_level": 2, "file_order": 16, "section_index": 4, "content_hash": "1b1985b83fec3a4926b03a108a4a1fb1568ec46da93f377aca6f96ee3f9f34a5", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:ff2e8349367215ebc907481d58823fabc3b911562eaad330d7ce12115590d923", "content": "The `@Node` annotation is not inherited from super-types and interfaces.\nYou can however annotate your domain classes individually at every inheritance level.\nThis allows polymorphic queries: You can pass in base or intermediate classes and retrieve the correct, concrete instance for your nodes.\nThis is only supported for abstract bases annotated with `@Node`.\nThe labels defined on such a class will be used as additional labels together with the labels of the concrete implementations.\n\nWe also support interfaces in domain-class-hierarchies for some scenarios:\n\n.Domain model in a separate module, same primary label like the interface name\n[source,java,indent=0,tabsize=4]\n----\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\n\nimport org.springframework.data.neo4j.core.schema.GeneratedValue;\nimport org.springframework.data.neo4j.core.schema.Id;\nimport org.springframework.data.neo4j.core.schema.Node;\nimport org.springframework.data.neo4j.core.schema.Relationship;\nimport org.springframework.data.neo4j.core.schema.RelationshipId;\nimport org.springframework.data.neo4j.core.schema.RelationshipProperties;\nimport org.springframework.data.neo4j.core.schema.TargetNode;\n\npublic interface SomeInterface { // <.>\n\n\tString getName();\n\n\tSomeInterface getRelated();\n}\n\n@Node(\"SomeInterface\") // <.>\npublic static class SomeInterfaceEntity implements SomeInterface {\n\n @Id\n @GeneratedValue\n private Long id;\n\n private final String name;\n\n private SomeInterface related;\n\n public SomeInterfaceEntity(String name) {\n this.name = name;\n }\n\n @Override\n public String getName() {\n return name;\n }\n\n @Override\n public SomeInterface getRelated() {\n return related;\n }\n\n public Long getId() {\n return id;\n }\n\n public void setRelated(SomeInterface related) {\n this.related = related;\n }\n}\n----\n<.> Just the plain interface name, as you would name your domain\n<.> As we need to synchronize the primary labels, we put `@Node` on the implementing class, which\nis probably in another module. Note that the value is exactly the same as the name of the interface\nimplemented. Renaming is not possible.\n\nUsing a different primary label instead of the interface name is possible, too:\n\n.Different primary label\n[source,java,indent=0,tabsize=4]\n----\n@Node(\"PrimaryLabelWN\") // <.>\npublic interface SomeInterface2 {\n\n String getName();\n\n SomeInterface2 getRelated();\n}\n\npublic static class SomeInterfaceEntity2 implements SomeInterface {\n\n\t// Overrides omitted for brevity\n}\n----\n<.> Put the `@Node` annotation on the interface\n\nIt's also possible to use different implementations of an interface and have a polymorph domain model.\nWhen doing so, at least two labels are required: A label determining the interface and one determining the concrete class:\n\n.Multiple implementations\n[source,java,indent=0,tabsize=4]\n----\n@Node(\"SomeInterface3\") // <.>\npublic interface SomeInterface3 {\n\n String getName();\n\n SomeInterface3 getRelated();\n}\n\n@Node(\"SomeInterface3a\") // <.>\npublic static class SomeInterfaceImpl3a implements SomeInterface3 {\n\n\t// Overrides omitted for brevity\n}\n\n@Node(\"SomeInterface3b\") // <.>\npublic static class SomeInterfaceImpl3b implements SomeInterface3 {\n\n // Overrides omitted for brevity\n}\n\n@Node\npublic static class ParentModel { // <.>\n\n @Id\n @GeneratedValue\n private Long id;\n\n private SomeInterface3 related1; // <.>\n\n private SomeInterface3 related2;\n}\n----\n<.> Explicitly specifying the label that identifies the interface is required in this scenario\n<.> Which applies for the first…\n<.> and second implementation as well\n<.> This is a client or parent model, using `SomeInterface3` transparently for two relationships\n<.> No concrete type is specified\n\nThe data structure needed is shown in the following test:\n\n.Data structure needed for using multiple, different interface implementations\n[source,java,indent=0,tabsize=4]\n----\nvoid mixedImplementationsRead(@Autowired Neo4jTemplate template) {\n\n\tLong id;\n\ttry (Session session = this.driver.session(this.bookmarkCapture.createSessionConfig());\n Transaction transaction = session.beginTransaction()) {\n id = transaction\n .run(\"\"\"\n CREATE (s:ParentModel{name:'s'})\n CREATE (s)-[:RELATED_1]-> (:SomeInterface3:SomeInterface3b {name:'3b'})\n CREATE (s)-[:RELATED_2]-> (:SomeInterface3:SomeInterface3a {name:'3a'})\n RETURN id(s)\"\"\")\n .single()\n .get(0)\n .asLong();\n transaction.commit();\n\t}\n\n\tOptional<Inheritance.ParentModel> optionalParentModel = this.transactionTemplate\n .execute(tx -> template.findById(id, Inheritance.ParentModel.class));\n\n\tassertThat(optionalParentModel).hasValueSatisfying(v -> {\n assertThat(v.getName()).isEqualTo(\"s\");\n assertThat(v).extracting(Inheritance.ParentModel::getRelated1)\n .isInstanceOf(Inheritance.SomeInterfaceImpl3b.class)\n .extracting(Inheritance.SomeInterface3::getName)\n .isEqualTo(\"3b\");\n assertThat(v).extracting(Inheritance.ParentModel::getRelated2)\n .isInstanceOf(Inheritance.SomeInterfaceImpl3a.class)\n .extracting(Inheritance.SomeInterface3::getName)\n .isEqualTo(\"3a\");\n\t});\n}\n----\n\nNOTE: Interfaces cannot define an identifier field.\nAs a consequence they are not a valid entity type for repositories.\n\n[[mapping.annotations.node.dynamic.labels]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "A note on class hierarchies", "heading_level": 3, "file_order": 16, "section_index": 5, "content_hash": "ff2e8349367215ebc907481d58823fabc3b911562eaad330d7ce12115590d923", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:20a09a2a428b8506993c5b4d553bc33a4ecced1898f911fcd894085461170bf1", "content": "All labels implicitly defined through the simple class name or explicitly via the `@Node` annotation are static.\nThey cannot be changed during runtime.\nIf you need additional labels that can be manipulated during runtime, you can use `@DynamicLabels`.\n`@DynamicLabels` is an annotation on field level and marks an attribute of type `java.util.Collection<String>` (a `List` or `Set`) for example) as source of dynamic labels.\n\nIf this annotation is present, all labels present on a node and not statically mapped via `@Node` and the class names, will be collected into that collection during load.\nDuring writes, all labels of the node will be replaced with the statically defined labels plus the contents of the collection.\n\nWARNING: If you have other applications add additional labels to nodes, don't use `@DynamicLabels`.\nIf `@DynamicLabels` is present on a managed entity, the resulting set of labels will be \"the truth\" written to the database.\n\n[[mapping.annotations.id]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "Dynamic or \"runtime\" managed labels", "heading_level": 3, "file_order": 16, "section_index": 6, "content_hash": "20a09a2a428b8506993c5b4d553bc33a4ecced1898f911fcd894085461170bf1", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:90942973ee2fa7deb39264923d1cfc14412157aeb09c8da7f7363445001bf179", "content": "While `@Node` creates a mapping between a class and nodes having a specific label, we also need to make the connection between individual instances of that class (objects) and instances of the node.\n\nThis is where `@Id` comes into play.\n`@Id` marks an attribute of the class to be the unique identifier of the object.\nThat unique identifier is in an optimal world a unique business key or in other words, a natural key.\n`@Id` can be used on all attributes with a supported simple type.\n\nNatural keys are however pretty hard to find.\nPeoples names for example are seldom unique, change over time or worse, not everyone has a first and last name.\n\nWe therefore support two different kind of _surrogate keys_.\n\nOn an attribute of type `String`, `long` or `Long`, `@Id` can be used with `@GeneratedValue`.\n`Long` and `long` maps to the Neo4j internal id.\n`String` maps to the _elementId_ that is available since Neo4j 5.\nBoth are *not* a property on a node or relationship and usually not visible, to the attribute and allows SDN to retrieve individual instances of the class.\n\n`@GeneratedValue` provides the attribute `generatorClass`.\n`generatorClass` can be used to specify a class implementing `IdGenerator`.\nAn `IdGenerator` is a functional interface and its `generateId` takes the primary label and the instance to generate an Id for.\nWe support `UUIDStringGenerator` as one implementation out of the box.\n\nYou can also specify a Spring Bean from the application context on `@GeneratedValue` via `generatorRef`.\nThat bean also needs to implement `IdGenerator`, but can make use of everything in the context, including the Neo4j client or template to interact with the database.\n\nNOTE: Don't skip the important notes about ID handling in xref:object-mapping/mapping-ids.adoc#mapping.id-handling[Handling and provisioning of unique IDs]\n\n[[mapping.annotations.version]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "Identifying instances: `@Id`", "heading_level": 2, "file_order": 16, "section_index": 7, "content_hash": "90942973ee2fa7deb39264923d1cfc14412157aeb09c8da7f7363445001bf179", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:712278ba4be224e7c5679227e8b998331afe98b957aeb6f07399cbc0ad205d68", "content": "Spring Data Neo4j supports optimistic locking by using the `@Version` annotation on a `Long` typed field.\nThis attribute will get incremented automatically during updates and must not be manually modified.\n\nIf, e.g., two transactions in different threads want to modify the same object with version `x`, the first operation will get successfully persisted to the database.\nAt this moment, the version field will get incremented, so it is `x+1`.\nThe second operation will fail with a `OptimisticLockingFailureException` because it wants to modify the object with the version `x`\nthat does not exist anymore in the database.\nIn such cases the operation needs to get retried, beginning with a fresh fetch of the object with the current version from the database.\n\nThe `@Version` attribute is also mandatory if xref:object-mapping/mapping-ids.adoc#mapping.id-handling.business-key[business ids] are used.\nSpring Data Neo4j will check this field to determine if the entity is new or has already been persisted before.\n\n[[mapping.annotations.property]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "Optimistic locking: `@Version`", "heading_level": 2, "file_order": 16, "section_index": 8, "content_hash": "712278ba4be224e7c5679227e8b998331afe98b957aeb6f07399cbc0ad205d68", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:0ece1f8419a1a5ed95cd63a3c47d26da3b22110cc2def09d6dee6e9e1fa5d35a", "content": "All attributes of a `@Node`-annotated class will be persisted as properties of Neo4j nodes and relationships.\nWithout further configuration, the name of the attribute in the Java or Kotlin class will be used as Neo4j property.\n\nIf you are working with an existing Neo4j schema or just like to adapt the mapping to your needs, you will need to use `@Property`.\nThe `name` is used to specify the name of the property inside the database.\n\n[[mapping.annotations.relationship]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "Mapping properties: `@Property`", "heading_level": 2, "file_order": 16, "section_index": 9, "content_hash": "0ece1f8419a1a5ed95cd63a3c47d26da3b22110cc2def09d6dee6e9e1fa5d35a", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:405306dca39bcfec574bd53d04abeb6e76051458888829f8a80058dab8f33e93", "content": "The `@Relationship` annotation can be used on all attributes that are not a simple type.\nIt is applicable on attributes of other types annotated with `@Node` or collections and maps thereof.\n\nThe `type` or the `value` attribute allow configuration of the relationship's type, `direction` allows specifying the direction.\nThe default direction in SDN is `Relationship.Direction#OUTGOING`.\n\nWe support dynamic relationships.\nDynamic relationships are represented as a `Map<String, AnnotatedDomainClass>` or `Map<Enum, AnnotatedDomainClass>`.\nIn such a case, the type of the relationship to the other domain class is given by the maps key and must not be configured through the `@Relationship`.\n\n[[mapping.annotations.relationship.properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "Connecting nodes: `@Relationship`", "heading_level": 2, "file_order": 16, "section_index": 10, "content_hash": "405306dca39bcfec574bd53d04abeb6e76051458888829f8a80058dab8f33e93", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:f42271e1c90dc96418b2fb5f84591d25d3bf5f83c8718424591ee84e47cb83dd", "content": "Neo4j supports defining properties not only on nodes but also on relationships.\nTo express those properties in the model SDN provides `@RelationshipProperties` to be applied on a simple Java class.\nWithin the properties class there have to be exactly one field marked as `@TargetNode` to define the entity the relationship points towards.\nOr, in an `INCOMING` relationship context, is coming from.\n\nA relationship property class and its usage may look like this:\n\n.Relationship properties `Roles`\n[source,java]\n----\n@RelationshipProperties\npublic class Roles {\n\n\t@RelationshipId\n\tprivate Long id;\n\n\tprivate final List<String> roles;\n\n\t@TargetNode\n\tprivate final PersonEntity person;\n\n\tpublic Roles(PersonEntity person, List<String> roles) {\n this.person = person;\n this.roles = roles;\n\t}\n\n\tpublic List<String> getRoles() {\n return roles;\n\t}\n\n\t@Override\n\tpublic String toString() {\n return \"Roles{\" +\n \"id=\" + id +\n '}' + this.hashCode();\n\t}\n}\n----\n\nYou must define a property for the generated, internal ID (`@RelationshipId`) so that SDN can determine during save which relationships\ncan be safely overwritten without losing properties.\nIf SDN does not find a field for storing the internal node id, it will fail during startup.\n\n.Defining relationship properties for an entity\n[source,java,indent=0]\n----\n@Relationship(type = \"ACTED_IN\", direction = Direction.INCOMING)\nprivate List<Roles> actorsAndRoles = new ArrayList<>();\n----\n\n[[mapping.annotations.relationship.remarks]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "Map relationship properties", "heading_level": 3, "file_order": 16, "section_index": 11, "content_hash": "f42271e1c90dc96418b2fb5f84591d25d3bf5f83c8718424591ee84e47cb83dd", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:059e90c5c65cf21cd1375c00f3fad12162c4bef4e747017791cefacc0a14453d", "content": "In general there is no limitation of relationships / hops for creating the queries.\nSDN parses the whole reachable graph from your modelled nodes.\n\nThis said, when there is the idea of mapping a relationship bidirectional, meaning you define the relationship on both ends of your entity,\nyou might get more than what you are expecting.\n\nConsider an example where a _movie_ has _actors_, and you want to fetch a certain movie with all its actors.\nThis won't be problematical if the relationship from _movie_ to _actor_ were just unidirectional.\nIn a bidirectional scenario SDN would fetch the particular _movie_, its _actors_ but also the other movies defined for this _actor_ per definition of the relationship.\nIn the worst case, this will cascade to fetching the whole graph for a single entity.\n\n[[mapping.annotations.example]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "Relationship query remarks", "heading_level": 3, "file_order": 16, "section_index": 12, "content_hash": "059e90c5c65cf21cd1375c00f3fad12162c4bef4e747017791cefacc0a14453d", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:dadb49bcdf5ab976b0f547289e1c006797eb7e2e47edc4e5eee44e178f9c202e", "content": "Putting all those together, we can create a simple domain.\nWe use movies and people with different roles:\n\n.The `MovieEntity`\n====\n[source,java]\n----\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.data.neo4j.core.schema.Id;\nimport org.springframework.data.neo4j.core.schema.Node;\nimport org.springframework.data.neo4j.core.schema.Property;\nimport org.springframework.data.neo4j.core.schema.Relationship;\nimport org.springframework.data.neo4j.core.schema.Relationship.Direction;\n\n@Node(\"Movie\") // <.>\npublic class MovieEntity {\n\n\t@Id // <.>\n\tprivate final String title;\n\n\t@Property(\"tagline\") // <.>\n\tprivate final String description;\n\n\t@Relationship(type = \"ACTED_IN\", direction = Direction.INCOMING) // <.>\n\tprivate List<Roles> actorsAndRoles = new ArrayList<>();\n\n\n\t@Relationship(type = \"DIRECTED\", direction = Direction.INCOMING)\n\tprivate List<PersonEntity> directors = new ArrayList<>();\n\n\tpublic MovieEntity(String title, String description) { // <.>\n\t\tthis.title = title;\n\t\tthis.description = description;\n\t}\n\n\t// Getters omitted for brevity\n\n}\n----\n<.> `@Node` is used to mark this class as a managed entity.\nIt also is used to configure the Neo4j label.\nThe label defaults to the name of the class, if you're just using plain `@Node`.\n<.> Each entity has to have an id.\nWe use the movie's name as unique identifier.\n<.> This shows `@Property` as a way to use a different name for the field than for the graph property.\n<.> This configures an incoming relationship to a person.\n<.> This is the constructor to be used by your application code as well as by SDN.\n====\n\nPeople are mapped in two roles here, `actors` and `directors`.\nThe domain class is the same:\n\n[[mapping.complete-example.person]]\n.The `PersonEntity`\n====\n[source,java]\n----\nimport org.springframework.data.neo4j.core.schema.Id;\nimport org.springframework.data.neo4j.core.schema.Node;\n\n@Node(\"Person\")\npublic class PersonEntity {\n\n\t@Id\n\tprivate final String name;\n\n\tprivate final Integer born;\n\n\tpublic PersonEntity(Integer born, String name) {\n\t\tthis.born = born;\n\t\tthis.name = name;\n\t}\n\n\tpublic Integer getBorn() {\n\t\treturn this.born;\n\t}\n\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n}\n----\n====\n\nNOTE: We haven't modelled the relationship between movies and people in both direction.\nWhy is that?\nWe see the `MovieEntity` as the aggregate root, owning the relationships.\nOn the other hand, we want to be able to pull all people from the database without selecting all the movies associated with them.\nPlease consider your application's use case before you try to map every relationship in your database in every direction.\nWhile you can do this, you may end up rebuilding a graph database inside your object graph and this is not the intention of a mapping framework.\nIf you have to model your circular or bidirectional domain and don't want to fetch the whole graph,\nyou can define a fine-grained description of the data that you want to fetch by using xref:repositories/projections.adoc[projections].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc", "title": "metadata-based-mapping", "heading": "A complete example", "heading_level": 2, "file_order": 16, "section_index": 13, "content_hash": "dadb49bcdf5ab976b0f547289e1c006797eb7e2e47edc4e5eee44e178f9c202e", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/metadata-based-mapping.adoc"}}
{"id": "sha256:9b20bcdcd18e9cad3443debd5360c59a05196dec866517126836a3cbfd76b627", "content": "[[mapping.fundamentals]]\n\nThis section covers the fundamentals of Spring Data object mapping, object creation, field and property access, mutability and immutability.\n\nCore responsibility of the Spring Data object mapping is to create instances of domain objects and map the store-native data structures onto those.\nThis means we need two fundamental steps:\n\n1. Instance creation by using one of the constructors exposed.\n2. Instance population to materialize all exposed properties.\n\n[[mapping.fundamentals.object-creation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc", "title": "sdc-object-mapping", "heading": "sdc-object-mapping", "heading_level": 1, "file_order": 17, "section_index": 0, "content_hash": "9b20bcdcd18e9cad3443debd5360c59a05196dec866517126836a3cbfd76b627", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc"}}
{"id": "sha256:8828c79e908b52608188c9c7914f5e786e21f27a8dfd5a9c2a4963a261c5c345", "content": "Spring Data automatically tries to detect a persistent entity's constructor to be used to materialize objects of that type.\nThe resolution algorithm works as follows:\n\n1. If there is a no-argument constructor, it will be used.\nOther constructors will be ignored.\n2. If there is a single constructor taking arguments, it will be used.\n3. If there are multiple constructors taking arguments, the one to be used by Spring Data will have to be annotated with `@PersistenceCreator`.\n\nThe value resolution assumes constructor argument names to match the property names of the entity, i.e. the resolution will be performed as if the property was to be populated, including all customizations in mapping (different datastore column or field name etc.).\nThis also requires either parameter names information available in the class file or an `@ConstructorProperties` annotation being present on the constructor.\n\n[[mapping.fundamentals.object-creation.details]]\n.Object creation internals\n****\n\nTo avoid the overhead of reflection, Spring Data object creation uses a factory class generated at runtime by default, which will call the domain classes constructor directly.\nI.e. for this example type:\n\n[source,java]\n----\nclass Person {\n Person(String firstname, String lastname) { … }\n}\n----\n\nwe will create a factory class semantically equivalent to this one at runtime:\n\n[source,java]\n----\nclass PersonObjectInstantiator implements ObjectInstantiator {\n\n Object newInstance(Object... args) {\n return new Person((String) args[0], (String) args[1]);\n }\n}\n----\n\nThis gives us a roundabout 10% performance boost over reflection.\nFor the domain class to be eligible for such optimization, it needs to adhere to a set of constraints:\n\n- it must not be a private class\n- it must not be a non-static inner class\n- it must not be a CGLib proxy class\n- the constructor to be used by Spring Data must not be private\n\nIf any of these criteria match, Spring Data will fall back to entity instantiation via reflection.\n****\n\n[[mapping.fundamentals.property-population]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc", "title": "sdc-object-mapping", "heading": "Object creation", "heading_level": 2, "file_order": 17, "section_index": 1, "content_hash": "8828c79e908b52608188c9c7914f5e786e21f27a8dfd5a9c2a4963a261c5c345", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc"}}
{"id": "sha256:71a34e6506cb6dbf313bd59231071e9f1bcbcd67cd8f3ed8a63d52c8841f1b24", "content": "Once an instance of the entity has been created, Spring Data populates all remaining persistent properties of that class.\nUnless already populated by the entity's constructor (i.e. consumed through its constructor argument list), the identifier property will be populated first to allow the resolution of cyclic object references.\nAfter that, all non-transient properties that have not already been populated by the constructor are set on the entity instance.\nFor that we use the following algorithm:\n\n1. If the property is immutable but exposes a _wither_ method (see below), we use the _wither_ to create a new entity instance with the new property value.\n2. If property access (i.e. access through getters and setters) is defined, we are invoking the setter method.\n3. By default, we set the field value directly.\n\n[[mapping.fundamentals.property-population.details]]\n.Property population internals\n****\nSimilarly to our <<mapping.fundamentals.object-creation.details,optimizations in object construction>> we also use Spring Data runtime generated accessor classes to interact with the entity instance.\n\n[source,java]\n----\nclass Person {\n\n private final Long id;\n private String firstname;\n private @AccessType(Type.PROPERTY) String lastname;\n\n Person() {\n this.id = null;\n }\n\n Person(Long id, String firstname, String lastname) {\n // Field assignments\n }\n\n Person withId(Long id) {\n return new Person(id, this.firstname, this.lastame);\n }\n\n void setLastname(String lastname) {\n this.lastname = lastname;\n }\n}\n----\n\n.A generated Property Accessor\n====\n[source,java]\n----\nclass PersonPropertyAccessor implements PersistentPropertyAccessor {\n\n private static final MethodHandle firstname; <2>\n\n private Person person; <1>\n\n public void setProperty(PersistentProperty property, Object value) {\n\n String name = property.getName();\n\n if (\"firstname\".equals(name)) {\n firstname.invoke(person, (String) value); <2>\n } else if (\"id\".equals(name)) {\n this.person = person.withId((Long) value); <3>\n } else if (\"lastname\".equals(name)) {\n this.person.setLastname((String) value); <4>\n }\n }\n}\n----\n<.> PropertyAccessor's hold a mutable instance of the underlying object.\nThis is, to enable mutations of otherwise immutable properties.\n<.> By default, Spring Data uses field-access to read and write property values.\nAs per visibility rules of `private` fields, `MethodHandles` are used to interact with fields.\n<.> The class exposes a `withId(…)` method that's used to set the identifier, e.g. when an instance is inserted into the datastore and an identifier has been generated.\nCalling `withId(…)` creates a new `Vertex` object.\nAll subsequent mutations will take place in the new instance leaving the previous untouched.\n<.> Using property-access allows direct method invocations without using `MethodHandles`.\n====\n\nThis gives us a roundabout 25% performance boost over reflection.\nFor the domain class to be eligible for such optimization, it needs to adhere to a set of constraints:\n\n- Types must not reside in the default or under the `java` package.\n- Types and their constructors must be `public`\n- Types that are inner classes must be `static`.\n- The used Java Runtime must allow for declaring classes in the originating `ClassLoader`.\nJava 9 and newer impose certain limitations.\n\nBy default, Spring Data attempts to use generated property accessors and falls back to reflection-based ones if a limitation is detected.\n****\n\nLet's have a look at the following entity:\n\n.A sample entity\n====\n[source,java]\n----\nclass Person {\n\n private final @Id Long id; <1>\n private final String firstname, lastname; <2>\n private final LocalDate birthday;\n private final int age; <3>\n\n private String comment; <4>\n private @AccessType(Type.PROPERTY) String remarks; <5>\n\n static Person of(String firstname, String lastname, LocalDate birthday) { <6>\n\n return new Person(null, firstname, lastname, birthday,\n Period.between(birthday, LocalDate.now()).getYears());\n }\n\n Person(Long id, String firstname, String lastname, LocalDate birthday, int age) { <6>\n\n this.id = id;\n this.firstname = firstname;\n this.lastname = lastname;\n this.birthday = birthday;\n this.age = age;\n }\n\n Person withId(Long id) { <1>\n return new Person(id, this.firstname, this.lastname, this.birthday);\n }\n\n void setRemarks(String remarks) { <5>\n this.remarks = remarks;\n }\n}\n----\n====\n<.> The identifier property is final but set to `null` in the constructor.\nThe class exposes a `withId(…)` method that's used to set the identifier, e.g. when an instance is inserted into the datastore and an identifier has been generated.\nThe original `Vertex` instance stays unchanged as a new one is created.\nThe same pattern is usually applied for other properties that are store managed but might have to be changed for persistence operations.\n<.> The `firstname` and `lastname` properties are ordinary immutable properties potentially exposed through getters.\n<.> The `age` property is an immutable but derived one from the `birthday` property.\nWith the design shown, the database value will trump the defaulting as Spring Data uses the only declared constructor.\nEven if the intent is that the calculation should be preferred, it's important that this constructor also takes `age` as parameter (to potentially ignore it) as otherwise the property population step will attempt to set the age field and fail due to it being immutable and no wither being present.\n<.> The `comment` property is mutable is populated by setting its field directly.\n<.> The `remarks` properties are mutable and populated by setting the `comment` field directly or by invoking the setter method for\n<.> The class exposes a factory method and a constructor for object creation.\nThe core idea here is to use factory methods instead of additional constructors to avoid the need for constructor disambiguation through `@PersistenceCreator`.\nInstead, defaulting of properties is handled within the factory method.\n\n[[mapping.fundamentals.recommendations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc", "title": "sdc-object-mapping", "heading": "Property population", "heading_level": 2, "file_order": 17, "section_index": 2, "content_hash": "71a34e6506cb6dbf313bd59231071e9f1bcbcd67cd8f3ed8a63d52c8841f1b24", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc"}}
{"id": "sha256:a7f185243c698ff2bb096281e31b12dbf867bd0217e177b8944e7621c2a9d758", "content": "* _Try to stick to immutable objects_ --\nImmutable objects are straightforward to create as materializing an object is then a matter of calling its constructor only.\nAlso, this prevents your domain objects from being littered with setter methods that allow client code to manipulate the objects state.\nIf you need those, prefer to make them package protected so that they can only be invoked by a limited amount of co-located types.\nConstructor-only materialization is up to 30% faster than properties population.\n* _Provide an all-args constructor_ --\nEven if you cannot or don't want to model your entities as immutable values, there's still value in providing a constructor that takes all properties of the entity as arguments, including the mutable ones, as this allows the object mapping to skip the property population for optimal performance.\n* _Use factory methods instead of overloaded constructors to avoid ``@PersistenceCreator``_ --\nWith an all-argument constructor needed for optimal performance, we usually want to expose more application use case specific constructors that omit things like auto-generated identifiers etc.\nIt's an established pattern to rather use static factory methods to expose these variants of the all-args constructor.\n* _Make sure you adhere to the constraints that allow the generated instantiator and property accessor classes to be used_\n* _For identifiers to be generated, still use a final field in combination with a wither method_\n* _Use Lombok to avoid boilerplate code_ --\nAs persistence operations usually require a constructor taking all arguments, their declaration becomes a tedious repetition of boilerplate parameter to field assignments that can best be avoided by using Lombok's `@AllArgsConstructor`.\n\n[[mapping.fundamentals.recommendations.note-immutable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc", "title": "sdc-object-mapping", "heading": "General recommendations", "heading_level": 2, "file_order": 17, "section_index": 3, "content_hash": "a7f185243c698ff2bb096281e31b12dbf867bd0217e177b8944e7621c2a9d758", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc"}}
{"id": "sha256:d9ace6bd838e7f4282645e5810b003e2818cd3b831849b1dfd33de10ce5a0d7e", "content": "Although we recommend to use immutable mapping and constructs wherever possible, there are some limitations when it comes to mapping.\nGiven a bidirectional relationship where `A` has a constructor reference to `B` and `B` has a reference to `A`, or a more complex scenario.\nThis hen/egg situation is not solvable for Spring Data Neo4j.\nDuring the instantiation of `A` it eagerly needs to have a fully instantiated `B`, which on the other hand requires an instance (to be precise, the _same_ instance) of `A`.\nSDN allows such models in general, but will throw a `MappingException` at runtime if the data that gets returned from the database contains such constellation as described above.\nIn such cases or scenarios, where you cannot foresee what the data that gets returned looks like, you are better suited with a mutable field for the relationships.\n\n[[mapping.fundamentals.kotlin]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc", "title": "sdc-object-mapping", "heading": "A note on immutable mapping", "heading_level": 3, "file_order": 17, "section_index": 4, "content_hash": "d9ace6bd838e7f4282645e5810b003e2818cd3b831849b1dfd33de10ce5a0d7e", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc"}}
{"id": "sha256:b9486c8eac1bc3cfcc0dce6d31a32a4898a2e6f8a4b25d1f9839743f7d7840cf", "content": "Spring Data adapts specifics of Kotlin to allow object creation and mutation.\n\n[[mapping.fundamentals.kotlin.object-creation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc", "title": "sdc-object-mapping", "heading": "Kotlin support", "heading_level": 2, "file_order": 17, "section_index": 5, "content_hash": "b9486c8eac1bc3cfcc0dce6d31a32a4898a2e6f8a4b25d1f9839743f7d7840cf", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc"}}
{"id": "sha256:e38a4e1bf9fce0e1c09ece9287ac997868d1f913201f879fcf7cc4b1531c1944", "content": "Kotlin classes are supported to be instantiated , all classes are immutable by default and require explicit property declarations to define mutable properties.\nConsider the following `data` class `Vertex`:\n\n====\n[source,java]\n----\ndata class Person(val id: String, val name: String)\n----\n====\n\nThe class above compiles to a typical class with an explicit constructor.\nWe can customize this class by adding another constructor and annotate it with `@PersistenceCreator` to indicate a constructor preference:\n\n====\n[source,java]\n----\ndata class Person(var id: String, val name: String) {\n\n @PersistenceCreator\n constructor(id: String) : this(id, \"unknown\")\n}\n----\n====\n\nKotlin supports parameter optionality by allowing default values to be used if a parameter is not provided.\nWhen Spring Data detects a constructor with parameter defaulting, then it leaves these parameters absent if the data store does not provide a value (or simply returns `null`) so Kotlin can apply parameter defaulting.\nConsider the following class that applies parameter defaulting for `name`\n\n====\n[source,java]\n----\ndata class Person(var id: String, val name: String = \"unknown\")\n----\n====\n\nEvery time the `name` parameter is either not part of the result or its value is `null`, then the `name` defaults to `unknown`.\n\n[[mapping.fundamentals.kotlin.property-population]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc", "title": "sdc-object-mapping", "heading": "Kotlin object creation", "heading_level": 3, "file_order": 17, "section_index": 6, "content_hash": "e38a4e1bf9fce0e1c09ece9287ac997868d1f913201f879fcf7cc4b1531c1944", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc"}}
{"id": "sha256:365b49b91950d63eb3191b83ca0970364505f681acdfcbbb1b02d482cb47d99a", "content": "In Kotlin, all classes are immutable by default and require explicit property declarations to define mutable properties.\nConsider the following `data` class `Vertex`:\n\n====\n[source,java]\n----\ndata class Person(val id: String, val name: String)\n----\n====\n\nThis class is effectively immutable.\nIt allows creating new instances as Kotlin generates a `copy(…)` method that creates new object instances copying all property values from the existing object and applying property values provided as arguments to the method.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc", "title": "sdc-object-mapping", "heading": "Property population of Kotlin data classes", "heading_level": 3, "file_order": 17, "section_index": 7, "content_hash": "365b49b91950d63eb3191b83ca0970364505f681acdfcbbb1b02d482cb47d99a", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping/sdc-object-mapping.adoc"}}
{"id": "sha256:5ae62705326b4e3494ec33d748d7b0479f136fd33b08103246f8e22b34aec7ca", "content": "[[projections.sdn]]\n\nAs stated above, projections come in two flavors: Interface and DTO based projections.\nIn Spring Data Neo4j both types of projections have a direct influence which properties and relationships are transferred\nover the wire.\nTherefore, both approaches can reduce the load on your database in case you are dealing with nodes and entities containing\nlots of properties which might not be needed in all usage scenarios in your application.\n\nFor both interface and DTO based projections, Spring Data Neo4j will use the repository's domain type for building the\nquery. All annotations on all attributes that might change the query will be taken in consideration.\nThe domain type is the type that has been defined through the repository declaration\n(Given a declaration like `interface TestRepository extends CrudRepository<TestEntity, Long>` the domain type would be\n`TestEntity`).\n\nInterface based projections will always be dynamic proxies to the underlying domain type. The names of the accessors defined\non such interfaces (like `getName`) must resolve to properties (here: `name`) that are present on the projected entity.\nWhether those properties have accessors or not on the domain type is not relevant, as long as they can be accessed through\nthe common Spring Data infrastructure. The latter is already ensured, as the domain type wouldn't be a persistent entity in\nthe first place.\n\nDTO based projections are somewhat more flexible when used with custom queries. While the standard query is derived from\nthe original domain type and therefore only the properties and relationship being defined there can be used, custom queries\ncan add additional properties.\n\nThe rules are as follows: first, the properties of the domain type are used to populate the DTO. In case the DTO declares\nadditional properties - via accessors or fields - Spring Data Neo4j looks in the resulting record for matching properties.\nProperties must match exactly by name and can be of simple types (as defined in `org.springframework.data.neo4j.core.convert.Neo4jSimpleTypes`)\nor of known persistent entities. Collections of those are supported, but maps are not.\n\nThere is also an additional mechanism built into Spring Data Neo4j which allows defining loading and persisting boundaries on the entity definition level.\nRead more about this in the <<projections.sdn.aggregate-boundaries>> section.\n\n[[projections.sdn.multi-level]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/projections/sdn-projections.adoc", "title": "sdn-projections", "heading": "sdn-projections", "heading_level": 1, "file_order": 18, "section_index": 0, "content_hash": "5ae62705326b4e3494ec33d748d7b0479f136fd33b08103246f8e22b34aec7ca", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/projections/sdn-projections.adoc"}}
{"id": "sha256:5dc619c436e2f21020b6bcb690e141ccb230b098a0cc8b3fefd102e406b88df5", "content": "Spring Data Neo4j also supports multi-level projections.\n\n[source,java]\n.Example of multi-level projection\n----\ninterface ProjectionWithNestedProjection {\n\n String getName();\n\n List<Subprojection1> getLevel1();\n\n interface Subprojection1 {\n String getName();\n List<Subprojection2> getLevel2();\n }\n\n interface Subprojection2 {\n String getName();\n }\n}\n----\n\nEven though it is possible to model cyclic projections or point towards entities that will create a cycle,\nthe projection logic will not follow those cycles but only create cycle-free queries.\n\nMulti-level projections are bounded to the entities they should project.\n`RelationshipProperties` fall into the category of entities in this case and needs to get respected if projections get applied.\n\n[[projections.sdn.manipulation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/projections/sdn-projections.adoc", "title": "sdn-projections", "heading": "Multi-level projections", "heading_level": 2, "file_order": 18, "section_index": 1, "content_hash": "5dc619c436e2f21020b6bcb690e141ccb230b098a0cc8b3fefd102e406b88df5", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/projections/sdn-projections.adoc"}}
{"id": "sha256:470bb0cb3276ed92212cc9578769599ae1064a68d60a66831266c4ab6b855bac", "content": "If you have fetched the projection as a DTO, you can modify its values.\nBut in case you are using the interface-based projection, you cannot just update the interface.\nA typical pattern that can be used is to provide a method in your domain entity class that consumes the interface and creates a domain entity with the copied values from the interface.\nThis way, you can then update the entity and persist it again with the projection blueprint/mask as described in the next section.\n\n[[projections.sdn.persistence]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/projections/sdn-projections.adoc", "title": "sdn-projections", "heading": "Data manipulation of projections", "heading_level": 2, "file_order": 18, "section_index": 2, "content_hash": "470bb0cb3276ed92212cc9578769599ae1064a68d60a66831266c4ab6b855bac", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/projections/sdn-projections.adoc"}}
{"id": "sha256:ab0fbf5f85b1ce21ec08b2b6f837dcf37bdf5eb4485d76e7596f25e515aebdf9", "content": "Analogue to the retrieval of data via projections, they can also be used as a blueprint for persistence.\nThe `Neo4jTemplate` offers a fluent API to apply those projections to a save operation.\n\nYou could either save a projection for a given domain class\n\n[source,java]\n.Save projection for a given domain class\n----\nProjection projection = neo4jTemplate.save(DomainClass.class).one(projectionValue);\n----\n\nor you could save a domain object but only respect the fields defined in the projection.\n\n[source,java]\n.Save domain object with a given projection blueprint\n----\nProjection projection = neo4jTemplate.saveAs(domainObject, Projection.class);\n----\n\nIn both cases, that also are available for collection based operations, only the fields and relationships\ndefined in the projection will get updated.\n\nNOTE: To prevent deletion of data (e.g. removal of relationships),\nyou should always load at least all the data that should get persisted later.\n\n[[projections.sdn.full-example]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/projections/sdn-projections.adoc", "title": "sdn-projections", "heading": "Persistence of projections", "heading_level": 2, "file_order": 18, "section_index": 3, "content_hash": "ab0fbf5f85b1ce21ec08b2b6f837dcf37bdf5eb4485d76e7596f25e515aebdf9", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/projections/sdn-projections.adoc"}}
{"id": "sha256:1a7f1b6915325bfe03209c6f8b51f7acf846888aa838a0e861fd2ce611603236", "content": "Given the following entities, projections and the corresponding repository:\n\n[[projections.simple-entity]]\n[source,java]\n.A simple entity\n----\n@Node\nclass TestEntity {\n @Id @GeneratedValue private Long id;\n\n private String name;\n\n @Property(\"a_property\") // <.>\n private String aProperty;\n}\n----\n<.> This property has a different name in the Graph\n\n[[projections.simple-entity-extended]]\n[source,java]\n.A derived entity, inheriting from `TestEntity`\n----\n@Node\nclass ExtendedTestEntity extends TestEntity {\n\n private String otherAttribute;\n}\n----\n\n[[projections.simple-entity-interface-projected]]\n[source,java]\n.Interface projection of `TestEntity`\n----\ninterface TestEntityInterfaceProjection {\n\n String getName();\n}\n----\n\n[[projections.simple-entity-dto-projected]]\n[source,java]\n.DTO projection of `TestEntity`, including one additional attribute\n----\nclass TestEntityDTOProjection {\n\n private String name;\n\n private Long numberOfRelations; // <.>\n\n public String getName() {\n return name;\n }\n\n public void setName(String name) {\n this.name = name;\n }\n\n public Long getNumberOfRelations() {\n return numberOfRelations;\n }\n\n public void setNumberOfRelations(Long numberOfRelations) {\n this.numberOfRelations = numberOfRelations;\n }\n}\n----\n<.> This attribute doesn't exist on the projected entity\n\nA repository for `TestEntity` is shown below and it will behave as explained with the listing.\n\n[[projections.simple-entity-repository]]\n[source,java]\n.A repository for the `TestEntity`\n----\ninterface TestRepository extends CrudRepository<TestEntity, Long> { // <.>\n\n List<TestEntity> findAll(); // <.>\n\n List<ExtendedTestEntity> findAllExtendedEntities(); // <.>\n\n List<TestEntityInterfaceProjection> findAllInterfaceProjectionsBy(); // <.>\n\n List<TestEntityDTOProjection> findAllDTOProjectionsBy(); // <.>\n\n @Query(\"MATCH (t:TestEntity) - [r:RELATED_TO] -> () RETURN t, COUNT(r) AS numberOfRelations\") // <.>\n List<TestEntityDTOProjection> findAllDTOProjectionsWithCustomQuery();\n}\n----\n<.> The domain type of the repository is `TestEntity`\n<.> Methods returning one or more `TestEntity` will just return instances of it, as it matches the domain type\n<.> Methods returning one or more instances of classes that extend the domain type will just return instances\nof the extending class. The domain type of the method in question will be the extended class, which\nstill satisfies the domain type of the repository itself\n<.> This method returns an interface projection, the return type of the method is therefore different\nfrom the repository's domain type. The interface can only access properties defined in the domain type.\nThe suffix `By` is needed to make SDN not look for a property called `InterfaceProjections` in the `TestEntity`\n<.> This method returns a DTO projection. Executing it will cause SDN to issue a warning, as the DTO defines\n`numberOfRelations` as additional attribute, which is not in the contract of the domain type.\nThe annotated attribute `aProperty` in `TestEntity` will be correctly translated to `a_property` in the query.\nAs above, the return type is different from the repositories' domain type.\nThe suffix `By` is needed to make SDN not look for a property called `DTOProjections` in the `TestEntity`\n<.> This method also returns a DTO projection. However, no warning will be issued, as the query contains a fitting\nvalue for the additional attributes defined in the projection\n\nTIP: While the repository in <<projections.simple-entity-repository,the listing above>> uses a concrete return type to\ndefine the projection, another variant is the use of xref:repositories/projections.adoc#projection.dynamic[dynamic projections] as explained in the\nparts of the documentation Spring Data Neo4j shares with other Spring Data Projects. A dynamic projection can be\napplied to both closed and open interface projections as well as to class based DTO projections:\n +\n +\nThe key to a dynamic projection is to specify the desired projection type as the last parameter to a query method\nin a repository like this: `<T> Collection<T> findByName(String name, Class<T> type)`. This is a declaration that\ncould be added to the `TestRepository` above and allow for different projections retrieved by the same method, without\nto repeat a possible `@Query` annotation on several methods.\n\n[[projections.sdn.aggregate-boundaries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/projections/sdn-projections.adoc", "title": "sdn-projections", "heading": "A full example", "heading_level": 2, "file_order": 18, "section_index": 4, "content_hash": "1a7f1b6915325bfe03209c6f8b51f7acf846888aa838a0e861fd2ce611603236", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/projections/sdn-projections.adoc"}}
{"id": "sha256:aeb3ce009c7421c1742eb8eae32954543faed9d253ecc1887c726a02ba8870c1", "content": "Reflecting multiple levels of relationships by introducing multiple projections can be cumbersome.\nTo simplify this already on the entity level, it's possible to add an additional parameter `aggregateBoundary` and supply 1..n classes.\nWith this the parameterized entity will only report its `@Id` field back and SDN won't follow its relationships or fetch other properties.\n\nIt's still possible to use interface-based projections for those entities.\nThose projections can be even broader as the declared aggregate boundaries and e.g. include properties or relationships.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/projections/sdn-projections.adoc", "title": "sdn-projections", "heading": "Aggregate boundaries", "heading_level": 2, "file_order": 18, "section_index": 5, "content_hash": "aeb3ce009c7421c1742eb8eae32954543faed9d253ecc1887c726a02ba8870c1", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/projections/sdn-projections.adoc"}}
{"id": "sha256:8e9b44400b53dbc606e4a389b77e7e9d995def5d7f568ee68dc4c138fb6e3828", "content": "include::{commons}@data-commons::page$repositories/core-concepts.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/core-concepts.adoc", "title": "core-concepts", "heading": "core-concepts", "heading_level": 1, "file_order": 19, "section_index": 0, "content_hash": "8e9b44400b53dbc606e4a389b77e7e9d995def5d7f568ee68dc4c138fb6e3828", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/core-concepts.adoc"}}
{"id": "sha256:81e019ce75dee61eea59094a236a3871f4c9af62f0fcd3a5c7a87af4b30030f9", "content": "include::{commons}@data-commons::page$repositories/core-domain-events.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/core-domain-events.adoc", "title": "core-domain-events", "heading": "core-domain-events", "heading_level": 1, "file_order": 20, "section_index": 0, "content_hash": "81e019ce75dee61eea59094a236a3871f4c9af62f0fcd3a5c7a87af4b30030f9", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/core-domain-events.adoc"}}
{"id": "sha256:64aa7d024c0d4411af2a39c72ec3db2ed9b849e1a6db2f27c6bebd29fb12b71b", "content": "include::{commons}@data-commons::page$repositories/core-extensions.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/core-extensions.adoc", "title": "core-extensions", "heading": "core-extensions", "heading_level": 1, "file_order": 21, "section_index": 0, "content_hash": "64aa7d024c0d4411af2a39c72ec3db2ed9b849e1a6db2f27c6bebd29fb12b71b", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/core-extensions.adoc"}}
{"id": "sha256:bac28174cb786cac49ffd811dcd631b892f0813fc0fc9743e93def55346e1e58", "content": "include::{commons}@data-commons::page$repositories/create-instances.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/create-instances.adoc", "title": "create-instances", "heading": "create-instances", "heading_level": 1, "file_order": 22, "section_index": 0, "content_hash": "bac28174cb786cac49ffd811dcd631b892f0813fc0fc9743e93def55346e1e58", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/create-instances.adoc"}}
{"id": "sha256:bcf8fe4d0728082fd278624d23223ff29157e4fb465061471d2d50f2f401bc0d", "content": "include::{commons}@data-commons::page$repositories/custom-implementations.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/custom-implementations.adoc", "title": "custom-implementations", "heading": "custom-implementations", "heading_level": 1, "file_order": 23, "section_index": 0, "content_hash": "bcf8fe4d0728082fd278624d23223ff29157e4fb465061471d2d50f2f401bc0d", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/custom-implementations.adoc"}}
{"id": "sha256:661a93bfb9c9780b8bb205b092562b371e697955026e3abea11cc0abb0a3fc20", "content": "include::{commons}@data-commons::page$repositories/definition.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/definition.adoc", "title": "definition", "heading": "definition", "heading_level": 1, "file_order": 24, "section_index": 0, "content_hash": "661a93bfb9c9780b8bb205b092562b371e697955026e3abea11cc0abb0a3fc20", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/definition.adoc"}}
{"id": "sha256:b142a68ffd3baadcd7ab94a76e2096bd729711f18f8ebb8b3cc5651939c2be8a", "content": "include::{commons}@data-commons::page$repositories/projections.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/projections.adoc", "title": "projections", "heading": "projections", "heading_level": 1, "file_order": 25, "section_index": 0, "content_hash": "b142a68ffd3baadcd7ab94a76e2096bd729711f18f8ebb8b3cc5651939c2be8a", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/projections.adoc"}}
{"id": "sha256:7e953260056fa458d00ccd6d3916965e33c635a0e5a9c1068e6d4c915b4642be", "content": "include::{commons}@data-commons::page$repositories/query-keywords-reference.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/query-keywords-reference.adoc", "title": "query-keywords-reference", "heading": "query-keywords-reference", "heading_level": 1, "file_order": 26, "section_index": 0, "content_hash": "7e953260056fa458d00ccd6d3916965e33c635a0e5a9c1068e6d4c915b4642be", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/query-keywords-reference.adoc"}}
{"id": "sha256:2931a4be98bc609c2eb349faa7f3ea7d07742930fa4e31487a2957e5874e0633", "content": "include::{commons}@data-commons::page$repositories/query-methods-details.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/query-methods-details.adoc", "title": "query-methods-details", "heading": "query-methods-details", "heading_level": 1, "file_order": 27, "section_index": 0, "content_hash": "2931a4be98bc609c2eb349faa7f3ea7d07742930fa4e31487a2957e5874e0633", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/query-methods-details.adoc"}}
{"id": "sha256:f950986d90c18454031b34a48b4c3b833e536884117c2c735ee273921cd9f62d", "content": "include::{commons}@data-commons::page$repositories/query-methods.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/query-methods.adoc", "title": "query-methods", "heading": "query-methods", "heading_level": 1, "file_order": 28, "section_index": 0, "content_hash": "f950986d90c18454031b34a48b4c3b833e536884117c2c735ee273921cd9f62d", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/query-methods.adoc"}}
{"id": "sha256:8586bea837d1b2b190fc36059384044b5c88fe73a8012f0e6782feb992f85865", "content": "include::{commons}@data-commons::page$repositories/query-return-types-reference.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/query-return-types-reference.adoc", "title": "query-return-types-reference", "heading": "query-return-types-reference", "heading_level": 1, "file_order": 29, "section_index": 0, "content_hash": "8586bea837d1b2b190fc36059384044b5c88fe73a8012f0e6782feb992f85865", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/query-return-types-reference.adoc"}}
{"id": "sha256:7daa3d88be738064615928c5ca7f9e04ed5d0935a784f889920dd442aa9a32db", "content": "include::{commons}@data-commons::page$repositories/scrolling.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/scrolling.adoc", "title": "scrolling", "heading": "scrolling", "heading_level": 1, "file_order": 30, "section_index": 0, "content_hash": "7daa3d88be738064615928c5ca7f9e04ed5d0935a784f889920dd442aa9a32db", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/scrolling.adoc"}}
{"id": "sha256:ec69a5ab604e9d4e6a3b294c9d2cf31741dfa75ca0d8ae2f31e3f5ae105374d6", "content": "[[sdn-mixins]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/sdn-extension.adoc", "title": "sdn-extension", "heading": "sdn-extension", "heading_level": 1, "file_order": 31, "section_index": 0, "content_hash": "ec69a5ab604e9d4e6a3b294c9d2cf31741dfa75ca0d8ae2f31e3f5ae105374d6", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/sdn-extension.adoc"}}
{"id": "sha256:c3a474d00e06749255c52d31c9d014caaad88070f9c8af549b336543ccb5b80c", "content": "Spring Data Neo4j offers a couple of extensions or \"mixins\" that can be added to repositories. What is a mixin? According to\nhttps://en.wikipedia.org/wiki/Mixin[Wikipedia] mixins are a language concept that allows a programmer to inject some code\ninto a class. Mixin programming is a style of software development, in which units of functionality are created in a class\nand then mixed in with other classes.\n\nJava does not support that concept on the language level, but we do emulate it via a couple of interfaces and a runtime\nthat adds appropriate implementations and interceptors for.\n\nMixins added by default are `QueryByExampleExecutor` and `ReactiveQueryByExampleExecutor` respectively. Those interfaces are\nexplained in detail in xref:query-by-example.adoc#query-by-example[Query by Example].\n\nAdditional mixins provided are:\n\n* `QuerydslPredicateExecutor`\n* `CypherdslConditionExecutor`\n* `CypherdslStatementExecutor`\n* `ReactiveQuerydslPredicateExecutor`\n* `ReactiveCypherdslConditionExecutor`\n* `ReactiveCypherdslStatementExecutor`\n\n[[sdn-mixins.dynamic-conditions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/sdn-extension.adoc", "title": "sdn-extension", "heading": "Available extensions for Spring Data Neo4j repositories", "heading_level": 2, "file_order": 31, "section_index": 1, "content_hash": "c3a474d00e06749255c52d31c9d014caaad88070f9c8af549b336543ccb5b80c", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/sdn-extension.adoc"}}
{"id": "sha256:1d87685039e97bc795a467e0fb15e7d4fc4e99198f48975c67cc736171481764", "content": "Both the `QuerydslPredicateExecutor` and `CypherdslConditionExecutor` provide the same concept: SDN generates a query, you\nprovide \"predicates\" (Query DSL) or \"conditions\" (Cypher DSL) that will be added. We recommend the Cypher DSL, as this is\nwhat SDN uses natively. You might even want to consider using the\nhttps://neo4j.github.io/cypher-dsl#thespringdataneo4j6annotationprocessor[annotation processor] that generates\na static meta model for you.\n\nHow does that work? Declare your repository as described above and add *one* of the following interfaces:\n\n[source,java,indent=0,tabsize=4]\n----\n\tinterface QueryDSLPersonRepository extends Neo4jRepository<Person, Long>, // <.>\n\t\t\tQuerydslPredicateExecutor<Person> {\n\n\t\t// <.>\n\n\t}\n\n\tstatic class DtoPersonProjection {\n\n\t\tprivate final String firstName;\n\n\t\tDtoPersonProjection(String firstName) {\n\t\t\tthis.firstName = firstName;\n\t\t}\n\n\t\tString getFirstName() {\n\t\t\treturn this.firstName;\n\t\t}\n\n\t}\n----\n<.> Standard repository declaration\n<.> The Query DSL mixin\n\n*OR*\n\n[source,java,indent=0,tabsize=4]\n----\n\tinterface PersonRepository extends Neo4jRepository<Person, Long>, // <.>\n\t\t\tCypherdslConditionExecutor<Person> {\n\n\t\t// <.>\n\n\t}\n----\n<.> Standard repository declaration\n<.> The Cypher DSL mixin\n\nExemplary usage is shown with the Cypher DSL condition executor:\n\n[source,java,indent=0,tabsize=4]\n----\n\t\tNode person = Cypher.node(\"Person\").named(\"person\"); // <.>\n\t\tProperty firstName = person.property(\"firstName\"); // <.>\n\t\tProperty lastName = person.property(\"lastName\");\n\n\t\tassertThat(repository.findAll(\n\t\t\t\tthis.firstName.eq(Cypher.anonParameter(\"Helge\"))\n\t\t\t\t\t.or(this.lastName.eq(Cypher.parameter(\"someName\", \"B.\"))), // <.>\n\t\t\t\tthis.lastName.descending() // <.>\n\t\t)).extracting(Person::getFirstName).containsExactly(\"Helge\", \"Bela\");\n----\n<.> Define a named `Node` object, targeting the root of the query\n<.> Derive some properties from it\n<.> Create an `or` condition. An anonymous parameter is used for the first name, a named parameter for\nthe last name. This is how you define parameters in those fragments and one of the advantages over the Query-DSL\nmixin which can't do that.\nLiterals can be expressed with `Cypher.literalOf`.\n<.> Define a `SortItem` from one of the properties\n\nThe code looks pretty similar for the Query-DSL mixin. Reasons for the Query-DSL mixin can be familiarity of the API and\nthat it works with other stores, too. Reasons against it are the fact that you need an additional library on the class path,\nit's missing support for traversing relationships and the above-mentioned fact that it doesn't support parameters in its\npredicates (it technically does, but there are no API methods to actually pass them to the query being executed).\n\n[[sdn-mixins.using-cypher-dsl-statements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/sdn-extension.adoc", "title": "sdn-extension", "heading": "Add dynamic conditions to generated queries", "heading_level": 3, "file_order": 31, "section_index": 2, "content_hash": "1d87685039e97bc795a467e0fb15e7d4fc4e99198f48975c67cc736171481764", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/sdn-extension.adoc"}}
{"id": "sha256:dceaaba48332208d109c48e496654b69e535be6f3943fc82d30287f23f15c9ab", "content": "Adding the corresponding mixin is not different from using the <<sdn-mixins.dynamic-conditions, condition excecutor>>:\n\n[source,java,indent=0,tabsize=4]\n----\n\tinterface PersonRepository extends Neo4jRepository<Person, Long>, CypherdslStatementExecutor<Person> {\n\n\t}\n----\n\nPlease use the `ReactiveCypherdslStatementExecutor` when extending the `ReactiveNeo4jRepository`.\n\nThe `CypherdslStatementExecutor` comes with several overloads for `findOne` and `findAll`. They all take a Cypher-DSL\nstatement respectively an ongoing definition of that as a first parameter and in case of the projecting methods, a type.\n\nIf a query requires parameters, they must be defined via the Cypher-DSL itself and also populated by it, as the following listing shows:\n\n[source,java,indent=0,tabsize=4]\n----\n\tstatic Statement whoHasFirstNameWithAddress(String name) { // <.>\n\t\tNode p = Cypher.node(\"Person\").named(\"p\"); // <.>\n\t\tNode a = Cypher.anyNode(\"a\");\n\t\tRelationship r = p.relationshipTo(a, \"LIVES_AT\");\n\t\treturn Cypher.match(r)\n\t\t\t.where(p.property(\"firstName\").isEqualTo(Cypher.anonParameter(name))) // <.>\n\t\t\t.returning(p.getRequiredSymbolicName(), Cypher.collect(r), Cypher.collect(a))\n\t\t\t.build();\n\t}\n\n\t@Test\n\tvoid fineOneShouldWork(@Autowired PersonRepository repository) {\n\n\t\tOptional<Person> result = repository.findOne(whoHasFirstNameWithAddress(\"Helge\")); // <.>\n\n\t\tassertThat(result).hasValueSatisfying(namesOnly -> {\n\t\t\tassertThat(namesOnly.getFirstName()).isEqualTo(\"Helge\");\n\t\t\tassertThat(namesOnly.getLastName()).isEqualTo(\"Schneider\");\n\t\t\tassertThat(namesOnly.getAddress()).extracting(Person.Address::getCity).isEqualTo(\"Mülheim an der Ruhr\");\n\t\t});\n\t}\n\n\t@Test\n\tvoid fineOneProjectedShouldWork(@Autowired PersonRepository repository) {\n\n\t\tOptional<NamesOnly> result = repository.findOne(whoHasFirstNameWithAddress(\"Helge\"), NamesOnly.class // <.>\n\t\t);\n\n\t\tassertThat(result).hasValueSatisfying(namesOnly -> {\n\t\t\tassertThat(namesOnly.getFirstName()).isEqualTo(\"Helge\");\n\t\t\tassertThat(namesOnly.getLastName()).isEqualTo(\"Schneider\");\n\t\t\tassertThat(namesOnly.getFullName()).isEqualTo(\"Helge Schneider\");\n\t\t});\n\t}\n----\n<.> The dynamic query is build in a type safe way in a helper method\n<.> We already saw this in <<sdn-mixins.dynamic-conditions,here>>, where we also defined some variables holding the model\n<.> We define an anonymous parameter, filled by the actual value of `name`, which was passed to the method\n<.> The statement returned from the helper method is used to find an entity\n<.> Or a projection.\n\nThe `findAll` methods works similar.\nThe imperative Cypher-DSL statement executor also provides an overload returning paged results.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/sdn-extension.adoc", "title": "sdn-extension", "heading": "Using (dynamic) Cypher-DSL statements for entities and projections", "heading_level": 3, "file_order": 31, "section_index": 3, "content_hash": "dceaaba48332208d109c48e496654b69e535be6f3943fc82d30287f23f15c9ab", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/sdn-extension.adoc"}}
{"id": "sha256:75fbb203b7871446758f937ab86c2422dd71bed3eb763e92c6c04f3dd7f8f1e4", "content": "[[sdn-vector-search]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/vector-search.adoc", "title": "vector-search", "heading": "vector-search", "heading_level": 1, "file_order": 32, "section_index": 0, "content_hash": "75fbb203b7871446758f937ab86c2422dd71bed3eb763e92c6c04f3dd7f8f1e4", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/vector-search.adoc"}}
{"id": "sha256:fe3790e98b9ce30efd03897c4656744b6d5d96fa7a0ef927170724ac7b867f56", "content": "Spring Data Neo4j supports Neo4j's vector search on the repository level by using the `@VectorSearch` annotation.\nFor this to work, Neo4j needs to have a vector index in place.\nHow to create a vector index is explained in the https://neo4j.com/docs/cypher-manual/current/indexes/search-performance-indexes/managing-indexes/[Neo4j documentation].\n\nNOTE: It's not required to have any (Spring Data) Vector typed property be defined in the domain entities for this to work\nbecause the search operates exclusively on the index.\n\nThe `@VectorSearch` annotation requires two arguments:\nThe name of the vector index to be used and the number of nearest neighbours.\n\nFor a general vector search over the whole domain, it's possible to use a derived finder method without any property.\n[source,java,indent=0,tabsize=4]\n----\ninclude::example$integration/imperative/VectorSearchIT.java[tags=sdn-vector-search.usage;sdn-vector-search.usage.findall]\n----\n\nThe vector index can be combined with any property-based finder method to filter down the results.\n\nNOTE: For technical reasons, the vector search will always be executed before the property search gets invoked.\nE.g. if the property filter looks for a person named \"Helge\",\nbut the vector search only yields \"Hannes\", there won't be a result.\n\n[source,java,indent=0,tabsize=4]\n----\ninclude::example$integration/imperative/VectorSearchIT.java[tags=sdn-vector-search.usage;sdn-vector-search.usage.findbyproperty]\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories/vector-search.adoc", "title": "vector-search", "heading": "The `@VectorSearch` annotation", "heading_level": 2, "file_order": 32, "section_index": 1, "content_hash": "fe3790e98b9ce30efd03897c4656744b6d5d96fa7a0ef927170724ac7b867f56", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories/vector-search.adoc"}}
{"id": "sha256:7c0302b275db7bcd9724f88ba7581261ed8af366d729468c1e0f28b3a2f44cd0", "content": "[[dataneo4jtest]]\n\nSpring Boot offers `@DataNeo4jTest` through `org.springframework.boot:spring-boot-starter-test`.\nThe latter brings in `org.springframework.boot:spring-boot-test-autoconfigure` which contains the annotation and the\nrequired infrastructure code.\n\n[source,xml,subs=\"verbatim,attributes\"]\n.Include Spring Boot Starter Test in a Maven build\n----\n<dependency>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-test</artifactId>\n <scope>test</scope>\n</dependency>\n----\n\n[source,groovy,subs=\"verbatim,attributes\"]\n.Include Spring Boot Starter Test in a Gradle build\n----\ndependencies {\n testImplementation 'org.springframework.boot:spring-boot-starter-test'\n}\n----\n\n`@DataNeo4jTest` is a Spring Boot https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing[test slice].\nThe test slice provides all the necessary infrastructure for tests using Neo4j: a transaction manager, a client, a template and declared repositories, in their imperative or reactive variants,\ndepending on reactive dependencies present or not.\nThe test slice already includes `@ExtendWith(SpringExtension.class)` so that it runs automatically with JUnit 5 (JUnit Jupiter).\n\n`@DataNeo4jTest` provides both imperative and reactive infrastructure by default and also adds an implicit `@Transactional` as well.\n`@Transactional` in Spring tests however always means imperative transactional, as declarative transactions needs the\nreturn type of a method to decide whether the imperative `PlatformTransactionManager` or the reactive `ReactiveTransactionManager` is needed.\n\nTo assert the correct transactional behaviour for reactive repositories or services, you will need to inject a `TransactionalOperator`\ninto the test or wrap your domain logic in services that use annotated methods exposing a return type that makes it possible\nfor the infrastructure to select the correct transaction manager.\n\nThe test slice does not bring in an embedded database or any other connection setting.\nIt is up to you to use an appropriate connection.\n\nWe recommend one of two options: either use the https://www.testcontainers.org/modules/databases/neo4j/[Neo4j Testcontainers module]\nor the Neo4j test harness.\nWhile Testcontainers is a known project with modules for a lot of different services, Neo4j test harness is rather unknown.\nIt is an embedded instance that is especially useful when testing stored procedures as described in https://medium.com/neo4j/testing-your-neo4j-based-java-application-34bef487cc3c[Testing your Neo4j-based Java application].\nThe test harness can however be used to test an application as well.\nAs it brings up a database inside the same JVM as your application, performance and timings may not resemble your production setup.\n\nFor your convenience we provide three possible scenarios, Neo4j test harness 3.5 and 4.x/5.x as well as Testcontainers Neo4j.\nWe provide different examples for 3.5 and 4.x/5.x as the test harness changed between those versions.\nAlso, 4.0 requires JDK 11.\n\n[[dataneo4jtest-harness35]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/testing/testing-with-spring-boot.adoc", "title": "testing-with-spring-boot", "heading": "testing-with-spring-boot", "heading_level": 1, "file_order": 33, "section_index": 0, "content_hash": "7c0302b275db7bcd9724f88ba7581261ed8af366d729468c1e0f28b3a2f44cd0", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/testing/testing-with-spring-boot.adoc"}}
{"id": "sha256:3d8f51965fc83f7169be1554c45e7470e4c3847a0196ce8d269106bb45a53c37", "content": "You need the following dependencies to run <<dataneo4jtest-harness35-example>>:\n\n[source,xml,subs=\"verbatim,+attributes\"]\n.Neo4j 3.5 test harness dependencies\n----\n<dependency>\n <groupId>org.neo4j.test</groupId>\n <artifactId>neo4j-harness</artifactId>\n <version>{docs-neo4j-3-version}</version>\n <scope>test</scope>\n</dependency>\n----\n\nThe dependencies for the enterprise version of Neo4j 3.5 are available under the `com.neo4j.test:neo4j-harness-enterprise` and\nan appropriate repository configuration.\n\n[[dataneo4jtest-harness35-example]]\n[source,java]\n.Using Neo4j 3.5 test harness\n----\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.Optional;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.neo4j.harness.ServerControls;\nimport org.neo4j.harness.TestServerBuilders;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;\nimport org.springframework.data.neo4j.core.Neo4jClient;\nimport org.springframework.test.context.DynamicPropertyRegistry;\nimport org.springframework.test.context.DynamicPropertySource;\n\n@DataNeo4jTest\nclass MovieRepositoryTest {\n\n\tprivate static ServerControls embeddedDatabaseServer;\n\n\t@BeforeAll\n\tstatic void initializeNeo4j() {\n\n embeddedDatabaseServer = TestServerBuilders.newInProcessBuilder() // <.>\n .newServer();\n\t}\n\n\t@AfterAll\n\tstatic void stopNeo4j() {\n\n embeddedDatabaseServer.close(); // <.>\n\t}\n\n\t@DynamicPropertySource // <.>\n\tstatic void neo4jProperties(DynamicPropertyRegistry registry) {\n\n registry.add(\"spring.neo4j.uri\", embeddedDatabaseServer::boltURI);\n registry.add(\"spring.neo4j.authentication.username\", () -> \"neo4j\");\n registry.add(\"spring.neo4j.authentication.password\", () -> null);\n\t}\n\n\t@Test\n\tpublic void findSomethingShouldWork(@Autowired Neo4jClient client) {\n\n Optional<Long> result = client.query(\"MATCH (n) RETURN COUNT(n)\")\n .fetchAs(Long.class)\n .one();\n assertThat(result).hasValue(0L);\n\t}\n}\n----\n<.> Entrypoint to create an embedded Neo4j\n<.> This is a Spring Boot annotation that allows for dynamically registered\napplication properties. We overwrite the corresponding Neo4j settings.\n<.> Shutdown Neo4j after all tests.\n\n[[dataneo4jtest-harness40]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/testing/testing-with-spring-boot.adoc", "title": "testing-with-spring-boot", "heading": "`@DataNeo4jTest` with Neo4j test harness 3.5", "heading_level": 2, "file_order": 33, "section_index": 1, "content_hash": "3d8f51965fc83f7169be1554c45e7470e4c3847a0196ce8d269106bb45a53c37", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/testing/testing-with-spring-boot.adoc"}}
{"id": "sha256:7a55be2db34c8dc97e41f2d7d6b98c4234474f5330fedb4821a60208a9f85e1f", "content": "You need the following dependencies to run <<dataneo4jtest-harness40-example>>:\n\n[source,xml,subs=\"verbatim,attributes\"]\n.Neo4j 4.x test harness dependencies\n----\n<dependency>\n <groupId>org.neo4j.test</groupId>\n <artifactId>neo4j-harness</artifactId>\n <version>{docs-neo4j-4-version}</version>\n <scope>test</scope>\n <exclusions>\n <exclusion>\n <groupId>org.slf4j</groupId>\n <artifactId>slf4j-nop</artifactId>\n </exclusion>\n </exclusions>\n</dependency>\n----\n\nThe dependencies for the enterprise version of Neo4j 4.x/5.x are available under the `com.neo4j.test:neo4j-harness-enterprise` and\nan appropriate repository configuration.\n\n[[dataneo4jtest-harness40-example]]\n[source,java]\n.Using Neo4j 4.x/5.x test harness\n----\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.Optional;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.neo4j.harness.Neo4j;\nimport org.neo4j.harness.Neo4jBuilders;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;\nimport org.springframework.data.neo4j.core.Neo4jClient;\nimport org.springframework.test.context.DynamicPropertyRegistry;\nimport org.springframework.test.context.DynamicPropertySource;\n\n@DataNeo4jTest\nclass MovieRepositoryTest {\n\n\tprivate static Neo4j embeddedDatabaseServer;\n\n\t@BeforeAll\n\tstatic void initializeNeo4j() {\n\n embeddedDatabaseServer = Neo4jBuilders.newInProcessBuilder() // <.>\n .withDisabledServer() // <.>\n .build();\n\t}\n\n\t@DynamicPropertySource // <.>\n\tstatic void neo4jProperties(DynamicPropertyRegistry registry) {\n\n registry.add(\"spring.neo4j.uri\", embeddedDatabaseServer::boltURI);\n registry.add(\"spring.neo4j.authentication.username\", () -> \"neo4j\");\n registry.add(\"spring.neo4j.authentication.password\", () -> null);\n\t}\n\n\t@AfterAll\n\tstatic void stopNeo4j() {\n\n embeddedDatabaseServer.close(); // <.>\n\t}\n\n\t@Test\n\tpublic void findSomethingShouldWork(@Autowired Neo4jClient client) {\n\n Optional<Long> result = client.query(\"MATCH (n) RETURN COUNT(n)\")\n .fetchAs(Long.class)\n .one();\n assertThat(result).hasValue(0L);\n\t}\n}\n----\n<.> Entrypoint to create an embedded Neo4j\n<.> Disable the unneeded Neo4j HTTP server\n<.> This is a Spring Boot annotation that allows for dynamically registered\napplication properties. We overwrite the corresponding Neo4j settings.\n<.> Shut down Neo4j after all tests.\n\n[[dataneo4jtest-testcontainers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/testing/testing-with-spring-boot.adoc", "title": "testing-with-spring-boot", "heading": "`@DataNeo4jTest` with Neo4j test harness 4.x/5.x", "heading_level": 2, "file_order": 33, "section_index": 2, "content_hash": "7a55be2db34c8dc97e41f2d7d6b98c4234474f5330fedb4821a60208a9f85e1f", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/testing/testing-with-spring-boot.adoc"}}
{"id": "sha256:a6da41fcdf2add650bb4355b6e85a90f908556fe2f3b0931d5a90b884b8ff52c", "content": "The principal of configuring the connection is of course still the same with Testcontainers as shown in <<dataneo4jtest-testcontainers-example>>.\nYou need the following dependencies:\n\n[source,xml]\n----\n<dependency>\n <groupId>org.testcontainers</groupId>\n <artifactId>testcontainers-neo4j</artifactId>\n <version>${testcontainers.version}</version>\n <scope>test</scope>\n</dependency>\n----\n\nAnd a complete test:\n\n[[dataneo4jtest-testcontainers-example]]\n[source,java]\n.Using Test containers\n----\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport java.util.Optional;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;\nimport org.springframework.data.neo4j.core.Neo4jClient;\nimport org.springframework.test.context.DynamicPropertyRegistry;\nimport org.springframework.test.context.DynamicPropertySource;\nimport org.testcontainers.neo4j.Neo4jContainer;\n\n@DataNeo4jTest\nclass MovieRepositoryTCTest {\n\n\tprivate static Neo4jContainer neo4jContainer;\n\n\t@BeforeAll\n\tstatic void initializeNeo4j() {\n\n neo4jContainer = new Neo4jContainer()\n .withAdminPassword(\"somePassword\");\n neo4jContainer.start();\n\t}\n\n\t@AfterAll\n\tstatic void stopNeo4j() {\n\n neo4jContainer.close();\n\t}\n\n\t@DynamicPropertySource\n\tstatic void neo4jProperties(DynamicPropertyRegistry registry) {\n\n registry.add(\"spring.neo4j.uri\", neo4jContainer::getBoltUrl);\n registry.add(\"spring.neo4j.authentication.username\", () -> \"neo4j\");\n registry.add(\"spring.neo4j.authentication.password\", neo4jContainer::getAdminPassword);\n\t}\n\n\t@Test\n\tpublic void findSomethingShouldWork(@Autowired Neo4jClient client) {\n\n Optional<Long> result = client.query(\"MATCH (n) RETURN COUNT(n)\")\n .fetchAs(Long.class)\n .one();\n assertThat(result).hasValue(0L);\n\t}\n}\n----\n\n[[dataneo4jtest-dynamicpropertysource-alternatives]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/testing/testing-with-spring-boot.adoc", "title": "testing-with-spring-boot", "heading": "`@DataNeo4jTest` with Testcontainers Neo4j", "heading_level": 2, "file_order": 33, "section_index": 3, "content_hash": "a6da41fcdf2add650bb4355b6e85a90f908556fe2f3b0931d5a90b884b8ff52c", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/testing/testing-with-spring-boot.adoc"}}
{"id": "sha256:b6fd67545efddaf19894be0ffaad16ef41b30497a8fe15c4a0ecf7a8f1a31cad", "content": "There are some scenarios in which the above annotation does not fit your use case.\nOne of those might be that you want to have 100% control over how the driver is initialized.\nWith a test container running, you could do this with a nested, static configuration class like this:\n\n[source,java]\n----\n@TestConfiguration(proxyBeanMethods = false)\nstatic class TestNeo4jConfig {\n\n @Bean\n Driver driver() {\n return GraphDatabase.driver(\n neo4jContainer.getBoltUrl(),\n AuthTokens.basic(\"neo4j\", neo4jContainer.getAdminPassword())\n );\n }\n}\n----\n\nIf you want to use the properties but cannot use a `@DynamicPropertySource`, you would use an initializer:\n\n[source,java]\n.Alternative injection of dynamic properties\n----\n@ContextConfiguration(initializers = PriorToBoot226Test.Initializer.class)\n@DataNeo4jTest\nclass PriorToBoot226Test {\n\n private static Neo4jContainer neo4jContainer;\n\n @BeforeAll\n static void initializeNeo4j() {\n\n neo4jContainer = new Neo4jContainer()\n .withAdminPassword(\"somePassword\");\n neo4jContainer.start();\n }\n\n @AfterAll\n static void stopNeo4j() {\n\n neo4jContainer.close();\n }\n\n static class Initializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {\n public void initialize(ConfigurableApplicationContext configurableApplicationContext) {\n TestPropertyValues.of(\n \"spring.neo4j.uri=\" + neo4jContainer.getBoltUrl(),\n \"spring.neo4j.authentication.username=neo4j\",\n \"spring.neo4j.authentication.password=\" + neo4jContainer.getAdminPassword()\n ).applyTo(configurableApplicationContext.getEnvironment());\n }\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/testing/testing-with-spring-boot.adoc", "title": "testing-with-spring-boot", "heading": "Alternatives to a `@DynamicPropertySource`", "heading_level": 2, "file_order": 33, "section_index": 4, "content_hash": "b6fd67545efddaf19894be0ffaad16ef41b30497a8fe15c4a0ecf7a8f1a31cad", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/testing/testing-with-spring-boot.adoc"}}
{"id": "sha256:b5b10927acb789867db36c618aef9407fa9cd96197f7b7bf1908a1f84694493c", "content": "[[sdn.testing.without.spring-boot]]\n\nWe work a lot with our abstract base classes for configuration in our own integration tests. They can be used like this:\n\n[source,java]\n.One possible test setup without Spring Boot\n----\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.neo4j.driver.AuthTokens;\nimport org.neo4j.driver.Driver;\nimport org.neo4j.driver.GraphDatabase;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.neo4j.config.AbstractNeo4jConfig;\nimport org.springframework.data.neo4j.core.Neo4jTemplate;\nimport org.springframework.data.neo4j.repository.config.EnableNeo4jRepositories;\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\n@ExtendWith(SpringExtension.class)\nclass YourIntegrationTest {\n\n\t@Test\n\tvoid thingsShouldWork(@Autowired Neo4jTemplate neo4jTemplate) {\n // Add your test\n\t}\n\n\t@Configuration\n\t@EnableNeo4jRepositories(considerNestedRepositories = true)\n\t@EnableTransactionManagement\n\tstatic class Config extends AbstractNeo4jConfig {\n\n @Bean\n public Driver driver() {\n return GraphDatabase.driver(\"bolt://yourtestserver:7687\", AuthTokens.none()); // <.>\n }\n\t}\n}\n----\n. Here you should provide a connection to your test server or container.\n\nSimilar classes are provided for reactive tests.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/testing/testing-without-spring-boot.adoc", "title": "testing-without-spring-boot", "heading": "testing-without-spring-boot", "heading_level": 1, "file_order": 34, "section_index": 0, "content_hash": "b5b10927acb789867db36c618aef9407fa9cd96197f7b7bf1908a1f84694493c", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/testing/testing-without-spring-boot.adoc"}}
{"id": "sha256:3eef4bcab3b672857d659b2ed27367d50e4bfb9414e44a4699db5956c32e1b6e", "content": "[[auditing]]\ninclude::{commons}@data-commons::page$auditing.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/auditing.adoc", "title": "auditing", "heading": "auditing", "heading_level": 1, "file_order": 35, "section_index": 0, "content_hash": "3eef4bcab3b672857d659b2ed27367d50e4bfb9414e44a4699db5956c32e1b6e", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/auditing.adoc"}}
{"id": "sha256:c280893c409b1e3ebb0d2ff42b47444fedc19b28b1ac6bfe1d9e08178f40817c", "content": "include::{commons}@data-commons::page$dependencies.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/dependencies.adoc", "title": "dependencies", "heading": "dependencies", "heading_level": 1, "file_order": 36, "section_index": 0, "content_hash": "c280893c409b1e3ebb0d2ff42b47444fedc19b28b1ac6bfe1d9e08178f40817c", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/dependencies.adoc"}}
{"id": "sha256:876fc8e64f4c4613aa5f270c0b5c27f6e4be7200ceb7314be93e059bfe41326a", "content": "[[faq]]\n\n[[faq.sdn-related-to-ogm]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "faq", "heading_level": 1, "file_order": 37, "section_index": 0, "content_hash": "876fc8e64f4c4613aa5f270c0b5c27f6e4be7200ceb7314be93e059bfe41326a", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:664c5b25776c9d5561c8508883192b0dae2f24b3c507b2c0b8ba4946fefdbe9d", "content": "https://neo4j.com/docs/ogm-manual/current/[Neo4j-OGM] is an Object Graph Mapping library, which is mainly used by previous versions of Spring Data Neo4j as its backend for the heavy lifting of mapping nodes and relationships into domain object.\nThe current SDN *does not need* and *does not support* Neo4j-OGM.\nSDN uses Spring Data's mapping context exclusively for scanning classes and building the meta model.\n\nWhile this pins SDN to the Spring ecosystem, it has several advantages, among them the smaller footprint regarding CPU and memory usage and especially, all the features of Spring's mapping context.\n\n[[faq.why-should-you-favor-sdn]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "How does SDN relate to Neo4j-OGM?", "heading_level": 2, "file_order": 37, "section_index": 1, "content_hash": "664c5b25776c9d5561c8508883192b0dae2f24b3c507b2c0b8ba4946fefdbe9d", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:072aab7a1f57e0f1ccf34865edfd0883c042c2a05ab5b57f11b679b22c5e797f", "content": "SDN has several features not present in SDN+OGM, notably\n\n* Full support for Springs reactive story, including reactive transaction\n* Full support for https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#query-by-example[Query By Example]\n* Full support for fully immutable entities\n* Support for all modifiers and variations of derived finder methods, including spatial queries\n\n[[faq.sdn-and-http-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Why should I use SDN in favor of SDN+OGM", "heading_level": 3, "file_order": 37, "section_index": 2, "content_hash": "072aab7a1f57e0f1ccf34865edfd0883c042c2a05ab5b57f11b679b22c5e797f", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:9da57e17974ff360f8555897d7d5eaf4521c83b6d6d47a3a8dc661cbed48704d", "content": "No.\n\n[[faq.sdn-and-embedded-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Does SDN support connections over HTTP to Neo4j?", "heading_level": 2, "file_order": 37, "section_index": 3, "content_hash": "9da57e17974ff360f8555897d7d5eaf4521c83b6d6d47a3a8dc661cbed48704d", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:deeb3c1538124b6fc1a7d5e163ec683e7c63bdb798ae986766072db5dccf4a98", "content": "Embedded Neo4j has multiple facets to it:\n\n[[faq.sdn-and-embedded-instances-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Does SDN support embedded Neo4j?", "heading_level": 2, "file_order": 37, "section_index": 4, "content_hash": "deeb3c1538124b6fc1a7d5e163ec683e7c63bdb798ae986766072db5dccf4a98", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:8a835f85b4dd14b17cb50a09ec6673751e1782e38a7758f03f25a24c5e634173", "content": "No.\n\n[[faq.sdn-interact-with-embedded-instances]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Does SDN provide an embedded instance for your application?", "heading_level": 3, "file_order": 37, "section_index": 5, "content_hash": "8a835f85b4dd14b17cb50a09ec6673751e1782e38a7758f03f25a24c5e634173", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:a7b220dd82d3aaeb6821588f34439d31bf77a3b0330734501b44c6145526f1dd", "content": "No.\nAn embedded database is usually represented by an instance of `org.neo4j.graphdb.GraphDatabaseService` and has no Bolt connector out of the box.\n\nSDN can however work very much with Neo4j's test harness, the test harness is specially meant to be a drop-in replacement for the real database.\nSupport for Neo4j 3.5, 4.x and 5.x test harness is implemented via link:{java-driver-starter-href}[the Spring Boot starter for the driver].\nHave a look at the corresponding module `org.neo4j.driver:neo4j-java-driver-test-harness-spring-boot-autoconfigure`.\n\n[[faq.change-driver-version]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Does SDN interact directly with an embedded instance?", "heading_level": 3, "file_order": 37, "section_index": 6, "content_hash": "a7b220dd82d3aaeb6821588f34439d31bf77a3b0330734501b44c6145526f1dd", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:ab3c1e233bf0f63b6e72d5a6227cec9adafad5846016111c37b4a888b8a16ec4", "content": "SDN relies on the Neo4j Java Driver.\nEach SDN release uses a Neo4j Java Driver version compatible with the latest Neo4j available at the time of its\nrelease.\nWhile patch versions of the Neo4j Java Driver are usually drop-in replacements, SDN makes sure that even minor versions\nare interchangeable as it checks for the presence or absence of methods or interface changes if necessary.\n\nTherefore, you are able to use any 4.x Neo4j Java Driver with any SDN 6.x version,\nand any 5.x Neo4j Driver with any SDN 7.x version.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Which Neo4j Java Driver can be used and how?", "heading_level": 2, "file_order": 37, "section_index": 7, "content_hash": "ab3c1e233bf0f63b6e72d5a6227cec9adafad5846016111c37b4a888b8a16ec4", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:606afb0b54f9a9971c67a996cb13f7f2f6f73d3ff7a349b77110e0e6caf735ea", "content": "These days, a Spring boot deployment is the most likely deployment of a Spring Data based applications. Please use\nSpring Boots dependency management to change the driver version like this:\n\n.Change the driver version from Maven (pom.xml)\n[source,xml]\n----\n<properties>\n <neo4j-java-driver.version>5.4.0</neo4j-java-driver.version>\n</properties>\n----\n\nOr\n\n.Change the driver version from Gradle (gradle.properties)\n[source,properties]\n----\nneo4j-java-driver.version = 5.4.0\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "With Spring Boot", "heading_level": 3, "file_order": 37, "section_index": 8, "content_hash": "606afb0b54f9a9971c67a996cb13f7f2f6f73d3ff7a349b77110e0e6caf735ea", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:bc3b0d4a2fc5e4e5f862e01bfed85010256b9dcf8bb7ed449fb6276007e9b06c", "content": "Without Spring Boot, you would just manually declare the dependency. For Maven, we recommend using the `<dependencyManagement />`\nsection like this:\n\n.Change the driver version without Spring Boot from Maven (pom.xml)\n----\n<dependencyManagement>\n <dependency>\n <groupId>org.neo4j.driver</groupId>\n <artifactId>neo4j-java-driver</artifactId>\n <version>5.4.0</version>\n </dependency>\n</dependencyManagement>\n----\n\n[[faq.multidatabase]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Without Spring Boot", "heading_level": 3, "file_order": 37, "section_index": 9, "content_hash": "bc3b0d4a2fc5e4e5f862e01bfed85010256b9dcf8bb7ed449fb6276007e9b06c", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:7be50369fa28ceb971c84df171deac40ccbf3afef0a4dd76ed5a5a9ffaa532c9", "content": "You can either statically configure the database name or run your own database name provider.\nBear in mind that SDN will not create the databases for you.\nYou can do this with the help of a https://github.com/michael-simons/neo4j-migrations[migrations tool]\nor of course with a simple script upfront.\n\n[[faq.multidatabase.statically]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Neo4j 4 supports multiple databases - How can I use them?", "heading_level": 2, "file_order": 37, "section_index": 10, "content_hash": "7be50369fa28ceb971c84df171deac40ccbf3afef0a4dd76ed5a5a9ffaa532c9", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:3e1f155be912044105866e7cd0026f2ab17713e2d512a46e3ee9ff9c39f3e98b", "content": "Configure the database name to use in your Spring Boot configuration like this (the same property applies of course for YML or environment based configuration, with Spring Boot's conventions applied):\n\n[source,properties]\n----\nspring.data.neo4j.database = yourDatabase\n----\n\nWith that configuration in place, all queries generated by all instances of SDN repositories (both reactive and imperative) and by the `ReactiveNeo4jTemplate` respectively `Neo4jTemplate` will be executed against the database `yourDatabase`.\n\n[[faq.multidatabase.dynamically]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Statically configured", "heading_level": 3, "file_order": 37, "section_index": 11, "content_hash": "3e1f155be912044105866e7cd0026f2ab17713e2d512a46e3ee9ff9c39f3e98b", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:55bdbe62f1af51da1f7844380d36d69803bef2dd6fffb4e25a56593c6ea64078", "content": "Provide a bean with the type `Neo4jDatabaseNameProvider` or `ReactiveDatabaseSelectionProvider` depending on the type of your Spring application.\n\nThat bean could use for example Spring's security context to retrieve a tenant.\nHere is a working example for an imperative application secured with Spring Security:\n\n[source,java]\n[[faq.databaseSelectionProvider]]\n.Neo4jConfig.java\n----\nimport org.neo4j.springframework.data.core.DatabaseSelection;\nimport org.neo4j.springframework.data.core.DatabaseSelectionProvider;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContext;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.User;\n\n@Configuration\npublic class Neo4jConfig {\n\t@Bean\n\tDatabaseSelectionProvider databaseSelectionProvider() {\n\n return () -> Optional.ofNullable(SecurityContextHolder.getContext())\n .map(SecurityContext::getAuthentication)\n .filter(Authentication::isAuthenticated)\n .map(Authentication::getPrincipal)\n .map(User.class::cast)\n .map(User::getUsername)\n .map(DatabaseSelection::byName)\n .orElseGet(DatabaseSelection::undecided);\n\t}\n}\n----\n\nNOTE: Be careful that you don't mix up entities retrieved from one database with another database.\nThe database name is requested for each new transaction, so you might end up with less or more entities than expected when changing the database name in between calls.\nOr worse, you could inevitably store the wrong entities in the wrong database.\n\n[[faq.multidatabase.health]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Dynamically configured", "heading_level": 3, "file_order": 37, "section_index": 12, "content_hash": "55bdbe62f1af51da1f7844380d36d69803bef2dd6fffb4e25a56593c6ea64078", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:9e5301d2a57a056b23e316874a500204a48064def09e03f1ced99c2b84bcf0fd", "content": "Spring Boot comes with both imperative and reactive Neo4j https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-health[health indicators.]\nBoth variants are able to detect multiple beans of `org.neo4j.driver.Driver` inside the application context and provide\na contribution to the overall health for each instance.\nThe Neo4j driver however does connect to a server and not to a specific database inside that server.\nSpring Boot is able to configure the driver without Spring Data Neo4j and as the information which database is to be used\nis tied to Spring Data Neo4j, this information is not available to the built-in health indicator.\n\nThis is most likely not a problem in many deployment scenarios.\nHowever, if configured database user does not have at least access rights to the default database, the health checks will fail.\n\nThis can be mitigated by custom Neo4j health contributors that are aware of the database selection.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "The Spring Boot Neo4j health indicator targets the default database, how can I change that?", "heading_level": 3, "file_order": 37, "section_index": 13, "content_hash": "9e5301d2a57a056b23e316874a500204a48064def09e03f1ced99c2b84bcf0fd", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:ddc914a0ab497396e1fc2ad82c79eb61e1f7221470e5939777010ea9428411af", "content": "[[faq.multidatabase.health.imperative]]\n[source,java,indent=0,tabsize=4]\n----\nimport java.util.Optional;\n\nimport org.neo4j.driver.Driver;\nimport org.neo4j.driver.Result;\nimport org.neo4j.driver.SessionConfig;\nimport org.neo4j.driver.summary.DatabaseInfo;\nimport org.neo4j.driver.summary.ResultSummary;\nimport org.neo4j.driver.summary.ServerInfo;\nimport org.springframework.boot.actuate.health.AbstractHealthIndicator;\nimport org.springframework.boot.actuate.health.Health;\nimport org.springframework.data.neo4j.core.DatabaseSelection;\nimport org.springframework.data.neo4j.core.DatabaseSelectionProvider;\nimport org.springframework.util.StringUtils;\n\npublic class DatabaseSelectionAwareNeo4jHealthIndicator extends AbstractHealthIndicator {\n\n\tprivate final Driver driver;\n\n\tprivate final DatabaseSelectionProvider databaseSelectionProvider;\n\n\tpublic DatabaseSelectionAwareNeo4jHealthIndicator(\n Driver driver, DatabaseSelectionProvider databaseSelectionProvider\n ) {\n this.driver = driver;\n this.databaseSelectionProvider = databaseSelectionProvider;\n\t}\n\n\t@Override\n\tprotected void doHealthCheck(Health.Builder builder) {\n try {\n SessionConfig sessionConfig = Optional\n .ofNullable(databaseSelectionProvider.getDatabaseSelection())\n .filter(databaseSelection -> databaseSelection != DatabaseSelection.undecided())\n .map(DatabaseSelection::getValue)\n .map(v -> SessionConfig.builder().withDatabase(v).build())\n .orElseGet(SessionConfig::defaultConfig);\n\n class Tuple {\n String edition;\n ResultSummary resultSummary;\n\n Tuple(String edition, ResultSummary resultSummary) {\n this.edition = edition;\n this.resultSummary = resultSummary;\n }\n }\n\n String query =\n \"CALL dbms.components() YIELD name, edition WHERE name = 'Neo4j Kernel' RETURN edition\";\n Tuple health = driver.session(sessionConfig)\n .writeTransaction(tx -> {\n Result result = tx.run(query);\n String edition = result.single().get(\"edition\").asString();\n return new Tuple(edition, result.consume());\n });\n\n addHealthDetails(builder, health.edition, health.resultSummary);\n } catch (Exception ex) {\n builder.down().withException(ex);\n }\n\t}\n\n\tstatic void addHealthDetails(Health.Builder builder, String edition, ResultSummary resultSummary) {\n ServerInfo serverInfo = resultSummary.server();\n builder.up()\n .withDetail(\n \"server\", serverInfo.version() + \"@\" + serverInfo.address())\n .withDetail(\"edition\", edition);\n DatabaseInfo databaseInfo = resultSummary.database();\n if (StringUtils.hasText(databaseInfo.name())) {\n builder.withDetail(\"database\", databaseInfo.name());\n }\n\t}\n}\n----\n\nThis uses the available database selection to run the same query that Boot runs to check whether a connection is healthy or not.\nUse the following configuration to apply it:\n\n[[faq.multidatabase.health.imperative.config]]\n[source,java,indent=0,tabsize=4]\n----\nimport java.util.Map;\n\nimport org.neo4j.driver.Driver;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.boot.actuate.health.CompositeHealthContributor;\nimport org.springframework.boot.actuate.health.HealthContributor;\nimport org.springframework.boot.actuate.health.HealthContributorRegistry;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.neo4j.core.DatabaseSelectionProvider;\n\n@Configuration(proxyBeanMethods = false)\npublic class Neo4jHealthConfig {\n\n\t@Bean // <.>\n\tDatabaseSelectionAwareNeo4jHealthIndicator databaseSelectionAwareNeo4jHealthIndicator(\n Driver driver, DatabaseSelectionProvider databaseSelectionProvider\n\t) {\n return new DatabaseSelectionAwareNeo4jHealthIndicator(driver, databaseSelectionProvider);\n\t}\n\n\t@Bean // <.>\n\tHealthContributor neo4jHealthIndicator(\n Map<String, DatabaseSelectionAwareNeo4jHealthIndicator> customNeo4jHealthIndicators) {\n return CompositeHealthContributor.fromMap(customNeo4jHealthIndicators);\n\t}\n\n\t@Bean // <.>\n\tInitializingBean healthContributorRegistryCleaner(\n HealthContributorRegistry healthContributorRegistry,\n Map<String, DatabaseSelectionAwareNeo4jHealthIndicator> customNeo4jHealthIndicators\n\t) {\n return () -> customNeo4jHealthIndicators.keySet()\n .stream()\n .map(HealthContributorNameFactory.INSTANCE)\n .forEach(healthContributorRegistry::unregisterContributor);\n\t}\n}\n----\n<.> If you have multiple drivers and database selection providers, you would need to create one indicator per combination\n<.> This makes sure that all of those indicators are grouped under Neo4j, replacing the default Neo4j health indicator\n<.> This prevents the individual contributors showing up in the health endpoint directly", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Imperative variant", "heading_level": 4, "file_order": 37, "section_index": 14, "content_hash": "ddc914a0ab497396e1fc2ad82c79eb61e1f7221470e5939777010ea9428411af", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:1d19aedeaa9acfb6af1222f327326f6ea50a327417278e4b9965190d8a35193a", "content": "The reactive variant is basically the same, using reactive types and the corresponding reactive infrastructure classes:\n\n[[faq.multidatabase.health.reactive]]\n[source,java,indent=0,tabsize=4]\n----\nimport reactor.core.publisher.Mono;\nimport reactor.util.function.Tuple2;\n\nimport org.neo4j.driver.Driver;\nimport org.neo4j.driver.SessionConfig;\nimport org.neo4j.driver.reactivestreams.RxResult;\nimport org.neo4j.driver.reactivestreams.RxSession;\nimport org.neo4j.driver.summary.DatabaseInfo;\nimport org.neo4j.driver.summary.ResultSummary;\nimport org.neo4j.driver.summary.ServerInfo;\nimport org.reactivestreams.Publisher;\nimport org.springframework.boot.actuate.health.AbstractReactiveHealthIndicator;\nimport org.springframework.boot.actuate.health.Health;\nimport org.springframework.data.neo4j.core.DatabaseSelection;\nimport org.springframework.data.neo4j.core.ReactiveDatabaseSelectionProvider;\nimport org.springframework.util.StringUtils;\n\npublic final class DatabaseSelectionAwareNeo4jReactiveHealthIndicator\n extends AbstractReactiveHealthIndicator {\n\n\tprivate final Driver driver;\n\n\tprivate final ReactiveDatabaseSelectionProvider databaseSelectionProvider;\n\n\tpublic DatabaseSelectionAwareNeo4jReactiveHealthIndicator(\n Driver driver,\n ReactiveDatabaseSelectionProvider databaseSelectionProvider\n ) {\n this.driver = driver;\n this.databaseSelectionProvider = databaseSelectionProvider;\n\t}\n\n\t@Override\n\tprotected Mono<Health> doHealthCheck(Health.Builder builder) {\n String query =\n \"CALL dbms.components() YIELD name, edition WHERE name = 'Neo4j Kernel' RETURN edition\";\n return databaseSelectionProvider.getDatabaseSelection()\n .map(databaseSelection -> databaseSelection == DatabaseSelection.undecided() ?\n SessionConfig.defaultConfig() :\n SessionConfig.builder().withDatabase(databaseSelection.getValue()).build()\n )\n .flatMap(sessionConfig ->\n Mono.usingWhen(\n Mono.fromSupplier(() -> driver.rxSession(sessionConfig)),\n s -> {\n Publisher<Tuple2<String, ResultSummary>> f = s.readTransaction(tx -> {\n RxResult result = tx.run(query);\n return Mono.from(result.records())\n .map((record) -> record.get(\"edition\").asString())\n .zipWhen((edition) -> Mono.from(result.consume()));\n });\n return Mono.fromDirect(f);\n },\n RxSession::close\n )\n ).map((result) -> {\n addHealthDetails(builder, result.getT1(), result.getT2());\n return builder.build();\n });\n\t}\n\n\tstatic void addHealthDetails(Health.Builder builder, String edition, ResultSummary resultSummary) {\n ServerInfo serverInfo = resultSummary.server();\n builder.up()\n .withDetail(\n \"server\", serverInfo.version() + \"@\" + serverInfo.address())\n .withDetail(\"edition\", edition);\n DatabaseInfo databaseInfo = resultSummary.database();\n if (StringUtils.hasText(databaseInfo.name())) {\n builder.withDetail(\"database\", databaseInfo.name());\n }\n\t}\n}\n\n----\n\nAnd of course, the reactive variant of the configuration. It needs two different registry cleaners, as Spring Boot will\nwrap existing reactive indicators to be used with the non-reactive actuator endpoint, too.\n\n[[faq.multidatabase.health.reactive.config]]\n[source,java,indent=0,tabsize=4]\n----\nimport java.util.Map;\n\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.boot.actuate.health.CompositeReactiveHealthContributor;\nimport org.springframework.boot.actuate.health.HealthContributorNameFactory;\nimport org.springframework.boot.actuate.health.HealthContributorRegistry;\nimport org.springframework.boot.actuate.health.ReactiveHealthContributor;\nimport org.springframework.boot.actuate.health.ReactiveHealthContributorRegistry;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration(proxyBeanMethods = false)\npublic class Neo4jHealthConfig {\n\n\t@Bean\n\tReactiveHealthContributor neo4jHealthIndicator(\n Map<String, DatabaseSelectionAwareNeo4jReactiveHealthIndicator> customNeo4jHealthIndicators) {\n return CompositeReactiveHealthContributor.fromMap(customNeo4jHealthIndicators);\n\t}\n\n\t@Bean\n\tInitializingBean healthContributorRegistryCleaner(HealthContributorRegistry healthContributorRegistry,\n Map<String, DatabaseSelectionAwareNeo4jReactiveHealthIndicator> customNeo4jHealthIndicators) {\n return () -> customNeo4jHealthIndicators.keySet()\n .stream()\n .map(HealthContributorNameFactory.INSTANCE)\n .forEach(healthContributorRegistry::unregisterContributor);\n\t}\n\n\t@Bean\n\tInitializingBean reactiveHealthContributorRegistryCleaner(\n ReactiveHealthContributorRegistry healthContributorRegistry,\n Map<String, DatabaseSelectionAwareNeo4jReactiveHealthIndicator> customNeo4jHealthIndicators) {\n return () -> customNeo4jHealthIndicators.keySet()\n .stream()\n .map(HealthContributorNameFactory.INSTANCE)\n .forEach(healthContributorRegistry::unregisterContributor);\n\t}\n}\n----\n\n[[faq.impersonation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Reactive variant", "heading_level": 4, "file_order": 37, "section_index": 15, "content_hash": "1d19aedeaa9acfb6af1222f327326f6ea50a327417278e4b9965190d8a35193a", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:d267a8f867fdacfa4e602350e1160e43c0398fffa57bf964d795e4f287d396cf", "content": "User impersonation is especially interesting in big multi-tenant settings, in which one physically connected (or technical)\nuser can impersonate many tenants. Depending on your setup this will drastically reduce the number of physical driver instances needed.\n\nThe feature requires Neo4j Enterprise 4.4+ on the server side and a 4.4+ driver on the client side (`org.neo4j.driver:neo4j-java-driver:4.4.0` or higher).\n\nFor both imperative and reactive versions you need to provide a `UserSelectionProvider` respectively a `ReactiveUserSelectionProvider`.\nThe same instance needs to be passed along to the `Neo4Client` and `Neo4jTransactionManager` respectively their reactive variants.\n\nIn xref:#bootless-imperative-configuration[Bootless imperative] and xref:#bootless-reactive-configuration[reactive] configurations you just need to provide a bean of the\ntype in question:\n\n[[faq.impersonation.userselectionbean]]\n.User selection provider bean\n[source,java]\n----\nimport org.springframework.data.neo4j.core.UserSelection;\nimport org.springframework.data.neo4j.core.UserSelectionProvider;\n\npublic class CustomConfig {\n\n @Bean\n public UserSelectionProvider getUserSelectionProvider() {\n return () -> UserSelection.impersonate(\"someUser\");\n }\n}\n----\n\nIn a typical Spring Boot scenario this feature requires a bit more work, as Boot supports also SDN versions without that feature.\nSo given the bean in xref:#faq.impersonation.userselectionbean[] you would need fully customize the client and transaction manager:\n\n[[faq.impersonation.boot]]\n.Necessary customization for Spring Boot\n[source,java]\n----\nimport org.neo4j.driver.Driver;\n\nimport org.springframework.data.neo4j.core.DatabaseSelectionProvider;\nimport org.springframework.data.neo4j.core.Neo4jClient;\nimport org.springframework.data.neo4j.core.UserSelectionProvider;\nimport org.springframework.data.neo4j.core.transaction.Neo4jTransactionManager;\n\nimport org.springframework.transaction.PlatformTransactionManager;\n\npublic class CustomConfig {\n\n @Bean\n public Neo4jClient neo4jClient(\n Driver driver,\n DatabaseSelectionProvider databaseSelectionProvider,\n UserSelectionProvider userSelectionProvider\n ) {\n\n return Neo4jClient.with(driver)\n .withDatabaseSelectionProvider(databaseSelectionProvider)\n .withUserSelectionProvider(userSelectionProvider)\n .build();\n\t}\n\n @Bean\n public PlatformTransactionManager transactionManager(\n Driver driver,\n DatabaseSelectionProvider databaseSelectionProvider,\n UserSelectionProvider userSelectionProvider\n ) {\n\n return Neo4jTransactionManager\n .with(driver)\n .withDatabaseSelectionProvider(databaseSelectionProvider)\n .withUserSelectionProvider(userSelectionProvider)\n .build();\n\t}\n}\n----\n\n[[faq.cluster]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Neo4j 4.4+ supports impersonation of different users - How can I use them?", "heading_level": 2, "file_order": 37, "section_index": 16, "content_hash": "d267a8f867fdacfa4e602350e1160e43c0398fffa57bf964d795e4f287d396cf", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:af6c133f4437b84930ab5e7119dca19143d34bf5a675cf7cc8d9281de79e90c6", "content": "The following questions apply to Neo4j AuraDB as well as to Neo4j on-premise cluster instances.\n\n[[faq.transactions.cluster]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Using a Neo4j cluster instance from Spring Data Neo4j", "heading_level": 2, "file_order": 37, "section_index": 17, "content_hash": "af6c133f4437b84930ab5e7119dca19143d34bf5a675cf7cc8d9281de79e90c6", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:e405b07240df5dd334a527214ee8065554309e2200f98a0fa2e2d4e32e0bfb11", "content": "No, you don't.\nSDN uses Neo4j Causal Cluster bookmarks internally without any configuration on your side required.\nTransactions in the same thread or the same reactive stream following each other will be able to read their previously changed values as you would expect.\n\n[[faq.transactions.cluster.rw]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Do I need specific configuration so that transactions work seamless with a Neo4j Causal Cluster?", "heading_level": 3, "file_order": 37, "section_index": 18, "content_hash": "e405b07240df5dd334a527214ee8065554309e2200f98a0fa2e2d4e32e0bfb11", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:b7dbea0aa74abd9f01a3d75c8fdb70664b3bf9278a5b81bf76c776fa54636280", "content": "Yes, it is.\nThe Neo4j cluster architecture is a causal clustering architecture, and it distinguishes between primary and secondary servers.\nPrimary server either are single instances or core instances. Both of them can answer to read and write operations.\nWrite operations are propagated from the core instances to read replicas or more generally, followers, inside the cluster.\nThose followers are secondary servers.\nSecondary servers don't answer to write operations.\n\nIn a standard deployment scenario you'll have some core instances and many read replicas inside a cluster.\nTherefore, it is important to mark operations or queries as read-only to scale your cluster in such a way that leaders are\nnever overwhelmed and queries are propagated as much as possible to read replicas.\n\nNeither Spring Data Neo4j nor the underlying Java driver do Cypher parsing and both building blocks assume\nwrite operations by default. This decision has been made to support all operations out of the box. If something in the\nstack would assume read-only by default, the stack might end up sending write queries to read replicas and fail\non executing them.\n\nNOTE: All `findById`, `findAllById`, `findAll` and predefined existential methods are marked as read-only by default.\n\nSome options are described below:\n\n.Making a whole repository read-only\n[source,java]\n----\nimport org.springframework.data.neo4j.repository.Neo4jRepository;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Transactional(readOnly = true)\ninterface PersonRepository extends Neo4jRepository<Person, Long> {\n}\n----\n\n.Making selected repository methods read-only\n[source,java]\n----\nimport org.springframework.data.neo4j.repository.Neo4jRepository;\nimport org.springframework.data.neo4j.repository.query.Query;\nimport org.springframework.transaction.annotation.Transactional;\n\ninterface PersonRepository extends Neo4jRepository<Person, Long> {\n\n @Transactional(readOnly = true)\n Person findOneByName(String name); // <.>\n\n @Transactional(readOnly = true)\n @Query(\"\"\"\n CALL apoc.search.nodeAll('{Person: \"name\",Movie: [\"title\",\"tagline\"]}','contains','her')\n YIELD node AS n RETURN n\"\"\")\n Person findByCustomQuery(); // <.>\n}\n----\n<.> Why isn't this read-only be default? While it would work for the derived finder above (which we actually know to be read-only),\nwe often have seen cases in which user add a custom `@Query` and implement it via a `MERGE` construct,\nwhich of course is a write operation.\n<.> Custom procedures can do all kinds of things, there's no way at the moment to check for read-only vs write here for us.\n\n.Orchestrate calls to a repository from a service\n[source,java]\n----\nimport java.util.Optional;\n\nimport org.springframework.data.neo4j.repository.Neo4jRepository;\nimport org.springframework.transaction.annotation.Transactional;\n\ninterface PersonRepository extends Neo4jRepository<Person, Long> {\n}\n\ninterface MovieRepository extends Neo4jRepository<Movie, Long> {\n List<Movie> findByLikedByPersonName(String name);\n}\n\npublic class PersonService {\n\n private final PersonRepository personRepository;\n private final MovieRepository movieRepository;\n\n public PersonService(PersonRepository personRepository,\n MovieRepository movieRepository) {\n this.personRepository = personRepository;\n this.movieRepository = movieRepository;\n }\n\n @Transactional(readOnly = true)\n public Optional<PersonDetails> getPerson(Long id) { // <.>\n return this.repository.findById(id)\n .map(person -> {\n var movies = this.movieRepository\n .findByLikedByPersonName(person.getName());\n return new PersonDetails(person, movies);\n });\n }\n}\n----\n<.> Here, several calls to multiple repositories are wrapped in one single, read-only transaction.\n\n.Using Springs `TransactionTemplate` inside private service methods and / or with the Neo4j client\n[source,java]\n----\nimport java.util.Collection;\n\nimport org.neo4j.driver.types.Node;\nimport org.springframework.data.neo4j.core.Neo4jClient;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.TransactionDefinition;\nimport org.springframework.transaction.support.TransactionTemplate;\n\npublic class PersonService {\n\n private final TransactionTemplate readOnlyTx;\n\n private final Neo4jClient neo4jClient;\n\n public PersonService(PlatformTransactionManager transactionManager, Neo4jClient neo4jClient) {\n\n this.readOnlyTx = new TransactionTemplate(transactionManager, // <.>\n new TransactionDefinition() {\n @Override public boolean isReadOnly() {\n return true;\n }\n }\n );\n this.neo4jClient = neo4jClient;\n }\n\n void internalOperation() { // <.>\n\n Collection<Node> nodes = this.readOnlyTx.execute(state -> {\n return neo4jClient.query(\"MATCH (n) RETURN n\").fetchAs(Node.class) // <.>\n .mappedBy((types, record) -> record.get(0).asNode())\n .all();\n });\n }\n}\n----\n<.> Create an instance of the `TransactionTemplate` with the characteristics you need.\nOf course, this can be a global bean, too.\n<.> Reason number one for using the transaction template: Declarative transactions don't work\nin package private or private methods and also not in inner method calls (imagine another method\nin this service calling `internalOperation`) due to their nature being implemented with Aspects\nand proxies.\n<.> The `Neo4jClient` is a fixed utility provided by SDN. It cannot be annotated, but it integrates with Spring.\nSo it gives you everything you would do with the pure driver and without automatic mapping and with\ntransactions. It also obeys declarative transactions.\n\n[[faq.bookmarks.seeding]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Is it important to use read-only transactions for Neo4j cluster?", "heading_level": 3, "file_order": 37, "section_index": 19, "content_hash": "b7dbea0aa74abd9f01a3d75c8fdb70664b3bf9278a5b81bf76c776fa54636280", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:272ce46f8defbecf60f388d812168c6d576ac634c31cdd90b00bff7ebb424a63", "content": "As mentioned briefly in xref:appendix/migrating.adoc#migrating.bookmarks[Bookmark Management], there is no need to configure anything with regard to bookmarks.\nIt may however be useful to retrieve the latest bookmark the SDN transaction system received from a database.\nYou can add a `@Bean` like `BookmarkCapture` to do this:\n\n[source,java,indent=0,tabsize=4]\n.BookmarkCapture.java\n----\nimport java.util.Set;\n\nimport org.neo4j.driver.Bookmark;\nimport org.springframework.context.ApplicationListener;\n\npublic final class BookmarkCapture\n\timplements ApplicationListener<Neo4jBookmarksUpdatedEvent> {\n\n\t@Override\n\tpublic void onApplicationEvent(Neo4jBookmarksUpdatedEvent event) {\n // We make sure that this event is called only once,\n // the thread safe application of those bookmarks is up to your system.\n Set<Bookmark> latestBookmarks = event.getBookmarks();\n\t}\n}\n----\n\nFor seeding the transaction system, a customized transaction manager like the following is required:\n\n[source,java,indent=0,tabsize=4]\n.BookmarkSeedingConfig.java\n----\nimport java.util.Set;\nimport java.util.function.Supplier;\n\nimport org.neo4j.driver.Bookmark;\nimport org.neo4j.driver.Driver;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.neo4j.core.DatabaseSelectionProvider;\nimport org.springframework.data.neo4j.core.transaction.Neo4jBookmarkManager;\nimport org.springframework.data.neo4j.core.transaction.Neo4jTransactionManager;\nimport org.springframework.transaction.PlatformTransactionManager;\n\n@Configuration\npublic class BookmarkSeedingConfig {\n\n\t@Bean\n\tpublic PlatformTransactionManager transactionManager(\n Driver driver, DatabaseSelectionProvider databaseNameProvider) { // <.>\n\n Supplier<Set<Bookmark>> bookmarkSupplier = () -> { // <.>\n Bookmark a = null;\n Bookmark b = null;\n return Set.of(a, b);\n };\n\n Neo4jBookmarkManager bookmarkManager =\n Neo4jBookmarkManager.create(bookmarkSupplier); // <.>\n return new Neo4jTransactionManager(\n driver, databaseNameProvider, bookmarkManager); // <.>\n\t}\n}\n----\n<.> Let Spring inject those\n<.> This supplier can be anything that holds the latest bookmarks you want to bring into the system\n<.> Create the bookmark manager with it\n<.> Pass it on to the customized transaction manager\n\nWARNING: There is *no* need to do any of these things above, unless your application has the need to access or provide\nthis data. If in doubt, don't do either.\n\n[[faq.bookmarks.noop]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Can I retrieve the latest Bookmarks or seed the transaction manager?", "heading_level": 3, "file_order": 37, "section_index": 20, "content_hash": "272ce46f8defbecf60f388d812168c6d576ac634c31cdd90b00bff7ebb424a63", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:4c9f456d3fbbedba2977622e5ea6b14d2c9d88f8bdaffe1011806843982e3e96", "content": "We provide a Noop bookmark manager that effectively disables bookmark management.\n\nWARNING: Use this bookmark manager at your own risk, it will effectively disable any bookmark management by dropping all\nbookmarks and never supplying any. In a cluster you will be at a high risk of experiencing stale reads. In a single\ninstance it will most likely not make any difference.\n+\nIn a cluster this can be a sensible approach only and if only you can tolerate stale reads and are not in danger of\noverwriting old data.\n\nThe following configuration creates a \"noop\" variant of the bookmark manager that will be picked up from relevant classes.\n\n[source,java,indent=0,tabsize=4]\n.BookmarksDisabledConfig.java\n----\nimport org.neo4j.driver.Driver;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.neo4j.core.transaction.Neo4jBookmarkManager;\n\n@Configuration\npublic class BookmarksDisabledConfig {\n\n\t@Bean\n\tpublic Neo4jBookmarkManager neo4jBookmarkManager() {\n\n return Neo4jBookmarkManager.noop();\n\t}\n}\n----\n\nYou can configure the pairs of `Neo4jTransactionManager/Neo4jClient` and `ReactiveNeo4jTransactionManager/ReactiveNeo4jClient` individually, but we recommend in doing so only when you already configuring them for specific database selection needs.\n\n[[faq.annotations.specific]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Can I disable bookmark management?", "heading_level": 3, "file_order": 37, "section_index": 21, "content_hash": "4c9f456d3fbbedba2977622e5ea6b14d2c9d88f8bdaffe1011806843982e3e96", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:27129aff78150babfcee079c0e294396cfd2beddb618e21f7c249ffb7eb06a0d", "content": "No.\nYou are free to use the following, equivalent Spring Data annotations:\n\n[cols=\"4*\",options=\"header\"]\n|===\n\n|SDN specific annotation\n|Spring Data common annotation\n|Purpose\n|Difference\n\n|`org.springframework.data.neo4j.core.schema.Id`\n|`org.springframework.data.annotation.Id`\n|Marks the annotated attribute as the unique id.\n|Specific annotation has no additional features.\n\n|`org.springframework.data.neo4j.core.schema.Node`\n|`org.springframework.data.annotation.Persistent`\n|Marks the class as persistent entity.\n|`@Node` allows customizing the labels\n\n|===\n\n[[faq.ids.assignment]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Do I need to use Neo4j specific annotations?", "heading_level": 2, "file_order": 37, "section_index": 22, "content_hash": "27129aff78150babfcee079c0e294396cfd2beddb618e21f7c249ffb7eb06a0d", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:99006366bac840ce303352451436a696498a61152102e4844674d93271d14e10", "content": "Just use `@Id` without `@GeneratedValue` and fill your id attribute via a constructor parameter or a setter or _wither_.\nSee this https://medium.com/neo4j/neo4j-ogm-and-spring-data-neo4j-a55a866df68c[blog post] for some general remarks about finding good ids.\n\n[[faq.ids.externally]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "How do I use assigned ids?", "heading_level": 2, "file_order": 37, "section_index": 23, "content_hash": "99006366bac840ce303352451436a696498a61152102e4844674d93271d14e10", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:7697d9c8659e70cf8b2afa237697c6e1ed5edc217608aa9325f7d5315de99381", "content": "We provide the interface `org.springframework.data.neo4j.core.schema.IdGenerator`.\nImplement it in any way you want and configure your implementation like this:\n\n[source,java]\n.ThingWithGeneratedId.java\n----\n@Node\npublic class ThingWithGeneratedId {\n\n\t@Id @GeneratedValue(TestSequenceGenerator.class)\n\tprivate String theId;\n}\n----\n\nIf you pass in the name of a class to `@GeneratedValue`, this class must have a no-args default constructor.\nYou can however use a string as well:\n\n[source,java]\n.ThingWithIdGeneratedByBean.java\n----\n@Node\npublic class ThingWithIdGeneratedByBean {\n\n\t@Id @GeneratedValue(generatorRef = \"idGeneratingBean\")\n\tprivate String theId;\n}\n----\n\nWith that, `idGeneratingBean` refers to a bean in the Spring context.\nThis might be useful for sequence generating.\n\nNOTE: Setters are not required on non-final fields for the id.\n\n[[template-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "How do I use externally generated ids?", "heading_level": 2, "file_order": 37, "section_index": 24, "content_hash": "7697d9c8659e70cf8b2afa237697c6e1ed5edc217608aa9325f7d5315de99381", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:12c0b89e235560d764b6a49699509dda33537b77d710af90fda55cf85eaef121", "content": "No.\nHave a look at the xref:introduction-and-preface/building-blocks.adoc#sdn-building-blocks[SDN building blocks] and find the `Neo4jTemplate` or the `ReactiveNeo4jTemplate`.\n\nThose templates know your domain and provide all necessary basic CRUD methods for retrieving, writing and counting entities.\n\nThis is our canonical movie example with the imperative template:\n\n[source,java]\n[[imperative-template-example]]\n.TemplateExampleTest.java\n----\nimport java.util.Collections;\nimport java.util.Optional;\n\nimport org.junit.jupiter.api.Test;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;\nimport org.springframework.data.neo4j.core.Neo4jTemplate;\nimport org.springframework.data.neo4j.documentation.domain.MovieEntity;\nimport org.springframework.data.neo4j.documentation.domain.PersonEntity;\nimport org.springframework.data.neo4j.documentation.domain.Roles;\nimport org.springframework.data.neo4j.test.Neo4jIntegrationTest;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@Neo4jIntegrationTest\n@DataNeo4jTest\npublic class TemplateExampleTest {\n\n\t@Test\n\tvoid shouldSaveAndReadEntities(@Autowired Neo4jTemplate neo4jTemplate) {\n\n MovieEntity movie = new MovieEntity(\"The Love Bug\",\n \"A movie that follows the adventures of Herbie, Herbie's driver, \"\n + \"Jim Douglas (Dean Jones), and Jim's love interest, \" + \"Carole Bennett (Michele Lee)\");\n\n Roles roles1 = new Roles(new PersonEntity(1931, \"Dean Jones\"), Collections.singletonList(\"Didi\"));\n Roles roles2 = new Roles(new PersonEntity(1942, \"Michele Lee\"), Collections.singletonList(\"Michi\"));\n movie.getActorsAndRoles().add(roles1);\n movie.getActorsAndRoles().add(roles2);\n\n MovieEntity result = neo4jTemplate.save(movie);\n assertThat(result.getActorsAndRoles()).allSatisfy(relationship -> assertThat(relationship.getId()).isNotNull());\n\n Optional<PersonEntity> person = neo4jTemplate.findById(\"Dean Jones\", PersonEntity.class);\n assertThat(person).map(PersonEntity::getBorn).hasValue(1931);\n\n assertThat(neo4jTemplate.count(PersonEntity.class)).isEqualTo(2L);\n\t}\n\n}\n----\n\nAnd here is the reactive version, omitting the setup for brevity:\n\n[source,java]\n[[reactive-template-example]]\n.ReactiveTemplateExampleTest.java\n----\nimport java.util.Collections;\n\nimport org.junit.jupiter.api.Test;\nimport org.testcontainers.neo4j.Neo4jContainer;\nimport org.testcontainers.junit.jupiter.Container;\nimport org.testcontainers.junit.jupiter.Testcontainers;\nimport reactor.test.StepVerifier;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;\nimport org.springframework.data.neo4j.core.ReactiveNeo4jTemplate;\nimport org.springframework.data.neo4j.documentation.domain.MovieEntity;\nimport org.springframework.data.neo4j.documentation.domain.PersonEntity;\nimport org.springframework.data.neo4j.documentation.domain.Roles;\nimport org.springframework.test.context.DynamicPropertyRegistry;\nimport org.springframework.test.context.DynamicPropertySource;\n\n@Testcontainers\n@DataNeo4jTest\nclass ReactiveTemplateExampleTest {\n\n\t@Container\n\tprivate static Neo4jContainer neo4jContainer = new Neo4jContainer(\"neo4j:5\");\n\n\t@DynamicPropertySource\n\tstatic void neo4jProperties(DynamicPropertyRegistry registry) {\n registry.add(\"org.neo4j.driver.uri\", neo4jContainer::getBoltUrl);\n registry.add(\"org.neo4j.driver.authentication.username\", () -> \"neo4j\");\n registry.add(\"org.neo4j.driver.authentication.password\", neo4jContainer::getAdminPassword);\n\t}\n\n\t@Test\n\tvoid shouldSaveAndReadEntities(@Autowired ReactiveNeo4jTemplate neo4jTemplate) {\n\n MovieEntity movie = new MovieEntity(\"The Love Bug\",\n \"A movie that follows the adventures of Herbie, Herbie's driver, Jim Douglas (Dean Jones), and Jim's love interest, Carole Bennett (Michele Lee)\");\n\n Roles role1 = new Roles(new PersonEntity(1931, \"Dean Jones\"), Collections.singletonList(\"Didi\"));\n Roles role2 = new Roles(new PersonEntity(1942, \"Michele Lee\"), Collections.singletonList(\"Michi\"));\n movie.getActorsAndRoles().add(role1);\n movie.getActorsAndRoles().add(role2);\n\n StepVerifier.create(neo4jTemplate.save(movie)).expectNextCount(1L).verifyComplete();\n\n StepVerifier.create(neo4jTemplate.findById(\"Dean Jones\", PersonEntity.class).map(PersonEntity::getBorn))\n .expectNext(1931)\n .verifyComplete();\n\n StepVerifier.create(neo4jTemplate.count(PersonEntity.class)).expectNext(2L).verifyComplete();\n\t}\n\n}\n----\n\nPlease note that both examples use `@DataNeo4jTest` from Spring Boot.\n\n[[faq.custom-queries-with-page-and-slice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Do I have to create repositories for each domain class?", "heading_level": 2, "file_order": 37, "section_index": 25, "content_hash": "12c0b89e235560d764b6a49699509dda33537b77d710af90fda55cf85eaef121", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:0fc0cf1e71d8041ffa590d6c532068c86e0dd0b3ce92d22f6faa9124fcb573e1", "content": "While you don't have to provide anything else apart a `Pageable` as a parameter on derived finder methods\nthat return a `Page<T>` or a `Slice<T>`, you must prepare your custom query to handle the pageable.\n<<custom-queries-with-page-and-slice-examples>> gives you an overview about what's needed.\n\n[[custom-queries-with-page-and-slice-examples]]\n[source,java]\n.Pages and Slices\n----\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.neo4j.repository.Neo4jRepository;\nimport org.springframework.data.neo4j.repository.query.Query;\n\npublic interface MyPersonRepository extends Neo4jRepository<Person, Long> {\n\n Page<Person> findByName(String name, Pageable pageable); // <.>\n\n @Query(\"\"\n + \"MATCH (n:Person) WHERE n.name = $name RETURN n \"\n + \"ORDER BY n.name ASC SKIP $skip LIMIT $limit\"\n )\n Slice<Person> findSliceByName(String name, Pageable pageable); // <.>\n\n @Query(\n value = \"\"\n + \"MATCH (n:Person) WHERE n.name = $name RETURN n \"\n + \"ORDER BY n.name ASC SKIP $skip LIMIT $limit\",\n countQuery = \"\"\n + \"MATCH (n:Person) WHERE n.name = $name RETURN count(n)\"\n )\n Page<Person> findPageByName(String name, Pageable pageable); // <.>\n}\n----\n<.> A derived finder method that creates a query for you.\nIt handles the `Pageable` for you.\nYou should use a sorted pageable.\n<.> This method uses `@Query` to define a custom query. It returns a `Slice<Person>`.\nA slice does not know about the total number of pages, so the custom query\ndoesn't need a dedicated count query. SDN will notify you that it estimates the next slice.\nThe Cypher template must spot both `$skip` and `$limit` Cypher parameter.\nIf you omit them, SDN will issue a warning. The will probably not match your expectations.\nAlso, the `Pageable` should be unsorted and you should provide a stable order.\nWe won't use the sorting information from the pageable.\n<.> This method returns a page. A page knows about the exact number of total pages.\nTherefore, you must specify an additional count query.\nAll other restrictions from the second method apply.\n\n[[faq.path-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "How do I use custom queries with repository methods returning `Page<T>` or `Slice<T>`?", "heading_level": 2, "file_order": 37, "section_index": 26, "content_hash": "0fc0cf1e71d8041ffa590d6c532068c86e0dd0b3ce92d22f6faa9124fcb573e1", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:d781bd99c080e260f6ed0efe3b4581d423986e6f32aed2102704bc52399a2335", "content": "A series of connected nodes and relationships is called a \"path\" in Neo4j.\nCypher allows paths to be named using an identifier, as exemplified by:\n\n[source,cypher]\n----\np = (a)-[*3..5]->(b)\n----\n\nor as in the infamous Movie graph, that includes the following path (in that case, one of the shortest path between two actors):\n\n[[bacon-distance]]\n[source,cypher]\n.The \"Bacon\" distance\n----\nMATCH p=shortestPath((bacon:Person {name:\"Kevin Bacon\"})-[*]-(meg:Person {name:\"Meg Ryan\"}))\nRETURN p\n----\n\nWhich looks like this:\n\nimage::image$bacon-distance.png[]\n\nWe find 3 nodes labeled `Vertex` and 2 nodes labeled `Movie`. Both can be mapped with a custom query.\nAssume there's a node entity for both `Vertex` and `Movie` as well as `Actor` taking care of the relationship:\n\n[source,java]\n.\"Standard\" movie graph domain model\n----\n@Node\npublic final class Person {\n\n\t@Id @GeneratedValue\n\tprivate final Long id;\n\n\tprivate final String name;\n\n\tprivate Integer born;\n\n\t@Relationship(\"REVIEWED\")\n\tprivate List<Movie> reviewed = new ArrayList<>();\n}\n\n@RelationshipProperties\npublic final class Actor {\n\n\t@RelationshipId\n\tprivate final Long id;\n\n\t@TargetNode\n\tprivate final Person person;\n\n\tprivate final List<String> roles;\n}\n\n@Node\npublic final class Movie {\n\n\t@Id\n\tprivate final String title;\n\n\t@Property(\"tagline\")\n\tprivate final String description;\n\n\t@Relationship(value = \"ACTED_IN\", direction = Direction.INCOMING)\n\tprivate final List<Actor> actors;\n}\n----\n\nWhen using a query as shown in <<bacon-distance>> for a domain class of type `Vertex` like this\n\n[source,java]\n----\ninterface PeopleRepository extends Neo4jRepository<Person, Long> {\n @Query(\"\"\n + \"MATCH p=shortestPath((bacon:Person {name: $person1})-[*]-(meg:Person {name: $person2}))\\n\"\n + \"RETURN p\"\n )\n List<Person> findAllOnShortestPathBetween(@Param(\"person1\") String person1, @Param(\"person2\") String person2);\n}\n----\n\nit will retrieve all people from the path and map them.\nIf there are relationship types on the path like `REVIEWED` that are also present on the domain, these\nwill be filled accordingly from the path.\n\nWARNING: Take special care when you use nodes hydrated from a path based query to save data.\nIf not all relationships are hydrated, data will be lost.\n\nThe other way round works as well. The same query can be used with the `Movie` entity.\nIt then will only populate movies.\nThe following listing shows how todo this as well as how the query can be enriched with additional data\nnot found on the path. That data is used to correctly populate the missing relationships (in that case, all the actors)\n\n[source,java]\n----\ninterface MovieRepository extends Neo4jRepository<Movie, String> {\n\n @Query(\"\"\n + \"MATCH p=shortestPath(\\n\"\n + \"(bacon:Person {name: $person1})-[*]-(meg:Person {name: $person2}))\\n\"\n + \"WITH p, [n IN nodes(p) WHERE n:Movie] AS x\\n\"\n + \"UNWIND x AS m\\n\"\n + \"MATCH (m) <-[r:DIRECTED]-(d:Person)\\n\"\n + \"RETURN p, collect(r), collect(d)\"\n )\n List<Movie> findAllOnShortestPathBetween(@Param(\"person1\") String person1, @Param(\"person2\") String person2);\n}\n----\n\nThe query returns the path plus all relationships and related nodes collected so that the movie entities are fully hydrated.\n\nThe path mapping works for single paths as well for multiple records of paths (which are returned by the `allShortestPath` function.)\n\nTIP: Named paths can be used efficiently to populate and return more than just a root node, see xref:appendix/custom-queries.adoc#custom-query.paths[].\n\n[[faq.custom-queries-and-custom-mappings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Can I map named paths?", "heading_level": 2, "file_order": 37, "section_index": 27, "content_hash": "d781bd99c080e260f6ed0efe3b4581d423986e6f32aed2102704bc52399a2335", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:f71ea6722efec218d5bc3de9c9083c50b99407e179d10539e173f4d4387c1f41", "content": "No, `@Query` is *not* the only way to run custom queries.\nThe annotation is comfortable in situations in which your custom query fills your domain completely.\nPlease remember that SDN assumes your mapped domain model to be the truth.\nThat means if you use a custom query via `@Query` that only fills a model partially, you are in danger of using the same\nobject to write the data back which will eventually erase or overwrite data you didn't consider in your query.\n\nSo, please use repositories and declarative methods with `@Query` in all cases where the result is shaped like your domain\nmodel or you are sure you don't use a partially mapped model for write commands.\n\nWhat are the alternatives?\n\n* xref:projections/sdn-projections.adoc#projections.sdn.general-remarks[Projections] might be already enough to shape your *view* on the graph: They can be used to define\nthe depth of fetching properties and related entities in an explicit way: By modelling them.\n* If your goal is to make only the conditions of your queries *dynamic*, then have a look at the xref:repositories/core-extensions.adoc#core.extensions.querydsl[`QuerydslPredicateExecutor`]\nbut especially our own variant of it, the `CypherdslConditionExecutor`. Both xref:repositories/sdn-extension.adoc#sdn-mixins[mixins] allow adding conditions to\nthe full queries we create for you. Thus, you will have the domain fully populated together with custom conditions.\nOf course, your conditions must work with what we generate. Find the names of the root node, the related nodes and more\nxref:appendix/custom-queries.adoc#custom-queries[here].\n* Use the https://neo4j.github.io/cypher-dsl[Cypher-DSL] via the `CypherdslStatementExecutor` or the `ReactiveCypherdslStatementExecutor`.\nThe Cypher-DSL is predestined to create dynamic queries. In the end, it's what SDN uses under the hood anyway. The corresponding\nmixins work both with the domain type of repository itself and with projections (something that the mixins for adding\nconditions don't).\n\nIf you think that you can solve your problem with a partially dynamic query or a full dynamic query together with a projection,\nplease jump back now to the chapter xref:repositories/sdn-extension.adoc#sdn-mixins[about Spring Data Neo4j Mixins].\n\nOtherwise, please read up on two things: xref:repositories/custom-implementations.adoc#repositories.custom-implementations[custom repository fragments]\nthe xref:introduction-and-preface/building-blocks.adoc#sdn-building-blocks[levels of abstractions] we offer in SDN.\n\nWhy speaking about custom repository fragments now?\n\n* You might have more complex situation in which more than one dynamic query is required, but the queries still belong\nconceptually in a repository and not in the service layer\n* Your custom queries return a graph shaped result that fits not quite to your domain model\nand therefore the custom query should be accompanied by a custom mapping as well\n* You have the need for interacting with the driver, i.e. for bulk loads that should not go through object mapping.\n\nAssume the following repository _declaration_ that basically aggregates one base repository plus 3 fragments:\n\n[source,java,indent=0,tabsize=4]\n[[aggregating-repository]]\n.A repository composed of several fragments\n----\n/*\n * Copyright 2011-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.neo4j.documentation.repositories.custom_queries;\n\nimport org.springframework.data.neo4j.documentation.domain.MovieEntity;\nimport org.springframework.data.neo4j.repository.Neo4jRepository;\n\npublic interface MovieRepository\n\t\textends Neo4jRepository<MovieEntity, String>, DomainResults, NonDomainResults, LowlevelInteractions {\n\n}\n----\n\nThe repository contains xref:getting-started.adoc#movie-entity[Movies] as shown in xref:getting-started.adoc#example-node-spring-boot-project[the getting started section].\n\nThe additional interface from which the repository extends (`DomainResults`, `NonDomainResults` and `LowlevelInteractions`)\nare the fragments that addresses all the concerns above.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Is `@Query` the only way to use custom queries?", "heading_level": 2, "file_order": 37, "section_index": 28, "content_hash": "f71ea6722efec218d5bc3de9c9083c50b99407e179d10539e173f4d4387c1f41", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:100c1f297290732b32e0e29e0c77dc59293cdfa08ddd266c045c22b6df571344", "content": "The fragment `DomainResults` declares one additional method `findMoviesAlongShortestPath`:\n\n[source,java,indent=0,tabsize=4]\n[[domain-results]]\n.DomainResults fragment\n----\n/*\n * Copyright 2011-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.neo4j.documentation.repositories.custom_queries;\n\nimport java.util.List;\n\nimport org.springframework.data.neo4j.documentation.domain.MovieEntity;\nimport org.springframework.data.neo4j.documentation.domain.PersonEntity;\nimport org.springframework.transaction.annotation.Transactional;\n\ninterface DomainResults {\n\n\t@Transactional(readOnly = true)\n\tList<MovieEntity> findMoviesAlongShortestPath(PersonEntity from, PersonEntity to);\n\n}\n----\n\nThis method is annotated with `@Transactional(readOnly = true)` to indicate that readers can answer it.\nIt cannot be derived by SDN but would need a custom query.\nThis custom query is provided by the one implementation of that interface.\nThe implementation has the same name with the suffix `Impl`:\n\n[source,java,indent=0,tabsize=4]\n[[domain-results-impl]]\n.A fragment implementation using the Neo4jTemplate\n----\n/*\n * Copyright 2011-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.neo4j.documentation.repositories.custom_queries;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.neo4j.cypherdsl.core.Cypher;\n\nimport org.springframework.data.neo4j.core.Neo4jTemplate;\nimport org.springframework.data.neo4j.documentation.domain.MovieEntity;\nimport org.springframework.data.neo4j.documentation.domain.PersonEntity;\n\nimport static org.neo4j.cypherdsl.core.Cypher.anyNode;\nimport static org.neo4j.cypherdsl.core.Cypher.listWith;\nimport static org.neo4j.cypherdsl.core.Cypher.name;\nimport static org.neo4j.cypherdsl.core.Cypher.node;\nimport static org.neo4j.cypherdsl.core.Cypher.parameter;\n\nclass DomainResultsImpl implements DomainResults {\n\n\tprivate final Neo4jTemplate neo4jTemplate; // <.>\n\n\tDomainResultsImpl(Neo4jTemplate neo4jTemplate) {\n\t\tthis.neo4jTemplate = neo4jTemplate;\n\t}\n\n\t@Override\n\tpublic List<MovieEntity> findMoviesAlongShortestPath(PersonEntity from, PersonEntity to) {\n\n\t\tvar p1 = node(\"Person\").withProperties(\"name\", parameter(\"person1\"));\n\t\tvar p2 = node(\"Person\").withProperties(\"name\", parameter(\"person2\"));\n\t\tvar shortestPath = Cypher.shortestK(1).named(\"p\").definedBy(p1.relationshipBetween(p2).unbounded());\n\t\tvar p = shortestPath.getRequiredSymbolicName();\n\t\tvar statement = Cypher.match(shortestPath)\n\t\t\t.with(p, listWith(name(\"n\")).in(Cypher.nodes(shortestPath))\n\t\t\t\t.where(anyNode().named(\"n\").hasLabels(\"Movie\"))\n\t\t\t\t.returning()\n\t\t\t\t.as(\"mn\"))\n\t\t\t.unwind(name(\"mn\"))\n\t\t\t.as(\"m\")\n\t\t\t.with(p, name(\"m\"))\n\t\t\t.match(node(\"Person\").named(\"d\").relationshipTo(anyNode(\"m\"), \"DIRECTED\").named(\"r\"))\n\t\t\t.returning(p, Cypher.collect(name(\"r\")), Cypher.collect(name(\"d\")))\n\t\t\t.build();\n\n\t\tMap<String, Object> parameters = new HashMap<>();\n\t\tparameters.put(\"person1\", from.getName());\n\t\tparameters.put(\"person2\", to.getName());\n\t\treturn this.neo4jTemplate.findAll(statement, parameters, MovieEntity.class); // <.>\n\t}\n\n}\n----\n<.> The `Neo4jTemplate` is injected by the runtime through the constructor of `DomainResultsImpl`. No need for `@Autowired`.\n<.> The Cypher-DSL is used to build a complex statement (pretty much the same as shown in <<faq.path-mapping,path mapping>>.)\nThe statement can be passed directly to the template.\n\nThe template has overloads for String-based queries as well, so you could write down the query as String as well.\nThe important takeaway here is:\n\n* The template \"knows\" your domain objects and maps them accordingly\n* `@Query` is not the only option to define custom queries\n* They can be generated in various ways\n* The `@Transactional` annotation is respected", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Using complex, dynamic custom queries but still returning domain types", "heading_level": 3, "file_order": 37, "section_index": 29, "content_hash": "100c1f297290732b32e0e29e0c77dc59293cdfa08ddd266c045c22b6df571344", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:ee2d1fd2c27eedb216207cf56222c06db50cb637b2a5416d72adf527a42ad6d4", "content": "Often times a custom query indicates custom results.\nShould all of those results be mapped as `@Node`? Of course not! Many times those objects represents read commands\nand are not meant to be used as write commands.\nIt is also not unlikely that SDN cannot or want not map everything that is possible with Cypher.\nIt does however offer several hooks to run your own mapping: On the `Neo4jClient`.\nThe benefit of using the SDN `Neo4jClient` over the driver:\n\n* The `Neo4jClient` is integrated with Springs transaction management\n* It has a fluent API for binding parameters\n* It has a fluent API exposing both the records and the Neo4j type system so that you can access\neverything in your result to execute the mapping\n\nDeclaring the fragment is exactly the same as before:\n\n[source,java,indent=0,tabsize=4]\n[[non-domain-results]]\n.A fragment declaring non-domain-type results\n----\n/*\n * Copyright 2011-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.neo4j.documentation.repositories.custom_queries;\n\nimport java.util.Collection;\n\nimport org.springframework.data.neo4j.documentation.domain.MovieEntity;\nimport org.springframework.transaction.annotation.Transactional;\n\ninterface NonDomainResults {\n\n\t@Transactional(readOnly = true)\n\tCollection<Result> findRelationsToMovie(MovieEntity movie); // <.>\n\n\tclass Result {\n\n\t\t// <.>\n\t\tpublic final String name;\n\n\t\tpublic final String typeOfRelation;\n\n\t\tResult(String name, String typeOfRelation) {\n\t\t\tthis.name = name;\n\t\t\tthis.typeOfRelation = typeOfRelation;\n\t\t}\n\n\t}\n\n}\n----\n<.> This is a made up non-domain result. A real world query result would probably look more complex.\n<.> The method this fragment adds. Again, the method is annotated with Spring's `@Transactional`\n\nWithout an implementation for that fragment, startup would fail, so here it is:\n\n[source,java,indent=0,tabsize=4]\n[[non-domain-results-impl]]\n.A fragment implementation using the Neo4jClient\n----\n/*\n * Copyright 2011-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.neo4j.documentation.repositories.custom_queries;\n\nimport java.util.Collection;\n\nimport org.springframework.data.neo4j.core.Neo4jClient;\nimport org.springframework.data.neo4j.documentation.domain.MovieEntity;\n\nclass NonDomainResultsImpl implements NonDomainResults {\n\n\tprivate final Neo4jClient neo4jClient; // <.>\n\n\tNonDomainResultsImpl(Neo4jClient neo4jClient) {\n\t\tthis.neo4jClient = neo4jClient;\n\t}\n\n\t@Override\n\tpublic Collection<Result> findRelationsToMovie(MovieEntity movie) {\n\t\treturn this.neo4jClient\n\t\t\t.query(\"\" + \"MATCH (people:Person)-[relatedTo]-(:Movie {title: $title}) \" + \"RETURN people.name AS name, \"\n\t\t\t\t\t+ \"       Type(relatedTo) as typeOfRelation\") // <.>\n\t\t\t.bind(movie.getTitle())\n\t\t\t.to(\"title\") // <.>\n\t\t\t.fetchAs(Result.class) // <.>\n\t\t\t.mappedBy((typeSystem, record) -> new Result(record.get(\"name\").asString(),\n\t\t\t\t\trecord.get(\"typeOfRelation\").asString())) // <.>\n\t\t\t.all(); // <.>\n\t}\n\n}\n----\n<.> Here we use the `Neo4jClient`, as provided by the infrastructure.\n<.> The client takes only in Strings, but the Cypher-DSL can still be used when rendering into a String\n<.> Bind one single value to a named parameter. There's also an overload to bind a whole map of parameters\n<.> This is the type of the result you want\n<.> And finally, the `mappedBy` method, exposing one `Record` for each entry in the result plus the drivers type system if needed.\nThis is the API in which you hook in for your custom mappings\n\nThe whole query runs in the context of a Spring transaction, in this case, a read-only one.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Using custom queries and custom mappings", "heading_level": 3, "file_order": 37, "section_index": 30, "content_hash": "ee2d1fd2c27eedb216207cf56222c06db50cb637b2a5416d72adf527a42ad6d4", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:6f573393e7b02ff518774aeb72db78d27174876a1783230a86a79ab4ac3027ee", "content": "Sometimes you might want to do bulk loadings from a repository or delete whole subgraphs or interact in very specific ways\nwith the Neo4j Java-Driver. This is possible as well. The following example shows how:\n\n[source,java,indent=0,tabsize=4]\n[[low-level-interactions]]\n.Fragments using the plain driver\n----\n/*\n * Copyright 2011-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.neo4j.documentation.repositories.custom_queries;\n\ninterface LowlevelInteractions {\n\n\tint deleteGraph();\n\n}\n\n/*\n * Copyright 2011-present the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.neo4j.documentation.repositories.custom_queries;\n\nimport org.neo4j.driver.Driver;\nimport org.neo4j.driver.Session;\nimport org.neo4j.driver.summary.SummaryCounters;\n\nclass LowlevelInteractionsImpl implements LowlevelInteractions {\n\n\tprivate final Driver driver; // <.>\n\n\tLowlevelInteractionsImpl(Driver driver) {\n\t\tthis.driver = driver;\n\t}\n\n\t@Override\n\tpublic int deleteGraph() {\n\n\t\ttry (Session session = this.driver.session()) {\n\t\t\tSummaryCounters counters = session.executeWrite(tx -> tx.run(\"MATCH (n) DETACH DELETE n\").consume()) // <.>\n\t\t\t\t.counters();\n\t\t\treturn counters.nodesDeleted() + counters.relationshipsDeleted();\n\t\t}\n\t}\n\n}\n----\n<.> Work with the driver directly. As with all the examples: There is no need for `@Autowired` magic. All the fragments\nare actually testable on their own.\n<.> The use case is made up. Here we use a driver managed transaction deleting the whole graph and return the number of\ndeleted nodes and relationships\n\nThis interaction does of course not run in a Spring transaction, as the driver does not know about Spring.\n\nPutting it all together, this test succeeds:\n\n[source,java,indent=0,tabsize=4]\n[[custom-queries-test]]\n.Testing the composed repository\n----\n\t@Test\n\tvoid customRepositoryFragmentsShouldWork(@Autowired PersonRepository people, @Autowired MovieRepository movies) {\n\n\t\tPersonEntity meg = people.findById(\"Meg Ryan\").get();\n\t\tPersonEntity kevin = people.findById(\"Kevin Bacon\").get();\n\n\t\tList<MovieEntity> moviesBetweenMegAndKevin = movies.findMoviesAlongShortestPath(meg, kevin);\n\t\tassertThat(moviesBetweenMegAndKevin).isNotEmpty();\n\n\t\tCollection<NonDomainResults.Result> relatedPeople = movies\n\t\t\t.findRelationsToMovie(moviesBetweenMegAndKevin.get(0));\n\t\tassertThat(relatedPeople).isNotEmpty();\n\n\t\tassertThat(movies.deleteGraph()).isGreaterThan(0);\n\t\tassertThat(movies.findAll()).isEmpty();\n\t\tassertThat(people.findAll()).isEmpty();\n\t}\n----\n\nAs a final word: All three interfaces and implementations are picked up by Spring Data Neo4j automatically.\nThere is no need for further configuration.\nAlso, the same overall repository could have been created with only one additional fragment (the interface defining all three methods)\nand one implementation. The implementation would than have had all three abstractions injected (template, client and driver).\n\nAll of this applies of course to reactive repositories as well.\nThey would work with the `ReactiveNeo4jTemplate` and `ReactiveNeo4jClient` and the reactive session provided by the driver.\n\nIf you have recurring methods for all repositories, you could swap out the default repository implementation.\n\n[[faq.custom-base-repositories]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Low level interactions", "heading_level": 4, "file_order": 37, "section_index": 31, "content_hash": "6f573393e7b02ff518774aeb72db78d27174876a1783230a86a79ab4ac3027ee", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:60269fb11777d725e71c4e2dd347e4fd4da5f9e13309519fbf7eadb08cad9a0f", "content": "Basically the same ways as the shared Spring Data Commons documentation shows for Spring Data JPA in xref:repositories/custom-implementations.adoc#repositories.customize-base-repository[Customize the Base Repository].\nOnly that in our case you would extend from\n\n[source,java,indent=0,tabsize=4]\n[[custom-base-repository]]\n.Custom base repository\n----\n\tpublic static class MyRepositoryImpl<T, ID> extends SimpleNeo4jRepository<T, ID> {\n\n\t\tMyRepositoryImpl(Neo4jOperations neo4jOperations, Neo4jEntityInformation<T, ID> entityInformation) {\n\t\t\tsuper(neo4jOperations, entityInformation); // <.>\n\t\t}\n\n\t\t@Override\n\t\tpublic List<T> findAll() {\n\t\t\tthrow new UnsupportedOperationException(\"This implementation does not support `findAll`\");\n\t\t}\n\n\t}\n----\n<.> This signature is required by the base class. Take the `Neo4jOperations` (the actual specification of the `Neo4jTemplate`)\nand the entity information and store them on an attribute if needed.\n\nIn this example we forbid the use of the `findAll` method.\nYou could add methods taking in a fetch depth and run custom queries based on that depth.\nOne way to do this is shown in <<domain-results>>.\n\nTo enable this base repository for all declared repositories enable Neo4j repositories with: `@EnableNeo4jRepositories(repositoryBaseClass = MyRepositoryImpl.class)`.\n\n[[faq.entities.auditing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "How do I use custom Spring Data Neo4j base repositories?", "heading_level": 2, "file_order": 37, "section_index": 32, "content_hash": "60269fb11777d725e71c4e2dd347e4fd4da5f9e13309519fbf7eadb08cad9a0f", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:d0d914edbd3715a1f0d0080d8f4f555cf98df55d2a7b5294abd3fd088250ec4c", "content": "All Spring Data annotations are supported.\nThose are\n\n* `org.springframework.data.annotation.CreatedBy`\n* `org.springframework.data.annotation.CreatedDate`\n* `org.springframework.data.annotation.LastModifiedBy`\n* `org.springframework.data.annotation.LastModifiedDate`\n\nxref:auditing.adoc[Auditing] gives you a general view how to use auditing in the bigger context of Spring Data Commons.\nThe following listing presents every configuration option provided by Spring Data Neo4j:\n\n[source,java,indent=0,tabsize=4]\n.Enabling and configuring Neo4j auditing\n----\n@Configuration\n@EnableNeo4jAuditing(modifyOnCreate = false, // <.>\n auditorAwareRef = \"auditorProvider\", // <.>\n dateTimeProviderRef = \"fixedDateTimeProvider\" // <.>\n)\nclass AuditingConfig {\n\n\t@Bean\n\tAuditorAware<String> auditorProvider() {\n return () -> Optional.of(\"A user\");\n\t}\n\n\t@Bean\n\tDateTimeProvider fixedDateTimeProvider() {\n return () -> Optional.of(AuditingITBase.DEFAULT_CREATION_AND_MODIFICATION_DATE);\n\t}\n\n}\n----\n<.> Set to true if you want the modification data to be written during creating as well\n<.> Use this attribute to specify the name of the bean that provides the auditor (i.e. a user name)\n<.> Use this attribute to specify the name of a bean that provides the current date. In this case\na fixed date is used as the above configuration is part of our tests\n\nThe reactive version is basically the same apart from the fact the auditor aware bean is of type `ReactiveAuditorAware`,\nso that the retrieval of an auditor is part of the reactive flow.\n\nIn addition to those auditing mechanism you can add as many beans implementing `BeforeBindCallback<T>` or `ReactiveBeforeBindCallback<T>`\nto the context. These beans will be picked up by Spring Data Neo4j and called in order (in case they implement `Ordered` or\nare annotated with `@Order`) just before an entity is persisted.\n\nThey can modify the entity or return a completely new one.\nThe following example adds one callback to the context that changes one attribute before the entity is persisted:\n\n[source,java,indent=0,tabsize=4]\n.Modifying entities before save\n----\nimport java.util.UUID;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.neo4j.core.mapping.callback.AfterConvertCallback;\nimport org.springframework.data.neo4j.core.mapping.callback.BeforeBindCallback;\nimport org.springframework.data.neo4j.integration.shared.common.ThingWithAssignedId;\n\n@Configuration\nclass CallbacksConfig {\n\n\t@Bean\n\tBeforeBindCallback<ThingWithAssignedId> nameChanger() {\n return entity -> {\n ThingWithAssignedId updatedThing = new ThingWithAssignedId(entity.getTheId(),\n entity.getName() + \" (Edited)\");\n return updatedThing;\n };\n\t}\n\n\t@Bean\n\tAfterConvertCallback<ThingWithAssignedId> randomValueAssigner() {\n return (entity, definition, source) -> {\n entity.setRandomValue(UUID.randomUUID().toString());\n return entity;\n };\n\t}\n\n}\n----\n\nNo additional configuration is required.\n\n[[faq.find-by-example]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "How do I audit entities?", "heading_level": 2, "file_order": 37, "section_index": 33, "content_hash": "d0d914edbd3715a1f0d0080d8f4f555cf98df55d2a7b5294abd3fd088250ec4c", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:bd8d2c813566529c625691b6b3fa7b754fa0551cb2e115f51a811db479fbbed0", "content": "\"Find by example\" is a new feature in SDN.\nYou instantiate an entity or use an existing one.\nWith this instance you create an `org.springframework.data.domain.Example`.\nIf your repository extends `org.springframework.data.neo4j.repository.Neo4jRepository` or `org.springframework.data.neo4j.repository.ReactiveNeo4jRepository`, you can immediately use the available `findBy` methods taking in an example, like shown in xref:#find-by-example-example[findByExample].\n\n[source,java]\n[[find-by-example-example]]\n.findByExample in Action\n----\nExample<MovieEntity> movieExample = Example.of(new MovieEntity(\"The Matrix\", null));\nFlux<MovieEntity> movies = this.movieRepository.findAll(movieExample);\n\nmovieExample = Example.of(\n new MovieEntity(\"Matrix\", null),\n ExampleMatcher\n .matchingAny()\n .withMatcher(\n \"title\",\n ExampleMatcher.GenericPropertyMatcher.of(ExampleMatcher.StringMatcher.CONTAINING)\n )\n);\nmovies = this.movieRepository.findAll(movieExample);\n----\n\nYou can also negate individual properties. This will add an appropriate `NOT` operation, thus turning an `=` into a `<>`.\nAll scalar datatypes and all string operators are supported:\n\n[source,java,indent=0,tabsize=4]\n[[find-by-example-example-with-negated-properties]]\n.findByExample with negated values\n----\nExample<MovieEntity> movieExample = Example.of(\n new MovieEntity(\"Matrix\", null),\n ExampleMatcher\n .matchingAny()\n .withMatcher(\n \"title\",\n ExampleMatcher.GenericPropertyMatcher.of(ExampleMatcher.StringMatcher.CONTAINING)\n )\n .withTransformer(\"title\", Neo4jPropertyValueTransformers.notMatching())\n);\nFlux<MovieEntity> allMoviesThatNotContainMatrix = this.movieRepository.findAll(movieExample);\n----\n\n[[faq.spring-boot.sdn]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "How do I use \"Find by example\"?", "heading_level": 2, "file_order": 37, "section_index": 34, "content_hash": "bd8d2c813566529c625691b6b3fa7b754fa0551cb2e115f51a811db479fbbed0", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:7b49346f2cd6b5eb065c2f9bad06a2582c244072a8f0c957548fea87932aac4a", "content": "No, you don't.\nWhile the automatic configuration of many Spring aspects through Spring Boot takes away a lot of manual cruft and is the recommended approach for setting up new Spring projects, you don't need to have to use this.\n\nThe following dependency is required for the solutions described above:\n\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<dependency>\n\t<groupId>{neo4jGroupId}</groupId>\n\t<artifactId>{artifactId}</artifactId>\n\t<version>{version}</version>\n</dependency>\n----\n\nThe coordinates for a Gradle setup are the same.\n\nTo select a different database - either statically or dynamically - you can add a Bean of type `DatabaseSelectionProvider` as explained in <<faq.multidatabase>>.\nFor a reactive scenario, we provide `ReactiveDatabaseSelectionProvider`.\n\n[[faq.sdn-without-spring-boot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Do I need Spring Boot to use Spring Data Neo4j?", "heading_level": 2, "file_order": 37, "section_index": 35, "content_hash": "7b49346f2cd6b5eb065c2f9bad06a2582c244072a8f0c957548fea87932aac4a", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:d07d47efe065f8b7b05ddb6b40fa0768265111144bef6e7f3f137f683376aefa", "content": "We provide two abstract configuration classes to support you in bringing in the necessary beans:\n`org.springframework.data.neo4j.config.AbstractNeo4jConfig` for imperative database access and\n`org.springframework.data.neo4j.config.AbstractReactiveNeo4jConfig` for the reactive version.\nThey are meant to be used with `@EnableNeo4jRepositories` and `@EnableReactiveNeo4jRepositories` respectively.\nSee <<bootless-imperative-configuration>> and <<bootless-reactive-configuration>> for an example usage.\nBoth classes require you to override `driver()` in which you are supposed to create the driver.\n\nTo get the imperative version of the xref:appendix/neo4j-client.adoc#neo4j-client[Neo4j client], the template and support for imperative repositories, use something similar as shown here:\n\n[source,java]\n[[bootless-imperative-configuration]]\n.Enabling Spring Data Neo4j infrastructure for imperative database access\n----\nimport org.neo4j.driver.Driver;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport org.springframework.data.neo4j.config.AbstractNeo4jConfig;\nimport org.springframework.data.neo4j.core.DatabaseSelectionProvider;\nimport org.springframework.data.neo4j.repository.config.EnableNeo4jRepositories;\n\n@Configuration\n@EnableNeo4jRepositories\n@EnableTransactionManagement\nclass MyConfiguration extends AbstractNeo4jConfig {\n\n @Override @Bean\n public Driver driver() { // <.>\n return GraphDatabase.driver(\"bolt://localhost:7687\", AuthTokens.basic(\"neo4j\", \"secret\"));\n }\n\n @Override\n protected Collection<String> getMappingBasePackages() {\n return Collections.singletonList(Person.class.getPackage().getName());\n }\n\n @Override @Bean // <.>\n protected DatabaseSelectionProvider databaseSelectionProvider() {\n\n return DatabaseSelectionProvider.createStaticDatabaseSelectionProvider(\"yourDatabase\");\n }\n}\n----\n<.> The driver bean is required.\n<.> This statically selects a database named `yourDatabase` and is *optional*.\n\nThe following listing provides the reactive Neo4j client and template, enables reactive transaction management and discovers Neo4j related repositories:\n\n[source,java]\n[[bootless-reactive-configuration]]\n.Enabling Spring Data Neo4j infrastructure for reactive database access\n----\nimport org.neo4j.driver.Driver;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.neo4j.config.AbstractReactiveNeo4jConfig;\nimport org.springframework.data.neo4j.repository.config.EnableReactiveNeo4jRepositories;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\n@Configuration\n@EnableReactiveNeo4jRepositories\n@EnableTransactionManagement\nclass MyConfiguration extends AbstractReactiveNeo4jConfig {\n\n @Bean\n @Override\n public Driver driver() {\n return GraphDatabase.driver(\"bolt://localhost:7687\", AuthTokens.basic(\"neo4j\", \"secret\"));\n }\n\n @Override\n protected Collection<String> getMappingBasePackages() {\n return Collections.singletonList(Person.class.getPackage().getName());\n }\n}\n----\n\n[[faq.sdn-in-cdi-2.0]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Using Spring Data Neo4j inside a Spring context without Spring Boot", "heading_level": 3, "file_order": 37, "section_index": 36, "content_hash": "d07d47efe065f8b7b05ddb6b40fa0768265111144bef6e7f3f137f683376aefa", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:bb44855f1d05c115f56c9811394e7a4930ca128704cf0107336ab6ff0a0eed25", "content": "For your convenience we provide a CDI extension with `Neo4jCdiExtension`.\nWhen run in a compatible CDI 2.0 container, it will be automatically be registered and loaded through https://docs.oracle.com/javase/tutorial/ext/basics/spi.html[Java's service loader SPI].\n\nThe only thing you have to bring into your application is an annotated type that produces the Neo4j Java Driver:\n\n[source,java]\n[[cdi-driver-producer]]\n.A CDI producer for the Neo4j Java Driver\n----\nimport javax.enterprise.context.ApplicationScoped;\nimport javax.enterprise.inject.Disposes;\nimport javax.enterprise.inject.Produces;\n\nimport org.neo4j.driver.AuthTokens;\nimport org.neo4j.driver.Driver;\nimport org.neo4j.driver.GraphDatabase;\n\npublic class Neo4jConfig {\n\n @Produces @ApplicationScoped\n public Driver driver() { // <.>\n return GraphDatabase\n .driver(\"bolt://localhost:7687\", AuthTokens.basic(\"neo4j\", \"secret\"));\n }\n\n public void close(@Disposes Driver driver) {\n driver.close();\n }\n\n @Produces @Singleton\n public DatabaseSelectionProvider getDatabaseSelectionProvider() { // <.>\n return DatabaseSelectionProvider.createStaticDatabaseSelectionProvider(\"yourDatabase\");\n }\n}\n----\n<.> Same as with plain Spring in <<bootless-imperative-configuration>>, but annotated with the corresponding CDI infrastructure.\n<.> This is *optional*. However, if you run a custom database selection provider, you _must_ not qualify this bean.\n\nIf you are running in a SE Container - like the one https://weld.cdi-spec.org[Weld] provides for example, you can enable the extension like that:\n\n[source,java]\n[[cdi-driver-producer-se]]\n.Enabling the Neo4j CDI extension in a SE container\n----\nimport javax.enterprise.inject.se.SeContainer;\nimport javax.enterprise.inject.se.SeContainerInitializer;\n\nimport org.springframework.data.neo4j.config.Neo4jCdiExtension;\n\npublic class SomeClass {\n void someMethod() {\n try (SeContainer container = SeContainerInitializer.newInstance()\n .disableDiscovery()\n .addExtensions(Neo4jCdiExtension.class)\n .addBeanClasses(YourDriverFactory.class)\n .addPackages(Package.getPackage(\"your.domain.package\"))\n .initialize()\n ) {\n SomeRepository someRepository = container.select(SomeRepository.class).get();\n }\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/faq.adoc", "title": "faq", "heading": "Using Spring Data Neo4j in a CDI 2.0 environment", "heading_level": 3, "file_order": 37, "section_index": 37, "content_hash": "bb44855f1d05c115f56c9811394e7a4930ca128704cf0107336ab6ff0a0eed25", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/faq.adoc"}}
{"id": "sha256:4d3220b5adaa26b52f1fc8d175eb2300776775c2af522a73ea19e83c8b9675f4", "content": "[[getting-started]]\n\nWe provide a Spring Boot starter for SDN.\nPlease include the starter module via your dependency management and configure the bolt URL to use, for example `spring.neo4j.uri=bolt://localhost:7687`.\nThe starter assumes that the server has disabled authentication.\nAs the SDN starter depends on the starter for the Java Driver, all things regarding configuration said there, apply here as well.\nFor a reference of the available properties, use your IDEs autocompletion in the `spring.neo4j` namespace.\n\nSDN supports\n\n* The well known and understood imperative programming model (much like Spring Data JDBC or JPA)\n* Reactive programming based on https://www.reactive-streams.org[Reactive Streams], including full support for https://spring.io/blog/2019/05/16/reactive-transactions-with-spring[reactive transactions].\n\nThose are all included in the same binary.\nThe reactive programming model requires a 4+ Neo4j server on the database side and reactive Spring on the other hand.\n\n[[prepare-the-database]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/getting-started.adoc", "title": "getting-started", "heading": "getting-started", "heading_level": 1, "file_order": 38, "section_index": 0, "content_hash": "4d3220b5adaa26b52f1fc8d175eb2300776775c2af522a73ea19e83c8b9675f4", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/getting-started.adoc"}}
{"id": "sha256:1d32cb8bef79daf4b76641651b74cc8f8cddba08e19da9af09fba131299d2c8a", "content": "For this example, we stay within the https://neo4j.com/developer/movie-database/[movie graph], as it comes for free with every Neo4j instance.\n\nIf you don't have a running database but Docker installed, please run:\n\n[source,console,subs=\"verbatim,attributes\"]\n[[start-docker-neo4j]]\n.Start a local Neo4j instance inside Docker.\n----\ndocker run --publish=7474:7474 --publish=7687:7687 -e 'NEO4J_AUTH=neo4j/secret' neo4j:{docs-neo4j-docker-version}\n----\n\nYou can now access http://localhost:7474/browser/?cmd=play&arg=movies[http://localhost:7474].\nThe above command sets the password of the server to `secret`.\nNote the command ready to run in the prompt (`:play movies`).\nExecute it to fill your database with some test data.\n\n[[create-spring-boot-project]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/getting-started.adoc", "title": "getting-started", "heading": "Prepare the database", "heading_level": 2, "file_order": 38, "section_index": 1, "content_hash": "1d32cb8bef79daf4b76641651b74cc8f8cddba08e19da9af09fba131299d2c8a", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/getting-started.adoc"}}
{"id": "sha256:a8dffd6bc2f3eb287bce3e11e9fad271951fe09a94d239c2de35fb0c7bd311a0", "content": "The easiest way to set up a Spring Boot project is https://start.spring.io#!type=maven-project&dependencies=webflux,data-neo4j[start.spring.io]\n(which is integrated in the major IDEs as well, in case you don't want to use the website).\n\nSelect the \"Spring Web Starter\" to get all the dependencies needed for creating a Spring based web application.\nThe Spring Initializr will take care of creating a valid project structure for you, with all the files and settings in place for the selected build tool.\n\n[[create-spring-boot-project-using-maven]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/getting-started.adoc", "title": "getting-started", "heading": "Create a new Spring Boot project", "heading_level": 2, "file_order": 38, "section_index": 2, "content_hash": "a8dffd6bc2f3eb287bce3e11e9fad271951fe09a94d239c2de35fb0c7bd311a0", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/getting-started.adoc"}}
{"id": "sha256:f9114c64a0eca6597acc70531a695379f65ae7626f222c0a7009283fa170d224", "content": "You can issue a _curl_ request against the Spring Initializer to create a basic Maven project:\n\n[source,bash,subs=\"verbatim,attributes\"]\n[[generate-maven-project]]\n.Create a basic Maven project with the Spring Initializr\n----\ncurl https://start.spring.io/starter.tgz \\\n -d dependencies=webflux,data-neo4j \\\n -d bootVersion={spring-boot-version} \\\n -d baseDir=Neo4jSpringBootExample \\\n -d name=Neo4j%20SpringBoot%20Example | tar -xzvf -\n----\n\nThis will create a new folder `Neo4jSpringBootExample`.\nAs this starter is not yet on the initializer, you will have to add the following dependency manually to your `pom.xml`:\n\n[source,xml,subs=\"verbatim,attributes\"]\n[[dependencies-maven]]\n.Inclusion of the spring-data-neo4j-spring-boot-starter in a Maven project\n----\n<dependency>\n\t<groupId>{groupIdStarter}</groupId>\n\t<artifactId>{artifactIdStarter}</artifactId>\n</dependency>\n----\n\nYou would also add the dependency manually in case of an existing project.\n\n[[create-spring-boot-project-using-gradle]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/getting-started.adoc", "title": "getting-started", "heading": "Using Maven", "heading_level": 3, "file_order": 38, "section_index": 3, "content_hash": "f9114c64a0eca6597acc70531a695379f65ae7626f222c0a7009283fa170d224", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/getting-started.adoc"}}
{"id": "sha256:fa68e0ebfeca5a1c151a910a26a596f09126df2e355af6228be16d1a7fb87361", "content": "The idea is the same, just generate a Gradle project:\n\n[source,bash,subs=\"verbatim,attributes\"]\n[[generate-gradle-project]]\n.Create a basic Gradle project with the Spring Initializr\n----\ncurl https://start.spring.io/starter.tgz \\\n -d dependencies=webflux,data-neo4j \\\n -d type=gradle-project \\\n -d bootVersion={spring-boot-version} \\\n -d baseDir=Neo4jSpringBootExampleGradle \\\n -d name=Neo4j%20SpringBoot%20Example | tar -xzvf -\n----\n\nThe dependency for Gradle looks like this and must be added to `build.gradle`:\n\n[source,groovy,subs=\"verbatim,attributes\"]\n.Inclusion of the spring-data-neo4j-spring-boot-starter in a Gradle project\n----\ndependencies {\n implementation '{groupIdStarter}:{artifactIdStarter}'\n}\n----\n\nYou would also add the dependency manually in case of an existing project.\n\n[[configure-spring-boot-project]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/getting-started.adoc", "title": "getting-started", "heading": "Using Gradle", "heading_level": 3, "file_order": 38, "section_index": 4, "content_hash": "fa68e0ebfeca5a1c151a910a26a596f09126df2e355af6228be16d1a7fb87361", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/getting-started.adoc"}}
{"id": "sha256:cd46710045c1070218f19bb3608599c838f82753a3f5ad6d81133fd119ffa17b", "content": "Now open any of those projects in your favorite IDE.\nFind `application.properties` and configure your Neo4j credentials:\n\n[source,properties]\n----\nspring.neo4j.uri=bolt://localhost:7687\nspring.neo4j.authentication.username=neo4j\nspring.neo4j.authentication.password=verysecret\n----\n\nThis is the bare minimum of what you need to connect to a Neo4j instance.\n\nNOTE: It is not necessary to add any programmatic configuration of the driver when you use this starter.\nSDN repositories will be automatically enabled by this starter.\n\n[[configure-cypher-dsl-dialect]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/getting-started.adoc", "title": "getting-started", "heading": "Configure the project", "heading_level": 2, "file_order": 38, "section_index": 5, "content_hash": "cd46710045c1070218f19bb3608599c838f82753a3f5ad6d81133fd119ffa17b", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/getting-started.adoc"}}
{"id": "sha256:25c58422d84bde644e6faf7a2df2405f753f949f7d313b9ff9165c1b367a4864", "content": "Depending on the Neo4j version you are running your application with,\nit is advised to configure the dialect Neo4j Cypher-DSL runs with.\nThe default dialect that is used is targeting Neo4j 5 as the LTS version of Neo4j.\nIt's compatible with Neo4j 5.23+ and Neo4j 2025.x.\nThis can be changed by defining a Cypher-DSL `Configuration` bean.\n\n.Make Cypher-DSL use the Neo4j 4 dialect\n[source,java]\n----\n@Bean\nConfiguration cypherDslConfiguration() {\n\treturn Configuration.newConfig()\n .withDialect(Dialect.NEO4J_4).build();\n}\n----\n\nNOTE: Although Spring Data Neo4j tries it best to be compatible with also the combination of Neo4j 5 and a default dialect,\nit is always recommend to explicitly define the dialect.\nE.g. it will lead to more optimized queries and make use of `elementId()` for newer Neo4j versions.\n\n[[running-on-the-module-path]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/getting-started.adoc", "title": "getting-started", "heading": "Configure Neo4j Cypher-DSL", "heading_level": 3, "file_order": 38, "section_index": 6, "content_hash": "25c58422d84bde644e6faf7a2df2405f753f949f7d313b9ff9165c1b367a4864", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/getting-started.adoc"}}
{"id": "sha256:1dac0947e1a3b0484a3c42acfe0ec7d41ddb9d0f68e34954ecf8aad57c9134f3", "content": "Spring Data Neo4j can run on the module path. It's automatic module name is `spring.data.neo4j`.\nIt does not provide a module itself due to restrictions in the current Spring Data build setup.\nHence, it uses an automatic but stable module name. However, it does depend on\na modularized library (the https://github.com/neo4j-contrib/cypher-dsl[Cypher-DSL]). Without a `module-info.java` due to\nthe restriction mentioned above, we cannot express the requirement for that library on your behalf.\n\nTherefore, the minimal required `module-info.java` in your project for running Spring Data Neo4j 6.1+ on the module path\nis the following:\n\n.A `module-info.java` in a project supposed to use Spring Data Neo4j on the module path\n[source,java]\n----\nmodule your.module {\n\n\trequires org.neo4j.cypherdsl.core;\n\n\trequires spring.data.commons;\n\trequires spring.data.neo4j;\n\n\topens your.domain to spring.core; // <.>\n\n\texports your.domain; // <.>\n}\n----\n<.> Spring Data Neo4j uses Spring Data Commons and its reflective capabilities, so\n you would need to open up your domain packages to `spring.core` at least.\n<.> We assume here that `your.domain` contains also repositories: Those must be exported to be accessible by\n `spring.beans`, `spring.context` and `spring.data.commons`. If you don't want to export them to the world,\n you can restrict them to those modules.\n\n[[create-domain-spring-boot-project]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/getting-started.adoc", "title": "getting-started", "heading": "Running on the Module-Path", "heading_level": 2, "file_order": 38, "section_index": 7, "content_hash": "1dac0947e1a3b0484a3c42acfe0ec7d41ddb9d0f68e34954ecf8aad57c9134f3", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/getting-started.adoc"}}
{"id": "sha256:c353ca6c483a92c7522359c6f47bd6b9ae8193458dc6386d31fa93c363b00af0", "content": "Our domain layer should accomplish two things:\n\n* Map your graph to objects\n* Provide access to those\n\n[[example-node-spring-boot-project]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/getting-started.adoc", "title": "getting-started", "heading": "Create your domain", "heading_level": 2, "file_order": 38, "section_index": 8, "content_hash": "c353ca6c483a92c7522359c6f47bd6b9ae8193458dc6386d31fa93c363b00af0", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/getting-started.adoc"}}
{"id": "sha256:de247b14dc4dc1ff7963ddd15820f8e36afd0e4882923616d766330db020fe35", "content": "SDN fully supports unmodifiable entities, for both Java and `data` classes in Kotlin.\nTherefore, we will focus on immutable entities here, <<movie-entity>> shows a such an entity.\n\nNOTE: SDN supports all data types the Neo4j Java Driver supports, see https://neo4j.com/docs/driver-manual/current/cypher-workflow/#driver-type-mapping[Map Neo4j types to native language types] inside the chapter \"The Cypher type system\".\nFuture versions will support additional converters.\n\n[source,java]\n[[movie-entity]]\n.MovieEntity.java\n----\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.data.neo4j.core.schema.Id;\nimport org.springframework.data.neo4j.core.schema.Node;\nimport org.springframework.data.neo4j.core.schema.Property;\nimport org.springframework.data.neo4j.core.schema.Relationship;\nimport org.springframework.data.neo4j.core.schema.Relationship.Direction;\n\n@Node(\"Movie\") // <.>\npublic class MovieEntity {\n\n\t@Id // <.>\n\tprivate final String title;\n\n\t@Property(\"tagline\") // <.>\n\tprivate final String description;\n\n\t@Relationship(type = \"ACTED_IN\", direction = Direction.INCOMING) // <.>\n\tprivate List<Roles> actorsAndRoles = new ArrayList<>();\n\n\n\t@Relationship(type = \"DIRECTED\", direction = Direction.INCOMING)\n\tprivate List<PersonEntity> directors = new ArrayList<>();\n\n\tpublic MovieEntity(String title, String description) { // <.>\n\t\tthis.title = title;\n\t\tthis.description = description;\n\t}\n\n\t// Getters omitted for brevity\n\n}\n----\n<.> `@Node` is used to mark this class as a managed entity.\nIt also is used to configure the Neo4j label.\nThe label defaults to the name of the class, if you're just using plain `@Node`.\n<.> Each entity has to have an id.\nThe movie class shown here uses the attribute `title` as a unique business key.\nIf you don't have such a unique key, you can use the combination of `@Id` and `@GeneratedValue`\nto configure SDN to use Neo4j's internal id.\nWe also provide generators for UUIDs.\n<.> This shows `@Property` as a way to use a different name for the field than for the graph property.\n<.> This defines a relationship to a class of type `PersonEntity` and the relationship type `ACTED_IN`\n<.> This is the constructor to be used by your application code.\n\nAs a general remark: immutable entities using internally generated ids are a bit contradictory, as SDN needs a way to set the field with the value generated by the database.\n\nIf you don't find a good business key or don't want to use a generator for IDs, here's the same entity using the internally generated id together with a regular constructor and a so called _wither_-Method, that is used by SDN:\n\n[source,java]\n[[movie-entity-with-wither]]\n.MovieEntity.java\n----\nimport org.springframework.data.neo4j.core.schema.GeneratedValue;\nimport org.springframework.data.neo4j.core.schema.Id;\nimport org.springframework.data.neo4j.core.schema.Node;\nimport org.springframework.data.neo4j.core.schema.Property;\n\nimport org.springframework.data.annotation.PersistenceConstructor;\n\n@Node(\"Movie\")\npublic class MovieEntity {\n\n\t@Id @GeneratedValue\n\tprivate Long id;\n\n\tprivate final String title;\n\n\t@Property(\"tagline\")\n\tprivate final String description;\n\n\tpublic MovieEntity(String title, String description) { // <.>\n this.id = null;\n this.title = title;\n this.description = description;\n\t}\n\n\tpublic MovieEntity withId(Long id) { // <.>\n if (this.id.equals(id)) {\n return this;\n } else {\n MovieEntity newObject = new MovieEntity(this.title, this.description);\n newObject.id = id;\n return newObject;\n }\n\t}\n}\n----\n<.> This is the constructor to be used by your application code.\nIt sets the id to null, as the field containing the internal id should never be manipulated.\n<.> This is a so-called _wither_ for the `id`-attribute.\nIt creates a new entity and sets the field accordingly, without modifying the original entity, thus making it immutable.\n\nYou can of course use SDN with https://kotlinlang.org/[Kotlin] and model your domain with Kotlin's data classes.\nhttps://projectlombok.org/[Project Lombok] is an alternative if you want or need to stay purely within Java.\n\n[[spring-data-repositories-spring-boot-project]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/getting-started.adoc", "title": "getting-started", "heading": "Example Node-Entity", "heading_level": 3, "file_order": 38, "section_index": 9, "content_hash": "de247b14dc4dc1ff7963ddd15820f8e36afd0e4882923616d766330db020fe35", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/getting-started.adoc"}}
{"id": "sha256:1cbf4653d2670f7bbcb5fef304d82a0df88036a72ca5b0b300f605eb7674dce9", "content": "You basically have two options here:\nyou can work in a store-agnostic fashion with SDN and make your domain specific extend one of\n\n* `org.springframework.data.repository.Repository`\n* `org.springframework.data.repository.CrudRepository`\n* `org.springframework.data.repository.reactive.ReactiveCrudRepository`\n* `org.springframework.data.repository.reactive.ReactiveSortingRepository`\n\nChoose imperative and reactive accordingly.\n\nWARNING: While technically not prohibited, it is not recommended mixing imperative and reactive database access in the same application.\nWe won't support you with scenarios like this.\n\nThe other option is to settle on a store specific implementation and gain all the methods we support out of the box.\nThe advantage of this approach is also its biggest disadvantage: once out, all those methods will be part of your API.\nMost of the time it's harder to take something away, than to add stuff afterwards.\nFurthermore, using store specifics leaks your store into your domain.\nFrom a performance point of view, there is no penalty.\n\nA reactive repository fitting to any of the movie entities above looks like this:\n\n[source,java]\n[[movie-repository]]\n.MovieRepository.java\n----\nimport reactor.core.publisher.Mono;\n\nimport org.springframework.data.neo4j.repository.ReactiveNeo4jRepository;\n\npublic interface MovieRepository extends ReactiveNeo4jRepository<MovieEntity, String> {\n\n\tMono<MovieEntity> findOneByTitle(String title);\n\n}\n----\n\nTIP: Testing reactive code is done with a `reactor.test.StepVerifier`.\nHave a look at the corresponding https://projectreactor.io/docs/core/release/reference/#testing[documentation of Project Reactor] or see our example code.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/getting-started.adoc", "title": "getting-started", "heading": "Declaring Spring Data repositories", "heading_level": 3, "file_order": 38, "section_index": 10, "content_hash": "1cbf4653d2670f7bbcb5fef304d82a0df88036a72ca5b0b300f605eb7674dce9", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/getting-started.adoc"}}
{"id": "sha256:29076722654cc6f1f137c8c3c866031f6a041849ee700b5ff046204f36ae0676", "content": "[[spring-data-neo4j-reference-documentation]]\n\n_Spring Data Neo4j provides repository support for the Neo4j graph database.\nIt eases development of applications with a consistent programming model that need to access Neo4j data sources._\n\n[horizontal]\nxref:introduction-and-preface/index.adoc[Preface] :: General information about Spring Data, Spring Data Neo4j and Neo4j\nxref:getting-started.adoc[Getting Started] :: Start with your first Spring Data Neo4j application\nxref:object-mapping.adoc[Object Mapping] :: Detailed information about entity definition\nxref:repositories.adoc[Repositories] :: Concepts and details about Spring Data (Neo4j) repositories\nxref:repositories/projections.adoc[Projections] :: General information about Spring Data projections and Spring Data Neo4j specifics\nxref:testing.adoc[Testing] :: Test support in Spring Data Neo4j\nxref:auditing.adoc[Auditing] :: Auditing support in Spring Data\nxref:faq.adoc[FAQ] :: Collected questions and answers\nxref:appendix/index.adoc[Appendix] :: In depth information about Spring Data Neo4j details and supported Spring Data types\nhttps://github.com/spring-projects/spring-data-commons/wiki[Wiki] :: What's New, Upgrade Notes, Supported Versions, additional cross-version information\n\nMichael Simons, Gerrit Meier\n\n(C) 2008-{copyright-year} The original authors.\n\nCopies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 39, "section_index": 0, "content_hash": "29076722654cc6f1f137c8c3c866031f6a041849ee700b5ff046204f36ae0676", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:25a8eabcabed6e1b046b232521c54063bb29275e6e71047f06bbc6ce76159899", "content": "[[object-mapping]]\n\nThe following sections will explain the process of mapping between your graph and your domain.\nIt is split into three parts.\nThe first part explains the actual mapping and the available tools for you to describe how to map nodes, relationships and properties to objects.\nThe second part shows the options and implications of using a specific identifier style for your entities.\nThe third part will have a look at Spring Data's object mapping fundamentals.\nIt gives valuable tips on general mapping, why you should prefer immutable domain objects and how you can model them with Java or Kotlin.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "object-mapping", "heading_level": 1, "file_order": 40, "section_index": 0, "content_hash": "25a8eabcabed6e1b046b232521c54063bb29275e6e71047f06bbc6ce76159899", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:f7cb88ed45417f436f50c03ec55762841ea21d289d17dc154659c4a7ac481f32", "content": "include::{commons}@data-commons::page$query-by-example.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/query-by-example.adoc", "title": "query-by-example", "heading": "query-by-example", "heading_level": 1, "file_order": 41, "section_index": 0, "content_hash": "f7cb88ed45417f436f50c03ec55762841ea21d289d17dc154659c4a7ac481f32", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/query-by-example.adoc"}}
{"id": "sha256:e9b1524fb221a23111d66a0c824057f4f38634977770bf8e39ac4e7c992215cb", "content": "[[repositories]]\n\nThis chapter explains the basic foundations of Spring Data repositories and Neo4j specifics. Before continuing to the Neo4j specifics, make sure you have a sound understanding of the basic concepts.\n\nThe goal of the Spring Data repository abstraction is to significantly reduce the amount of boilerplate code required to implement data access layers for various persistence stores.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/repositories.adoc", "title": "repositories", "heading": "repositories", "heading_level": 1, "file_order": 42, "section_index": 0, "content_hash": "e9b1524fb221a23111d66a0c824057f4f38634977770bf8e39ac4e7c992215cb", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/repositories.adoc"}}
{"id": "sha256:7604ccfb8c2d97107cc24e1f7624eab0b903a65f9161eb2d23d35e87f75bdedb", "content": "[[testing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-neo4j", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "testing", "heading_level": 1, "file_order": 43, "section_index": 0, "content_hash": "7604ccfb8c2d97107cc24e1f7624eab0b903a65f9161eb2d23d35e87f75bdedb", "source_url": "https://github.com/spring-projects/spring-data-neo4j/blob/45c56d71aa3b4126e0f95c1bc81a3b81e57fbe9d/src/main/antora/modules/ROOT/pages/testing.adoc"}}
