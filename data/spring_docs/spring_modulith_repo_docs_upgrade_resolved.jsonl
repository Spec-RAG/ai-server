{"id": "sha256:25b6e9053769feee627edeb88a1f346a15fbff3843a374de0600fca9041c589a", "content": "[[appendix]]\n\n[appendix]\n[[compatibility-matrix]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "appendix", "heading_level": 1, "file_order": 0, "section_index": 0, "content_hash": "25b6e9053769feee627edeb88a1f346a15fbff3843a374de0600fca9041c589a", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:63181753da24ba655ae6aba606ebc6b4c1632c6193066375e63dffae176092c6", "content": "[cols=\"1,1,1,1,1\", options=\"header, unbreakable\"]\n|===\n|Spring Modulith Version\n|Spring Boot Version +\n(compiled against)\n|Spring Boot Version +\n(examples tested against)\n|jMolecules +\n(compiled)\n|jMolecules +\n(tested)\n\n|2.0 (snapshot)\n|4.0 SNAPSHOT\n|4.0 SNAPSHOT and milestones\n|2023.2\n|2023.2, 2025.0 RC2\n\n|1.4\n|3.5\n|3.1, 3.2, 3.3, 3.4, 3.5\n|2023.2\n|2023.2, 2025.0 RC2\n\n|1.3\n|3.4\n|3.1, 3.2, 3.3, 3.4, 3.5\n|2023.1\n|2023.1, 2023.2, 2025.0 RC2\n\n|1.2\n|3.3\n|3.1, 3.2, 3.3, 3.4\n|2023.1\n|2023.1, 2023.2, 2025.0 RC2\n\n|1.1\n|3.2\n|3.1, 3.2, 3.3, 3.4\n|2023.1\n|2023.1, 2023.2, 2025.0 RC2\n|===\n\n[appendix]\n[[configuration-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Spring Boot Compatibility", "heading_level": 2, "file_order": 0, "section_index": 1, "content_hash": "63181753da24ba655ae6aba606ebc6b4c1632c6193066375e63dffae176092c6", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:29c0679fcd046b7ebe3abd8252a742552b695c309b12010fa5d3e361e79db948", "content": "[cols=\"2,1,3\", options=\"header, unbreakable\"]\n|===\n|Property|Default value|Description\n\n|`spring.modulith.default-async-termination`\n|`true`\n|Whether to configure defaults for the async processing termination, namely to wait for task completion for 2 seconds. See `TaskExecutionProperties` for details.\n\n|`spring.modulith.detection-strategy`\n|none\n|The strategy to be applied to detect application modules.\nCan either be the class name of a custom implementation of `ApplicationModuleDetectionStrategy` or `direct-subpackages` (which is also the final fallback if nothing is configured) or `explicitly-annotated` to only select packages explicitly annotated with `@ApplicationModule` or jMolecules' `@Module`. See xref:fundamentals.adoc#customizing-modules[Customize Application Module Detection] for details.\n\n|`spring.modulith.events.completion-mode`\n|`update`\na|How to mark an event publication as completed.\nThe following values are supported:\n\n* `update` (default) -- Sets the completion date on the event publication entry.\n* `delete` -- Removes the event publication entry.\nCompleted event publications are not available via `CompletedEventPublications`.\n* `archive` -- Removes the event publication entry from the primary database abstraction (table, collection or node) and creates one in a archive (a table, collection or node of same schema).\nFor details, see xref:events.adoc#publication-registry.completion[Event Publication Completion].\n\n|`spring.modulith.events.externalization.enabled`\n|`true`\n|Whether to enable event externalization.\n\n|`spring.modulith.events.externalization.serialize-externalization`\n|`false`\n|Whether to serialize event externalization to brokers.\n\n|`spring.modulith.events.jdbc.schema-initialization.enabled`\n|`true`\n|Whether to initialize the JDBC event publication schema.\n\n|`spring.modulith.events.jdbc.schema`\n|\n|The schema name for the event publication table. If not specified, the table will not be schema-qualified.\n\n|`spring.modulith.events.jdbc.use-legacy-structure`\n|`false`\n|Whether to use the legacy event publication database structure.\n\n|`spring.modulith.events.kafka.enable-json`\n|`true`\n|Whether to enable JSON support for `KafkaTemplate`.\n\n|`spring.modulith.events.mongodb.transaction-management.enabled`\n|`true`\n|Whether to automatically enable transactions for MongoDB. Requires the database to be run with a replica set.\n\n|`spring.modulith.events.neo4j.event-index.enabled`\n|`false`\n|Whether to create indexes on the Neo4j event publication event hash property.\n\n|`spring.modulith.events.rabbitmq.enable-json`\n|`true`\n|Whether to enable JSON support for `RabbitTemplate`.\n\n|`spring.modulith.events.republish-outstanding-events-on-restart`\n|`false`\n|Whether to republish outstanding event publications on restarts of the application.\nUsually not recommended in multi-instance deployments as other instances might still be processing events.\n\n|`spring.modulith.events.staleness.check-interval`\n|`Duration.ofMinutes(1)`\n|The interval in which we should check for stale event publications.\n\n|`spring.modulith.events.staleness.processing`\n|`Duration.ZERO`\n|After which duration an event publication in the processing state is considered stale.\n\n|`spring.modulith.events.staleness.published`\n|`Duration.ZERO`\n|After which duration an event publication in the published state is considered stale.\n\n|`spring.modulith.events.staleness.resubmitted`\n|`Duration.ZERO`\n|After which duration an event publication in the resubmitted state is considered stale.\n\n|`spring.modulith.moments.enableTimeMachine`\n|`false`\n|Whether to enable the xref:moments.adoc[`TimeMachine`].\n\n|`spring.modulith.moments.granularity`\n|`HOURS`\n|The granularity of events to publish. (`HOURS`, `DAYS`)\n\n|`spring.modulith.moments.locale`\n|`Locale.getDefault()`\n|The `Locale` to use when determining week boundaries.\n\n|`spring.modulith.moments.zoneId`\n|`ZoneOffset.UTC`\n|The timezone of the dates for the events being published.\n\n|`spring.modulith.republish-outstanding-events-on-restart`\n|`false`\n|Deprecated as of 1.3. Prefer `spring.modulith.events.republish-outstanding-events-on-restart`.\n\n|`spring.modulith.runtime.flyway-enabled`\n|`false`\n|Configures whether to enable the module-specific Flyway customization.\nIf enabled, the Flyway instance configured with the application will be augmented to additionally executed migrations located in module-specific sub-folders of the configured locations, executed in the order of module dependencies.\nThis allows test executions to only apply the migrations needed for the actual test run.\nSee xref:runtime.adoc#module-aware-flyway-migrations[this section] for details.\n\n|`spring.modulith.runtime.verification-enabled`\n|`false`\n|Whether to verify the application module arrangement during application startup. Requires the `spring-modulith-runtime` artifact on the classpath. For more information, see xref:runtime.adoc#setup[the section on Spring Modulith's runtime support] for details.\n\n|`spring.modulith.test.file-modification-detector`\n|none\n|This can either be one of the predefined values `uncommitted-changes`, `reference-commit`, `default` or the fully-qualified class name of a `FileModificationDetector` that will be used to inspect which files of the projects have been changed.\nAs the name suggests, `uncommitted-changes` will only consider changed files not already committed.\n`reference-commit` will consider all files changed since a given Git commit provided via `spring.modulith.test.reference-commit`, particularly useful CI environments in which that property could point to the commit hash of the last successful build.\n`default` detects all uncomitted changes and ones that have not been pushed to the current branch's tracking branch which is primarily useful for local development.\n\n|`spring.modulith.test.on-no-changes`\n|`execute-all`\n|Whether to execute (`execute-all`) or skip (`skip-all`) all tests in case no classpath or build resource changes have been detected.\n\n|`spring.modulith.test.reference-commit`\n|none\n|The commit hash of to which to calculate the set of changed files.\nUsually propagated in CI environments to consider all changes since the last successful build.\n\n|===\n\n[appendix]\n[[artifacts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Spring Modulith Configuration Properties", "heading_level": 2, "file_order": 0, "section_index": 2, "content_hash": "29c0679fcd046b7ebe3abd8252a742552b695c309b12010fa5d3e361e79db948", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:5622fa397c04915954c6a7171e2bd5de65c07ebf0d6fb0da66a35cec25582027", "content": ".Spring Modulith starter POMs\n[cols=\"2,1,3\", options=\"header, unbreakable\"]\n|===\n|Starter|Typical scope|Includes\n\n|`spring-modulith-starter-core`\n|`compile`\na|* `spring-modulith-api`\n* `spring-modulith-apt`\n* `spring-modulith-moments`\n* `spring-modulith-core` (runtime)\n* `spring-modulith-runtime` (runtime)\n\n|`spring-modulith-starter-insight`\n|`runtime`\na|* `spring-modulith-actuator` (runtime)\n* `spring-modulith-observability` (runtime)\n* `spring-boot-starter-actuator` (runtime)\n\n|`spring-modulith-starter-jdbc`\n|`compile`\na|* `spring-modulith-starter-core`\n* `spring-modulith-events-api`\n* `spring-modulith-events-core` (runtime)\n* `spring-modulith-events-jdbc` (runtime)\n* `spring-modulith-events-jackson` (runtime)\n\n|`spring-modulith-starter-jpa`\n|`compile`\na|* `spring-modulith-starter-core`\n* `spring-modulith-events-api`\n* `spring-modulith-events-core` (runtime)\n* `spring-modulith-events-jpa` (runtime)\n* `spring-modulith-events-jackson` (runtime)\n\n|`spring-modulith-starter-mongodb`\n|`compile`\na|* `spring-modulith-starter-core`\n* `spring-modulith-events-api`\n* `spring-modulith-events-core` (runtime)\n* `spring-modulith-events-mongodb` (runtime)\n* `spring-modulith-events-jackson` (runtime)\n\n|`spring-modulith-starter-neo4j`\n|`compile`\na|* `spring-modulith-starter-core`\n* `spring-modulith-events-api`\n* `spring-modulith-events-core` (runtime)\n* `spring-modulith-events-neo4j` (runtime)\n* `spring-modulith-events-jackson` (runtime)\n\n|`spring-modulith-starter-test`\n|`test`\na|* `spring-modulith-docs`\n* `spring-modulith-test`\n|===\n\n.Individual Spring Modulith JARs\n[cols=\"2,1,3\", options=\"header, unbreakable\"]\n|===\n|Module|Typical scope|Description\n|`spring-modulith-actuator`|`runtime`|A Spring Boot actuator to expose the application module structure via an actuator.\n|`spring-modulith-api`|`compile`|The abstractions to be used in your production code to customize Spring Modulith's default behavior.\n|`spring-modulith-apt`|`compile`|An annotation processor to extract Javadoc for inclusion in xref:documentation.adoc#application-module-canvas[Application Module Canvases].\n|`spring-modulith-core`|`runtime`|The core application module model and API.\n|`spring-modulith-docs`|`test`|The `Documenter` API to create Asciidoctor and PlantUML documentation from the module model.\n|`spring-modulith-events-amqp`|`runtime`|Event externalization support for AMQP.\n|`spring-modulith-events-api`|`runtime`|API to customize the event features of Spring Modulith.\n|`spring-modulith-events-core`|`runtime`|The core implementation of the event publication registry as well as the integration abstractions `EventPublicationRegistry` and `EventPublicationSerializer`.\n|`spring-modulith-events-jackson`|`runtime`|A Jackson-based implementation of the `EventPublicationSerializer`.\n|`spring-modulith-events-jdbc`|`runtime`|A JDBC-based implementation of the `EventPublicationRegistry`.\n|`spring-modulith-events-jms`|`runtime`|Event externalization support for JMS.\n|`spring-modulith-events-jpa`|`runtime`|A JPA-based implementation of the `EventPublicationRegistry`.\n|`spring-modulith-events-kafka`|`runtime`|Event externalization support for Kafka.\n|`spring-modulith-events-messaging`|`runtime`|Event externalization support into Spring Messaging ``MessageChannel``s.\n|`spring-modulith-events-mongodb`|`runtime`|A MongoDB-based implementation of the `EventPublicationRegistry`.\n|`spring-modulith-events-neo4j`|`runtime`|A Neo4j-based implementation of the `EventPublicationRegistry`.\n|`spring-modulith-junit`|`test`|Test execution optimizations based on the application module structure. Find more details xref:testing.adoc#change-aware-test-execution[here].\n|`spring-modulith-moments`|`compile`|The Passage of Time events implementation described xref:moments.adoc[here].\n|`spring-modulith-observability`|`runtime`|Observability infrastructure described <<observability, here>>.\n|`spring-modulith-runtime`|`runtime`|Support to bootstrap an `ApplicationModules` instance at runtime. Usually not directly depended on but transitively used by `spring-modulith-actuator` and `spring-modulith-observability`.\n|`spring-modulith-test`|`test`|Integration testing support. Find more details xref:testing.adoc[here].\n|===\n\n[appendix]\n[[schemas]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Spring Modulith modules", "heading_level": 2, "file_order": 0, "section_index": 3, "content_hash": "5622fa397c04915954c6a7171e2bd5de65c07ebf0d6fb0da66a35cec25582027", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:bc9e72f411e7feb4575410b256b3d7274c993ee3662eb3101cdca53b4616525d", "content": "The JDBC-based event publication registry support expects the following database schemas to be present in the database.\nIf you would like Spring Modulith to create the schema for you, set the application property `spring.modulith.events.jdbc-schema-initialization.enabled` to `true`.\n\n[[schemas.h2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Event publication registry schemas", "heading_level": 2, "file_order": 0, "section_index": 4, "content_hash": "bc9e72f411e7feb4575410b256b3d7274c993ee3662eb3101cdca53b4616525d", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:770ca0381b871cf609531424e2609a76b060579bf6c22ee5d03d28f05c997aa0", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-h2.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-h2-archive.sql[]\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Current schemas", "heading_level": 4, "file_order": 0, "section_index": 5, "content_hash": "770ca0381b871cf609531424e2609a76b060579bf6c22ee5d03d28f05c997aa0", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:2284614654197d9787479ecd808efd74cc87fef6f65ecea84faf7c2e91f30b11", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-h2.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-h2-archive.sql[]\n----\n\n[[schemas.hsqldb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Legacy schemas", "heading_level": 4, "file_order": 0, "section_index": 6, "content_hash": "2284614654197d9787479ecd808efd74cc87fef6f65ecea84faf7c2e91f30b11", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:86c3cf45a04490ebf9c19e59e3929e8ff7c642ed0e2830aa759645d0dc3b3bfc", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-hsqldb.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-hsqldb-archive.sql[]\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Current schemas", "heading_level": 4, "file_order": 0, "section_index": 7, "content_hash": "86c3cf45a04490ebf9c19e59e3929e8ff7c642ed0e2830aa759645d0dc3b3bfc", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:6d19dc59d56a9dda9176508601685254dcf67dfe4fcc9ba052a9ada7c385229f", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-hsqldb.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-hsqldb-archive.sql[]\n----\n\n[[schemas.mariadb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Legacy schemas", "heading_level": 4, "file_order": 0, "section_index": 8, "content_hash": "6d19dc59d56a9dda9176508601685254dcf67dfe4fcc9ba052a9ada7c385229f", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:85e3b768512b98dca659ba314875fc8f9451ab69c3664d2cc5f8ed40ad5d0ba9", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-mariadb.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-mariadb-archive.sql[]\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Current schemas", "heading_level": 4, "file_order": 0, "section_index": 9, "content_hash": "85e3b768512b98dca659ba314875fc8f9451ab69c3664d2cc5f8ed40ad5d0ba9", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:a38b052a6cb43f90a285abe194964927e3ba917ec94bb7379634cdb860096faf", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-mariadb.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-mariadb-archive.sql[]\n----\n\n[[schemas.sqlserver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Legacy schemas", "heading_level": 4, "file_order": 0, "section_index": 10, "content_hash": "a38b052a6cb43f90a285abe194964927e3ba917ec94bb7379634cdb860096faf", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:0af3db56bdcc0824691d6b0e1bfd7d6220a06b5d0717a38b885e17d92cfe50e3", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-sqlserver.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-sqlserver-archive.sql[]\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Current schemas", "heading_level": 4, "file_order": 0, "section_index": 11, "content_hash": "0af3db56bdcc0824691d6b0e1bfd7d6220a06b5d0717a38b885e17d92cfe50e3", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:9d345dfdc8dc74237ad1a543a625aea8f517d36296ad3ce5a9ee01714ae5d486", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-sqlserver.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-sqlserver-archive.sql[]\n----\n\n[[schemas.mysql]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Legacy schemas", "heading_level": 4, "file_order": 0, "section_index": 12, "content_hash": "9d345dfdc8dc74237ad1a543a625aea8f517d36296ad3ce5a9ee01714ae5d486", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:e85bb04ce20a2a45bbe324cb65672ce5594c1c64e84c0e3230d0cd98d2f5e7c1", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-mysql.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-mysql-archive.sql[]\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Current schemas", "heading_level": 4, "file_order": 0, "section_index": 13, "content_hash": "e85bb04ce20a2a45bbe324cb65672ce5594c1c64e84c0e3230d0cd98d2f5e7c1", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:641194487b159206574ba43a5016ef48798b0f692577ac51951295ce5eb7a1ff", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-mysql.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-mysql-archive.sql[]\n----\n\n[[schemas.postgresql]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Legacy schemas", "heading_level": 4, "file_order": 0, "section_index": 14, "content_hash": "641194487b159206574ba43a5016ef48798b0f692577ac51951295ce5eb7a1ff", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:77340fc905b4f3925a5b5ee19afa214f5c48a9f44e6a7bdcbd3d63528a427744", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-postgresql.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v2/schema-postgresql-archive.sql[]\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Current schemas", "heading_level": 4, "file_order": 0, "section_index": 15, "content_hash": "77340fc905b4f3925a5b5ee19afa214f5c48a9f44e6a7bdcbd3d63528a427744", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:e81a82c3cce65d23f9265376939550c02fada394158c85a9e1a51dad8cb05837", "content": ".Standard schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-postgresql.sql[]\n----\n\n.Archive-enabled schema\n[source, sql]\n----\ninclude::{jdbc-schema-base}/v1/schema-postgresql-archive.sql[]\n----\n\n[appendix]\n[[migrating-from-moduliths]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Legacy schemas", "heading_level": 4, "file_order": 0, "section_index": 16, "content_hash": "e81a82c3cce65d23f9265376939550c02fada394158c85a9e1a51dad8cb05837", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:edfa6fc839c39ceae7cdb5206d9d179db1675c85712384780e8f6a89753ab53b", "content": "* `o.m.model.Modules` has been renamed to `o.s.m.model.ApplicationModules`\n* `o.m.model.ModuleDetectionStrategy` has been renamed to `o.s.m.model.ApplicationModuleDetectionStrategy`\n\n* `@o.m.test.ModuleTest` has been renamed to `@o.s.m.test.ApplicationModuleTest`\n\n* `o.m.docs.Documenter.Options` has been renamed to `o.s.m.docs.Documenter.DiagramOptions`\n* The diagram style of component diagrams now defaults to `DiagramStyle.C4` (override by calling `DiagramOptions.withStyle(DiagramStyle.UML)`)\n* The module canvas hides non exposed types by default.\nTo include application-module-internal types in the canvas, configure `CanvasOptions` to `….revealInternals()`.\n* The output folder for component diagrams and application module canvases has moved from `moduliths-docs` to `spring-modulith-docs` located in your build's target folder (such as `target` for Maven).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Migrating from Moduliths", "heading_level": 2, "file_order": 0, "section_index": 17, "content_hash": "edfa6fc839c39ceae7cdb5206d9d179db1675c85712384780e8f6a89753ab53b", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:b8125c7d100db7f8a384e1a98e38312ddcee5c62a8d842265efeafb523bcdb50", "content": "[[documentation]]\n\nThe application module model created via `ApplicationModules` can be used to create documentation snippets for inclusion into developer documentation written in Asciidoc.\nSpring Modulith's `Documenter` abstraction can produce two different kinds of snippets:\n\n* C4 and UML component diagrams describing the relationships between the individual application modules\n* A so-called __Application Module Canvas__, a tabular overview about the module and the most relevant elements in those (Spring beans, aggregate roots, events published and listened to as well as configuration properties).\n\nAdditionally, `Documenter` can produce an aggregating Asciidoc file that includes all existing component diagrams and canvases.\n\n[[component-diagrams]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/documentation.adoc", "title": "documentation", "heading": "documentation", "heading_level": 1, "file_order": 1, "section_index": 0, "content_hash": "b8125c7d100db7f8a384e1a98e38312ddcee5c62a8d842265efeafb523bcdb50", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/documentation.adoc"}}
{"id": "sha256:f7b1ab62beff13a3e07cfb40653dbd2e195e73c23289df99946af3dc28ef80c3", "content": "The documentation snippets can be generated by handing the `ApplicationModules` instance into a `Documenter`.\n\n.Generating application module component diagrams using `Documenter`\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nclass DocumentationTests {\n\n ApplicationModules modules = ApplicationModules.of(Application.class);\n\n @Test\n void writeDocumentationSnippets() {\n\n new Documenter(modules)\n .writeModulesAsPlantUml()\n .writeIndividualModulesAsPlantUml();\n }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\nclass DocumentationTests {\n private val modules = ApplicationModules.of(Application::class.java)\n\n @Test\n fun writeDocumentationSnippets() {\n Documenter(modules)\n .writeModulesAsPlantUml()\n .writeIndividualModulesAsPlantUml()\n }\n}\n----\n======\n\nThe first call on `Documenter` will generate a C4 component diagram containing all modules within the system.\n\n.All modules and their relationships rendered as C4 component diagram\n[plantuml, c4-all-modules, svg]\n....\ntop to bottom direction\n\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4.puml\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml\n\nContainer_Boundary(\"Modulith.Application_boundary\", \"Application\") {\n Component(Modulith.Application.core, \"core\", \"Module\", \"\", $tags=\"\")\n Component(Modulith.Application.catalog, \"catalog\", \"Module\", \"\", $tags=\"\")\n Component(Modulith.Application.inventory, \"inventory\", \"Module\", \"\", $tags=\"\")\n Component(Modulith.Application.order, \"order\", \"Module\", \"\", $tags=\"\")\n Component(Modulith.Application.customer, \"customer\", \"Module\", \"\", $tags=\"\")\n}\n\nRel_D(Modulith.Application.order, Modulith.Application.core, \"depends on\", $tags=\"\")\nRel_D(Modulith.Application.order, Modulith.Application.customer, \"uses\", $tags=\"\")\nRel_D(Modulith.Application.catalog, Modulith.Application.core, \"depends on\", $tags=\"\")\nRel_D(Modulith.Application.inventory, Modulith.Application.order, \"listens to\", $tags=\"\")\nRel_D(Modulith.Application.inventory, Modulith.Application.catalog, \"uses\", $tags=\"\")\nRel_D(Modulith.Application.inventory, Modulith.Application.order, \"uses\", $tags=\"\")\nRel_D(Modulith.Application.inventory, Modulith.Application.core, \"uses\", $tags=\"\")\nRel_D(Modulith.Application.order, Modulith.Application.catalog, \"depends on\", $tags=\"\")\n\nSHOW_LEGEND()\n....\n\nThe second call will create additional diagrams that only include the individual module and the ones they directly depend on the canvas.\n\n.A subset of application modules and their relationships starting from the order module rendered as C4 component diagram\n[plantuml, c4-individual-modules, svg]\n....\ntop to bottom direction\n\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4.puml\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml\n\nContainer_Boundary(\"Modulith.Application_boundary\", \"Application\") {\n Component(Modulith.Application.core, \"core\", \"Module\", \"\", $tags=\"\")\n Component(Modulith.Application.catalog, \"catalog\", \"Module\", \"\", $tags=\"\")\n Component(Modulith.Application.order, \"order\", \"Module\", \"\", $tags=\"\")\n Component(Modulith.Application.customer, \"customer\", \"Module\", \"\", $tags=\"\")\n}\n\nRel_D(Modulith.Application.order, Modulith.Application.core, \"depends on\", $tags=\"\")\nRel_D(Modulith.Application.order, Modulith.Application.customer, \"uses\", $tags=\"\")\nRel_D(Modulith.Application.catalog, Modulith.Application.core, \"depends on\", $tags=\"\")\nRel_D(Modulith.Application.order, Modulith.Application.catalog, \"depends on\", $tags=\"\")\n\nSHOW_LEGEND()\n....\n\n[[component-diagrams.uml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/documentation.adoc", "title": "documentation", "heading": "Generating Application Module Component diagrams", "heading_level": 2, "file_order": 1, "section_index": 1, "content_hash": "f7b1ab62beff13a3e07cfb40653dbd2e195e73c23289df99946af3dc28ef80c3", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/documentation.adoc"}}
{"id": "sha256:485171199dea96b9d32e43096fbbc5c78c29c79ecccb15a94d521948eb1c6e1a", "content": "If you prefer the traditional UML style component diagrams, tweak the `DiagramOptions` to rather use that style as follows:\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nDiagramOptions.defaults()\n .withStyle(DiagramStyle.UML);\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\nDiagramOptions.defaults()\n .withStyle(DiagramStyle.UML)\n----\n======\nThis will cause the diagrams to look like this:\n\n.All modules and their relationships rendered as UML component diagram\n[plantuml, uml-all-modules, svg]\n....\nskinparam {\n shadowing false\n arrowColor #707070\n actorBorderColor #707070\n componentBorderColor #707070\n rectangleBorderColor #707070\n noteBackgroundColor #ffffff\n noteBorderColor #707070\n defaultTextAlignment center\n wrapWidth 200\n maxMessageSize 100\n componentStyle uml1\n}\npackage \"Application\" <<Container>> {\n component 4 <<Component: Module>> #dddddd [\n com.acme.commerce.catalog\n ]\n component 3 <<Component: Module>> #dddddd [\n com.acme.commerce.core\n ]\n component 7 <<Component: Module>> #dddddd [\n com.acme.commerce.customer\n ]\n component 5 <<Component: Module>> #dddddd [\n com.acme.commerce.inventory\n ]\n component 6 <<Component: Module>> #dddddd [\n com.acme.commerce.order\n ]\n}\n4 .[#707070].> 3 : depends on\n5 .[#707070].> 4 : uses\n5 .[#707070].> 3 : uses\n5 .[#707070].> 6 : uses\n5 .[#707070].> 6 : listens to\n6 .[#707070].> 4 : depends on\n6 .[#707070].> 3 : depends on\n6 .[#707070].> 7 : uses\n....\n\n.A subset of application modules and their relationships starting from the order module rendered as UML component diagram\n[plantuml,uml-individiual-module, svg]\n....\nskinparam {\n shadowing false\n arrowColor #707070\n actorBorderColor #707070\n componentBorderColor #707070\n rectangleBorderColor #707070\n noteBackgroundColor #ffffff\n noteBorderColor #707070\n defaultTextAlignment center\n wrapWidth 200\n maxMessageSize 100\n componentStyle uml1\n}\npackage \"Application\" <<Container>> {\n component 4 <<Component: Module>> #dddddd [\n com.acme.commerce.catalog\n ]\n component 3 <<Component: Module>> #dddddd [\n com.acme.commerce.core\n ]\n component 7 <<Component: Module>> #dddddd [\n com.acme.commerce.customer\n ]\n component 6 <<Component: Module>> #dddddd [\n com.acme.commerce.order\n ]\n}\n4 .[#707070].> 3 : depends on\n6 .[#707070].> 4 : depends on\n6 .[#707070].> 3 : depends on\n6 .[#707070].> 7 : uses\n....\n\n[[application-module-canvas]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/documentation.adoc", "title": "documentation", "heading": "Using Traditional UML Component Diagrams", "heading_level": 3, "file_order": 1, "section_index": 2, "content_hash": "485171199dea96b9d32e43096fbbc5c78c29c79ecccb15a94d521948eb1c6e1a", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/documentation.adoc"}}
{"id": "sha256:2fc55300b15e721acf8d7f649517f2cd245a38d183cd03cae6fda589ee55c81a", "content": "The Application Module Canvases can be generated by calling `Documenter.writeModuleCanvases()`:\n\n.Generating application module canvases using `Documenter`\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nclass DocumentationTests {\n\n ApplicationModules modules = ApplicationModules.of(Application.class);\n\n @Test\n void writeDocumentationSnippets() {\n\n new Documenter(modules)\n .writeModuleCanvases();\n }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\nclass DocumentationTests {\n\n private val modules = ApplicationModules.of(Application::class.java)\n\n @Test\n fun writeDocumentationSnippets() {\n Documenter(modules)\n .writeModuleCanvases()\n }\n}\n----\n======\nBy default, the documentation will be generated to `spring-modulith-docs` folder in your build system's build folder.\nA generated canvas looks like this:\n\n.A sample Application Module Canvas\n[cols=\"1h,4a\"]\n|===\n|Base package\n|`com.acme.commerce.inventory`\n|Spring components\n|_Services_\n\n* `c.a.c.i.InventoryManagement`\n\n_Repositories_\n\n* `c.a.c.i.Inventory`\n\n_Event listeners_\n\n* `c.a.c.i.InternalInventoryListeners` listening to `o.s.m.m.DayHasPassed`, `c.a.c.i.QuantityReduced`\n* `c.a.c.i.InventoryOrderEventListener` listening to `c.a.c.o.OrderCanceled`, `c.a.c.o.OrderCompleted`\n\n_Configuration properties_\n\n* `c.a.c.i.InventoryProperties`\n\n_Others_\n\n* `c.a.c.i.InventoryItemCreationListener`\n|Aggregate roots\n|* `c.a.c.i.InventoryItem`\n|Published events\n|* `c.a.c.i.QuantityReduced` created by:\n** `c.a.c.i.InventoryItem.decreaseQuantity(…)`\n* `c.a.c.i.StockShort` created by:\n** `c.a.c.i.InternalInventoryListeners.on(…)`\n\n|Events listened to\n|* `c.a.c.o.OrderCompleted`\n* `c.a.c.o.OrderCanceled`\n|Properties\n|* `acme.commerce.inventory.restock-threshold` -- `c.a.c.c.Quantity`. The threshold at which a `InventoryEvents.StockShort` is supposed to be triggered during inventory updates.\n|===\n\nIt consists of the following sections:\n\n* __The application module's base package.__\n* __The Spring beans exposed by the application module, grouped by stereotype.__ -- In other words, beans that are located in either the API package or any xref:fundamentals.adoc#modules.named-interfaces[named interface package].\nThis will detect component stereotypes defined by https://github.com/xmolecules/jmolecules/tree/main/jmolecules-architecture[jMolecules architecture abstractions], but also standard Spring stereotype annotations.\n* __Exposed aggregate roots__ -- Any entities that we find repositories for or explicitly declared as aggregate via jMolecules.\n* __Application events published by the module__ -- Those event types need to be demarcated using jMolecules `@DomainEvent` or implement its `DomainEvent` interface.\n* __Application events listened to by the module__ -- Derived from methods annotated with Spring's `@EventListener`, `@TransactionalEventListener`, jMolecules' `@DomainEventHandler` or beans implementing `ApplicationListener`.\n* __Configuration properties__ -- Spring Boot Configuration properties exposed by the application module.\nRequires the usage of the `spring-boot-configuration-processor` artifact to extract the metadata attached to the properties.\n\n[[aggregating-document]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/documentation.adoc", "title": "documentation", "heading": "Generating Application Module Canvases", "heading_level": 2, "file_order": 1, "section_index": 3, "content_hash": "2fc55300b15e721acf8d7f649517f2cd245a38d183cd03cae6fda589ee55c81a", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/documentation.adoc"}}
{"id": "sha256:ea0c6ad93711cee38c8d20c1bd4bcc1b8d373472b1b3636148f7fcea93be27b9", "content": "When using `Documenter.writeDocumentation(…)` an `all-docs.adoc` file will be generated, linking all generated diagrams and Application Module Canvases.\nWe can manually generate the aggregating document by calling `Documenter.writeAggregatingDocument()`:\n\n.Generating an aggregating document using `Documenter`\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nclass DocumentationTests {\n\n ApplicationModules modules = ApplicationModules.of(Application.class);\n\n @Test\n void writeDocumentationSnippets() {\n\n new Documenter(modules)\n .writeAggregatingDocument();\n }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\nclass DocumentationTests {\n\n private val modules = ApplicationModules.of(Application::class.java)\n\n @Test\n fun writeDocumentationSnippets() {\n Documenter(modules)\n .writeAggregatingDocument()\n }\n}\n----\n======\n\nThe aggregating document will include any existing application module component diagrams and application module canvases.\nIf there are none, then this method will not produce an output file.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/documentation.adoc", "title": "documentation", "heading": "Generating an Aggregating Document", "heading_level": 2, "file_order": 1, "section_index": 4, "content_hash": "ea0c6ad93711cee38c8d20c1bd4bcc1b8d373472b1b3636148f7fcea93be27b9", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/documentation.adoc"}}
{"id": "sha256:cb68ccb3328322e08d35b69904ec338a5a34d4fdcffee0eba7f31cde92b1a211", "content": "[[events]]\n[[working-with-application-events]]\n\nTo keep application modules as decoupled as possible from each other, their primary means of interaction should be event publication and consumption.\nThis avoids the originating module to know about all potentially interested parties, which is a key aspect to enable application module integration testing (see xref:testing.adoc[Integration Testing Application Modules]).\n\nOften we will find application components defined like this:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Service\n@RequiredArgsConstructor\npublic class OrderManagement {\n\n private final InventoryManagement inventory;\n\n @Transactional\n public void complete(Order order) {\n\n // State transition on the order aggregate go here\n\n // Invoke related functionality\n inventory.updateStockFor(order);\n }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Service\nclass OrderManagement(val inventory: InventoryManagement) {\n\n @Transactional\n fun complete(order: Order) {\n inventory.updateStockFor(order)\n }\n}\n----\n======\n\nThe `complete(…)` method creates functional gravity in the sense that it attracts related functionality and thus interaction with Spring beans defined in other application modules.\nThis especially makes the component harder to test as we need to have instances available of those depended on beans just to create an instance of `OrderManagement` (see xref:testing.adoc#efferent-dependencies[Dealing with Efferent Dependencies]).\nIt also means that we will have to touch the class whenever we would like to integrate further functionality with the business event order completion.\n\nWe can change the application module interaction as follows:\n\n.Publishing an application event via Spring's `ApplicationEventPublisher`\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Service\n@RequiredArgsConstructor\npublic class OrderManagement {\n\n private final ApplicationEventPublisher events;\n private final OrderInternal dependency;\n\n @Transactional\n public void complete(Order order) {\n\n // State transition on the order aggregate go here\n\n events.publishEvent(new OrderCompleted(order.getId()));\n }\n}\n----\n\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Service\nclass OrderManagement(val events: ApplicationEventPublisher, val dependency: OrderInternal) {\n\n @Transactional\n fun complete(order: Order) {\n events.publishEvent(OrderCompleted(order.id))\n }\n}\n----\n======\n\nNote how, instead of depending on the other application module's Spring bean, we use Spring's `ApplicationEventPublisher` to publish a domain event once we have completed the state transitions on the primary aggregate.\nFor a more aggregate-driven approach to event publication, see https://docs.spring.io/spring-data/commons/reference/repositories/core-domain-events.html[Spring Data's application event publication mechanism] for details.\nAs event publication happens synchronously by default, the transactional semantics of the overall arrangement stay the same as in the example above.\nBoth for the good, as we get to a very simple consistency model (either both the status change of the order _and_ the inventory update succeed or none of them does), but also for the bad as more triggered related functionality will widen the transaction boundary and potentially cause the entire transaction to fail, even if the functionality that is causing the error is not crucial.\n\nA different way of approaching this is by moving the event consumption to asynchronous handling at transaction commit and treat secondary functionality exactly as that:\n\n.An async, transactional event listener\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Component\nclass InventoryManagement {\n\n @Async\n @TransactionalEventListener\n void on(OrderCompleted event) { /* … */ }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Component\nclass InventoryManagement {\n\n @Async\n @TransactionalEventListener\n fun on(event: OrderCompleted) { /* … */ }\n}\n----\n======\n\nThis now effectively decouples the original transaction from the execution of the listener.\nWhile this avoids the expansion of the original business transaction, it also creates a risk: if the listener fails for whatever reason, the event publication is lost, unless each listener actually implements its own safety net.\nEven worse, that doesn't even fully work, as the system might fail before the method is even invoked.\n\n[[aml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "events", "heading_level": 1, "file_order": 2, "section_index": 0, "content_hash": "cb68ccb3328322e08d35b69904ec338a5a34d4fdcffee0eba7f31cde92b1a211", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:063eff3ac2fb20e29285e301c25e6fbb2cb529a012f1ce2565efc6a891ab3903", "content": "To run a transactional event listener in a transaction itself, it would need to be annotated with `@Transactional` in turn.\n\n.An async, transactional event listener running in a transaction itself\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Component\nclass InventoryManagement {\n\n @Async\n @Transactional(propagation = Propagation.REQUIRES_NEW)\n @TransactionalEventListener\n void on(OrderCompleted event) { /* … */ }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Component\nclass InventoryManagement {\n\n @Async\n @Transactional(propagation = Propagation.REQUIRES_NEW)\n @TransactionalEventListener\n fun on(event: OrderCompleted) { /* … */ }\n}\n----\n======\n\nTo ease the declaration of what is supposed to describe the default way of integrating modules via events, Spring Modulith provides `@ApplicationModuleListener` as a shortcut.\n\n.An application module listener\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Component\nclass InventoryManagement {\n\n @ApplicationModuleListener\n void on(OrderCompleted event) { /* … */ }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Component\nclass InventoryManagement {\n\n @ApplicationModuleListener\n fun on(event: OrderCompleted) { /* … */ }\n}\n----\n======\n\n[[publication-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Application Module Listener", "heading_level": 2, "file_order": 2, "section_index": 1, "content_hash": "063eff3ac2fb20e29285e301c25e6fbb2cb529a012f1ce2565efc6a891ab3903", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:052a1cfc87b3babc4a954f30453392f4272b7879583a90f4885dff99b20cd074", "content": "Spring Modulith ships with an event publication registry that hooks into the core event publication mechanism of Spring Framework.\nOn event publication, it finds out about the transactional event listeners that will get the event delivered and writes entries for each of them (dark blue) into an event publication log as part of the original business transaction.\n\n.The transactional event listener arrangement before execution\nimage::event-publication-registry-start.png[]\n\nEach transactional event listener is wrapped into an aspect that marks that log entry as completed if the execution of the listener succeeds.\nIn case the listener fails, the log entry stays untouched so that retry mechanisms can be deployed depending on the application's needs.\nAutomatic re-publication of the events can be enabled via the xref:appendix.adoc#configuration-properties[`spring.modulith.events.republish-outstanding-events-on-restart`] property.\n\n.The transactional event listener arrangement after execution\nimage::event-publication-registry-end.png[]\n\n[[publication-registry.starters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "The Event Publication Registry", "heading_level": 2, "file_order": 2, "section_index": 2, "content_hash": "052a1cfc87b3babc4a954f30453392f4272b7879583a90f4885dff99b20cd074", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:f5aaad166d7ebbb6575800314c03ce016a5b21b410e3a7f37bf25f20e2bb4517", "content": "Using the transactional event publication log requires a combination of artifacts added to your application.\nTo ease that task, Spring Modulith provides starter POMs that are centered around the <<publication-registry.publication-repositories, persistence technology>> to be used and default to the Jackson-based <<publication-registry.serialization, EventSerializer>> implementation.\nThe following starters are available:\n\n[%header,cols=\"1,3,6\"]\n|===\n|Persistence Technology|Artifact|Description\n\n|JPA\n|`spring-modulith-starter-jpa`\n|Using JPA as persistence technology.\n\n|JDBC\n|`spring-modulith-starter-jdbc`\n|Using JDBC as persistence technology. Also works in JPA-based applications but bypasses your JPA provider for actual event persistence.\n\n|MongoDB\n|`spring-modulith-starter-mongodb`\n|Using MongoDB as persistence technology. Also enables MongoDB transactions and requires a replica set setup of the server to interact with. The transaction auto-configuration can be disabled by setting the `spring.modulith.events.mongodb.transaction-management.enabled` property to `false`.\n\n|Neo4j\n|`spring-modulith-starter-neo4j`\n|Using Neo4j behind Spring Data Neo4j.\n|===\n\n[[publication-registry.managing-publications]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Spring Boot Event Registry Starters", "heading_level": 3, "file_order": 2, "section_index": 3, "content_hash": "f5aaad166d7ebbb6575800314c03ce016a5b21b410e3a7f37bf25f20e2bb4517", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:721271584e5624f39d40eb1f892482de8e8d3a2828334d3dbd3228020dd76580", "content": "Event publications may need to be managed in a variety of ways during the runtime of an application.\nIncomplete publications might have to be re-submitted to the corresponding listeners after a given amount of time.\nCompleted publications on the other hand, will likely have to be purged from the database or moved into an archive store.\nAs the needs for that kind of housekeeping strongly vary from application to application, Spring Modulith offers an API to deal with both kinds of publications.\nThat API is available through the `spring-modulith-events-api` artifact that you can add to your application:\n\n.Using Spring Modulith Events API artifact\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"+attributes\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.modulith</groupId>\n <artifactId>spring-modulith-events-api</artifactId>\n <version>{projectVersion}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, subs=\"+attributes\", role=\"secondary\"]\n----\ndependencies {\n implementation 'org.springframework.modulith:spring-modulith-events-api:{projectVersion}'\n}\n----\n======\n\nThis artifact contains two primary abstractions that are available to application code as Spring Beans:\n\n* `CompletedEventPublications` -- This interface allows accessing all completed event publications, and provides an API to immediately purge all of them from the database or the completed publications older than a given duration (for example, 1 minute).\n* `IncompleteEventPublications` -- This interface allows accessing all incomplete event publications to resubmit either the ones matching a given predicate or older than a given `Duration` relative to the original publishing date.\n\n[[publication-registry.completion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Managing Event Publications", "heading_level": 3, "file_order": 2, "section_index": 4, "content_hash": "721271584e5624f39d40eb1f892482de8e8d3a2828334d3dbd3228020dd76580", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:8a8aed6672d2dd5a355e05783cec4fbe9dbcda5a5f1f475686a0d79091435ade", "content": "Event publications are marked as completed when a transactional or `@ApplicationModuleListener` execution completes successfully.\nBy default, the completion is registered by setting the completion date on an `EventPublication`.\nThis means that completed publications will remain in the Event Publication Registry so that they can be inspected through the `CompletedEventPublications` interface as described xref:events.adoc#publication-registry.managing-publications[above].\nA consequence of this is that you'll need to put some code in place that will periodically purge old, completed ``EventPublication``s.\nOtherwise, the persistent abstraction of them, for example a relational database table, will grow unbounded and the interaction with the store creating and completing new ``EventPublication`` might slow down.\n\nSpring Modulith 1.3 introduces a configuration property `spring.modulith.events.completion-mode` to support two additional modes of completion.\nIt defaults to `UPDATE` which is backed by the strategy described above.\nAlternatively, the completion mode can be set to `DELETE`, which alters the registry's persistence mechanisms to rather delete ``EventPublication``s on completion.\nThis means that `CompletedEventPublications` will not return any publications anymore, but at the same time, you don't have to worry about purging the completed events from the persistence store manually anymore.\n\nThe third option is the `ARCHIVE` mode, which copies the entry into an archive table, collection or node.\nFor that archive entry, the completion date is set and the original entry is removed.\nContrary to the `DELETE` mode, completed event publications are then still accessible via the `CompletedEventPublications` abstraction.\n\n[[publication-registry.publication-repositories]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Event Publication Completion", "heading_level": 3, "file_order": 2, "section_index": 5, "content_hash": "8a8aed6672d2dd5a355e05783cec4fbe9dbcda5a5f1f475686a0d79091435ade", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:6b854462d21fdf93b057f2fe3f6d39b3fcc8c95fdf333b8dd67ff021cafdd475", "content": "To actually write the event publication log, Spring Modulith exposes an `EventPublicationRepository` SPI and implementations for popular persistence technologies that support transactions, like JPA, JDBC and MongoDB.\nYou select the persistence technology to be used by adding the corresponding JAR to your Spring Modulith application.\nWe have prepared dedicated xref:events.adoc#starters[starters] to ease that task.\n\nThe JDBC-based implementation will create a dedicated table for the event publication log unless the respective configuration property (`spring.modulith.events.jdbc.schema-initialization.enabled`) is set to `false`.\nThe schema creation will of course also back off if the required tables already exist, for example if created via database migration tools such as Flyway or Liquibase.\nFor details, please consult the xref:appendix.adoc#schemas[schema overview] in the appendix.\n\n[[publication-registry.serialization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Event Publication Repositories", "heading_level": 3, "file_order": 2, "section_index": 6, "content_hash": "6b854462d21fdf93b057f2fe3f6d39b3fcc8c95fdf333b8dd67ff021cafdd475", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:60c5ed26c40387357b8e6bb9e31a4907b48fe1dfa873d7101db93f9183dc56d9", "content": "Each log entry contains the original event in serialized form.\nThe `EventSerializer` abstraction contained in `spring-modulith-events-core` allows plugging different strategies for how to turn the event instances into a format suitable for the datastore.\nSpring Modulith provides a Jackson-based JSON implementation through the `spring-modulith-events-jackson` artifact, which registers a `JacksonEventSerializer` consuming an `ObjectMapper` through standard Spring Boot auto-configuration by default.\n\n[[publication-registry.customize-publication-date]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Event Serializer", "heading_level": 3, "file_order": 2, "section_index": 7, "content_hash": "60c5ed26c40387357b8e6bb9e31a4907b48fe1dfa873d7101db93f9183dc56d9", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:675888a1dfe66a0127309f765be1f273c2735c5228b463336f9746852f898c82", "content": "By default, the Event Publication Registry will use the date returned by the `Clock.systemUTC()` as event publication date.\nIf you want to customize this, register a bean of type clock with the application context:\n\n[source, java]\n----\n@Configuration\nclass MyConfiguration {\n\n @Bean\n Clock myCustomClock() {\n return … // Your custom Clock instance created here.\n }\n}\n----\n\n[[externalization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Customizing the Event Publication Date", "heading_level": 3, "file_order": 2, "section_index": 8, "content_hash": "675888a1dfe66a0127309f765be1f273c2735c5228b463336f9746852f898c82", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:fb2050f4d790a0683c58a1d36c17b4f9a78cb4fc345fce3f3f944ba4864bc351", "content": "Some of the events exchanged between application modules might be interesting to external systems.\nSpring Modulith allows publishing selected events to a variety of message brokers.\nTo use that support you need to take the following steps:\n\n1. Add the <<externalization.infrastructure, broker-specific Spring Modulith artifact>> to your project.\n2. Select event types to be externalized by annotating them with either Spring Modulith's or jMolecules' `@Externalized` annotation.\n3. Specify the broker-specific routing target in the annotation's value.\n\nTo find out how to use other ways of selecting events for externalization, or customize their routing within the broker, check out <<externalization.fundamentals>>.\n\n[[externalization.infrastructure]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Externalizing Events", "heading_level": 2, "file_order": 2, "section_index": 9, "content_hash": "fb2050f4d790a0683c58a1d36c17b4f9a78cb4fc345fce3f3f944ba4864bc351", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:eee1beb8d9555008fdf405d13bc39106c043f566320c9c890c6f735588a9c2c6", "content": "[%header,cols=\"1,3,6\"]\n|===\n|Broker|Artifact|Description\n\n|Kafka\n|`spring-modulith-events-kafka`\n|Uses Spring Kafka for the interaction with the broker.\nThe logical routing key will be used as Kafka's topic and message key.\n\n|AMQP\n|`spring-modulith-events-amqp`\n|Uses Spring AMQP for the interaction with any compatible broker.\nRequires an explicit dependency declaration for Spring Rabbit for example.\nThe logical routing key will be used as AMQP routing key.\n\n|JMS\n|`spring-modulith-events-jms`\n|Uses Spring's core JMS support.\nDoes not support routing keys.\n\n|Spring Messaging\n|`spring-modulith-events-messaging`\n|Uses Spring's core `Message` and `MessageChannel` support.\nResolves the target `MessageChannel` by its bean name given the `target` in the `Externalized` annotation.\nForwards routing information as a header - called `springModulith_routingTarget` - to be processed in whatever way by downstream components, typically in a Spring Integration `IntegrationFlow`.\n\n|===\n\n[[externalization.fundamentals]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Supported Infrastructure", "heading_level": 3, "file_order": 2, "section_index": 10, "content_hash": "eee1beb8d9555008fdf405d13bc39106c043f566320c9c890c6f735588a9c2c6", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:9f3a5bec1e4ccca0eff093a298ed2084d844cb787f2d10d80b74129b509fa1bd", "content": "Spring Modulith's event externalization is implemented as xref:events.adoc#aml[transactional event listener] delegating to broker specific publication implementations.\nThat means that Spring Modulith's xref:events.adoc#publication-registry[Event Publication Registry] guards the externalization against failures during the interaction with the broker so that the publications can be resubmitted through the APIs provided.\n\nThe event externalization performs three steps on each application event published.\n\n1. _Determining whether the event is supposed to be externalized_ -- We refer to this as \"`event selection`\".\nBy default, only event types located within a Spring Boot auto-configuration package and annotated with one of the supported `@Externalized` annotations are selected for externalization.\n2. _Preparing the message (optional)_ -- By default, the event is serialized as is by the corresponding broker infrastructure.\nAn optional mapping step allows developers to customize or even completely replace the original event with a payload suitable for external parties.\nFor Kafka and AMQP, developers can also add headers to the message to be published.\n3. _Determining a routing target_ -- Message broker clients need a logical target to publish the message to.\nThe target usually identifies physical infrastructure (a topic, exchange, or queue depending on the broker) and is often statically derived from the event type.\nUnless defined in the `@Externalized` annotation specifically, Spring Modulith uses the application-local type name as target.\nIn other words, in a Spring Boot application with a base package of `com.acme.app`, an event type `com.acme.app.sample.SampleEvent` would get published to `sample.SampleEvent`.\n+\nSome brokers also allow to define a rather dynamic routing key, that is used for different purposes within the actual target.\nBy default, no routing key is used.\n\n[[externalization.annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Fundamentals of Event Externalization", "heading_level": 3, "file_order": 2, "section_index": 11, "content_hash": "9f3a5bec1e4ccca0eff093a298ed2084d844cb787f2d10d80b74129b509fa1bd", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:a38e46593563ea55ae79e3a2d8f6e677d1a8be8e728b7b3870d43c5e3ff74947", "content": "To define a custom routing key via the `@Externalized` annotations, a pattern of `$target::$key` can be used for the target/value attribute available in each of the particular annotations.\nBoth the target and key can be a SpEL expression which will get the event instance configured as root object.\n\n.Defining a dynamic routing key via SpEL expression\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Externalized(\"customer-created::#{#this.getLastname()}\") // <2>\nclass CustomerCreated {\n\n String getLastname() { // <1>\n // …\n }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Externalized(\"customer-created::#{#this.getLastname()}\") // <2>\nclass CustomerCreated {\n fun getLastname(): String { // <1>\n // …\n }\n}\n----\n======\n\nThe `CustomerCreated` event exposes the last name of the customer via an accessor method.\nThat method is then used via the ``&#35;this.getLastname()`` expression in key expression following the `::` delimiter of the target declaration.\n\nIf the key calculation becomes more involved, it is advisable to rather delegate that into a Spring bean that takes the event as argument:\n\n.Invoking a Spring bean to calculate a routing key\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Externalized(\"…::#{@beanName.someMethod(#this)}\")\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Externalized(\"…::#{@beanName.someMethod(#this)}\")\n----\n======\n\n[[externalization.api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Annotation-based Event Externalization Configuration", "heading_level": 3, "file_order": 2, "section_index": 12, "content_hash": "a38e46593563ea55ae79e3a2d8f6e677d1a8be8e728b7b3870d43c5e3ff74947", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:00fa446154a7d74952e36af40f3bea62aec2ab7ea5d866e87a82ca171002fe1c", "content": "The `spring-modulith-events-api` artifact contains `EventExternalizationConfiguration` that allows developers to customize all of the above mentioned steps.\n\n.Programmatically configuring event externalization\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Configuration\nclass ExternalizationConfiguration {\n\n @Bean\n EventExternalizationConfiguration eventExternalizationConfiguration() {\n\n return EventExternalizationConfiguration.externalizing() // <1>\n .select(EventExternalizationConfiguration.annotatedAsExternalized()) // <2>\n .mapping(SomeEvent.class, event -> …) // <3>\n .headers(event -> …) // <4>\n .routeKey(WithKeyProperty.class, WithKeyProperty::getKey) // <5>\n .build();\n }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Configuration\nclass ExternalizationConfiguration {\n\n @Bean\n fun eventExternalizationConfiguration(): EventExternalizationConfiguration {\n\n EventExternalizationConfiguration.externalizing() // <1>\n .select(EventExternalizationConfiguration.annotatedAsExternalized()) // <2>\n .mapping(SomeEvent::class.java) { event -> … } // <3>\n .headers() { event -> … } // <4>\n .routeKey(WithKeyProperty::class.java, WithKeyProperty::getKey) // <5>\n .build()\n }\n}\n----\n======\n\n<1> We start by creating a default instance of `EventExternalizationConfiguration`.\n<2> We customize the event selection by calling one of the `select(…)` methods on the `Selector` instance returned by the previous call.\nThis step fundamentally disables the application base package filter as we only look for the annotation now.\nConvenience methods to easily select events by type, by packages, packages and annotation exist.\nAlso, a shortcut to define selection and routing in one step.\n<3> We define a mapping step for `SomeEvent` instances.\nNote that the routing will still be determined by the original event instance, unless you additionally call `….routeMapped()` on the router.\n<4> We add custom headers to the message to be sent out either generally as shown or specific to a certain payload type.\n<5> We finally determine a routing key by defining a method handle to extract a value of the event instance.\nAlternatively, a full `RoutingKey` can be produced for individual events by using the general `route(…)` method on the `Router` instance returned from the previous call.\n\n[[externalization.serialization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Programmatic Event Externalization Configuration", "heading_level": 3, "file_order": 2, "section_index": 13, "content_hash": "00fa446154a7d74952e36af40f3bea62aec2ab7ea5d866e87a82ca171002fe1c", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:a3b807fabd1fe28aa5628871f96661c56045ced2b08e419a7b4f7e48820e0d1a", "content": "Spring Modulith's event externalization is implemented as transactional event listener.\nThis means that multiple threads might trigger the interaction with the broker at the same time.\nThis can become particularly relevant when event publications are resubmitted.\nAs the broker might see a sudden spike in interactions, some interactions might take a bit longer so that the externalization of later events might overtake former ones.\n\nTo prevent that, the interaction with the broker can be serialized so that only one event is sent out at a time by setting the `spring.modulith.events.externalization.serialize-externalization` property to `true`.\n\n[[testing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Serializing Event Externalization", "heading_level": 2, "file_order": 2, "section_index": 14, "content_hash": "a3b807fabd1fe28aa5628871f96661c56045ced2b08e419a7b4f7e48820e0d1a", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:0db47296fc99416b81e6a7fb0204e80b76399894708a2d5077cd8979a18b9207", "content": "NOTE: The following section describes a testing approach solely focused on tracking Spring application events.\nFor a more holistic approach on testing modules that use xref:testing.adoc[`@ApplicationModuleListener`], please check out the xref:testing.adoc#scenarios[`Scenario` API].\n\nSpring Modulith's `@ApplicationModuleTest` enables the ability to get a `PublishedEvents` instance injected into the test method to verify a particular set of events has been published during the course of the business operation under test.\n\n.Event-based integration testing of the application module arrangement\n[tabs]\n======\nJava::\n+\n[source, java, subs=\"quotes\", role=\"primary\"]\n----\n@ApplicationModuleTest\nclass OrderIntegrationTests {\n\n @Test\n void someTestMethod(**PublishedEvents events**) {\n\n // …\n var matchingMapped = events.ofType(OrderCompleted.class)\n .matching(OrderCompleted::getOrderId, reference.getId());\n\n assertThat(matchingMapped).hasSize(1);\n }\n}\n----\nKotlin::\n+\n[source, kotlin, subs=\"quotes\", role=\"secondary\"]\n----\n@ApplicationModuleTest\nclass OrderIntegrationTests {\n\n @Test\n fun someTestMethod(events: PublishedEvents events) {\n\n // …\n val matchingMapped = events.ofType(OrderCompleted::class.java)\n .matching(OrderCompleted::getOrderId, reference.getId())\n\n assertThat(matchingMapped).hasSize(1)\n }\n}\n----\n======\n\nNote how `PublishedEvents` exposes an API to select events matching a certain criteria.\nThe verification is concluded by an AssertJ assertion that verifies the number of elements expected.\nIf you are using AssertJ for those assertions anyway, you can also use `AssertablePublishedEvents` as test method parameter type and use the fluent assertion APIs provided through that.\n\n.Using `AssertablePublishedEvents` to verify event publications\n[tabs]\n======\nJava::\n+\n[source, java, subs=\"quotes\", role=\"primary\"]\n----\n@ApplicationModuleTest\nclass OrderIntegrationTests {\n\n @Test\n void someTestMethod(**AssertablePublishedEvents events**) {\n\n // …\n assertThat(events)\n .contains(OrderCompleted.class)\n .matching(OrderCompleted::getOrderId, reference.getId());\n }\n}\n----\nKotlin::\n+\n[source, kotlin, subs=\"quotes\", role=\"secondary\"]\n----\n@ApplicationModuleTest\nclass OrderIntegrationTests {\n\n @Test\n fun someTestMethod(events: AssertablePublishedEvents) {\n\n // …\n assertThat(events)\n .contains(OrderCompleted::class.java)\n .matching(OrderCompleted::getOrderId, reference.getId())\n }\n}\n----\n======\n\nNote how the type returned by the `assertThat(…)` expression allows to define constraints on the published events directly.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/events.adoc", "title": "events", "heading": "Testing published events", "heading_level": 2, "file_order": 2, "section_index": 15, "content_hash": "0db47296fc99416b81e6a7fb0204e80b76399894708a2d5077cd8979a18b9207", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/events.adoc"}}
{"id": "sha256:aa0d171d194c8d236d46d5573c8c7242f2c9c489b0322f521537ab449821d789", "content": "[[fundamentals]]\n\nSpring Modulith supports developers implementing logical modules in Spring Boot applications.\nIt allows them to apply structural validation, document the module arrangement, run integration tests for individual modules, observe the modules' interaction at runtime, and generally implement module interaction in a loosely coupled way.\nThis section will discuss the fundamental concepts that developers need to understand before diving into the technical support.\n\n[[modules]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "fundamentals", "heading_level": 1, "file_order": 3, "section_index": 0, "content_hash": "aa0d171d194c8d236d46d5573c8c7242f2c9c489b0322f521537ab449821d789", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:ba2e331494987929ee32750011e92f8e14bcb49ad5741e4f86728a79f87c15ef", "content": "In a Spring Boot application, an application module is a unit of functionality that consists of the following parts:\n\n* An API exposed to other modules implemented by Spring bean instances and application events published by the module, usually referred to as _provided interface_.\n* Internal implementation components that are not supposed to be accessed by other modules.\n* References to API exposed by other modules in the form of Spring bean dependencies, application events listened to and configuration properties exposed, usually referred to as _required interface_.\n\nSpring Modulith provides different ways of expressing modules within Spring Boot applications, primarily differing in the level of complexity involved in the overall arrangement.\nThis allows developers to start simple and naturally move to more sophisticated means as and if needed.\n\n[[modules.application-modules]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Application Modules", "heading_level": 2, "file_order": 3, "section_index": 1, "content_hash": "ba2e331494987929ee32750011e92f8e14bcb49ad5741e4f86728a79f87c15ef", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:85274931b5370b0f1598d2de8c205220988002f8c9ea5cc549a23487c636d3a0", "content": "Spring Modulith allows to inspect a codebase to derive an application module model based on the given arrangement and optional configuration.\nThe `spring-modulith-core` artifact contains `ApplicationModules` that can be pointed to a Spring Boot application class:\n\n.Creating an application module model\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nvar modules = ApplicationModules.of(Application.class);\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\nval modules = ApplicationModules.of(Application::class.java)\n----\n======\nThe `modules` will contain an in-memory representation of the application module arrangement derived from the codebase.\nWhich parts of that will be detected as a module depends on the Java package structure underneath the package the class pointed to resides in.\nFind out more about the arrangement expected by default in xref:fundamentals.adoc#modules.simple[].\nAdvanced arrangements and customization options are described in xref:fundamentals.adoc#modules.advanced[] and\n\nTo get an impression of what the analyzed arrangement looks like, we can just write the individual modules contained in the overall model to the console:\n\n.Writing the application module arrangement to the console\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nmodules.forEach(System.out::println);\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\nmodules.forEach { println(it) }\n----\n======\n.The console output of our application module arrangement\n[source]\n----\n## example.inventory ##\n> Logical name: inventory\n> Base package: example.inventory\n> Spring beans:\n + ….InventoryManagement\n o ….SomeInternalComponent\n\n## example.order ##\n> Logical name: order\n> Base package: example.order\n> Spring beans:\n + ….OrderManagement\n + ….internal.SomeInternalComponent\n----\n\nNote how each module is listed, the contained Spring components are identified, and the respective visibility is rendered, too.\n\n[[modules.excluding-packages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "The `ApplicationModules` Type", "heading_level": 3, "file_order": 3, "section_index": 2, "content_hash": "85274931b5370b0f1598d2de8c205220988002f8c9ea5cc549a23487c636d3a0", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:b865fcc8342fadc621275eecddb80dd2f2546d1ec9c57be3add4f0924de8a078", "content": "In case you would like to exclude certain Java classes or full packages from the application module inspection, you can do so with:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nApplicationModules.of(Application.class, JavaClass.Predicates.resideInAPackage(\"com.example.db\")).verify();\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\nApplicationModules.of(Application::class.java, JavaClass.Predicates.resideInAPackage(\"com.example.db\")).verify()\n----\n======\n\nAdditional examples of exclusions:\n\n* `com.example.db` -- Matches all files in the given package `com.example.db`.\n* `com.example.db..` -- Matches all files in the given package (`com.example.db`) and all sub-packages (`com.example.db.a` or `com.example.db.b.c`).\n* `..example..` -- Matches `a.example`, `a.example.b` or `a.b.example.c.d`, but not `a.exam.b`\n\nFull details about possible matchers can be found in the JavaDoc of ArchUnit https://github.com/TNG/ArchUnit/blob/main/archunit/src/main/java/com/tngtech/archunit/core/domain/PackageMatcher.java[`PackageMatcher`].\n\n[[modules.simple]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Excluding Packages", "heading_level": 4, "file_order": 3, "section_index": 3, "content_hash": "b865fcc8342fadc621275eecddb80dd2f2546d1ec9c57be3add4f0924de8a078", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:c0c537c554f960f005f9b80243f297cd870399b8f4cb6e2f7cb55c20bd65a0b7", "content": "The application's _main package_ is the one that the main application class resides in.\nThat is the class, that is annotated with `@SpringBootApplication` and usually contains the `main(…)` method used to run it.\nBy default, each direct sub-package of the main package is considered an _application module package_.\n\nIf this package does not contain any sub-packages, it is considered a simple one.\nIt allows to hide code inside it by using Java's package scope to hide types from being referred to by code residing in other packages and thus not subject to dependency injection into those.\nThus, naturally, the module's API consists of all public types in the package.\n\nLet us have a look at an example arrangement (icon:plus-circle[role=green] denotes a public type, icon:minus-circle[role=red] a package-private one).\n\n.A single inventory application module\n[source, subs=\"+specialchars, macros\"]\n----\nicon:cubes[] Example\n╰─ icon:folder[] src/main/java\n ├─ icon:cube[] example <1>\n │ ╰─ icon:plus-circle[role=green] Application.java\n ╰─ icon:cube[] example.inventory <2>\n ├─ icon:plus-circle[role=green] InventoryManagement.java\n ╰─ icon:minus-circle[role=red] SomethingInventoryInternal.java\n----\n<1> The application's main package `example`.\n<2> An application module package `inventory`.\n\n[[modules.advanced]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Simple Application Modules", "heading_level": 3, "file_order": 3, "section_index": 4, "content_hash": "c0c537c554f960f005f9b80243f297cd870399b8f4cb6e2f7cb55c20bd65a0b7", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:b44502ac04c963f6b282282fcce1745fa5540943a1408144192e58753c32bc23", "content": "If an application module package contains sub-packages, types in those might need to be made public so that it can be referred to from code of the very same module.\n\n.An inventory and order application module\n[source, subs=\"macros, quotes\"]\n----\nicon:cubes[] Example\n╰─ icon:folder[] src/main/java\n ├─ icon:cube[] example\n │ ╰─ icon:plus-circle[role=green] Application.java\n ├─ icon:cube[] example.inventory\n │ ├─ icon:plus-circle[role=green] InventoryManagement.java\n │ ╰─ icon:minus-circle[role=red] SomethingInventoryInternal.java\n ├─ **icon:cube[] example.order**\n │ ╰─ icon:plus-circle[role=green] OrderManagement.java\n ╰─ icon:cube[] example.order.internal\n ╰─ icon:plus-circle[role=green] SomethingOrderInternal.java\n----\n\nIn such an arrangement, the `order` package is considered an API package.\nCode from other application modules is allowed to refer to types within that.\n`order.internal`, just as any other sub-package of the application module base package, is considered an _internal_ one.\nCode within those must not be referred to from other modules.\nNote how `SomethingOrderInternal` is a public type, likely because `OrderManagement` depends on it.\nThis unfortunately means that it can also be referred to from other packages such as the `inventory` one.\nIn this case, the Java compiler is not of much use to prevent these illegal references.\n\n[[modules.nested]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Advanced Application Modules", "heading_level": 3, "file_order": 3, "section_index": 5, "content_hash": "b44502ac04c963f6b282282fcce1745fa5540943a1408144192e58753c32bc23", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:d4155e24fd2d9530d1e62b272c5fb6149b969ca58e86acec9c2aaa6881f3ca52", "content": "As of version 1.3, Spring Modulith application modules can contain nested modules.\nThis allows governing the internal structure in case a module contains parts to be logically separated in turn.\nTo define nested application modules, explicitly annotate packages that are supposed to constitute with `@ApplicationModule`.\n\n[source, subs=\"macros, quotes\"]\n----\nicon:cubes[] Example\n╰─ icon:folder[] src/main/java\n │\n ├─ icon:cube[] example\n │ ╰─ icon:plus-circle[role=green] Application.java\n │\n │ -> Inventory\n │\n ├─ icon:cube[] example.inventory\n │ ├─ icon:plus-circle[role=green] InventoryManagement.java\n │ ╰─ icon:minus-circle[role=red] SomethingInventoryInternal.java\n ├─ icon:cube[] example.inventory.internal\n │ ╰─ icon:minus-circle[role=red] SomethingInventoryInternal.java\n │\n │ -> Inventory > Nested\n │\n ├─ icon:cube[] example.inventory.nested\n │ ├─ icon:coffee[] package-info.java // @ApplicationModule\n │ ╰─ icon:plus-circle[role=orange] NestedApi.java\n ├─ icon:cube[] example.inventory.nested.internal\n │ ╰─ icon:minus-circle[role=red] NestedInternal.java\n │\n │ -> Order\n │\n ╰─ icon:cube[] example.order\n ├─ icon:plus-circle[role=green] OrderManagement.java\n ╰─ icon:minus-circle[role=red] SomethingOrderInternal.java\n----\n\nIn this example `inventory` is an application module as described xref:fundamentals.adoc#modules.simple[above].\nThe `@ApplicationModule` annotation on the `nested` package caused that to become a nested application module in turn.\nIn that arrangement, the following access rules apply:\n\n* The code in _Nested_ is only available from _Inventory_ or any types exposed by sibling application modules nested inside _Inventory_.\n* Any code in the _Nested_ module can access code in parent modules, even internal.\nI.e., both `NestedApi` and `NestedInternal` can access `inventory.internal.SomethingInventoryInternal`.\n* Code from nested modules can also access exposed types by top-level application modules.\nAny code in `nested` (or any sub-packages) can access `OrderManagement`.\n\n[[modules.open, modules.advanced.open]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Nested Application Modules", "heading_level": 3, "file_order": 3, "section_index": 6, "content_hash": "d4155e24fd2d9530d1e62b272c5fb6149b969ca58e86acec9c2aaa6881f3ca52", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:96cc52a18bd1b83ce1b973c95161056a1e15dd0412ba40014a21b4f0c3fdfaa6", "content": "The arrangement described xref:fundamentals.adoc#modules.advanced[above] are considered closed as they only expose types to other modules that are actively selected for exposure.\nWhen applying Spring Modulith to legacy applications, hiding all types located in nested packages from other modules might be inadequate or require marking all those packages for exposure, too.\n\nTo turn an application module into an open one, use the `@ApplicationModule` annotation on the `package-info.java` type.\n\n.Declaring an Application Modules as Open\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\", chomp=\"none\"]\n----\n@org.springframework.modulith.ApplicationModule(\n type = Type.OPEN\n)\npackage example.inventory;\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\", chomp=\"none\"]\n----\npackage example.inventory\n\nimport org.springframework.modulith.ApplicationModule\nimport org.springframework.modulith.PackageInfo\n\n@ApplicationModule(\n type = Type.OPEN\n)\n@PackageInfo\nclass ModuleMetadata {}\n----\n======\n\nDeclaring an application module as open will cause the following changes to the verification:\n\n* Access to application module internal types from other modules is generally allowed.\n* All types, also ones residing in sub-packages of the application module base package are added to the xref:fundamentals.adoc#modules.named-interfaces[unnamed named interface], unless explicitly assigned to a named interface.\n\nNOTE: This feature is intended to be primarily used with code bases of existing projects gradually moving to the Spring Modulith recommended packaging structure.\nIn a fully-modularized application, using open application modules usually hints at sub-optimal modularization and packaging structures.\n\n[[modules.explicit-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Open Application Modules", "heading_level": 3, "file_order": 3, "section_index": 7, "content_hash": "96cc52a18bd1b83ce1b973c95161056a1e15dd0412ba40014a21b4f0c3fdfaa6", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:55ce4b5b593ea0e4af3b6af7d72c22453c208530524e9f99830accedf1454888", "content": "A module can opt into declaring its allowed dependencies by using the `@ApplicationModule` annotation on the package, represented through the `package-info.java` file.\nAs, for example, Kotlin lacks support for that file, you can also use the annotation on a single type located in the application module's root package.\n\n.Inventory explicitly configuring module dependencies\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\", chomp=\"none\"]\n----\n@org.springframework.modulith.ApplicationModule(\n allowedDependencies = \"order\"\n)\npackage example.inventory;\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\", chomp=\"none\"]\n----\npackage example.inventory\n\nimport org.springframework.modulith.ApplicationModule\n\n@ApplicationModule(allowedDependencies = \"order\")\nclass ModuleMetadata {}\n----\n======\n\nIn this case code within the __inventory__ module was only allowed to refer to code in the __order__ module (and code not assigned to any module in the first place).\nFind out about how to monitor that in xref:verification.adoc[Verifying Application Module Structure].\n\n[[modules.named-interfaces]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Explicit Application Module Dependencies", "heading_level": 3, "file_order": 3, "section_index": 8, "content_hash": "55ce4b5b593ea0e4af3b6af7d72c22453c208530524e9f99830accedf1454888", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:794bfd8132e96da117a4a427de4f1619faf0cd264beb4e548f1f49f475b394da", "content": "By default and as described in xref:fundamentals.adoc#modules.advanced[Advanced Application Modules], an application module's base package is considered the API package and thus is the only package to allow incoming dependencies from other modules.\nIn case you would like to expose additional packages to other modules, you need to use __named interfaces__.\nYou achieve that by annotating the `package-info.java` file of those packages with `@NamedInterface` or a type explicitly annotated with `@org.springframework.modulith.PackageInfo`.\n\n.A package arrangement to encapsulate an SPI named interface\n[source, text, subs=\"macros, quotes\"]\n----\nicon:cubes[] Example\n╰─ icon:folder[] src/main/java\n ├─ icon:cube[] example\n │ ╰─ icon:plus-circle[role=green] Application.java\n ├─ …\n ├─ icon:cube[] example.order\n │ ╰─ icon:plus-circle[role=green] OrderManagement.java\n ├─ **icon:cube[] example.order.spi**\n │ ├— icon:coffee[] package-info.java\n │ ╰─ icon:plus-circle[role=green] SomeSpiInterface.java\n ╰─ icon:cube[] example.order.internal\n ╰─ icon:minus-circle[role=red] SomethingOrderInternal.java\n----\n\n.`package-info.java` in `example.order.spi`\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\", chomp=\"none\"]\n----\n@org.springframework.modulith.NamedInterface(\"spi\")\npackage example.order.spi;\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\", chomp=\"none\"]\n----\npackage example.order.spi\n\nimport org.springframework.modulith.PackageInfo\nimport org.springframework.modulith.NamedInterface\n\n@PackageInfo\n@NamedInterface(\"spi\")\nclass ModuleMetadata {}\n----\n======\nThe effect of that declaration is twofold: first, code in other application modules is allowed to refer to `SomeSpiInterface`.\nApplication modules are able to refer to the named interface in explicit dependency declarations.\nAssume the __inventory__ module was making use of that, it could refer to the above declared named interface like this:\n\n.Defining allowed dependencies to dedicated named interfaces\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\", chomp=\"none\"]\n----\n@org.springframework.modulith.ApplicationModule(\n allowedDependencies = \"order :: spi\"\n)\npackage example.inventory;\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\", chomp=\"none\"]\n----\npackage example.inventory\n\nimport org.springframework.modulith.ApplicationModule\nimport org.springframework.modulith.PackageInfo\n\n@ApplicationModule(\n allowedDependencies = \"order :: spi\"\n)\n@PackageInfo\nclass ModuleMetadata {}\n----\n======\n\nNote how we concatenate the named interface's name `spi` via the double colon `::`.\nIn this setup, code in __inventory__ would be allowed to depend on `SomeSpiInterface` and other code residing in the `order.spi` interface, but not on `OrderManagement` for example.\nFor modules without explicitly described dependencies, both the application module root package *and* the SPI one are accessible.\n\nIf you wanted to express that an application module is allowed to refer to all explicitly declared named interfaces, you can use the asterisk (``*``) as follows:\n\n.Using the asterisk to declare allowed dependencies to all declared named interfaces\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\", chomp=\"none\"]\n----\n@org.springframework.modulith.ApplicationModule(\n allowedDependencies = \"order :: *\"\n)\npackage example.inventory;\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\", chomp=\"none\"]\n----\npackage example.inventory\n\nimport org.springframework.modulith.ApplicationModule\nimport org.springframework.modulith.PackageInfo\n\n@ApplicationModule(\n allowedDependencies = \"order :: *\"\n)\n@PackageInfo\nclass ModuleMetadata {}\n----\n======\n\nIf you require more generic control about the named interfaces of an application module, check out xref:fundamentals.adoc#customizing-named-interfaces[the customization section].\n\n[[customizing-modules-arrangement]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Named Interfaces", "heading_level": 3, "file_order": 3, "section_index": 9, "content_hash": "794bfd8132e96da117a4a427de4f1619faf0cd264beb4e548f1f49f475b394da", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:ae1e1276cc82ffbba63f6fbbcadf52d26928ff5fd499eeb87417c1f8aa83566c", "content": "Spring Modulith allows to configure some core aspects around the application module arrangement you create via the `@Modulithic` annotation to be used on the main Spring Boot application class.\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\npackage example;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.modulith.Modulithic;\n\n@Modulithic\n@SpringBootApplication\nclass MyApplication {\n\n public static void main(String... args) {\n SpringApplication.run(MyApplication.class, args);\n }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\npackage example\n\nimport org.springframework.boot.autoconfigure.SpringBootApplication\nimport org.springframework.boot.runApplication\nimport org.springframework.modulith.Modulithic\n\n@Modulithic\n@SpringBootApplication\nclass MyApplication\n\nfun main(args: Array<String>) {\n runApplication<MyApplication>(*args)\n}\n----\n======\n\nThe annotation exposes the following attributes to customize:\n\n[cols=\"1,3\", options=\"header, unbreakable\"]\n|===\n|Annotation attribute\n|Description\n\n|`systemName`\n|The human readable name of the application to be used in generated xref:documentation.adoc#documentation[documentation].\n\n|`sharedModules`\n|Declares the application modules with the given names as shared modules, which means that they will always be included in xref:testing.adoc#testing[application module integration tests].\n\n|`additionalPackages`\n|Instructs Spring Modulith to treat the configured packages as additional root application packages. In other words, application module detection will be triggered for those as well.\n\n|===\n\n[[customizing-modules]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Customizing the Application Modules Arrangement", "heading_level": 2, "file_order": 3, "section_index": 10, "content_hash": "ae1e1276cc82ffbba63f6fbbcadf52d26928ff5fd499eeb87417c1f8aa83566c", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:a295f02b276fad3997ba9a2c0b302eb1e398f1d2a81b365ec07233bd3a1c7732", "content": "By default, application modules will be expected to be located in direct sub-packages of the package the Spring Boot application class resides in.\nAn alternative detection strategy can be activated to only consider packages explicitly annotated, either via Spring Modulith's `@ApplicationModule` or jMolecules `@Module` annotation.\nThat strategy can be activated by configuring the `spring.modulith.detection-strategy` to `explicitly-annotated`.\n\n.Switching the application module detection strategy to only consider annotated packages\n[source, text]\n----\nspring.modulith.detection-strategy=explicitly-annotated\n----\n\nIf neither the default application module detection strategy nor the manually annotated one works for your application, the detection of the modules can be customized by providing an implementation of `ApplicationModuleDetectionStrategy`.\nThat interface exposes a single method `Stream<JavaPackage> getModuleBasePackages(JavaPackage)` and will be called with the package the Spring Boot application class resides in.\nYou can then inspect the packages residing within that and select the ones to be considered application module base packages based on a naming convention or the like.\n\nAssume you declare a custom `ApplicationModuleDetectionStrategy` implementation like this:\n\n.Implementing a custom `ApplicationModuleDetectionStrategy`\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\npackage example;\n\nclass CustomApplicationModuleDetectionStrategy implements ApplicationModuleDetectionStrategy {\n\n @Override\n public Stream<JavaPackage> getModuleBasePackages(JavaPackage basePackage) {\n // Your module detection goes here\n }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\npackage example\n\nclass CustomApplicationModuleDetectionStrategy : ApplicationModuleDetectionStrategy {\n\n override fun getModuleBasePackages(basePackage: JavaPackage): Stream<JavaPackage> {\n // Your module detection goes here\n }\n}\n----\n======\n\nThis class can now be registered as `spring.modulith.detection-strategy` as follows:\n\n[source, text]\n----\nspring.modulith.detection-strategy=example.CustomApplicationModuleDetectionStrategy\n----\n\nIf you are implementing the `ApplicationModuleDetectionStrategy` interface to customize the verification and documentation of modules, include the customization and its registration in your application's test sources.\nHowever, if you are using Spring Modulith xref:runtime.adoc#spring-modulith-runtime-support[runtime components] (such as the ``ApplicationModuleInitializer``s, or the xref:production-ready.adoc#production-ready-features[production-ready features] like the actuator and observability support), you need to explicitly declare the following as a compile-time dependency:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.modulith</groupId>\n <artifactId>spring-modulith-core</artifactId>\n</dependency>\n----\nGradle::\n+\n[source, groovy, role=\"secondary\"]\n----\ndependencies {\n implementation 'org.springframework.modulith:spring-modulith-core'\n}\n----\n======\n\n[[contributing-application-modules]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Customizing Module Detection", "heading_level": 3, "file_order": 3, "section_index": 11, "content_hash": "a295f02b276fad3997ba9a2c0b302eb1e398f1d2a81b365ec07233bd3a1c7732", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:9e3ba6bea7a3834df5b5c2d4f9d3aad72619a614d0e2f94269e43f556d1c688a", "content": "While `@Modulithic` allows defining `additionalPackages` to trigger application module detection for packages other than the one of the annotated class, its usage requires knowing about those in advance.\nAs of version 1.3, Spring Modulith supports external contributions of application modules via the `ApplicationModuleSource` and `ApplicationModuleSourceFactory` abstractions.\nAn implementation of the latter can be registered in a `spring.factories` file located in `META-INF`.\n\n[source, text]\n----\norg.springframework.modulith.core.ApplicationModuleSourceFactory=example.CustomApplicationModuleSourceFactory\n----\n\nSuch a factory can either return arbitrary package names to get an `ApplicationModuleDetectionStrategy` applied, or explicitly return packages to create modules for.\n\n[source, java]\n----\npackage example;\n\npublic class CustomApplicationModuleSourceFactory implements ApplicationModuleSourceFactory {\n\n\t@Override\n\tpublic List<String> getRootPackages() {\n return List.of(\"com.acme.toscan\");\n\t}\n\n\t@Override\n\tpublic ApplicationModuleDetectionStrategy getApplicationModuleDetectionStrategy() {\n return ApplicationModuleDetectionStrategy.explicitlyAnnotated();\n\t}\n\n\t@Override\n\tpublic List<String> getModuleBasePackages() {\n return List.of(\"com.acme.module\");\n\t}\n}\n----\n\nThe above example would use `com.acme.toscan` to detect xref:fundamentals.adoc#customizing-modules[explicitly declared modules] within that and also create an application module from `com.acme.module`.\nThe package names returned from these will subsequently be translated into ``ApplicationModuleSource``s via the corresponding `getApplicationModuleSource(…)` flavors exposed in `ApplicationModuleDetectionStrategy`.\n\n[[customizing-named-interfaces]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Contributing Application Modules From Other Packages", "heading_level": 3, "file_order": 3, "section_index": 12, "content_hash": "9e3ba6bea7a3834df5b5c2d4f9d3aad72619a614d0e2f94269e43f556d1c688a", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:5ebf32b7aecc2a910933a3c34b0f158d8c7ad42c231738bbf3401b0645f0aa5b", "content": "If you would like to programatically describe the named interfaces of an application module, register an `ApplicationModuleDetectionStrategy` as described xref:fundamentals.adoc#customizing-modules[here] and use the `detectNamedInterfaces(JavaPackage, ApplicationModuleInformation)` to implement a custom discovery algorithm.\n\n.Customizing the named interface detection using a custom `ApplicationModuleDetectionStrategy`\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\npackage example;\n\nclass CustomApplicationModuleDetectionStrategy implements ApplicationModuleDetectionStrategy {\n\n\t@Override\n\tpublic Stream<JavaPackage> getModuleBasePackages(JavaPackage basePackage) {\n // Your module detection goes here\n\t}\n\n\t@Override\n\tNamedInterfaces detectNamedInterfaces(JavaPackage basePackage, ApplicationModuleInformation information) {\n return NamedInterfaces.builder()\n .recursive()\n .matching(\"api\")\n .build();\n\t}\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\npackage example\n\nclass CustomApplicationModuleDetectionStrategy : ApplicationModuleDetectionStrategy {\n\n\toverride fun getModuleBasePackages(basePackage: JavaPackage): Stream<JavaPackage> {\n // Your module detection goes here\n\t}\n\n\toverride fun detectNamedInterfaces(basePackage: JavaPackage, information: ApplicationModuleInformation): NamedInterfaces {\n return NamedInterfaces.builder()\n .recursive()\n .matching(\"api\")\n .build()\n\t}\n}\n----\n======\n\nIn the `detectNamedInterfaces(…)` implementation shown above, we build up a `NamedInterfaces` instance for all packages named `api` underneath the given application module's base package.\nThe `Builder` API exposes additional methods to select packages as named interfaces or explicitly exclude them from that.\nNote, that the builder will always include the unnamed named interface containing all public methods located in the application module's base package as that interface is required for application modules.\n\nFor a more manual setup of a `NamedInterfaces`, be sure to check out its factory methods and the ones exposed by `NamedInterface`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/fundamentals.adoc", "title": "fundamentals", "heading": "Customizing Named Interface detection", "heading_level": 3, "file_order": 3, "section_index": 13, "content_hash": "5ebf32b7aecc2a910933a3c34b0f158d8c7ad42c231738bbf3401b0645f0aa5b", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/fundamentals.adoc"}}
{"id": "sha256:ffdb42edc00a056fea1dc544f1379de20b9c7eac7c314fc46679ea51bac0417e", "content": "[[spring-modulith-reference-documentation]]\nOliver Drotbohm\n\n© 2022-2025 The original authors.\n\nNOTE: Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.\n\n[[overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 4, "section_index": 0, "content_hash": "ffdb42edc00a056fea1dc544f1379de20b9c7eac7c314fc46679ea51bac0417e", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:c9b313968e4f154ae73b4541fa1aa38c81cc40bea9c94f135a5bd2b59f86be9e", "content": "Spring Modulith is an opinionated toolkit to build domain-driven, modular applications with Spring Boot.\nIn the same way that Spring Boot has an opinion on the technical arrangement of an application, Spring Modulith implements an opinion on how to structure an app functionally and allows its individual, logical parts to interact with each other.\nAs a result, Spring Modulith enables developers to build applications that are easier to update so they can accommodate changing business requirements over time.\n\n[[preface.project-metadata]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/index.adoc", "title": "index", "heading": "Overview", "heading_level": 2, "file_order": 4, "section_index": 1, "content_hash": "c9b313968e4f154ae73b4541fa1aa38c81cc40bea9c94f135a5bd2b59f86be9e", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:b31bc97fbb31a1b68990d628e3840eeaf7aa4a2ad1341931aa3b26b24ad9c53c", "content": "* Version control https://github.com/spring-projects/spring-modulith\n* Bug tracker: https://github.com/spring-projects/spring-modulith\n* Release repository: Maven central\n* Milestone repository: https://repo.spring.io/milestone\n* Snapshot repository: https://repo.spring.io/snapshot\n* Javadoc: https://docs.spring.io/spring-modulith/docs/{projectVersion}/api\n\n[[compatibility]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/index.adoc", "title": "index", "heading": "Project Metadata", "heading_level": 2, "file_order": 4, "section_index": 2, "content_hash": "b31bc97fbb31a1b68990d628e3840eeaf7aa4a2ad1341931aa3b26b24ad9c53c", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:262bf63bf8351aadc627c4fa079221e312031d564c59b0bf082d9dfcd829dca9", "content": "Find a full Spring Boot compatibility matrix xref:appendix.adoc#compatibility-matrix[here].\n\n[[using-spring-modulith]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/index.adoc", "title": "index", "heading": "Spring Boot compatibility", "heading_level": 2, "file_order": 4, "section_index": 3, "content_hash": "262bf63bf8351aadc627c4fa079221e312031d564c59b0bf082d9dfcd829dca9", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:91736b017a3f36464e98d65e863011b418bcffaab8c9ea7da495b15c5bac981b", "content": "Spring Modulith consists of a set of libraries that can be used individually and depending on which features of it you would like to use.\nTo ease the declaration of the individual modules, we recommend to declare the following BOM in your Maven POM:\n\n.Using the Spring Modulith BOM\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"+attributes\", role=\"primary\"]\n----\n<dependencyManagement>\n <dependencies>\n <dependency>\n <groupId>org.springframework.modulith</groupId>\n <artifactId>spring-modulith-bom</artifactId>\n <version>{projectVersion}</version>\n <scope>import</scope>\n <type>pom</type>\n </dependency>\n </dependencies>\n</dependencyManagement>\n----\n\nGradle::\n+\n[source, subs=\"+attributes\", role=\"secondary\"]\n----\ndependencyManagement {\n\timports {\n mavenBom 'org.springframework.modulith:spring-modulith-bom:{projectVersion}'\n\t}\n}\n----\n======\n\nThe individual sections describing Spring Modulith features will refer to the individual artifacts that are needed to make use of the feature.\nFor an overview about all modules available, have a look at xref:appendix.adoc#artifacts[Spring Modulith modules].\n\n[[examples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/index.adoc", "title": "index", "heading": "Using Spring Modulith", "heading_level": 2, "file_order": 4, "section_index": 4, "content_hash": "91736b017a3f36464e98d65e863011b418bcffaab8c9ea7da495b15c5bac981b", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:14af2071564ea96d082f83ca425af64097d89d97efdf135cda7feb66f113d718", "content": "If you would like to play with the features of the project and see them live in action, check out the examples https://github.com/spring-projects/spring-modulith/tree/{projectVersion}/spring-modulith-examples[here]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/index.adoc", "title": "index", "heading": "Examples", "heading_level": 2, "file_order": 4, "section_index": 5, "content_hash": "14af2071564ea96d082f83ca425af64097d89d97efdf135cda7feb66f113d718", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:f11e0bdfc5eadd2603732970853f923057b6a210befb63a082c2198253909fd0", "content": "[[moments]]\n\n`spring-modulith-moments` is a Passage of Time Events implementation heavily inspired by Matthias Verraes https://verraes.net/2019/05/patterns-for-decoupling-distsys-passage-of-time-event/[blog post].\nIt's an event-based approach to time to trigger actions that are tied to a particular period of time having passed.\n\nTo use the abstraction, include the following dependency in your project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.modulith</groupId>\n <artifactId>spring-modulith-moments</artifactId>\n</dependency>\n----\n\nGradle::\n+\n[source, role=\"secondary\"]\n----\ndependencies {\n implementation 'org.springframework.modulith:spring-modulith-moments'\n}\n----\n======\n\nThe dependency added to the project's classpath causes the following things in your application:\n\n* Application code can refer to `HourHasPassed`, `DayHasPassed`, `WeekHasPassed`, `MonthHasPassed`, `QuarterHasPassed`, `YearHasPassed` types in Spring event listeners to get notified if a certain amount of time has passed.\n* A bean of type `org.springframework.modulith.Moments` is available in the `ApplicationContext` that contains the logic to trigger these events.\n* If `spring.modulith.moments.enable-time-machine` is set to `true`, that instance will be a `org.springframework.modulith.TimeMachine` which allows to \"shift\" time and by that triggers all intermediate events, which is useful to integration test functionality that is triggered by the events.\n\nBy default, Moments uses a `Clock.systemUTC()` instance. To customize this, declare a bean of type `Clock`.\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Configuration\nclass MyConfiguration {\n\n @Bean\n Clock myCustomClock() {\n // Create a custom Clock here\n }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Configuration\nclass MyConfiguration {\n\n @Bean\n fun myCustomClock(): Clock {\n // Create a custom Clock here\n }\n}\n----\n======\n\nMoments exposes the following application properties for advanced customization:\n\n.Available application properties\n[%header, cols=\"3,1,2\"]\n|===\n|Property|Default value|Description\n|`spring.modulith.moments.enable-time-machine`|false|If set to `true`, the `Moments` instance will be a `TimeMachine`, that exposes API to shift time forward. Useful for integration tests that expect functionality triggered by the Passage of Time Events.\n|`spring.modulith.moments.granularity`|hours|The minimum granularity of events to be fired. Alternative value `days` to avoid hourly events.\n|`spring.modulith.moments.locale`|`Locale.getDefault()`|The `Locale` to use when determining week boundaries.\n|`spring.modulith.moments.quarter-start-month`|`Months.JANUARY`|The month at which quarters start.\n|`spring.modulith.moments.zone-id`|`ZoneOffset#UTC`|The `ZoneId` to determine times which are attached to the events published.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/moments.adoc", "title": "moments", "heading": "moments", "heading_level": 1, "file_order": 5, "section_index": 0, "content_hash": "f11e0bdfc5eadd2603732970853f923057b6a210befb63a082c2198253909fd0", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/moments.adoc"}}
{"id": "sha256:e10a8ad4138c2039f848c2a74ca31b8dba39c9123f884fa1660f7dce7896b8c6", "content": "[[production-ready]]\n\nNOTE: If you are applying customizations to the application module detection described xref:fundamentals.adoc#customizing-modules[here], you need to move those into your production sources, unless already present there, to make sure that those are considered by the features described here.\n\nSpring Modulith provides support to expose architectural information about your system as a Spring Boot actuator endpoint as well as observing the interaction between application modules by capturing metrics and traces.\nAs a production-ready application is likely to require both, the most convenient way to activate those features is to use the Spring Modulith Insight starter as follows:\n\n.Using the Spring Modulith Insight starter\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"+attributes\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.modulith</groupId>\n <artifactId>spring-modulith-starter-insight</artifactId>\n <version>{projectVersion}</version>\n <scope>runtime</scope>\n</dependency>\n----\n\nGradle::\n+\n[source, subs=\"+attributes\", role=\"secondary\"]\n----\ndependencies {\n runtimeOnly 'org.springframework.modulith:spring-modulith-starter-insight:{projectVersion}'\n}\n----\n======\n\nThis will include the actuator and observability support as well as Spring Boot's actuator startup for general support for actuators.\nNote, that you will still have to add further dependencies to connect your application to your monitoring tools such as https://zipkin.io/[Zipkin], https://docs.wavefront.com/[Wavefront] etc. usually via https://opentelemetry.io/[OpenTelemetry] or https://github.com/openzipkin/brave[Brave].\nFind more information on that in https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#actuator.micrometer-tracing[the corresponding section] of Spring Boot's reference documentation.\n\n[[actuator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/production-ready.adoc", "title": "production-ready", "heading": "production-ready", "heading_level": 1, "file_order": 6, "section_index": 0, "content_hash": "e10a8ad4138c2039f848c2a74ca31b8dba39c9123f884fa1660f7dce7896b8c6", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/production-ready.adoc"}}
{"id": "sha256:6138395e96b576511041c0ee832acb1bc1ec67ecd346b2df96de58943f26db2d", "content": "The application module structure can be exposed as Spring Boot actuator.\nTo enable the actuator, add the `spring-modulith-actuator` dependency to the project, unless you already declared the `spring-modulith-starter-insight` as described xref:production-ready.adoc#production-ready[above]:\n\n.Using the Spring Modulith actuator support\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"+attributes\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.modulith</groupId>\n <artifactId>spring-modulith-actuator</artifactId>\n <version>{projectVersion}</version>\n <scope>runtime</scope>\n</dependency>\n\n<!-- Spring Boot actuator starter required to enable actuators in general -->\n<dependency>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-actuator</artifactId>\n <version>…</version>\n <scope>runtime</scope>\n</dependency>\n----\n\nGradle::\n+\n[source, subs=\"+attributes\", role=\"secondary\"]\n----\ndependencies {\n runtimeOnly 'org.springframework.modulith:spring-modulith-actuator:{projectVersion}'\n}\n\n<!-- Spring Boot actuator starter required to enable actuators in general -->\ndependencies {\n runtimeOnly 'org.springframework.boot:spring-boot-starter-actuator'\n}\n----\n======\n\nRunning the application will now expose an `modulith` actuator resource:\n\n.Accessing the actuator HTTP resource\n[source, json]\n----\nGET http://localhost:8080/actuator\n\n{\n \"_links\": {\n \"self\": {\n \"href\": \"http://localhost:8080/actuator\",\n \"templated\": false\n },\n \"health-path\": {\n \"href\": \"http://localhost:8080/actuator/health/{*path}\",\n \"templated\": true\n },\n \"health\": {\n \"href\": \"http://localhost:8080/actuator/health\",\n \"templated\": false\n },\n \"modulith\": { <1>\n \"href\": \"http://localhost:8080/actuator/modulith\",\n \"templated\": false\n }\n }\n}\n----\n<1> The `modulith` actuator resource advertised.\n\nThe `modulith` resource adheres to the following structure:\n\n.The JSON structure of the application modules actuator\n[%autowidth.stretch]\n|===\n|JSONPath|Description\n\n|`+$.{moduleName}+`|The technical name of an application module. Target for module references in `dependencies.target`.\n|`+$.{moduleName}.displayName+`|The human-readable name of the application module.\n|`+$.{moduleName}.basePackage+`|The application module's base package.\n|`+$.{moduleName}.parent+`|(optional) The name of the parent module. See xref:fundamentals.adoc#modules.nested for details.\n|`+$.{moduleName}.nested+`|The names of nested modules, if any. See xref:fundamentals.adoc#modules.nested for details.\n|`+$.{moduleName}.dependencies[]+`|All outgoing dependencies of the application module\n|`+$.{moduleName}.dependencies[].target+`|The name of the application module depended on. A reference to a `+{moduleName}+`.\n|`+$.{moduleName}.dependencies[].types[]+`|The types of dependencies towards the target module. Can either be `DEFAULT` (simple type dependency), `USES_COMPONENT` (Spring bean dependency) or `EVENT_LISTENER`.\n|===\n\nAn example module arrangement would look like this:\n\n.An example response for the application modules actuator\n[source, json]\n----\n{\n \"a\": {\n \"basePackage\": \"example.a\",\n \"displayName\": \"A\",\n \"dependencies\": []\n },\n \"b\": {\n \"basePackage\": \"example.b\",\n \"displayName\": \"B\",\n \"dependencies\": [ {\n \"target\": \"a\",\n \"types\": [ \"EVENT_LISTENER\", \"USES_COMPONENT\" ]\n } ]\n }\n}\n----\n\n[[observability]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/production-ready.adoc", "title": "production-ready", "heading": "[[observability.actuator]]Application Module Actuator", "heading_level": 2, "file_order": 6, "section_index": 1, "content_hash": "6138395e96b576511041c0ee832acb1bc1ec67ecd346b2df96de58943f26db2d", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/production-ready.adoc"}}
{"id": "sha256:fa08ae1686d57d6d31008066cbc11ff2c5a905ae7663e6c786f1012d681a69d5", "content": "The interaction between application modules can be intercepted to create Micrometer spans to ultimately end up in traces you can visualize in tools like https://zipkin.io/[Zipkin] or https://grafana.com/[Grafana].\nTo activate the instrumentation add the following runtime dependency to your project, unless you already declared the `spring-modulith-starter-insight` as described xref:production-ready.adoc#production-ready[above]:\n\n.Using the Spring Modulith observability support\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"+attributes\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.modulith</groupId>\n <artifactId>spring-modulith-observability-core</artifactId>\n <version>{projectVersion}</version>\n <scope>runtime</scope>\n</dependency>\n----\n\nGradle::\n+\n[source, subs=\"+attributes\", role=\"secondary\"]\n----\ndependencies {\n runtimeOnly 'org.springframework.modulith:spring-modulith-observability-core:{projectVersion}'\n}\n----\n======\n\nIn case you would like to customize metrics created for application event publications, you will also need to declare the `spring-modulith-observability-api` artifact in compile scope.\n\nNOTE: You will have to configure additional infrastructure dependencies depending on the tooling you want to pipe the observability metadata in.\nFor details, please check the corresponding https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#actuator.micrometer-tracing[Spring Boot documentation] on which dependencies to include for your setup.\n\nThis will cause all Spring components that are part of the application module's API being decorated with an aspect that will intercept invocations and create Micrometer spans for them.\nA sample invocation trace can be seen below:\n\n.A sample module invocation trace\nimage::observability.png[]\n\nIn this particular case, triggering the payment changes the state of the order which then causes an order completion event being triggered.\nThis gets picked up asynchronously by the engine that triggers another state change on the order, works for a couple of seconds and triggers the final state change on the order in turn.\n\n[[observability-spans]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/production-ready.adoc", "title": "production-ready", "heading": "[[observability]]Observing Application Modules", "heading_level": 2, "file_order": 6, "section_index": 2, "content_hash": "fa08ae1686d57d6d31008066cbc11ff2c5a905ae7663e6c786f1012d681a69d5", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/production-ready.adoc"}}
{"id": "sha256:23150912c56b3c09679c02921b33dde986f1c801dcb2cc35f159d0b230f5b1bf", "content": "[[observability-spans-module-entry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/production-ready.adoc", "title": "production-ready", "heading": "Observability Spans", "heading_level": 3, "file_order": 6, "section_index": 3, "content_hash": "23150912c56b3c09679c02921b33dde986f1c801dcb2cc35f159d0b230f5b1bf", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/production-ready.adoc"}}
{"id": "sha256:45dcaa3f705b408c556842842fea147c0084a27a0c03ee2ad937125f16f1f4c1", "content": ".Tag Keys\n|===\n|Name | Description\n|`module.identifier`|The identifier of the module.\n|`module.invocation-type`|Type of invocation (\"event listener\" or \"bean\").\n|`module.method`|Method executed on a module.\n|`module.name`|Name of the module.\n|===\n\n[[observability-metrics]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/production-ready.adoc", "title": "production-ready", "heading": "Module Entry Span", "heading_level": 4, "file_order": 6, "section_index": 4, "content_hash": "45dcaa3f705b408c556842842fea147c0084a27a0c03ee2ad937125f16f1f4c1", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/production-ready.adoc"}}
{"id": "sha256:b26740488a8f5f935a2482d36ed8b8c3f3e94ee3d7e3b97fbbb77bb6675e00fe", "content": "Spring Modulith registers data for all domain events published in the application in the form of two metrics.\n\n- `module.events.published` – a counter summarizing all event publications.\n- `module.events.published.$moduleIdentifier.$simpleEventTypeName` - a counter for the individual event that can be further enriched with domain-specific values.\n\n[[observability-metrics-all-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/production-ready.adoc", "title": "production-ready", "heading": "Observability Metrics", "heading_level": 3, "file_order": 6, "section_index": 5, "content_hash": "b26740488a8f5f935a2482d36ed8b8c3f3e94ee3d7e3b97fbbb77bb6675e00fe", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/production-ready.adoc"}}
{"id": "sha256:1ee8503b9f03a6fb1a6f552325af9516fa32f4b04d7b9135ccf76fa52dc0b90f", "content": ".Low cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`module.event.type`|Type of the emitted event.\n|`module.identifier`|The identifier of the module.\n|`module.name`|Name of the module.\n|===\n\n[[observability-metrics-individual-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/production-ready.adoc", "title": "production-ready", "heading": "The All Events Metric", "heading_level": 4, "file_order": 6, "section_index": 6, "content_hash": "1ee8503b9f03a6fb1a6f552325af9516fa32f4b04d7b9135ccf76fa52dc0b90f", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/production-ready.adoc"}}
{"id": "sha256:950f7e8a4c5e9fbcee492e4255be7e2f1668a25b706ec4ee23316dd69b0feecd", "content": ".Low cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`module.identifier`|The identifier of the module.\n|`module.name`|Name of the module.\n|===\n\nAdditional tags can be added to the invidual events metrics by implementing a `ModulithEventMetricsCustomizer`.\n\n[source, java]\n----\n@Configuration\nclass ObservabilityConfiguration {\n\n @Bean\n ModulithEventMetricsCustomizer modulithEventMetricsCustomizer() {\n\n return metrics -> {\n\n metrics.customize(MyCustomDomainEvent.class, (event, it) -> {\n it.tags(\"someTag\", event.getValue());\n });\n };\n }\n}\n----\n\nNote how we are able to refer to the individual domain events by type and can translate values of the particular event into a value on the metric.\n\n[[observability-conventions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/production-ready.adoc", "title": "production-ready", "heading": "The Individual Events Metric", "heading_level": 4, "file_order": 6, "section_index": 7, "content_hash": "950f7e8a4c5e9fbcee492e4255be7e2f1668a25b706ec4ee23316dd69b0feecd", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/production-ready.adoc"}}
{"id": "sha256:0d7b57b01d0da17d0621ffe188aef7a6ed22d3e87b01a2ff0278dbafca884b3b", "content": "The metrics created by Spring Modulith can be customized by providing a `ModulithObservationConvention` as bean in your application.\n\n[source, java]\n----\n@Configuration\nclass ObservabilityConfiguration {\n\n @Bean\n ModulithObservationConvention observationConvention() {\n return new CustomModulithObservationConvention();\n }\n}\n----\n\nOur default implementation delegates all calls to methods on `ModulithContext`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/production-ready.adoc", "title": "production-ready", "heading": "Conventions", "heading_level": 4, "file_order": 6, "section_index": 8, "content_hash": "0d7b57b01d0da17d0621ffe188aef7a6ed22d3e87b01a2ff0278dbafca884b3b", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/production-ready.adoc"}}
{"id": "sha256:412a4f2cdf9c91927758dbd92f2d9d41aee3416298aa1bd2900609ea876bbbba", "content": "[[runtime]]\n\nThe functionality described in previous chapters have all used the application module arrangement in either testing scenarios for verification and documentation purposes or were general support functionality that help to loosely couple modules but did not work with the application module structure directly.\nIn this section we are going to describe Spring Modulith's support for module initialization at application runtime.\n\nNOTE: If you are applying customizations to the application module detection described xref:fundamentals.adoc#customizing-modules[here], you need to move those into your production sources, unless already present there, to make sure that those are considered by the features described here.\n\n[[setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/runtime.adoc", "title": "runtime", "heading": "runtime", "heading_level": 1, "file_order": 7, "section_index": 0, "content_hash": "412a4f2cdf9c91927758dbd92f2d9d41aee3416298aa1bd2900609ea876bbbba", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/runtime.adoc"}}
{"id": "sha256:bbae9f09b20d9b67ed395f1eb27a9aa02837f349a7195f8c05bbb37b8bf5f933", "content": "To enable the runtime support for Spring Modulith, make sure you include the `spring-modulith-runtime` JAR in your project.\n[tabs]\n======\nMaven::\n+\n[source, xml, role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.modulith</groupId>\n <artifactId>spring-modulith-runtime</artifactId>\n <scope>runtime</scope>\n</dependency>\n----\n\nGradle::\n+\n[source, xml, role=\"secondary\"]\n----\ndependencies {\n runtimeOnly 'org.springframework.modulith:spring-modulith-runtime'\n}\n----\n======\n\nAdding this JAR will cause Spring Boot auto-configuration to run that registers the following components in your application:\n\n* An `ApplicationModulesRuntime` that allows to access the `ApplicationModules`.\n* A `SpringBootApplicationRuntime` to back the former bean to detect the main application class.\n* A `RuntimeApplicationModuleVerifier` to verify the application module arrangement on startup and abort it if violations are detected, only if `spring.modulith.runtime.verification-enabled` is configured to `true`.\n* An event listener for https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.spring-application.application-events-and-listeners[`ApplicationStartedEvent`]s that will invoke xref:runtime.adoc#application-module-initializer[`ApplicationModuleInitializer`] beans defined in the application context.\n\n[[application-module-initializer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/runtime.adoc", "title": "runtime", "heading": "Setting up Runtime Support for Application Modules", "heading_level": 2, "file_order": 7, "section_index": 1, "content_hash": "bbae9f09b20d9b67ed395f1eb27a9aa02837f349a7195f8c05bbb37b8bf5f933", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/runtime.adoc"}}
{"id": "sha256:0d0887c6dc9bf138e202369407db7dd2480fa9a069ebb6a418709d23925d7b3e", "content": "When working with application modules, it is pretty common to need to execute some code specific to an individual module on application startup.\nThis means that the execution order of that code needs to follow the dependency structure of the application modules.\nIf a module B depends on module A, the initialization code of A has to run before the one for B, even if the initializers do not directly depend on another.\n\n[plantuml, format='svg']\n....\nhide empty members\n\npackage org.springframework.modulith {\ninterface ApplicationModuleInitializer\n}\n\npackage com.acme.moduleA {\n class InitializerA implements ApplicationModuleInitializer\n\n class ComponentA\n}\n\npackage com.acme.moduleB {\n\n class ComponentB\n\n class InitializerB implements ApplicationModuleInitializer\n}\n\nComponentB --> ComponentA\n\n....\n\nWhile developers could of course define the execution order via Spring's standard `@Order` annotation or `Ordered` interface, Spring Modulith provides an `ApplicationModuleInitializer` interface for beans to be run on application startup.\nThe execution order of those beans will automatically follow the application module dependency structure.\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Component\nclass MyInitializer implements ApplicationModuleInitializer {\n\n @Override\n public void initialize() {\n // Initialization code goes here\n }\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Component\nclass MyInitializer : ApplicationModuleInitializer {\n\n override fun initialize() {\n // Initialization code goes here\n }\n}\n----\n======\nNote that the `ApplicationModuleInitializer` beans will only be invoked if the `spring-modulith-runtime` JAR is on the classpath (see xref:runtime.adoc#setup[Setting up Runtime Support for Application Modules]) as that pulls in the dependencies that are needed to topologically sort the initializers according to the application module structure.\n\n[[module-aware-flyway-migrations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/runtime.adoc", "title": "runtime", "heading": "Application Module Initializers", "heading_level": 2, "file_order": 7, "section_index": 2, "content_hash": "0d0887c6dc9bf138e202369407db7dd2480fa9a069ebb6a418709d23925d7b3e", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/runtime.adoc"}}
{"id": "sha256:7af6d0a09dbbd56f5aad2f947994490024bfffe103da627bde4b69a5fee9cff6", "content": "As of Spring Modulith 2.0, we support the execution of module-specific https://docs.spring.io/spring-boot/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway[Flyway migrations].\nApplication modules are encouraged to define migrations for their own persistent data only, which means that these migrations have to be executed in the order of the module dependency tree.\n\nAssume a default Flyway setup with migrations located in `classpath:db/migration`, two application modules `first` and `second` (with `second` depending on `first`), and an activated `spring.modulith.runtime.flyway-enabled` xref:appendix.adoc#configuration-properties[configuration property].\n\nWith that in place we will customize the Flyway setup as follows:\n\n- The root migration folder will be changed to `db/migration/__root`. For that, the default version tracking table will be used.\n- Additional migrations for `db/migration/$moduleIdentifier` will be registered with a tracking table of `flyway_schema_history_$moduleIdentifier`.\nThese migrations are also set up to a baseline version of 0 and set up to baseline on migrate.\n- Migration locations ending in a wildcard will not be customized.\n\nNote, that the version numbers used in migration scripts are now effectively scoped to the application module and should not use global ordering.\n\nBy selecting which folder to place the migration files in, you can differentiate migrations always to be run from ones that will only get executed for the corresponding module. The application module test integration will only execute the default migration and the ones for modules included in the test run.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/runtime.adoc", "title": "runtime", "heading": "Application-Module Aware Flyway Migrations", "heading_level": 2, "file_order": 7, "section_index": 3, "content_hash": "7af6d0a09dbbd56f5aad2f947994490024bfffe103da627bde4b69a5fee9cff6", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/runtime.adoc"}}
{"id": "sha256:081b9f8e3ba58aa1e1c8995e791e4244e3e4991462e8119f8f36a918b3b4205a", "content": "[[testing]]\n\nSpring Modulith allows to run integration tests bootstrapping individual application modules in isolation or combination with others.\nTo achieve this, add the Spring Modulith test starter to your project like this\n\n[source, xml]\n----\n<dependency>\n\t<groupId>org.springframework.modulith</groupId>\n\t<artifactId>spring-modulith-starter-test</artifactId>\n\t<scope>test</scope>\n</dependency>\n----\n\nand place a JUnit test class in an application module package or any sub-package of that and annotate it with `@ApplicationModuleTest`:\n\n.An application module integration test class\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\npackage example.order;\n\n@ApplicationModuleTest\nclass OrderIntegrationTests {\n\n\t// Individual test cases go here\n}\n----\nKotlin::\n+\n[source, kortlin, role=\"secondary\"]\n----\npackage example.order\n\n@ApplicationModuleTest\nclass OrderIntegrationTests {\n\n\t// Individual test cases go here\n}\n----\n======\n\nThis will run your integration test similar to what `@SpringBootTest` would have achieved but with the bootstrap actually limited to the application module the test resides in.\nIf you configure the log level for `org.springframework.modulith` to `DEBUG`, you will see detailed information about how the test execution customizes the Spring Boot bootstrap:\n\n.The log output of an application module integration test bootstrap\n[source, text, subs=\"macros\"]\n----\n\t. ____ _ __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/ ___)| |_)| | | | | || (_| | ) ) ) )\n\t' |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot :: (v3.0.0-SNAPSHOT)\n\n… - Bootstrapping @ApplicationModuleTest for example.order in mode STANDALONE (class example.Application)…\n… - ======================================================================================================\n… - ## example.order ##\n… - > Logical name: order\n… - > Base package: example.order\n… - > Direct module dependencies: none\n… - > Spring beans:\n… - + ….OrderManagement\n… - + ….internal.OrderInternal\n… - Starting OrderIntegrationTests using Java 17.0.3 …\n… - No active profile set, falling back to 1 default profile: \"default\"\n… - pass:quotes[**Re-configuring auto-configuration and entity scan packages to: example.order.**]\n----\n\nNote, how the output contains the detailed information about the module included in the test run.\nIt creates the application module, finds the module to be run and limits the application of auto-configuration, component and entity scanning to the corresponding packages.\n\n[[bootstrap-modes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "testing", "heading_level": 1, "file_order": 8, "section_index": 0, "content_hash": "081b9f8e3ba58aa1e1c8995e791e4244e3e4991462e8119f8f36a918b3b4205a", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:bf8ce05c6ee56ee1e17a45b990632057ec4589f02e33ce0086362b2a4ffd05c5", "content": "The application module test can be bootstrapped in a variety of modes:\n\n* `STANDALONE` (default) -- Runs the current module only.\n* `DIRECT_DEPENDENCIES` -- Runs the current module as well as all modules the current one directly depends on.\n* `ALL_DEPENDENCIES` -- Runs the current module and the entire tree of modules depended on.\n\n[[efferent-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Bootstrap Modes", "heading_level": 2, "file_order": 8, "section_index": 1, "content_hash": "bf8ce05c6ee56ee1e17a45b990632057ec4589f02e33ce0086362b2a4ffd05c5", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:b79623a1a66ecd0952f75f0360cb39ff9a5435cfaeae4525a223b53e9a0aab19", "content": "When an application module is bootstrapped, the Spring beans it contains will be instantiated.\nIf those contain bean references that cross module boundaries, the bootstrap will fail if those other modules are not included in the test run (see xref:testing.adoc#bootstrap-modes[Bootstrap Modes] for details).\nWhile a natural reaction might be to expand the scope of the application modules included, it is usually a better option to mock the target beans.\n\n.Mocking Spring bean dependencies in other application modules\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@ApplicationModuleTest\nclass InventoryIntegrationTests {\n\n\t@MockitoBean SomeOtherComponent someOtherComponent;\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@ApplicationModuleTest\nclass InventoryIntegrationTests {\n\n\t@MockitoBean SomeOtherComponent someOtherComponent\n}\n----\n======\nSpring Boot will create bean definitions and instances for the types defined as `@MockitoBean` and add them to the `ApplicationContext` bootstrapped for the test run.\n\nIf you find your application module depending on too many beans of other ones, that is usually a sign of high coupling between them.\nThe dependencies should be reviewed for whether they are candidates for replacement by publishing xref:events.adoc#events[domain events].\n\n[[scenarios]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Dealing with Efferent Dependencies", "heading_level": 2, "file_order": 8, "section_index": 2, "content_hash": "b79623a1a66ecd0952f75f0360cb39ff9a5435cfaeae4525a223b53e9a0aab19", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:f0e21e3118cdb9c6b31248c37d4df2a95cbb915d797f3ac295410856bb18b436", "content": "Integration testing application modules can become a quite elaborate effort.\nEspecially if the integration of those is based on xref:events.adoc#aml[asynchronous, transactional event handling], dealing with the concurrent execution can be subject to subtle errors.\nAlso, it requires dealing with quite a few infrastructure components: `TransactionOperations` and `ApplicationEventProcessor` to make sure events are published and delivered to transactional listeners, Awaitility to handle concurrency and AssertJ assertions to formulate expectations on the test execution's outcome.\n\nTo ease the definition of application module integration tests, Spring Modulith provides the `Scenario` abstraction that can be used by declaring it as test method parameter in tests declared as `@ApplicationModuleTest`.\n\n.Using the `Scenario` API in a JUnit 5 test\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@ApplicationModuleTest\nclass SomeApplicationModuleTest {\n\n\t@Test\n\tpublic void someModuleIntegrationTest(Scenario scenario) {\n // Use the Scenario API to define your integration test\n\t}\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@ApplicationModuleTest\nclass SomeApplicationModuleTest {\n\n\t@Test\n\tfun someModuleIntegrationTest(scenario: Scenario) {\n // Use the Scenario API to define your integration test\n\t}\n}\n----\n======\n\nThe test definition itself usually follows the following skeleton:\n\n1. A stimulus to the system is defined. This is usually either an event publication or an invocation of a Spring component exposed by the module.\n2. Optional customization of technical details of the execution (timeouts, etc.)\n3. The definition of some expected outcome, such as another application event being fired that matches some criteria or some state change of the module that can be detected by invoking exposed components.\n4. Optional, additional verifications made on the received event or observed, changed state.\n\n`Scenario` exposes an API to define these steps and guide you through the definition.\n\n.Defining a stimulus as starting point of the `Scenario`\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nscenario.publish(new MyApplicationEvent(…)).…\n\nscenario.stimulate(() -> someBean.someMethod(…)).…\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\nscenario.publish(MyApplicationEvent(…)).…\n\nscenario.stimulate(Runnable { someBean.someMethod(…) }).…\n----\n======\n\nBoth the event publication and bean invocation will happen within a transaction callback to make sure the given event or any ones published during the bean invocation will be delivered to transactional event listeners.\nNote, that this will require a *new* transaction to be started, no matter whether the test case is already running inside a transaction or not.\nIn other words, state changes of the database triggered by the stimulus will *never* be rolled back and have to be cleaned up manually.\nSee the `….andCleanup(…)` methods for that purpose.\n\nThe resulting object can now get the execution customized though the generic `….customize(…)` method or specialized ones for common use cases like setting a timeout (`….waitAtMost(…)`).\n\nThe setup phase will be concluded by defining the actual expectation of the outcome of the stimulus.\nThis can be an event of a particular type in turn, optionally further constraint by matchers:\n\n.Expecting an event being published as operation result\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n….andWaitForEventOfType(SomeOtherEvent.class)\n .matching(event -> …) // Use some predicate here\n .…\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n….andWaitForEventOfType(SomeOtherEvent.class)\n .matching(event -> …) // Use some predicate here\n .…\n----\n======\n\nThese lines set up a completion criteria that the eventual execution will wait for to proceed.\nIn other words, the example above will cause the execution to eventually block until either the default timeout is reached or a `SomeOtherEvent` is published that matches the predicate defined.\n\nThe terminal operations to execute the event-based `Scenario` are named `….toArrive…()` and allow to optionally access the expected event published, or the result object of the bean invocation defined in the original stimulus.\n\n.Triggering the verification\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n….toArrive(…)\n\n….toArriveAndVerify(event -> …)\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n….toArrive(…)\n\n….toArriveAndVerify(event -> …)\n----\n======\n\nThe choice of method names might look a bit weird when looking at the steps individually but they actually read quite fluent when combined.\n\n.A complete `Scenario` definition\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nscenario.publish(new MyApplicationEvent(…))\n\t.andWaitForEventOfType(SomeOtherEvent.class)\n\t.matching(event -> …)\n\t.toArriveAndVerify(event -> …);\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\nscenario.publish(new MyApplicationEvent(…))\n\t.andWaitForEventOfType(SomeOtherEvent::class.java)\n\t.matching { event -> … }\n\t.toArriveAndVerify { event -> … }\n----\n======\n\nAlternatively to an event publication acting as expected completion signal, we can also inspect the state of the application module by invoking a method on one of the components exposed.\nThe scenario would then rather look like this:\n\n.Expecting a state change\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nscenario.publish(new MyApplicationEvent(…))\n\t.andWaitForStateChange(() -> someBean.someMethod(…)))\n\t.andVerify(result -> …);\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\nscenario.publish(MyApplicationEvent(…))\n\t.andWaitForStateChange { someBean.someMethod(…) }\n\t.andVerify { result -> … }\n----\n======\n\nThe `result` handed into the `….andVerify(…)` method will be the value returned by the method invocation to detect the state change.\nBy default, non-`null` values and non-empty ``Optional``s will be considered a conclusive state change.\nThis can be tweaked by using the `….andWaitForStateChange(…, Predicate)` overload.\n\n[[scenarios.customize]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Defining Integration Test Scenarios", "heading_level": 2, "file_order": 8, "section_index": 3, "content_hash": "f0e21e3118cdb9c6b31248c37d4df2a95cbb915d797f3ac295410856bb18b436", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:68d983e5c1de826aeba8f403bf02fcf262732932a56cb3f35faf8d5e8de276d8", "content": "To customize the execution of an individual scenario, call the `….customize(…)` method in the setup chain of the `Scenario`:\n\n.Customizing a `Scenario` execution\n[tabs]\n======\nJava::\n+\n[source, java, subs=\"+quotes\", role=\"primary\"]\n----\nscenario.publish(new MyApplicationEvent(…))\n\t**.customize(conditionFactory -> conditionFactory.atMost(Duration.ofSeconds(2)))**\n\t.andWaitForEventOfType(SomeOtherEvent.class)\n\t.matching(event -> …)\n\t.toArriveAndVerify(event -> …);\n----\nKotlin::\n+\n[source, kotlin, subs=\"+quotes\", role=\"secondary\"]\n----\nscenario.publish(MyApplicationEvent(…))\n\t**.customize { it.atMost(Duration.ofSeconds(2)) }**\n\t.andWaitForEventOfType(SomeOtherEvent::class.java)\n\t.matching { event -> … }\n\t.toArriveAndVerify { event -> … }\n----\n======\n\nTo globally customize all `Scenario` instances of a test class, implement a `ScenarioCustomizer` and register it as JUnit extension.\n\n.Registering a `ScenarioCustomizer`\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@ExtendWith(MyCustomizer.class)\nclass MyTests {\n\n\t@Test\n\tvoid myTestCase(Scenario scenario) {\n // scenario will be pre-customized with logic defined in MyCustomizer\n\t}\n\n\tstatic class MyCustomizer implements ScenarioCustomizer {\n\n @Override\n Function<ConditionFactory, ConditionFactory> getDefaultCustomizer(Method method, ApplicationContext context) {\n return conditionFactory -> …;\n }\n\t}\n}\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@ExtendWith(MyCustomizer::class)\nclass MyTests {\n\n\t@Test\n\tfun myTestCase(scenario: Scenario) {\n // scenario will be pre-customized with logic defined in MyCustomizer\n\t}\n\n\tclass MyCustomizer : ScenarioCustomizer {\n\n override fun getDefaultCustomizer(method: Method, context: ApplicationContext): UnaryOperator<ConditionFactory> {\n return UnaryOperator { conditionFactory -> … }\n }\n\t}\n}\n----\n======\n\n[[change-aware-test-execution]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Customizing Scenario Execution", "heading_level": 3, "file_order": 8, "section_index": 4, "content_hash": "68d983e5c1de826aeba8f403bf02fcf262732932a56cb3f35faf8d5e8de276d8", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:0436e5df41b098661d3f51f3adb2e7abdd3a2c108a9fd80e6879fe2f9cb5e7cf", "content": "As of version 1.3, Spring Modulith ships with a JUnit Jupiter extension that will optimize the execution of tests, so that tests not affected by changes to the project will be skipped.\nTo enable that optimization, declare the `spring-modulith-junit` artifact as a dependency in test scope:\n\n[source, xml]\n----\n<dependency>\n\t<groupId>org.springframework.modulith</groupId>\n\t<artifactId>spring-modulith-junit</artifactId>\n\t<scope>test</scope>\n</dependency>\n----\n\nTests will be selected for execution if they reside in either a root module, a module that has seen a change or one that transitively depends on one that has seen a change.\nThe optimization will back off optimizing the execution under the following circumstances:\n\n* The test execution originates from an IDE as we assume the execution is triggered explicitly.\n* The set of changes contains a change to a resource related to a build system (`pom.xml`, `build.gradle(.kts)`, `gradle.properties`, and `settings.gradle(.kts)`).\n* The set of changes contains a change to any classpath resource.\n* The project does not contain a change at all.\n\nIf no classpath or build resource changes are detected we will execute all tests by default.\nThis can be customized by setting the xref:appendix.adoc#configuration-properties[`spring.modulith.test.on-no-changes` property] to `skip-all`.\n\nTo optimize the execution in a CI environment, you need to populate the xref:appendix.adoc#configuration-properties[`spring.modulith.test.reference-commit` property] pointing to the commit of the last successful build and make sure that the build checks out all commits up to the reference one.\nThe algorithm detecting changes to application modules will then consider all files changed in that delta.\nTo override the project modification detection, declare an implementation of `FileModificationDetector` via the xref:appendix.adoc#configuration-properties[`spring.modulith.test.file-modification-detector` property].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Change-Aware Test Execution", "heading_level": 2, "file_order": 8, "section_index": 5, "content_hash": "0436e5df41b098661d3f51f3adb2e7abdd3a2c108a9fd80e6879fe2f9cb5e7cf", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:8d8918d5f50f5c0de51340ce161295cdabdbace4e34bb01fac8ef7ec9f585db0", "content": "[[verification]]\n\nWe can verify whether our code arrangement adheres to the intended constraints by calling the `….verify()` method on our `ApplicationModules` instance:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nApplicationModules.of(Application.class).verify();\n----\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\nApplicationModules.of(Application::class.java).verify()\n----\n======\nThe verification includes the following rules:\n\n* _No cycles on the application module level_ -- the dependencies between modules have to form a directed acyclic graph.\n* _Efferent module access via API packages only_ -- all references to types that reside in application module internal packages are rejected.\nSee xref:fundamentals.adoc#modules.advanced[Advanced Application Modules] for details.\nDependencies into internals of xref:fundamentals.adoc#modules.advanced.open[Open Application Modules] are allowed.\n* _Explicitly allowed application module dependencies only_ (optional) -- an application module can optionally define allowed dependencies via `@ApplicationModule(allowedDependencies = …)`.\nIf those are configured, dependencies to other application modules are rejected.\nSee xref:fundamentals.adoc#modules.explicit-dependencies[Explicit Application Module Dependencies] and xref:fundamentals.adoc#modules.named-interfaces[Named Interfaces] for details.\n\nSpring Modulith optionally integrates with the jMolecules ArchUnit library and, if present, automatically triggers its Domain-Driven Design and architectural verification rules described https://github.com/xmolecules/jmolecules-integrations/tree/main/jmolecules-archunit[here].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/verification.adoc", "title": "verification", "heading": "verification", "heading_level": 1, "file_order": 9, "section_index": 0, "content_hash": "8d8918d5f50f5c0de51340ce161295cdabdbace4e34bb01fac8ef7ec9f585db0", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/verification.adoc"}}
{"id": "sha256:0c7868862a66e47f124f48f24b7bb3dc385b23c07fc39a5003147f5a9e2d1484", "content": "`ApplicationModules.verify()` throws an exception in case of any architectural violation being detected.\nYou can access the violations for further processing, such as ignoring certain violations, by instead calling `ApplicationModules.detectViolations()`.\n\n[source, java]\n----\nApplicationModules.of(…)\n .detectViolations()\n .filter(violation -> …)\n .throwIfPresent();\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/verification.adoc", "title": "verification", "heading": "Handling Detected Violations", "heading_level": 2, "file_order": 9, "section_index": 1, "content_hash": "0c7868862a66e47f124f48f24b7bb3dc385b23c07fc39a5003147f5a9e2d1484", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/verification.adoc"}}
{"id": "sha256:e1072c0d12950f2ec493b8a56343b8e031e7b026aa48ce262937532f455bc151", "content": "As described xref:verification.adoc#verification[above], by default, both the `ApplicationModules.verify(…)` and `….detectViolations(…)` automatically perform additional verifications depending on the classpath configuration.\n\nTo customize these, disable them or register additional verifications, both `verify(…)` and `detectVolations(…)` take a `VerificationOptions` instance.\n\n[source, java]\n----\nvar hexagonal = JMoleculesArchitectureRules.ensureHexagonal(VerificationDepth.STRICT); <1>\nvar options = VerificationOptions.defaults().withAdditionalVerifications(hexagonal); <2>\n\nApplicationModules.of(…).verify(options); <3>\n----\n<1> Set up the jMolecules Architecture verification for Hexagonal Architecture in strict mode.\n<2> Create a `VerificationOptions` instance replacing the default verification with the one just set up.\n<3> Execute the verification using the just configured options.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-modulith", "path": "antora/modules/ROOT/pages/verification.adoc", "title": "verification", "heading": "Customizing the Verification", "heading_level": 2, "file_order": 9, "section_index": 2, "content_hash": "e1072c0d12950f2ec493b8a56343b8e031e7b026aa48ce262937532f455bc151", "source_url": "https://github.com/spring-projects/spring-modulith/blob/367486209f59017115122cd64ee7e57f6ce96f97/src/docs/antora/modules/ROOT/pages/verification.adoc"}}
