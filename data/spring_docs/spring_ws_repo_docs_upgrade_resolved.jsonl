{"id": "sha256:1e00aa646bf2d42b8e77d5847b04d350d4c91de37e33ddb28a1d4305e754042c", "content": "[bibliography]\n\n- [[[waldo-94]]] Jim Waldo, Ann Wollrath, and Sam Kendall. _A Note on Distributed Computing_. Springer Verlag. 1994\n- [[[alpine]]] Steve Loughran & Edmund Smith. _Rethinking the Java SOAP Stack_. May 17, 2005. (C) 2005 IEEE Telephone Laboratories, Inc.\n- [[[effective-enterprise-java]]] Ted Neward. Scott Meyers. _Effective Enterprise Java_. Addison-Wesley. 2004\n- [[[effective-xml]]] Elliotte Rusty Harold. Scott Meyers. _Effective XML_. Addison-Wesley. 2004", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/bibliography.adoc", "title": "bibliography", "heading": "bibliography", "heading_level": 1, "file_order": 0, "section_index": 0, "content_hash": "1e00aa646bf2d42b8e77d5847b04d350d4c91de37e33ddb28a1d4305e754042c", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/bibliography.adoc"}}
{"id": "sha256:caeb914062c0a14839e6aa680d50fca7fbfdc357917f3b39b57ef1f0fbc55a37", "content": "[[client]]\n\nSpring-WS provides a client-side Web service API that allows for consistent, XML-driven access to web services.\nIt also caters to the use of marshallers and unmarshallers so that your service-tier code can deal exclusively with Java objects.\n\nThe `org.springframework.ws.client.core` package provides the core functionality for using the client-side access API.\nIt contains template classes that simplify the use of Web services, much like the core Spring `JdbcTemplate` does for JDBC.\nThe design principle common to Spring template classes is to provide helper methods to perform common operations and, for more sophisticated usage, delegate to user implemented callback interfaces.\nThe web service template follows the same design.\nThe classes offer various convenience methods for\n\n* Sending and receiving of XML messages.\n* Marshalling objects to XML before sending.\n* Allowing for multiple transport options.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "client", "heading_level": 1, "file_order": 1, "section_index": 0, "content_hash": "caeb914062c0a14839e6aa680d50fca7fbfdc357917f3b39b57ef1f0fbc55a37", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:0eb9cf310ec539d40a8a0bde97f3203e642fc48d82ea4cfcc0cd5c7116028e02", "content": "This section describes how to use the client-side API.\nFor how to use the server-side API, see <<server>>.\n\n[[client-web-service-template]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "Using the Client-side API", "heading_level": 2, "file_order": 1, "section_index": 1, "content_hash": "0eb9cf310ec539d40a8a0bde97f3203e642fc48d82ea4cfcc0cd5c7116028e02", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:df8aecd3527324da6be6409c0ba9f6729ccc984520fc83011329e7e8dac0be3c", "content": "The {spring-ws-api}/client/core/WebServiceTemplate.html[`WebServiceTemplate`] is the core class for client-side web service access in Spring-WS.\nIt contains methods for sending `Source` objects and receiving response messages as either `Source` or `Result`.\nAdditionally, it can marshal objects to XML before sending them across a transport and unmarshal any response XML into an object again.\n\n[[client-transports]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "`WebServiceTemplate`", "heading_level": 3, "file_order": 1, "section_index": 2, "content_hash": "df8aecd3527324da6be6409c0ba9f6729ccc984520fc83011329e7e8dac0be3c", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:7f5cc9c857f2ba50851058872ef9f49b9ab1e592378d9cfc67eea7bf4f4ebbf0", "content": "The `WebServiceTemplate` class uses a URI as the message destination.\nYou can either set a `defaultUri` property on the template itself or explicitly supply a URI when calling a method on the template.\nThe URI is resolved into a `WebServiceMessageSender`, which is responsible for sending the XML message across a transport layer.\nYou can set one or more message senders by using the `messageSender` or `messageSenders` properties of the `WebServiceTemplate` class.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "URIs and Transports", "heading_level": 4, "file_order": 1, "section_index": 3, "content_hash": "7f5cc9c857f2ba50851058872ef9f49b9ab1e592378d9cfc67eea7bf4f4ebbf0", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:0dcba616b192176f85e7f438433e50d83efb4cf8a50f5539ecec20dbf6be3156", "content": "There are three implementations of the `WebServiceMessageSender` interface for sending messages over HTTP.\nThe default implementation is the `HttpUrlConnectionMessageSender`, which uses the facilities provided by Java itself.\nThe alternatives are either `JdkHttpClientMessageSender` that uses the JDK's `HttpClient`, or `HttpComponents5MessageSender`/`SimpleHttpComponents5MessageSender`, which use the https://hc.apache.org/httpcomponents-client-ga[Apache HttpClient].\nUse the latter if you need more advanced and easy-to-use functionality (such as authentication, HTTP connection pooling, and so forth).\n\nTo use the HTTP transport, either set the `defaultUri` to something like `http://example.com/services` or supply the `uri` parameter for one of the methods.\n\nThe following example shows how to use default configuration for HTTP transports:\n\n====\n[source,xml]\n----\n<beans>\n\n <bean id=\"messageFactory\" class=\"org.springframework.ws.soap.saaj.SaajSoapMessageFactory\"/>\n\n <bean id=\"webServiceTemplate\" class=\"org.springframework.ws.client.core.WebServiceTemplate\">\n <constructor-arg ref=\"messageFactory\"/>\n <property name=\"defaultUri\" value=\"http://example.com/WebService\"/>\n </bean>\n\n</beans>\n----\n====\n\nThe following example shows how to override the default configuration and how to use Apache HttpClient to authenticate with HTTP authentication:\n\n====\n[source,xml]\n----\n<bean id=\"webServiceTemplate\" class=\"org.springframework.ws.client.core.WebServiceTemplate\">\n <constructor-arg ref=\"messageFactory\"/>\n <property name=\"messageSender\">\n <bean class=\"org.springframework.ws.transport.http.HttpComponents5MessageSender\">\n <property name=\"credentials\">\n <bean class=\"org.apache.hc.client5.http.auth.UsernamePasswordCredentials\">\n <constructor-arg value=\"john\"/>\n <constructor-arg value=\"secret\"/>\n </bean>\n </property>\n </bean>\n </property>\n <property name=\"defaultUri\" value=\"http://example.com/WebService\"/>\n</bean>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "HTTP transports", "heading_level": 5, "file_order": 1, "section_index": 4, "content_hash": "0dcba616b192176f85e7f438433e50d83efb4cf8a50f5539ecec20dbf6be3156", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:3e3c2898aec973fd8f8812ca486239e43547f7a3ac638dd98c0ae1c4c1c901ef", "content": "For sending messages over JMS, Spring-WS provides `JmsMessageSender`.\nThis class uses the facilities of the Spring framework to transform the `WebServiceMessage` into a JMS `Message`, send it on its way on a `Queue` or `Topic`, and receive a response (if any).\n\nTo use `JmsMessageSender`, you need to set the `defaultUri` or `uri` parameter to a JMS URI, which -- at a minimum -- consists of the `jms:` prefix and a destination name.\nSome examples of JMS URIs are: `jms:SomeQueue`, `jms:SomeTopic?priority=3&deliveryMode=NON_PERSISTENT`, and `jms:RequestQueue?replyToName=ResponseName`.\nFor more information on this URI syntax, see the {spring-ws-api}/transport/jms/JmsMessageSender.html[Javadoc for `JmsMessageSender`].\n\nBy default, the `JmsMessageSender` sends JMS `BytesMessage`, but you can override this to use `TextMessages` by using the `messageType` parameter on the JMS URI -- for example, `jms:Queue?messageType=TEXT_MESSAGE`.\nNote that `BytesMessages` are the preferred type, because `TextMessages` do not support attachments and character encodings reliably.\n\nThe following example shows how to use the JMS transport in combination with an Artemis connection factory:\n\n====\n[source,xml]\n----\n<beans>\n\n <bean id=\"messageFactory\" class=\"org.springframework.ws.soap.saaj.SaajSoapMessageFactory\"/>\n\n <bean id=\"connectionFactory\" class=\"org.apache.activemq.artemis.jms.client.ActiveMQConnectionFactory\">\n <property name=\"brokerURL\" value=\"vm://localhost?broker.persistent=false\"/>\n\t</bean>\n\n <bean id=\"webServiceTemplate\" class=\"org.springframework.ws.client.core.WebServiceTemplate\">\n <constructor-arg ref=\"messageFactory\"/>\n <property name=\"messageSender\">\n <bean class=\"org.springframework.ws.transport.jms.JmsMessageSender\">\n <property name=\"connectionFactory\" ref=\"connectionFactory\"/>\n </bean>\n </property>\n <property name=\"defaultUri\" value=\"jms:RequestQueue?deliveryMode=NON_PERSISTENT\"/>\n </bean>\n\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "JMS transport", "heading_level": 5, "file_order": 1, "section_index": 5, "content_hash": "3e3c2898aec973fd8f8812ca486239e43547f7a3ac638dd98c0ae1c4c1c901ef", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:68d6e39539bbfa905ecf96bb1971570654125597da63a969b1c9c5da69f97583", "content": "Spring-WS also provides an email transport, which you can use to send web service messages over SMTP and retrieve them over either POP3 or IMAP.\nThe client-side email functionality is contained in {spring-ws-api}/transport/mail/MailMessageSender.html[`MailMessageSender`].\nThis class creates an email message from the request `WebServiceMessage` and sends it over SMTP.\nIt then waits for a response message to arrive at the incoming POP3 or IMAP server.\n\nTo use the `MailMessageSender`, set the `defaultUri` or `uri` parameter to a `mailto` URI -- for example, `mailto:john@example.com` or `mailto:server@localhost?subject=SOAP%20Test`.\nMake sure that the message sender is properly configured with a `transportUri`, which indicates the server to use for sending requests (typically a SMTP server), and a `storeUri`, which indicates the server to poll for responses (typically a POP3 or IMAP server).\n\nThe following example shows how to use the email transport:\n\n====\n[source,xml]\n----\n<beans>\n\n <bean id=\"messageFactory\" class=\"org.springframework.ws.soap.saaj.SaajSoapMessageFactory\"/>\n\n <bean id=\"webServiceTemplate\" class=\"org.springframework.ws.client.core.WebServiceTemplate\">\n <constructor-arg ref=\"messageFactory\"/>\n <property name=\"messageSender\">\n <bean class=\"org.springframework.ws.transport.mail.MailMessageSender\">\n <property name=\"from\" value=\"Spring-WS SOAP Client &lt;client@example.com&gt;\"/>\n <property name=\"transportUri\" value=\"smtp://client:s04p@smtp.example.com\"/>\n <property name=\"storeUri\" value=\"imap://client:s04p@imap.example.com/INBOX\"/>\n </bean>\n </property>\n <property name=\"defaultUri\" value=\"mailto:server@example.com?subject=SOAP%20Test\"/>\n </bean>\n\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "Email Transport", "heading_level": 5, "file_order": 1, "section_index": 6, "content_hash": "68d6e39539bbfa905ecf96bb1971570654125597da63a969b1c9c5da69f97583", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:8d9e5533bc18e1d3f107478c9e75e50f0ba092fddab271489f40e29b93c5c8c2", "content": "Spring-WS also provides a XMPP (Jabber) transport, which you can use to send and receive web service messages over XMPP.\nThe client-side XMPP functionality is contained in {spring-ws-api}/transport/xmpp/XmppMessageSender.html[`XmppMessageSender`].\nThis class creates an XMPP message from the request `WebServiceMessage` and sends it over XMPP.\nIt then listens for a response message to arrive.\n\nTo use the `XmppMessageSender`, set the `defaultUri` or `uri` parameter to a `xmpp` URI -- for example, `xmpp:johndoe@jabber.org`.\nThe sender also requires an `XMPPConnection` to work, which can be conveniently created by using the `org.springframework.ws.transport.xmpp.support.XmppConnectionFactoryBean`.\n\nThe following example shows how to use the XMPP transport:\n\n====\n[source,xml]\n----\n<beans>\n\n <bean id=\"messageFactory\" class=\"org.springframework.ws.soap.saaj.SaajSoapMessageFactory\"/>\n\n <bean id=\"connection\" class=\"org.springframework.ws.transport.xmpp.support.XmppConnectionFactoryBean\">\n <property name=\"host\" value=\"jabber.org\"/>\n <property name=\"username\" value=\"username\"/>\n <property name=\"password\" value=\"password\"/>\n </bean>\n\n <bean id=\"webServiceTemplate\" class=\"org.springframework.ws.client.core.WebServiceTemplate\">\n <constructor-arg ref=\"messageFactory\"/>\n <property name=\"messageSender\">\n <bean class=\"org.springframework.ws.transport.xmpp.XmppMessageSender\">\n <property name=\"connection\" ref=\"connection\"/>\n </bean>\n </property>\n <property name=\"defaultUri\" value=\"xmpp:user@jabber.org\"/>\n </bean>\n\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "XMPP Transport", "heading_level": 5, "file_order": 1, "section_index": 7, "content_hash": "8d9e5533bc18e1d3f107478c9e75e50f0ba092fddab271489f40e29b93c5c8c2", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:3fbf229713f2e410f36458e6294d7393b12fbb54a81a13be3585a27bd41a217a", "content": "In addition to a message sender, the `WebServiceTemplate` requires a web service message factory.\nThere are two message factories for SOAP: `SaajSoapMessageFactory` and `AxiomSoapMessageFactory`.\nIf no message factory is specified (by setting the `messageFactory` property), Spring-WS uses the `SaajSoapMessageFactory` by default.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "Message factories", "heading_level": 4, "file_order": 1, "section_index": 8, "content_hash": "3fbf229713f2e410f36458e6294d7393b12fbb54a81a13be3585a27bd41a217a", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:35f66fa0f410b2418c4b3eef055031096fe4dc8fe040668d77f85f0d6f88a1d1", "content": "The `WebServiceTemplate` contains many convenience methods to send and receive web service messages.\nThere are methods that accept and return a `Source` and those that return a `Result`.\nAdditionally, there are methods that marshal and unmarshal objects to XML.\nThe following example sends a simple XML message to a web service:\n\n====\n[source,java,subs=\"verbatim,quotes\"]\n----\nimport java.io.StringReader;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport org.springframework.ws.WebServiceMessageFactory;\nimport org.springframework.ws.client.core.WebServiceTemplate;\nimport org.springframework.ws.transport.WebServiceMessageSender;\n\npublic class WebServiceClient {\n\n private static final String MESSAGE =\n \"<message xmlns=\\\"http://tempuri.org\\\">Hello, Web Service World</message>\";\n\n private final WebServiceTemplate webServiceTemplate = new WebServiceTemplate();\n\n public void setDefaultUri(String defaultUri) {\n webServiceTemplate.setDefaultUri(defaultUri);\n }\n\n _// send to the configured default URI_\n public void simpleSendAndReceive() {\n StreamSource source = new StreamSource(new StringReader(MESSAGE));\n StreamResult result = new StreamResult(System.out);\n webServiceTemplate.sendSourceAndReceiveToResult(source, result);\n }\n\n _// send to an explicit URI_\n public void customSendAndReceive() {\n StreamSource source = new StreamSource(new StringReader(MESSAGE));\n StreamResult result = new StreamResult(System.out);\n webServiceTemplate.sendSourceAndReceiveToResult(\"http://localhost:8080/AnotherWebService\",\n source, result);\n }\n\n}\n----\n====\n\n====\n[source,xml]\n----\n\n<beans xmlns=\"http://www.springframework.org/schema/beans\">\n\n <bean id=\"webServiceClient\" class=\"com.example.WebServiceClient\">\n <property name=\"defaultUri\" value=\"http://localhost:8080/WebService\"/>\n </bean>\n\n</beans>\n----\n====\n\nThe preceding example uses the `WebServiceTemplate` to send a \"`Hello, World`\" message to the web service located at `http://localhost:8080/WebService` (in the case of the `simpleSendAndReceive()` method) and writes the result to the console.\nThe `WebServiceTemplate` is injected with the default URI, which is used because no URI was supplied explicitly in the Java code.\n\nNote that the `WebServiceTemplate` class is thread-safe once configured (assuming that all of its dependencies are also thread-safe, which is the case for all of the dependencies that ship with Spring-WS), so multiple objects can use the same shared `WebServiceTemplate` instance.\nThe `WebServiceTemplate` exposes a zero-argument constructor and `messageFactory` and `messageSender` bean properties that you can use to construct the instance (by using a Spring container or plain Java code).\nAlternatively, consider deriving from Spring-WS `WebServiceGatewaySupport` convenience base class, which exposes bean properties to enable easy configuration.\n(You do not have to extend this base class, it is provided as a convenience class only).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "Sending and Receiving a `WebServiceMessage`", "heading_level": 3, "file_order": 1, "section_index": 9, "content_hash": "35f66fa0f410b2418c4b3eef055031096fe4dc8fe040668d77f85f0d6f88a1d1", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:574c1b1b6b713d9581e3300314be04db7d028877c60d805add52e138c80b999c", "content": "To facilitate the sending of plain Java objects, the `WebServiceTemplate` has a number of `send(..)` methods that take an `Object` as an argument for a message's data content.\nThe method `marshalSendAndReceive(..)` in the `WebServiceTemplate` class delegates the conversion of the request object to XML to a `Marshaller` and the conversion of the response XML to an object to an `Unmarshaller`.\n(For more information about marshalling and unmarshaller, see https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#oxm-marshaller-unmarshaller[the Spring Framework reference documentation]).\n\nBy using the marshallers, your application code can focus on the business object that is being sent or received and not be concerned with the details of how it is represented as XML.\nTo use the marshalling functionality, you have to set a marshaller and an unmarshaller with the `marshaller` and `unmarshaller` properties of the `WebServiceTemplate` class.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "Sending and Receiving POJOs -- Marshalling and Unmarshalling", "heading_level": 3, "file_order": 1, "section_index": 10, "content_hash": "574c1b1b6b713d9581e3300314be04db7d028877c60d805add52e138c80b999c", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:852e377604ecbde9bc8e54ff95f451c49278dfc7efb763031e9f7db8dc4af32d", "content": "To accommodate setting SOAP headers and other settings on the message, the `WebServiceMessageCallback` interface gives you access to the message after it has been created but before it is sent.\nThe following example demonstrates how to set the SOAP action header on a message that is created by marshalling an object:\n\n====\n[source,java]\n----\n\npublic void marshalWithSoapActionHeader(MyObject o) {\n\n webServiceTemplate.marshalSendAndReceive(o, new WebServiceMessageCallback() {\n\n public void doWithMessage(WebServiceMessage message) {\n ((SoapMessage)message).setSoapAction(\"http://tempuri.org/Action\");\n }\n });\n}\n----\n====\n\nNOTE: Note that you can also use the `org.springframework.ws.soap.client.core.SoapActionCallback` to set the SOAP action header.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "Using `WebServiceMessageCallback`", "heading_level": 3, "file_order": 1, "section_index": 11, "content_hash": "852e377604ecbde9bc8e54ff95f451c49278dfc7efb763031e9f7db8dc4af32d", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:5c1b90b4fea315fda977b92f3aaca62ee277266059baa2ef314261f6e7e58e6f", "content": "In addition to the <<server-ws-addressing,server-side WS-Addressing>> support, Spring-WS also has support for this specification on the client-side.\n\nFor setting WS-Addressing headers on the client, you can use {spring-ws-api}/soap/addressing/client/ActionCallback.html[`ActionCallback`].\nThis callback takes the desired action header as a parameter.\nIt also has constructors for specifying the WS-Addressing version and a `To` header.\nIf not specified, the `To` header defaults to the URL of the connection being made.\n\nThe following example sets the `Action` header to `http://samples/RequestOrder`:\n\n====\n[source,java]\n----\nwebServiceTemplate.marshalSendAndReceive(o, new ActionCallback(\"http://samples/RequestOrder\"));\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "WS-Addressing", "heading_level": 4, "file_order": 1, "section_index": 12, "content_hash": "5c1b90b4fea315fda977b92f3aaca62ee277266059baa2ef314261f6e7e58e6f", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:0e553e035a7a744bedf5157b9d111b0b095d3139448f9e07327677ee263ee7bd", "content": "The `WebServiceMessageExtractor` interface is a low-level callback interface that gives you full control over the process to extract an `Object` from a received `WebServiceMessage`.\nThe `WebServiceTemplate` invokes the `extractData(..)` method on a supplied `WebServiceMessageExtractor` while the underlying connection to the serving resource is still open.\nThe following example shows the `WebServiceMessageExtractor` in action:\n\n====\n[source,java,subs=\"verbatim,quotes\"]\n----\npublic void marshalWithSoapActionHeader(final Source s) {\n final Transformer transformer = transformerFactory.newTransformer();\n webServiceTemplate.sendAndReceive(new WebServiceMessageCallback() {\n public void doWithMessage(WebServiceMessage message) {\n transformer.transform(s, message.getPayloadResult());\n },\n new WebServiceMessageExtractor() {\n public Object extractData(WebServiceMessage message) throws IOException {\n // do your own transforms with message.getPayloadResult()\n // or message.getPayloadSource()\n }\n }\n });\n}\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "Using `WebServiceMessageExtractor`", "heading_level": 3, "file_order": 1, "section_index": 13, "content_hash": "0e553e035a7a744bedf5157b9d111b0b095d3139448f9e07327677ee263ee7bd", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:680c8d5961652c29a1edc6194f7ac7cd1617109ab48ad9686c73c4a1007a5a4b", "content": "When it comes to testing your Web service clients (that is, classes that use the `WebServiceTemplate` to access a Web service), you have two possible approaches:\n\n* Write unit tests, which mock away the `WebServiceTemplate` class, `WebServiceOperations` interface, or the complete client class.\nThe advantage of this approach is that it s easy to accomplish.\nThe disadvantage is that you are not really testing the exact content of the XML messages that are sent over the wire, especially when mocking out the entire client class.\n* Write integrations tests, which do test the contents of the message.\n\nThe first approach can easily be accomplished with mocking frameworks, such as Mockito, EasyMock, and others.\nThe next section focuses on writing integration tests.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "Client-side Testing", "heading_level": 2, "file_order": 1, "section_index": 14, "content_hash": "680c8d5961652c29a1edc6194f7ac7cd1617109ab48ad9686c73c4a1007a5a4b", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:cc9c343567e5d2bcfa2aaf5563780ab4d819364d5208daa4d2aaa40fd6faf717", "content": "Spring-WS has support for creating for creating Web service client integration tests.\nIn this context, a client is a class that uses the `WebServiceTemplate` to access a web service.\n\nThe integration test support lives in the `org.springframework.ws.test.client` package.\nThe core class in that package is the `MockWebServiceServer`.\nThe underlying idea is that the web service template connects to this mock server and sends it a request message, which the mock server then verifies against the registered expectations.\nIf the expectations are met, the mock server then prepares a response message, which is sent back to the template.\n\nThe typical usage of the `MockWebServiceServer` is: .\n\n. Create a `MockWebServiceServer` instance by calling `MockWebServiceServer.createServer(WebServiceTemplate)`, `MockWebServiceServer.createServer(WebServiceGatewaySupport)`, or `MockWebServiceServer.createServer(ApplicationContext)`.\n. Set up request expectations by calling `expect(RequestMatcher)`, possibly by using the default `RequestMatcher` implementations provided in `RequestMatchers` (which can be statically imported).\nMultiple expectations can be set up by chaining `andExpect(RequestMatcher)` calls.\n. Create an appropriate response message by calling `andRespond(ResponseCreator)`, possibly by using the default `ResponseCreator` implementations provided in `ResponseCreators` (which can be statically imported).\n. Use the `WebServiceTemplate` as normal, either directly of through client code.\n. Call `MockWebServiceServer.verify()` to make sure that all expectations have been met.\n\n[NOTE]\n====\n`MockWebServiceServer` (and related classes) offers a 'fluent' API, so you can typically use the code-completion features in your IDE to guide you through the process of setting up the mock server.\n====\n\n[NOTE]\n====\nYou can rely on the standard logging features available in Spring-WS in your unit tests.\nSometimes, it might be useful to inspect the request or response message to find out why a particular tests failed.\nSee <<logging>> for more information.\n====\n\nConsider, for example, the following Web service client class:\n\n====\n[source,java]\n----\nimport org.springframework.ws.client.core.support.WebServiceGatewaySupport;\n\npublic class CustomerClient extends WebServiceGatewaySupport { //<1>\n\n public int getCustomerCount() {\n CustomerCountRequest request = new CustomerCountRequest(); //<2>\n request.setCustomerName(\"John Doe\");\n CustomerCountResponse response =\n (CustomerCountResponse) getWebServiceTemplate().marshalSendAndReceive(request); //<3>\n return response.getCustomerCount();\n }\n\n}\n----\n\n<1> The `CustomerClient` extends `WebServiceGatewaySupport`, which provides it with a `webServiceTemplate` property.\n<2> `CustomerCountRequest` is an object supported by a marshaller.\nFor instance, it can have an `@XmlRootElement` annotation to be supported by JAXB2.\n<3> The `CustomerClient` uses the `WebServiceTemplate` offered by `WebServiceGatewaySupport` to marshal the request object into a SOAP message and sends that to the web service.\nThe response object is unmarshalled into a `CustomerCountResponse`.\n====\n\nThe following example shows a typical test for `CustomerClient`:\n\n====\n[source,java]\n----\nimport javax.xml.transform.Source;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.xml.transform.StringSource;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport static org.junit.Assert.assertEquals;\n\nimport org.springframework.ws.test.client.MockWebServiceServer;\nimport static org.springframework.ws.test.client.RequestMatchers.*;\nimport static org.springframework.ws.test.client.ResponseCreators.*;\n\n@RunWith(SpringJUnit4ClassRunner.class) //<1>\n@ContextConfiguration(\"integration-test.xml\")\npublic class CustomerClientIntegrationTest {\n\n @Autowired\n private CustomerClient client; //<2>\n\n private MockWebServiceServer mockServer; //<3>\n\n @Before\n public void createServer() throws Exception {\n mockServer = MockWebServiceServer.createServer(client);\n }\n\n @Test\n public void customerClient() throws Exception {\n Source requestPayload = new StringSource(\"\"\"\n <customerCountRequest xmlns='http://springframework.org/spring-ws'>\n <customerName>John Doe</customerName>\n </customerCountRequest>\n \"\"\");\n Source responsePayload = new StringSource(\"\"\"\n <customerCountResponse xmlns='http://springframework.org/spring-ws'>\n <customerCount>10</customerCount>\n </customerCountResponse>\n \"\"\");\n\n mockServer.expect(payload(requestPayload)).andRespond(withPayload(responsePayload));//<4>\n\n int result = client.getCustomerCount(); //<5>\n assertEquals(10, result);\n\n mockServer.verify(); //<6>\n }\n\n}\n----\n\n<1> This test uses the standard testing facilities provided in the Spring Framework.\nThis is not required but is generally the easiest way to set up the test.\n<2> The `CustomerClient` is configured in `integration-test.xml` and wired into this test using `@Autowired`.\n<3> In a `@Before` method, we create a `MockWebServiceServer` by using the `createServer` factory method.\n<4> We define expectations by calling `expect()` with a `payload()` `RequestMatcher` provided by the statically imported `RequestMatchers` (see <<client-test-request-matcher>>).\nWe also set up a response by calling `andRespond()` with a `withPayload()` `ResponseCreator` provided by the statically imported `ResponseCreators` (see <<client-test-response-creator>>).\nThis part of the test might look a bit confusing, but the code-completion features of your IDE are of great help.\nAfter you type `expect(`, your IDE can provide you with a list of possible request matching strategies, provided you statically imported `RequestMatchers`.\nThe same applies to `andRespond(`, provided you statically imported `ResponseCreators`.\n<5> We call `getCustomerCount()` on the `CustomerClient`, thus using the `WebServiceTemplate`.\nThe template has been set up for \"`testing mode`\" by now, so no real (HTTP) connection is made by this method call.\nWe also make some JUnit assertions based on the result of the method call.\n<6> We call `verify()` on the `MockWebServiceServer`, verifying that the expected message was actually received.\n====\n\n[[client-test-request-matcher]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "Writing Client-side Integration Tests", "heading_level": 3, "file_order": 1, "section_index": 15, "content_hash": "cc9c343567e5d2bcfa2aaf5563780ab4d819364d5208daa4d2aaa40fd6faf717", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:85873081b1a176cc3b9ed28132e6cf26a96a85d87a898f1f9644b0b1c68af0be", "content": "To verify whether the request message meets certain expectations, the `MockWebServiceServer` uses the `RequestMatcher` strategy interface.\nThe contract defined by this interface is as follows:\n\n====\n[source,java]\n----\npublic interface RequestMatcher {\n\n void match(URI uri, WebServiceMessage request)\n throws IOException, AssertionError;\n\n}\n----\n====\n\nYou can write your own implementations of this interface, throwing `AssertionError` exceptions when the message does not meet your expectations, but you certainly do not have to.\nThe `RequestMatchers` class provides standard `RequestMatcher` implementations for you to use in your tests.\nYou typically statically import this class.\n\nThe `RequestMatchers` class provides the following request matchers:\n\n[cols=\"2\", options=\"header\"]\n|===\n| `RequestMatchers` method\n| Description\n\n| `anything()`\n| Expects any sort of request.\n\n| `payload()`\n| Expects a given request payload.\nMay include https://github.com/xmlunit/user-guide/wiki/Placeholders[XMLUnit Placeholders]\n\n| `validPayload()`\n| Expects the request payload to validate against given XSD schemas.\n\n| `xpath()`\n| Expects a given XPath expression to exist, not exist, or evaluate to a given value.\n\n| `soapHeader()`\n| Expects a given SOAP header to exist in the request message.\n\n| `soapEnvelope()`\n| Expects a given SOAP payload.\nMay include https://github.com/xmlunit/user-guide/wiki/Placeholders[XMLUnit Placeholders]\n\n| `connectionTo()`\n| Expects a connection to the given URL.\n|===\n\nYou can set up multiple request expectations by chaining `andExpect()` calls:\n\n====\n[source,java]\n----\nmockServer.expect(connectionTo(\"http://example.com\")).\n andExpect(payload(expectedRequestPayload)).\n andExpect(validPayload(schemaResource)).\n andRespond(...);\n----\n====\n\nFor more information on the request matchers provided by `RequestMatchers`, see the {spring-ws-api}/test/client/RequestMatchers.html[Javadoc].\n\n[[client-test-response-creator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "Using `RequestMatcher` and `RequestMatchers`", "heading_level": 3, "file_order": 1, "section_index": 16, "content_hash": "85873081b1a176cc3b9ed28132e6cf26a96a85d87a898f1f9644b0b1c68af0be", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:238625dbb7a968659eed396f6e794ae4ae7023a74df30727da499da58326409f", "content": "When the request message has been verified and meets the defined expectations, the `MockWebServiceServer` creates a response message for the `WebServiceTemplate` to consume.\nThe server uses the `ResponseCreator` strategy interface for this purpose:\n\n====\n[source,java]\n----\npublic interface ResponseCreator {\n\n WebServiceMessage createResponse(URI uri, WebServiceMessage request,\n WebServiceMessageFactory messageFactory)\n throws IOException;\n\n}\n----\n====\n\nOnce again, you can write your own implementations of this interface, creating a response message by using the message factory, but you certainly do not have to, as the `ResponseCreators` class provides standard `ResponseCreator` implementations for you to use in your tests.\nYou typically statically import this class.\n\nThe `ResponseCreators` class provides the following responses:\n\n[cols=\"2\", options=\"header\"]\n|===\n| `ResponseCreators` method\n| Description\n\n| `withPayload()`\n| Creates a response message with a given payload.\n\n| `withError()`\n| Creates an error in the response connection.\nThis method gives you the opportunity to test your error handling.\n\n| `withException()`\n| Throws an exception when reading from the response connection.\nThis method gives you the opportunity to test your exception handling.\n\n| `withMustUnderstandFault()`, `withClientOrSenderFault()`, `withServerOrReceiverFault()`, or `withVersionMismatchFault()`\n| Creates a response message with a given SOAP fault.\nThis method gives you the opportunity to test your Fault handling.\n|===\n\nFor more information on the request matchers provided by `RequestMatchers`, see the {spring-ws-api}/test/client/RequestMatchers.html[Javadoc].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/client.adoc", "title": "client", "heading": "Using `ResponseCreator` and `ResponseCreators`", "heading_level": 3, "file_order": 1, "section_index": 17, "content_hash": "238625dbb7a968659eed396f6e794ae4ae7023a74df30727da499da58326409f", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/client.adoc"}}
{"id": "sha256:0c2ad7921673524a5f98a6f974a3c13797700efa8b26c7e25e365ca1c6a6b250", "content": "[[common]]\n\nThis chapter explores the components that are shared between client- and server-side Spring-WS development.\nThese interfaces and classes represent the building blocks of Spring-WS, so you need to understand what they do, even if you do not use them directly.\n\n[[web-service-null-safety]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "common", "heading_level": 1, "file_order": 2, "section_index": 0, "content_hash": "0c2ad7921673524a5f98a6f974a3c13797700efa8b26c7e25e365ca1c6a6b250", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:04e8a8e61553db6f87dfefd528caeb213d0100fef52752fbd7584b39488101e3", "content": "Spring-WS is annotated with https://jspecify.dev/docs/start-here/[JSpecify] annotations to declare the nullability of its API.\nTo learn more about JSpecify, its https://jspecify.dev/docs/user-guide/[user guide] is recommended reading.\n\nThe primary goal of declaring the nullability of the API is to prevent a `NullPointerException` from being thrown at runtime.\nThis is achieved through build-time checks that are available with both Java and Kotlin.\nPerforming the checks with Java requires some tooling such as https://github.com/uber/NullAway[NullAway] or an IDE that supports JSpecify annotations such as IntelliJ IDEA.\nThe checks are available automatically with Kotlin which translates the JSpecify annotations into Kotlin's null safety.\n\nTo learn more about null safety with Spring, refer to the {spring-framework-docs}/core/null-safety.html[Spring Framework reference documentation].\n\n[[web-service-messages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "Null Safety", "heading_level": 2, "file_order": 2, "section_index": 1, "content_hash": "04e8a8e61553db6f87dfefd528caeb213d0100fef52752fbd7584b39488101e3", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:16399ee5ed808c5e22bb44bdb42762d12bc8b1e0978a9477d7d6baefa7937edf", "content": "This section describes the messages and message factories that Spring-WS uses.\n\n[[web-service-message]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "Web Service Messages", "heading_level": 2, "file_order": 2, "section_index": 2, "content_hash": "16399ee5ed808c5e22bb44bdb42762d12bc8b1e0978a9477d7d6baefa7937edf", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:334bbb719c478fc8e574f2c1003e93559ece500203ddaf64e66314325937a4a3", "content": "One of the core interfaces of Spring-WS is the `WebServiceMessage`.\nThis interface represents a protocol-agnostic XML message.\nThe interface contains methods that provide access to the payload of the message, in the form of a `javax.xml.transform.Source` or a `javax.xml.transform.Result`.\n`Source` and `Result` are tagging interfaces that represent an abstraction over XML input and output.\nConcrete implementations wrap various XML representations, as indicated in the following table:\n\n[cols=\"2\", options=\"header\"]\n|===\n| Source or Result implementation\n| Wrapped XML representation\n\n| `javax.xml.transform.dom.DOMSource`\n| `org.w3c.dom.Node`\n\n| `javax.xml.transform.dom.DOMResult`\n| `org.w3c.dom.Node`\n\n| `javax.xml.transform.sax.SAXSource`\n| `org.xml.sax.InputSource` and `org.xml.sax.XMLReader`\n\n| `javax.xml.transform.sax.SAXResult`\n| `org.xml.sax.ContentHandler`\n\n| `javax.xml.transform.stream.StreamSource`\n| `java.io.File`, `java.io.InputStream`, or `java.io.Reader`\n\n| `javax.xml.transform.stream.StreamResult`\n| `java.io.File`, `java.io.OutputStream`, or `java.io.Writer`\n|===\n\nIn addition to reading from and writing to the payload, a web service message can write itself to an output stream.\n\n[[soap-message]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "`WebServiceMessage`", "heading_level": 3, "file_order": 2, "section_index": 3, "content_hash": "334bbb719c478fc8e574f2c1003e93559ece500203ddaf64e66314325937a4a3", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:341a16fcdc8845be54fcfc4a0d758a6a9ee0cd48cf10953e5038c7a66b7a4f8c", "content": "`SoapMessage` is a subclass of `WebServiceMessage`.\nIt contains SOAP-specific methods, such as getting SOAP Headers, SOAP Faults, and so on.\nGenerally, your code should not be dependent on `SoapMessage`, because the content of the SOAP Body (the payload of the message) can be obtained by using `getPayloadSource()` and `getPayloadResult()` in the `WebServiceMessage`.\nOnly when it is necessary to perform SOAP-specific actions (such as adding a header, getting an attachment, and so on) should you need to cast `WebServiceMessage` to `SoapMessage`.\n\n[[message-factories]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "`SoapMessage`", "heading_level": 3, "file_order": 2, "section_index": 4, "content_hash": "341a16fcdc8845be54fcfc4a0d758a6a9ee0cd48cf10953e5038c7a66b7a4f8c", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:77edd0490c49cc7ead2d9e0dcf87b74dcaa970a29b0cd8453b88548ac5071972", "content": "Concrete message implementations are created by a `WebServiceMessageFactory`.\nThis factory can create an empty message or read a message from an input stream.\nThere are two concrete implementations of `WebServiceMessageFactory`.\nOne is based on SAAJ, the SOAP with Attachments API for Java.\nThe other is based on Axis 2â€™s AXIOM (AXis Object Model).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "Message Factories", "heading_level": 3, "file_order": 2, "section_index": 5, "content_hash": "77edd0490c49cc7ead2d9e0dcf87b74dcaa970a29b0cd8453b88548ac5071972", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:967c9275ca3c5bbde843115ad571666381d538f3eed05f9ec50936606b97a243", "content": "The `SaajSoapMessageFactory` uses the SOAP with Attachments API for Java (SAAJ) to create `SoapMessage` implementations.\nSAAJ is part of J2EE 1.4, so it should be supported under most modern application servers.\nHere is an overview of the SAAJ versions supplied by common application servers:\n\n[cols=\"2\", options=\"header\"]\n|===\n| Application Server\n| SAAJ Version\n\n| BEA WebLogic 8\n| 1.1\n\n| BEA WebLogic 9\n| 1.1/1.2^1^\n\n| IBM WebSphere 6\n| 1.2\n\n| SUN Glassfish 1\n| 1.3\n\n2+|^1^Weblogic 9 has a known bug in the SAAJ 1.2 implementation: it implements all the 1.2 interfaces but throws an `UnsupportedOperationException` when called.\nSpring-WS has a workaround: It uses SAAJ 1.1 when operating on WebLogic 9.\n|===\n\nAdditionally, Java SE 6 includes SAAJ 1.3.\nYou can wire up a `SaajSoapMessageFactory` as follows:\n\n====\n[source,xml]\n----\n<bean id=\"messageFactory\" class=\"org.springframework.ws.soap.saaj.SaajSoapMessageFactory\" />\n----\n====\n\n[NOTE]\n====\nSAAJ is based on DOM, the Document Object Model.\nThis means that all SOAP messages are stored in memory.\nFor larger SOAP messages, this may not be performant.\nIn that case, the `AxiomSoapMessageFactory` might be more applicable.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "`SaajSoapMessageFactory`", "heading_level": 4, "file_order": 2, "section_index": 6, "content_hash": "967c9275ca3c5bbde843115ad571666381d538f3eed05f9ec50936606b97a243", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:9bac5d56abd288a6f590b6981ea2876e1f3557f1d0513f29cc24a1e1a8a44df0", "content": "The `AxiomSoapMessageFactory` uses the AXis 2 Object Model (AXIOM) to create `SoapMessage` implementations.\nAXIOM is based on StAX, the Streaming API for XML.\nStAX provides a pull-based mechanism for reading XML messages, which can be more efficient for larger messages.\n\nTo increase reading performance on the `AxiomSoapMessageFactory`, you can set the `payloadCaching` property to false (default is true).\nDoing so causes the contents of the SOAP body to be read directly from the socket stream.\nWhen this setting is enabled, the payload can be read only once.\nThis means that you have to make sure that any pre-processing (logging or other work) of the message does not consume it.\n\nYou can use the `AxiomSoapMessageFactory` as follows:\n\n====\n[source,xml]\n----\n<bean id=\"messageFactory\" class=\"org.springframework.ws.soap.axiom.AxiomSoapMessageFactory\">\n <property name=\"payloadCaching\" value=\"true\"/>\n</bean>\n----\n====\n\nIn addition to payload caching, AXIOM supports full streaming messages, as defined in the `StreamingWebServiceMessage`.\nThis means that you can directly set the payload on the response message, rather than writing it to a DOM tree or buffer.\n\nFull streaming for AXIOM is used when a handler method returns a JAXB2-supported object.\nIt automatically sets this marshalled object into the response message and writes it out to the outgoing socket stream when the response is going out.\n\nFor more information about full streaming, see {spring-ws-api}/stream/StreamingWebServiceMessage.html[`StreamingWebServiceMessage`] and {spring-ws-api}/stream/StreamingPayload.html[`StreamingPayload`].\n\n[[soap_11_or_12]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "`AxiomSoapMessageFactory`", "heading_level": 4, "file_order": 2, "section_index": 7, "content_hash": "9bac5d56abd288a6f590b6981ea2876e1f3557f1d0513f29cc24a1e1a8a44df0", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:a3d0f8b0fd9afdc9df53039cd51db8b891c064417fb6302e7bf82d62ac807f94", "content": "Both the `SaajSoapMessageFactory` and the `AxiomSoapMessageFactory` have a `soapVersion` property, where you can inject a `SoapVersion` constant.\nBy default, the version is 1.1, but you can set it to 1.2:\n\n====\n[source,xml]\n----\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:util=\"http://www.springframework.org/schema/util\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n http://www.springframework.org/schema/beans/spring-beans-2.0.xsd\n http://www.springframework.org/schema/util\n http://www.springframework.org/schema/util/spring-util-2.0.xsd\">\n\n <bean id=\"messageFactory\" class=\"org.springframework.ws.soap.saaj.SaajSoapMessageFactory\">\n <property name=\"soapVersion\">\n <util:constant static-field=\"org.springframework.ws.soap.SoapVersion.SOAP_12\"/>\n </property>\n </bean>\n\n</beans>\n----\n====\n\nIn the preceding example, we define a `SaajSoapMessageFactory` that accepts only SOAP 1.2 messages.\n\n[WARNING]\n====\nEven though both versions of SOAP are quite similar in format, the 1.2 version is not backwards compatible with 1.1, because it uses a different XML namespace.\nOther major differences between SOAP 1.1 and 1.2 include the different structure of a fault and the fact that `SOAPAction` HTTP headers are effectively deprecated, though they still work.\n\nOne important thing to note with SOAP version numbers (or WS-* specification version numbers in general) is that the latest version of a specification is generally not the most popular version.\nFor SOAP, this means that (currently) the best version to use is 1.1.\nVersion 1.2 might become more popular in the future, but 1.1 is currently the safest bet.\n====\n\n[[message-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "SOAP 1.1 or 1.2", "heading_level": 4, "file_order": 2, "section_index": 8, "content_hash": "a3d0f8b0fd9afdc9df53039cd51db8b891c064417fb6302e7bf82d62ac807f94", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:bba37212efe8294f9e18fb71060e61c68731d9eefc0b32fb1cc12d67fa389196", "content": "Typically, messages come in pairs: a request and a response.\nA request is created on the client-side, which is sent over some transport to the server-side, where a response is generated.\nThis response gets sent back to the client, where it is read.\n\nIn Spring-WS, such a conversation is contained in a `MessageContext`, which has properties to get request and response messages.\nOn the client-side, the message context is created by the <<client-web-service-template,`WebServiceTemplate`>>.\nOn the server-side, the message context is read from the transport-specific input stream.\nFor example, in HTTP, it is read from the `HttpServletRequest`, and the response is written back to the `HttpServletResponse`.\n\n[[transport-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "`MessageContext`", "heading_level": 3, "file_order": 2, "section_index": 9, "content_hash": "bba37212efe8294f9e18fb71060e61c68731d9eefc0b32fb1cc12d67fa389196", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:e62abc6adb6b55da763bb3781b782d27fa0e85535e14886c2a6827aad245760f", "content": "One of the key properties of the SOAP protocol is that it tries to be transport-agnostic.\nThis is why, for instance, Spring-WS does not support mapping messages to endpoints by HTTP request URL but rather by message content.\n\nHowever, it is sometimes necessary to get access to the underlying transport, either on the client or the server side.\nFor this, Spring-WS has the `TransportContext`.\nThe transport context allows access to the underlying `WebServiceConnection`, which typically is a `HttpServletConnection` on the server side or a `HttpUrlConnection` or `CommonsHttpConnection` on the client side.\nFor example, you can obtain the IP address of the current request in a server-side endpoint or interceptor:\n\n====\n[source,java]\n----\nTransportContext context = TransportContextHolder.getTransportContext();\nHttpServletConnection connection = (HttpServletConnection )context.getConnection();\nHttpServletRequest request = connection.getHttpServletRequest();\nString ipAddress = request.getRemoteAddr();\n----\n====\n\n[[xpath]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "`TransportContext`", "heading_level": 2, "file_order": 2, "section_index": 10, "content_hash": "e62abc6adb6b55da763bb3781b782d27fa0e85535e14886c2a6827aad245760f", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:81340d417e9006dad7b5011ee87cc53ede4783ad20d798db33b04ecb1f3b3496", "content": "One of the best ways to handle XML is to use XPath.\nQuoting <<effective-xml>>, item 35:\n\n[quote, Elliotte Rusty Harold]\nXPath is a fourth generation declarative language that allows you to specify which nodes you want to process without specifying exactly how the processor is supposed to navigate to those nodes.\nXPath's data model is very well designed to support exactly what almost all developers want from XML.\nFor instance, it merges all adjacent text including that in CDATA sections, allows values to be calculated that skip over comments and processing instructions` and include text from child and descendant elements, and requires all external entity references to be resolved.\nIn practice, XPath expressions tend to be much more robust against unexpected but perhaps insignificant changes in the input document.\n\nSpring-WS has two ways to use XPath within your application: the faster `XPathExpression` or the more flexible `XPathOperations`.\n\n[[xpath-expression]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "Handling XML With XPath", "heading_level": 2, "file_order": 2, "section_index": 11, "content_hash": "81340d417e9006dad7b5011ee87cc53ede4783ad20d798db33b04ecb1f3b3496", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:4569c5f102fad5a51bcf5aef74c28ac547d703e9896177413d6ebd5a0aad44a4", "content": "The `XPathExpression` is an abstraction over a compiled XPath expression, such as the Java 5 `javax.xml.xpath.XPathExpression` interface or the Jaxen `XPath` class.\nTo construct an expression in an application context, you can use `XPathExpressionFactoryBean`.\nThe following example uses this factory bean:\n\n====\n[source,xml]\n----\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n http://www.springframework.org/schema/beans/spring-beans-2.0.xsd\">\n\n <bean id=\"nameExpression\" class=\"org.springframework.xml.xpath.XPathExpressionFactoryBean\">\n <property name=\"expression\" value=\"/Contacts/Contact/Name\"/>\n </bean>\n\n <bean id=\"myEndpoint\" class=\"sample.MyXPathClass\">\n <constructor-arg ref=\"nameExpression\"/>\n </bean>\n\n</beans>\n----\n====\n\nThe preceding expression does not use namespaces, but we could set those by using the `namespaces` property of the factory bean.\nThe expression can be used in the code as follows:\n\n====\n[source,java]\n----\npackage sample;\n\npublic class MyXPathClass {\n\n private final XPathExpression nameExpression;\n\n public MyXPathClass(XPathExpression nameExpression) {\n this.nameExpression = nameExpression;\n }\n\n public void doXPath(Document document) {\n String name = nameExpression.evaluateAsString(document.getDocumentElement());\n System.out.println(\"Name: \" + name);\n }\n\n}\n----\n====\n\nFor a more flexible approach, you can use a `NodeMapper`, which is similar to the `RowMapper` in Spring's JDBC support.\nThe following example shows how to use it:\n\n====\n[source,java]\n----\npackage sample;\n\npublic class MyXPathClass {\n\n private final XPathExpression contactExpression;\n\n public MyXPathClass(XPathExpression contactExpression) {\n this.contactExpression = contactExpression;\n }\n\n public void doXPath(Document document) {\n List contacts = contactExpression.evaluate(document,\n new NodeMapper() {\n public Object mapNode(Node node, int nodeNum) throws DOMException {\n Element contactElement = (Element) node;\n Element nameElement = (Element) contactElement.getElementsByTagName(\"Name\").item(0);\n Element phoneElement = (Element) contactElement.getElementsByTagName(\"Phone\").item(0);\n return new Contact(nameElement.getTextContent(), phoneElement.getTextContent());\n }\n });\n PlainText Section qName; // do something with the list of Contact objects\n }\n}\n----\n====\n\nSimilar to mapping rows in Spring JDBC's `RowMapper`, each result node is mapped by using an anonymous inner class.\nIn this case, we create a `Contact` object, which we use later on.\n\n[[xpath-template]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "`XPathExpression`", "heading_level": 3, "file_order": 2, "section_index": 12, "content_hash": "4569c5f102fad5a51bcf5aef74c28ac547d703e9896177413d6ebd5a0aad44a4", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:b87f84639914daf60365b9c068096e9ab2e94f4111401b167babbb18f7f7e1f4", "content": "The `XPathExpression` lets you evaluate only a single, pre-compiled expression.\nA more flexible, though slower, alternative is the `XPathOperations`.\nThis class follows the common template pattern used throughout Spring (`JdbcTemplate`, `JmsTemplate`, and others).\nThe following listing shows an example:\n\n====\n[source,java,subs=\"verbatim,quotes\"]\n----\npackage sample;\n\npublic class MyXPathClass {\n\n private XPathOperations template = new Jaxp13XPathTemplate();\n\n public void doXPath(Source source) {\n String name = template.evaluateAsString(\"/Contacts/Contact/Name\", request);\n _// do something with name_\n }\n\n}\n----\n====\n\n[[logging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "`XPathOperations`", "heading_level": 3, "file_order": 2, "section_index": 13, "content_hash": "b87f84639914daf60365b9c068096e9ab2e94f4111401b167babbb18f7f7e1f4", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:33f66bb9ff062be5ae236491fbc1e2a1a57f0c3375fb349fc4bb6984ecb4a330", "content": "When developing or debugging a web service, it can be quite useful to look at the content of a (SOAP) message when it arrives, or before it is sent.\nSpring-WS offer this functionality, through the standard Commons Logging interface.\n\nTo log all server-side messages, set the `org.springframework.ws.server.MessageTracing` logger level to `DEBUG` or `TRACE`.\nOn the `DEBUG` level, only the payload root element is logged.\nOn the `TRACE` level, the entire message content is logged.\nIf you want to log only sent messages, use the `org.springframework.ws.server.MessageTracing.sent` logger.\nSimilarly, you can use `org.springframework.ws.server.MessageTracing.received` to log only received messages.\n\nOn the client-side, similar loggers exist: `org.springframework.ws.client.MessageTracing.sent` and `org.springframework.ws.client.MessageTracing.received`.\n\nThe following example of a `log4j2.properties` configuration file logs the full content of sent messages on the client side and only the payload root element for client-side received messages.\nOn the server-side, the payload root is logged for both sent and received messages:\n\n====\n[source]\n----\nappender.console.name=STDOUT\nappender.console.type=Console\nappender.console.layout.type=PatternLayout\nappender.console.layout.pattern=%-5p [%c{3}] %m%n\n\nrootLogger=DEBUG,STDOUT\nlogger.org.springframework.ws.client.MessageTracing.sent=TRACE\nlogger.org.springframework.ws.client.MessageTracing.received=DEBUG\nlogger.org.springframework.ws.server.MessageTracing=DEBUG\n\n----\n====\n\nWith this configuration, a typical output is:\n\n====\n----\nTRACE [client.MessageTracing.sent] Sent request [<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"...\nDEBUG [server.MessageTracing.received] Received request [SaajSoapMessage {http://example.com}request] ...\nDEBUG [server.MessageTracing.sent] Sent response [SaajSoapMessage {http://example.com}response] ...\nDEBUG [client.MessageTracing.received] Received response [SaajSoapMessage {http://example.com}response] ...\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/common.adoc", "title": "common", "heading": "Message Logging and Tracing", "heading_level": 2, "file_order": 2, "section_index": 14, "content_hash": "33f66bb9ff062be5ae236491fbc1e2a1a57f0c3375fb349fc4bb6984ecb4a330", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/common.adoc"}}
{"id": "sha256:596178ff6344fdad1a884c08d802a729454629129591a73dc6e1724d5dce9cc3", "content": "Arjen Poutsma, Rick Evans, Tareq Abed Rabbo, Greg Turnquist, Jay Bryant, Corneil du Plessis, StÃ©phane Nicoll\n\nNOTE: Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.\n\n[[spring-framework-reference]]\ninclude::preface.adoc[leveloffset=+1]\n\nThis first part of the reference documentation <<what-is-spring-ws,is an overview>> of Spring Web Services and the underlying concepts.\nThen, <<why-contract-first,the concepts>> behind contract-first web service development are explained.\nFinally, the third section provides <<tutorial,a tutorial>>.\n\ninclude::what-is-spring-ws.adoc[leveloffset=+1]\n\ninclude::why-contract-first.adoc[leveloffset=+1]\n\ninclude::tutorial.adoc[leveloffset=+1]\n\nThis part of the reference documentation details the various components that comprise Spring Web Services.\nThis includes <<common,a chapter>> that discusses the parts common to both client- and server-side WS, a chapter devoted to the specifics of <<server,writing server-side web services>>, a chapter about using web services on <<client,the client-side>>, and a chapter on using <<security,WS-Security>>.\n\ninclude::common.adoc[leveloffset=+1]\n\ninclude::server.adoc[leveloffset=+1]\n\ninclude::client.adoc[leveloffset=+1]\n\ninclude::security.adoc[leveloffset=+1]\n\n[[resources]]\n\nIn addition to this reference documentation, a number of other resources may help you learn how to use Spring Web Services.\nThese additional, third-party resources are enumerated in this section.\n\ninclude::bibliography.adoc[leveloffset=+1]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/index.adoc", "title": "Spring Web Services Reference Documentation", "heading": "Spring Web Services Reference Documentation", "heading_level": 1, "file_order": 3, "section_index": 0, "content_hash": "596178ff6344fdad1a884c08d802a729454629129591a73dc6e1724d5dce9cc3", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/index.adoc"}}
{"id": "sha256:c6f8e17ad7b16208e7db70cc0232787a8a7a8ba69b6cd4739dfc0b7ba4993c2d", "content": "[preface]\n[[overview]]\n\nIn the current age of Service Oriented Architectures, more and more people use web services to connect previously unconnected systems.\nInitially, web services were considered to be just another way to do a Remote Procedure Call (RPC).\nOver time, however, people found out that there is a big difference between RPCs and web services.\nEspecially when interoperability with other platforms is important, it is often better to send encapsulated XML documents that contain all the data necessary to process the request.\nConceptually, XML-based web services are better compared to message queues than to remoting solutions.\nOverall, XML should be considered the platform-neutral representation of data, the _common language_ of SOA.\nWhen developing or using web services, the focus should be on this XML and not on Java.\n\nSpring-WS focuses on creating these document-driven web services.\nSpring-WS facilitates contract-first SOAP service development, allowing for the creation of flexible web services by using one of the many ways to manipulate XML payloads.\nSpring-WS provides a powerful <<server,message dispatching framework>>, a <<security,WS-Security>> solution that integrates with your existing application security solution, and a <<client,Client-side API>> that follows the familiar Spring template pattern.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/preface.adoc", "title": "preface", "heading": "preface", "heading_level": 1, "file_order": 4, "section_index": 0, "content_hash": "c6f8e17ad7b16208e7db70cc0232787a8a7a8ba69b6cd4739dfc0b7ba4993c2d", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/preface.adoc"}}
{"id": "sha256:b3c7d3e268c0ffaeced67647ed4d242b60acbec60db8bce66ac589841238ed34", "content": "[[security]]\n\nThis chapter explains how to add WS-Security aspects to your Web services.\nWe focus on the three different areas of WS-Security:\n\n* *Authentication*: This is the process of determining whether a principal is who they claim to be.\nIn this context, a \"principal\" generally means a user, device or some other system that can perform an action in your application.\n* *Digital signatures*: The digital signature of a message is a piece of information based on both the document and the signer's private key.\nIt is created through the use of a hash function and a private signing function (encrypting with the signer's private key).\n* *Encryption and Decryption*: Encryption is the process of transforming data into a form that is impossible to read without the appropriate key.\nIt is mainly used to keep information hidden from anyone for whom it is not intended.\nDecryption is the reverse of encryption.\nIt is the process of transforming encrypted data back into a readable form.\n\nThese three areas are implemented by using the `XwsSecurityInterceptor` or `Wss4jSecurityInterceptor`, which we describe in <<security-xws-security-interceptor>> and <<security-wss4j-security-interceptor>>, respectively.\n\n[NOTE]\n====\nWS-Security (especially encryption and signing) requires substantial amounts of memory and can decrease performance.\nIf performance is important to you, you might want to consider not using WS-Security or using HTTP-based security.\n====\n\n[[security-xws-security-interceptor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "security", "heading_level": 1, "file_order": 5, "section_index": 0, "content_hash": "b3c7d3e268c0ffaeced67647ed4d242b60acbec60db8bce66ac589841238ed34", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:0424d4ff7530c1d51de2508f5a310342f2ec80c0496271cb78bc624ef12a1101", "content": "The `XwsSecurityInterceptor` is an `EndpointInterceptor` (see <<server-endpoint-interceptor>>) that is based on SUN's XML and Web Services Security package (XWSS).\nThis WS-Security implementation is part of the Java Web Services Developer Pack (https://www.oracle.com/java/technologies/java-archive-jwsdp-downloads.html[Java WSDP]).\n\nLike any other endpoint interceptor, it is defined in the endpoint mapping (see <<server-endpoint-mapping>>).\nThis means that you can be selective about adding WS-Security support.\nSome endpoint mappings require it, while others do not.\n\n[NOTE]\n====\nXWSS requires a SUN SAAJ reference implementation.\nThe WSS4J interceptor does not have these requirements (see <<security-wss4j-security-interceptor>>).\n====\n\nThe `XwsSecurityInterceptor` requires a security policy file to operate.\nThis XML file tells the interceptor what security aspects to require from incoming SOAP messages and what aspects to add to outgoing messages.\nThe basic format of the policy file is explained in the following sections, but a more in-depth tutorial https://docs.oracle.com/cd/E17802_01/webservices/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp564887[is available].\nYou can set the policy with the `policyConfiguration` property, which requires a Spring resource.\nThe policy file can contain multiple elements -- for example, require a username token on incoming messages and sign all outgoing messages.\nIt contains a `SecurityConfiguration` element (not a `JAXRPCSecurity` element) as its root.\n\nAdditionally, the security interceptor requires one or more `CallbackHandler` instances to operate.\nThese handlers are used to retrieve certificates, private keys, validate user credentials, and so on.\nSpring-WS offers handlers for most common security concerns -- for example, authenticating against a Spring Security authentication manager and signing outgoing messages based on a X509 certificate.\nThe following sections indicate what callback handler to use for which security concern.\nYou can set the callback handlers by using the `callbackHandler` or `callbackHandlers` property.\n\nThe following example that shows how to wire up the `XwsSecurityInterceptor`:\n\n====\n[source,xml]\n----\n<beans>\n <bean id=\"wsSecurityInterceptor\"\n class=\"org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor\">\n <property name=\"policyConfiguration\" value=\"classpath:securityPolicy.xml\"/>\n <property name=\"callbackHandlers\">\n <list>\n <ref bean=\"certificateHandler\"/>\n <ref bean=\"authenticationHandler\"/>\n </list>\n </property>\n </bean>\n ...\n</beans>\n----\n====\n\nThis interceptor is configured by using the `securityPolicy.xml` file on the classpath.\nIt uses two callback handlers that are defined later in the file.\n\n[[keystore]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "`XwsSecurityInterceptor`", "heading_level": 2, "file_order": 5, "section_index": 1, "content_hash": "0424d4ff7530c1d51de2508f5a310342f2ec80c0496271cb78bc624ef12a1101", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:7e3b6275033cafaa665e5b73253e416b0d546fc4db02ad93673d5573d0ce0d2e", "content": "For most cryptographic operations, you an use the standard `java.security.KeyStore` objects.\nThese operations include certificate verification, message signing, signature verification, and encryption.\nThey exclude username and time-stamp verification.\nThis section aims to give you some background knowledge on keystores and the Java tools that you can use to store keys and certificates in a keystore file.\nThis information is mostly not related to Spring-WS but to the general cryptographic features of Java.\n\nThe `java.security.KeyStore` class represents a storage facility for cryptographic keys and certificates.\nIt can contain three different sort of elements:\n\n* *Private Keys*: These keys are used for self-authentication.\nThe private key is accompanied by a certificate chain for the corresponding public key.\nWithin the field of WS-Security, this accounts for message signing and message decryption.\n* *Symmetric Keys*: Symmetric (or secret) keys are also used for message encryption and decryption -- the difference being that both sides (sender and recipient) share the same secret key.\n* *Trusted certificates*: These X509 certificates are called a \"trusted certificate\" because the keystore owner trusts that the public key in the certificates does indeed belong to the owner of the certificate.\nWithin WS-Security, these certificates are used for certificate validation, signature verification, and encryption.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Keystores", "heading_level": 3, "file_order": 5, "section_index": 2, "content_hash": "7e3b6275033cafaa665e5b73253e416b0d546fc4db02ad93673d5573d0ce0d2e", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:c03c8cebf5e471434f59daf1f59d3fec0b9017ee2fe999330567220790363e4e", "content": "The `keytool` program, a key and certificate management utility, is supplied with your Java Virtual Machine.\nYou can use this tool to create new keystores, add new private keys and certificates to them, and so on.\nIt is beyond the scope of this document to provide a full reference of the `keytool` command, check the https://docs.oracle.com/en/java/javase/17/docs/specs/man/keytool.html[standard reference] or invoke `keytool -help` on the command line.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `keytool`", "heading_level": 4, "file_order": 5, "section_index": 3, "content_hash": "c03c8cebf5e471434f59daf1f59d3fec0b9017ee2fe999330567220790363e4e", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:8719832fa3b651c0a4711bbf87bd9c209e23068845041d9681d3848ef27d943f", "content": "To easily load a keystore by using Spring configuration, you can use the `KeyStoreFactoryBean`.\nIt has a resource location property, which you can set to point to the path of the keystore to load.\nA password may be given to check the integrity of the keystore data.\nIf a password is not given, integrity checking is not performed.\nThe following listing configures a `KeyStoreFactoryBean`:\n\n====\n[source,xml]\n----\n<bean id=\"keyStore\" class=\"org.springframework.ws.soap.security.support.KeyStoreFactoryBean\">\n <property name=\"password\" value=\"password\"/>\n <property name=\"location\" value=\"classpath:org/springframework/ws/soap/security/xwss/test-keystore.jks\"/>\n</bean>\n----\n====\n\nWARNING: If you do not specify the location property, a new, empty keystore is created, which is most likely not what you want.\n\n[[security-key-store-callback-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `KeyStoreFactoryBean`", "heading_level": 4, "file_order": 5, "section_index": 4, "content_hash": "8719832fa3b651c0a4711bbf87bd9c209e23068845041d9681d3848ef27d943f", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:06185508bb977ef0d58a54bc6b4c47a22cffcc054af0b8415af9b71f6e50701c", "content": "To use the keystores within a `XwsSecurityInterceptor`, you need to define a `KeyStoreCallbackHandler`.\nThis callback has three properties with type `keystore`: (`keyStore`,`trustStore`, and `symmetricStore`).\nThe exact stores used by the handler depend on the cryptographic operations that are to be performed by this handler.\nFor private key operation, the `keyStore` is used.\nFor symmetric key operations, the `symmetricStore` is used.\nFor determining trust relationships, the `trustStore` is used.\nThe following table indicates this:\n\n[cols=\"2\", options=\"header\"]\n|===\n| Cryptographic operation\n| Keystore used\n\n| Certificate validation\n| First `keyStore`, then `trustStore`\n\n| Decryption based on private key\n| `keyStore`\n\n| Decryption based on symmetric key\n| `symmetricStore`\n\n| Encryption based on public key certificate\n| `trustStore`\n\n| Encryption based on symmetric key\n| `symmetricStore`\n\n| Signing\n| `keyStore`\n\n| Signature verification\n| `trustStore`\n|===\n\nAdditionally, the `KeyStoreCallbackHandler` has a `privateKeyPassword` property, which should be set to unlock the private keys contained in the`keyStore`.\n\nIf the `symmetricStore` is not set, it defaults to the `keyStore`.\nIf the key or trust store is not set, the callback handler uses the standard Java mechanism to load or create it.\nSee {spring-ws-api}/soap/security/wss4j2/callback/KeyStoreCallbackHandler.html[`KeyStoreCallbackHandler`] for more details.\n\nFor instance, if you want to use the `KeyStoreCallbackHandler` to validate incoming certificates or signatures, you can use a trust store:\n\n====\n[source,xml]\n----\n<beans>\n <bean id=\"keyStoreHandler\" class=\"org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler\">\n <property name=\"trustStore\" ref=\"trustStore\"/>\n </bean>\n\n <bean id=\"trustStore\" class=\"org.springframework.ws.soap.security.support.KeyStoreFactoryBean\">\n <property name=\"location\" value=\"classpath:truststore.jks\"/>\n <property name=\"password\" value=\"changeit\"/>\n </bean>\n</beans>\n----\n====\n\nIf you want to use it to decrypt incoming certificates or sign outgoing messages, you can use a key store:\n\n====\n[source,xml]\n----\n<beans>\n <bean id=\"keyStoreHandler\" class=\"org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler\">\n <property name=\"keyStore\" ref=\"keyStore\"/>\n <property name=\"privateKeyPassword\" value=\"changeit\"/>\n </bean>\n\n <bean id=\"keyStore\" class=\"org.springframework.ws.soap.security.support.KeyStoreFactoryBean\">\n <property name=\"location\" value=\"classpath:keystore.jks\"/>\n <property name=\"password\" value=\"changeit\"/>\n </bean>\n</beans>\n----\n====\n\nThe following sections indicate where the `KeyStoreCallbackHandler` can be used and which properties to set for particular cryptographic operations.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "KeyStoreCallbackHandler", "heading_level": 4, "file_order": 5, "section_index": 5, "content_hash": "06185508bb977ef0d58a54bc6b4c47a22cffcc054af0b8415af9b71f6e50701c", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:607f46b756b153a1d94460a0bbc0c0964f8c4599bbe855b3aa6841758c329d2b", "content": "As stated in the <<security,introduction to this chapter>>, authentication is the task of determining whether a principal is who they claim to be.\nWithin WS-Security, authentication can take two forms: using a username and password token (using either a plain text password or a password digest) or using a X509 certificate.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Authentication", "heading_level": 3, "file_order": 5, "section_index": 6, "content_hash": "607f46b756b153a1d94460a0bbc0c0964f8c4599bbe855b3aa6841758c329d2b", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:7b550ad86375baa644e1c4039c0139f220fca4a91522849bb14c80b9428ca829", "content": "The simplest form of username authentication uses plain text passwords.\nIn this scenario, the SOAP message contains a `UsernameToken` element, which itself contains a `Username` element and a `Password` element which contains the plain text password.\nPlain text authentication can be compared to the basic authentication provided by HTTP servers.\n\n[WARNING]\n====\nPlain text passwords are not very secure.\nTherefore, you should always add additional security measures to your transport layer if you use them (using HTTPS instead of plain HTTP, for instance).\n====\n\nTo require that every incoming message contains a `UsernameToken` with a plain text password, the security policy file should contain a `RequireUsernameToken` element, with the `passwordDigestRequired` attribute set to `false`.\nFore more details, check the https://docs.oracle.com/cd/E17802_01/webservices/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp567459[official reference] of possible child elements.\nThe following listing shows how to include a `RequireUsernameToken` element:\n\n====\n[source,xml]\n----\n<xwss:SecurityConfiguration xmlns:xwss=\"http://java.sun.com/xml/ns/xwss/config\">\n ...\n <xwss:RequireUsernameToken passwordDigestRequired=\"false\" nonceRequired=\"false\"/>\n ...\n</xwss:SecurityConfiguration>\n----\n====\n\nIf the username token is not present, the `XwsSecurityInterceptor` returns a SOAP fault to the sender.\nIf it is present, it fires a `PasswordValidationCallback` with a `PlainTextPasswordRequest` to the registered handlers.\nWithin Spring-WS, there are three classes that handle this particular callback:\n\n* <<security-simple-password-validation-callback-handler,`SimplePasswordValidationCallbackHandler`>>\n* <<using-springplaintextpasswordvalidationcallbackhandler,`SpringPlainTextPasswordValidationCallbackHandler`>>\n* <<using-jaasplaintextpasswordvalidationcallbackhandler,`JaasPlainTextPasswordValidationCallbackHandler`>>\n\n[[security-simple-password-validation-callback-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Plain Text Username Authentication", "heading_level": 4, "file_order": 5, "section_index": 7, "content_hash": "7b550ad86375baa644e1c4039c0139f220fca4a91522849bb14c80b9428ca829", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:3f411ebc2ada009279884da728d8ba92a1daeb2ca264f68722da10f559561626", "content": "The simplest password validation handler is the `SimplePasswordValidationCallbackHandler`.\nThis handler validates passwords against an in-memory `Properties` object, which you can specify by using the `users` property:\n\n====\n[source,xml]\n----\n<bean id=\"passwordValidationHandler\"\n class=\"org.springframework.ws.soap.security.xwss.callback.SimplePasswordValidationCallbackHandler\">\n <property name=\"users\">\n <props>\n <prop key=\"Bert\">Ernie</prop>\n </props>\n </property>\n</bean>\n----\n====\n\nIn this case, we are allowing only the user, \"Bert\", to log in by using the password, \"Ernie\".\n\n[[using-springplaintextpasswordvalidationcallbackhandler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `SimplePasswordValidationCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 8, "content_hash": "3f411ebc2ada009279884da728d8ba92a1daeb2ca264f68722da10f559561626", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:8a9b965f59147d3730e40675536e50258885c1b8f4c2ea45e1eb6ac772ec63b0", "content": "The `SpringPlainTextPasswordValidationCallbackHandler` uses https://spring.io/projects/spring-security[Spring Security] to authenticate users.\nIt is beyond the scope of this document to describe Spring Security, but it is a full-fledged security framework.\nYou can read more about it in the https://docs.spring.io/spring-security/reference[Spring Security reference documentation].\n\nThe `SpringPlainTextPasswordValidationCallbackHandler` requires an `AuthenticationManager` to operate.\nIt uses this manager to authenticate against a `UsernamePasswordAuthenticationToken` that it creates.\nIf authentication is successful, the token is stored in the `SecurityContextHolder`.\nYou can set the authentication manager by using the `authenticationManager` property:\n\n====\n[source,xml]\n----\n<beans>\n <bean id=\"springSecurityHandler\"\n class=\"org.springframework.ws.soap.security.xwss.callback.SpringPlainTextPasswordValidationCallbackHandler\">\n <property name=\"authenticationManager\" ref=\"authenticationManager\"/>\n </bean>\n\n <bean id=\"authenticationManager\" class=\" org.springframework.security.authentication.ProviderManager\">\n <constructor-arg>\n <bean class=\"org.springframework.security.providers.dao.DaoAuthenticationProvider\">\n <property name=\"userDetailsService\" ref=\"userDetailsService\"/>\n </bean>\n </constructor-arg>\n </bean>\n\n <bean id=\"userDetailsService\" class=\"com.mycompany.app.dao.UserDetailService\" />\n ...\n</beans>\n----\n====\n\n[[using-jaasplaintextpasswordvalidationcallbackhandler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `SpringPlainTextPasswordValidationCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 9, "content_hash": "8a9b965f59147d3730e40675536e50258885c1b8f4c2ea45e1eb6ac772ec63b0", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:3e0734e23bb1ed7664acc14500f5e259d9ac891dadcd56ecbe49c29380aa3281", "content": "The `JaasPlainTextPasswordValidationCallbackHandler` is based on the standard https://www.oracle.com/java/technologies/javase/javase-tech-security.html[Java Authentication and Authorization Service].\nIt is beyond the scope of this document to provide a full introduction into JAAS, but https://docs.oracle.com/javase/8/docs/technotes/guides/security/jaas/tutorials/index.html[tutorials] are available.\n\nThe `JaasPlainTextPasswordValidationCallbackHandler` requires only a `loginContextName` to operate.\nIt creates a new JAAS `LoginContext` by using this name and handles the standard JAAS `NameCallback` and `PasswordCallback` by using the username and password provided in the SOAP message.\nThis means that this callback handler integrates with any JAAS `LoginModule` that fires these callbacks during the `login()` phase, which is standard behavior.\n\nYou can wire up a `JaasPlainTextPasswordValidationCallbackHandler` as follows:\n\n====\n[source,xml]\n----\n<bean id=\"jaasValidationHandler\"\n class=\"org.springframework.ws.soap.security.xwss.callback.jaas.JaasPlainTextPasswordValidationCallbackHandler\">\n <property name=\"loginContextName\" value=\"MyLoginModule\" />\n</bean>\n----\n====\n\nIn this case, the callback handler uses the `LoginContext` named `MyLoginModule`.\nThis module should be defined in your `jaas.config` file, as explained in the http://www.javaworld.com/javaworld/jw-09-2002/jw-0913-jaas.html[tutorial mentioned earlier].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `JaasPlainTextPasswordValidationCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 10, "content_hash": "3e0734e23bb1ed7664acc14500f5e259d9ac891dadcd56ecbe49c29380aa3281", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:cd761ea2b3a29c5c610c6c7b099cbaa42c62a71a3b4f8510eea6f675b538ac8d", "content": "When using password digests, the SOAP message also contains a `UsernameToken` element, which itself contains a `Username` element and a `Password` element.\nThe difference is that the password is not sent as plain text, but as a digest.\nThe recipient compares this digest to the digest he calculated from the known password of the user, and, if they are the same, the user is authenticated.\nThis method is comparable to the digest authentication provided by HTTP servers.\n\nTo require that every incoming message contains a `UsernameToken` element with a password digest, the security policy file should contain a `RequireUsernameToken` element, with the `passwordDigestRequired` attribute set to `true`.\nAdditionally, the `nonceRequired` attribute should be set to `true`.\nFor more details, check the http://java.sun.com/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp567459[official reference] of possible child elements.\nThe following listing shows how to define a `RequireUsernameToken` element:\n\n====\n[source,xml]\n----\n<xwss:SecurityConfiguration xmlns:xwss=\"http://java.sun.com/xml/ns/xwss/config\">\n ...\n <xwss:RequireUsernameToken passwordDigestRequired=\"true\" nonceRequired=\"true\"/>\n ...\n</xwss:SecurityConfiguration>\n----\n====\n\nIf the username token is not present, the `XwsSecurityInterceptor` returns a SOAP fault to the sender.\nIf it is present, it fires a `PasswordValidationCallback` with a `DigestPasswordRequest` to the registered handlers.\nWithin Spring-WS, two classes handle this particular callback: `SimplePasswordValidationCallbackHandler` and `SpringDigestPasswordValidationCallbackHandler`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Digest Username Authentication", "heading_level": 4, "file_order": 5, "section_index": 11, "content_hash": "cd761ea2b3a29c5c610c6c7b099cbaa42c62a71a3b4f8510eea6f675b538ac8d", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:4d67fa7986f5c3bd87feae9eb3d9a5aaf72c5a2ad5ceeb78270dc460361ea087", "content": "The `SimplePasswordValidationCallbackHandler` can handle both plain text passwords as well as password digests.\nIt is described in <<security-simple-password-validation-callback-handler>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `SimplePasswordValidationCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 12, "content_hash": "4d67fa7986f5c3bd87feae9eb3d9a5aaf72c5a2ad5ceeb78270dc460361ea087", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:76d30020ceb2f8a741c79b6f267fef19d5a601d32e663b8fdc4c7bf0d11f6fcb", "content": "The `SpringDigestPasswordValidationCallbackHandler` requires a Spring Security `UserDetailService` to operate.\nIt uses this service to retrieve the password of the user specified in the token.\nThe digest of the password contained in this details object is then compared with the digest in the message.\nIf they are equal, the user has successfully authenticated, and a `UsernamePasswordAuthenticationToken` is stored in the `SecurityContextHolder`.\nYou can set the service by using the `userDetailsService` property.\nAdditionally, you can set a `userCache` property, to cache loaded user details.\nThe following example shows how to do so:\n\n====\n[source,xml]\n----\n<beans>\n <bean class=\"org.springframework.ws.soap.security.xwss.callback.SpringDigestPasswordValidationCallbackHandler\">\n <property name=\"userDetailsService\" ref=\"userDetailsService\"/>\n </bean>\n\n <bean id=\"userDetailsService\" class=\"com.mycompany.app.dao.UserDetailService\" />\n ...\n</beans>\n----\n====\n\n[[security-certificate-authentication]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `SpringDigestPasswordValidationCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 13, "content_hash": "76d30020ceb2f8a741c79b6f267fef19d5a601d32e663b8fdc4c7bf0d11f6fcb", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:c9530eadf6af9a76705e704b820fa0e71767bbdcc3d724b465ad326d102e5201", "content": "A more secure way of authentication uses X509 certificates.\nIn this scenario, the SOAP message contains a `BinarySecurityToken`, which contains a Base 64-encoded version of a X509 certificate.\nThe certificate is used by the recipient to authenticate.\nThe certificate stored in the message is also used to sign the message (see <<security-verifying-signatures>>).\n\nTo make sure that all incoming SOAP messages carry a`BinarySecurityToken`, the security policy file should contain a `RequireSignature` element.\nThis element can further carry other elements, which are covered in <<security-verifying-signatures>>.\nFor more details, check the http://java.sun.com/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp565769[official reference] of possible child elements.\nThe following listing shows how to define a `RequireSignature` element:\n\n====\n[source,xml]\n----\n<xwss:SecurityConfiguration xmlns:xwss=\"http://java.sun.com/xml/ns/xwss/config\">\n ...\n <xwss:RequireSignature requireTimestamp=\"false\">\n ...\n</xwss:SecurityConfiguration>\n----\n====\n\nWhen a message arrives that carries no certificate, the `XwsSecurityInterceptor` returns a SOAP fault to the sender.\nIf it is present, it fires a `CertificateValidationCallback`.\nTwo handlers within Spring-WS handle this callback for authentication purposes:\n\n* <<using-keystorecallbackhandler,`KeyStoreCallbackHandler`>>\n* <<using-springcertificatevalidationcallbackhandler,`SpringCertificateValidationCallbackHandler`>>\n\n[NOTE]\n=====\nIn most cases, certificate authentication should be preceded by certificate validation, since you want to authenticate against only valid certificates.\nInvalid certificates, such as certificates for which the expiration date has passed or which are not in your store of trusted certificates, should be ignored.\n\nIn Spring-WS terms, this means that the `SpringCertificateValidationCallbackHandler` or `JaasCertificateValidationCallbackHandler` should be preceded by `KeyStoreCallbackHandler`.\nThis can be accomplished by setting the order of the `callbackHandlers` property in the configuration of the `XwsSecurityInterceptor`:\n\n====\n[source,xml]\n----\n<bean id=\"wsSecurityInterceptor\"\n class=\"org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor\">\n <property name=\"policyConfiguration\" value=\"classpath:securityPolicy.xml\"/>\n <property name=\"callbackHandlers\">\n <list>\n <ref bean=\"keyStoreHandler\"/>\n <ref bean=\"springSecurityHandler\"/>\n </list>\n </property>\n</bean>\n----\n====\n\nUsing this setup, the interceptor first determines if the certificate in the message is valid by using the keystore and then authenticating against it.\n=====\n\n[[using-keystorecallbackhandler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Certificate Authentication", "heading_level": 4, "file_order": 5, "section_index": 14, "content_hash": "c9530eadf6af9a76705e704b820fa0e71767bbdcc3d724b465ad326d102e5201", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:29df75639b2aec9583dc2c36ed45de85d9026fd2cb200ed68b831f569255ef5c", "content": "The `KeyStoreCallbackHandler` uses a standard Java keystore to validate certificates.\nThis certificate validation process consists of the following steps:\n\n. The handler checks whether the certificate is in the private `keyStore`.\nIf it is, it is valid.\n. If the certificate is not in the private keystore, the handler checks whether the current date and time are within the validity period given in the certificate.\nIf they are not, the certificate is invalid.\nIf it is, it continues with the final step.\n. A certification path for the certificate is created.\nThis basically means that the handler determines whether the certificate has been issued by any of the certificate authorities in the `trustStore`.\nIf a certification path can be built successfully, the certificate is valid.\nOtherwise, the certificate is not valid.\n\nTo use the `KeyStoreCallbackHandler` for certificate validation purposes, you most likely need to set only the `trustStore` property:\n\n====\n[source,xml]\n----\n<beans>\n <bean id=\"keyStoreHandler\" class=\"org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler\">\n <property name=\"trustStore\" ref=\"trustStore\"/>\n </bean>\n\n <bean id=\"trustStore\" class=\"org.springframework.ws.soap.security.support.KeyStoreFactoryBean\">\n <property name=\"location\" value=\"classpath:truststore.jks\"/>\n <property name=\"password\" value=\"changeit\"/>\n </bean>\n</beans>\n----\n====\n\nUsing the setup shown in the preceding example, the certificate that is to be validated must be in the trust store itself or the trust store must contain a certificate authority that issued the certificate.\n\n[[using-springcertificatevalidationcallbackhandler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `KeyStoreCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 15, "content_hash": "29df75639b2aec9583dc2c36ed45de85d9026fd2cb200ed68b831f569255ef5c", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:b3ed6a0230c320657dc1191a521c99c6ab7474f82b6d87fc0b575cb738fa36af", "content": "The `SpringCertificateValidationCallbackHandler` requires an Spring Security `AuthenticationManager` to operate.\nIt uses this manager to authenticate against a `X509AuthenticationToken` that it creates.\nThe configured authentication manager is expected to supply a provider that can handle this token (usually an instance of `X509AuthenticationProvider`).\nIf authentication is successful, the token is stored in the `SecurityContextHolder`.\nYou can set the authentication manager by using the `authenticationManager` property:\n\n====\n[source,xml]\n----\n<beans>\n <bean id=\"springSecurityCertificateHandler\"\n class=\"org.springframework.ws.soap.security.xwss.callback.SpringCertificateValidationCallbackHandler\">\n <property name=\"authenticationManager\" ref=\"authenticationManager\"/>\n </bean>\n\n <bean id=\"authenticationManager\"\n class=\"org.springframework.security.providers.ProviderManager\">\n <property name=\"providers\">\n <bean class=\"org.springframework.ws.soap.security.x509.X509AuthenticationProvider\">\n <property name=\"x509AuthoritiesPopulator\">\n <bean class=\"org.springframework.ws.soap.security.x509.populator.DaoX509AuthoritiesPopulator\">\n <property name=\"userDetailsService\" ref=\"userDetailsService\"/>\n </bean>\n </property>\n </bean>\n </property>\n </bean>\n\n <bean id=\"userDetailsService\" class=\"com.mycompany.app.dao.UserDetailService\" />\n ...\n</beans>\n----\n====\n\nIn this case, we use a custom user details service to obtain authentication details based on the certificate.\nSee the http://www.springframework.org/security[Spring Security reference documentation] for more information about authentication against X509 certificates.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `SpringCertificateValidationCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 16, "content_hash": "b3ed6a0230c320657dc1191a521c99c6ab7474f82b6d87fc0b575cb738fa36af", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:5da8afcf604e53a03ccd0d3bd8ae65b0efdcee35182e912d925e11ddc36c2141", "content": "The digital signature of a message is a piece of information based on both the document and the signer's private key.\nTwo main tasks are related to signatures in WS-Security: verifying signatures and signing messages.\n\n[[security-verifying-signatures]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Digital Signatures", "heading_level": 3, "file_order": 5, "section_index": 17, "content_hash": "5da8afcf604e53a03ccd0d3bd8ae65b0efdcee35182e912d925e11ddc36c2141", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:f51d216026c4abf1de02ace0363c696c79c8d27a6289f99538c9a3857a4bf4ca", "content": "As with <<security-certificate-authentication,certificate-based authentication>>, a signed message contains a `BinarySecurityToken`, which contains the certificate used to sign the message.\nAdditionally, it contains a `SignedInfo` block, which indicates what part of the message was signed.\n\nTo make sure that all incoming SOAP messages carry a `BinarySecurityToken`, the security policy file should contain a `RequireSignature` element.\nIt can also contain a `SignatureTarget` element, which specifies the target message part that was expected to be signed and various other sub-elements.\nYou can also define the private key alias to use, whether to use a symmetric instead of a private key, and many other properties.\nFor more details, check the https://docs.oracle.com/cd/E17802_01/webservices/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp565769[official reference] of possible child elements.\nThe following listing configures a `RequireSignature` element:\n\n====\n[source,xml]\n----\n<xwss:SecurityConfiguration xmlns:xwss=\"http://java.sun.com/xml/ns/xwss/config\">\n <xwss:RequireSignature requireTimestamp=\"false\"/>\n</xwss:SecurityConfiguration>\n----\n====\n\nIf the signature is not present, the `XwsSecurityInterceptor` returns a SOAP fault to the sender.\nIf it is present, it fires a `SignatureVerificationKeyCallback` to the registered handlers.\nWithin Spring-WS, one class handles this particular callback: `KeyStoreCallbackHandler`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Verifying Signatures", "heading_level": 4, "file_order": 5, "section_index": 18, "content_hash": "f51d216026c4abf1de02ace0363c696c79c8d27a6289f99538c9a3857a4bf4ca", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:8f17ef294b1ea24e61ef080d48aedb82544a08a410c7a61b152771ecaa09c422", "content": "As described in <<security-key-store-callback-handler>>, `KeyStoreCallbackHandler` uses a `java.security.KeyStore` for handling various cryptographic callbacks, including signature verification.\nFor signature verification, the handler uses the `trustStore` property:\n\n====\n[source,xml]\n----\n<beans>\n <bean id=\"keyStoreHandler\" class=\"org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler\">\n <property name=\"trustStore\" ref=\"trustStore\"/>\n </bean>\n\n <bean id=\"trustStore\" class=\"org.springframework.ws.soap.security.support.KeyStoreFactoryBean\">\n <property name=\"location\" value=\"classpath:org/springframework/ws/soap/security/xwss/test-truststore.jks\"/>\n <property name=\"password\" value=\"changeit\"/>\n </bean>\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `KeyStoreCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 19, "content_hash": "8f17ef294b1ea24e61ef080d48aedb82544a08a410c7a61b152771ecaa09c422", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:2498cbb75da8074024419522e301ffc6bf87a0a966aae1898dd70e1dcd372039", "content": "When signing a message, the `XwsSecurityInterceptor` adds the `BinarySecurityToken` to the message.\nIt also adds a `SignedInfo` block, which indicates what part of the message was signed.\n\nTo sign all outgoing SOAP messages, the security policy file should contain a `Sign` element.\nIt can also contain a `SignatureTarget` element, which specifies the target message part that was expected to be signed and various other sub-elements.\nYou can also define the private key alias to use, whether to use a symmetric instead of a private key, and many other properties.\nFor more details, check the https://docs.oracle.com/cd/E17802_01/webservices/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp565497[official reference] of possible child elements.\nThe following example includes a `Sign` element:\n\n====\n[source,xml]\n----\n<xwss:SecurityConfiguration xmlns:xwss=\"http://java.sun.com/xml/ns/xwss/config\">\n\t<xwss:Sign includeTimestamp=\"false\" />\n</xwss:SecurityConfiguration>\n----\n====\n\nThe `XwsSecurityInterceptor` fires a `SignatureKeyCallback` to the registered handlers.\nWithin Spring-WS, the `KeyStoreCallbackHandler` class handles this particular callback.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Signing Messages", "heading_level": 4, "file_order": 5, "section_index": 20, "content_hash": "2498cbb75da8074024419522e301ffc6bf87a0a966aae1898dd70e1dcd372039", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:a3eda99df3c7e67af3d2db292b9cf1d4bbfa741931dd2a9850e77ff73f7270fe", "content": "As described in <<security-key-store-callback-handler>>, the `KeyStoreCallbackHandler` uses a `java.security.KeyStore` to handle various cryptographic callbacks, including signing messages.\nFor adding signatures, the handler uses the `keyStore` property.\nAdditionally, you must set the `privateKeyPassword` property to unlock the private key used for signing.\nThe following example uses a `KeyStoreCallbackHandler`:\n\n====\n[source,xml]\n----\n<beans>\n <bean id=\"keyStoreHandler\" class=\"org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler\">\n <property name=\"keyStore\" ref=\"keyStore\"/>\n <property name=\"privateKeyPassword\" value=\"changeit\"/>\n </bean>\n\n <bean id=\"keyStore\" class=\"org.springframework.ws.soap.security.support.KeyStoreFactoryBean\">\n <property name=\"location\" value=\"classpath:keystore.jks\"/>\n <property name=\"password\" value=\"changeit\"/>\n </bean>\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `KeyStoreCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 21, "content_hash": "a3eda99df3c7e67af3d2db292b9cf1d4bbfa741931dd2a9850e77ff73f7270fe", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:781e7de6ceeabf41400d9b5b50b15d16fd0347eef6b647b631b68f4580674a6f", "content": "When encrypting, the message is transformed into a form that can be read only with the appropriate key.\nThe message can be decrypted to reveal the original, readable message.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Decryption and Encryption", "heading_level": 3, "file_order": 5, "section_index": 22, "content_hash": "781e7de6ceeabf41400d9b5b50b15d16fd0347eef6b647b631b68f4580674a6f", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:85f2645370acafdb86ace720c82eed652ed9c8257852508935c2a6767fb43c55", "content": "To decrypt incoming SOAP messages, the security policy file should contain a `RequireEncryption` element.\nThis element can further carry a `EncryptionTarget` element that indicates which part of the message should be encrypted and a `SymmetricKey` to indicate that a shared secret instead of the regular private key should be used to decrypt the message.\nFor more details, check the https://docs.oracle.com/cd/E17802_01/webservices/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp565951[official reference ] of the other elements.\nThe following example uses a `RequireEncryption` element:\n\n====\n[source,xml]\n----\n<xwss:SecurityConfiguration xmlns:xwss=\"http://java.sun.com/xml/ns/xwss/config\">\n <xwss:RequireEncryption />\n</xwss:SecurityConfiguration>\n----\n====\n\nIf an incoming message is not encrypted, the `XwsSecurityInterceptor` returns a SOAP fault to the sender.\nIf it is present, it fires a `DecryptionKeyCallback` to the registered handlers.\nWithin Spring-WS, the `KeyStoreCallbackHandler` class handles this particular callback.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Decryption", "heading_level": 4, "file_order": 5, "section_index": 23, "content_hash": "85f2645370acafdb86ace720c82eed652ed9c8257852508935c2a6767fb43c55", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:8f02b5ff593cf4d99c33e8c5e4c3d68c460e3afc5cd62354921e71795737c037", "content": "As described in <<security-key-store-callback-handler>>, the `KeyStoreCallbackHandler` uses a `java.security.KeyStore` to handle various cryptographic callbacks, including decryption.\nFor decryption, the handler uses the `keyStore` property.\nAdditionally, you must set the `privateKeyPassword` property to unlock the private key used for decryption.\nFor decryption based on symmetric keys, it uses the `symmetricStore`.\nThe following example uses `KeyStoreCallbackHandler`:\n\n====\n[source,xml]\n----\n<beans>\n <bean id=\"keyStoreHandler\" class=\"org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler\">\n <property name=\"keyStore\" ref=\"keyStore\"/>\n <property name=\"privateKeyPassword\" value=\"changeit\"/>\n </bean>\n\n <bean id=\"keyStore\" class=\"org.springframework.ws.soap.security.support.KeyStoreFactoryBean\">\n <property name=\"location\" value=\"classpath:keystore.jks\"/>\n <property name=\"password\" value=\"changeit\"/>\n </bean>\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `KeyStoreCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 24, "content_hash": "8f02b5ff593cf4d99c33e8c5e4c3d68c460e3afc5cd62354921e71795737c037", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:3d71b3015cda384581728a609677f7b1b8a58a213b048610179beca3160b06d6", "content": "To encrypt outgoing SOAP messages, the security policy file should contain an `Encrypt` element.\nThis element can further carry a `EncryptionTarget` element that indicates which part of the message should be encrypted and a `SymmetricKey` to indicate that a shared secret instead of the regular public key should be used to encrypt the message.\nFor more details, check the https://docs.oracle.com/cd/E17802_01/webservices/webservices/docs/1.6/tutorial/doc/XWS-SecurityIntro4.html#wp565951[official reference] of the other elements.\nThe following example uses an `Encrypt` element:\n\n====\n[source,xml]\n----\n<xwss:SecurityConfiguration xmlns:xwss=\"http://java.sun.com/xml/ns/xwss/config\">\n <xwss:Encrypt />\n</xwss:SecurityConfiguration>\n----\n====\n\nThe `XwsSecurityInterceptor` fires an `EncryptionKeyCallback` to the registered handlers to retrieve the encryption information.\nWithin Spring-WS, the `KeyStoreCallbackHandler` class handles this particular callback.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Encryption", "heading_level": 4, "file_order": 5, "section_index": 25, "content_hash": "3d71b3015cda384581728a609677f7b1b8a58a213b048610179beca3160b06d6", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:1a94165913656b1cb317c7596c07930c248a5e1bc83e75ed72103c7775710f77", "content": "As described in <<security-key-store-callback-handler>>, the `KeyStoreCallbackHandler` uses a `java.security.KeyStore` to handle various cryptographic callbacks, including encryption.\nFor encryption based on public keys, the handler uses the `trustStore` property.\nFor encryption based on symmetric keys, it uses `symmetricStore`.\nThe following example uses `KeyStoreCallbackHandler`:\n\n====\n[source,xml]\n----\n<beans>\n <bean id=\"keyStoreHandler\" class=\"org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler\">\n <property name=\"trustStore\" ref=\"trustStore\"/>\n </bean>\n\n <bean id=\"trustStore\" class=\"org.springframework.ws.soap.security.support.KeyStoreFactoryBean\">\n <property name=\"location\" value=\"classpath:truststore.jks\"/>\n <property name=\"password\" value=\"changeit\"/>\n </bean>\n</beans>\n----\n====\n\n[[security-xws-exception-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `KeyStoreCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 26, "content_hash": "1a94165913656b1cb317c7596c07930c248a5e1bc83e75ed72103c7775710f77", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:a56affda822211183da9a97bea7365fd9f43c6e176189162ed99bb63273d44f1", "content": "When a securement or validation action fails, the `XwsSecurityInterceptor` throws a `WsSecuritySecurementException` or `WsSecurityValidationException` respectively.\nThese exceptions bypass the <<server-endpoint-exception-resolver,standard exception handling mechanism>> but are handled by the interceptor itself.\n\n`WsSecuritySecurementException` exceptions are handled by the `handleSecurementException` method of the `XwsSecurityInterceptor`.\nBy default, this method logs an error and stops further processing of the message.\n\nSimilarly, `WsSecurityValidationException` exceptions are handled by the `handleValidationException` method of the `XwsSecurityInterceptor`.\nBy default, this method creates a SOAP 1.1 Client or SOAP 1.2 sender fault and sends that back as a response.\n\nNOTE: Both `handleSecurementException` and `handleValidationException` are protected methods, which you can override to change their default behavior.\n\n[[security-wss4j-security-interceptor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Security Exception Handling", "heading_level": 3, "file_order": 5, "section_index": 27, "content_hash": "a56affda822211183da9a97bea7365fd9f43c6e176189162ed99bb63273d44f1", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:afc31fda60a25fd7a5bfe114fe820aec8d7e5b01f378314c09f6314682717978", "content": "The `Wss4jSecurityInterceptor` is an `EndpointInterceptor` (see <<server-endpoint-interceptor>>) that is based on https://ws.apache.org/wss4j/[Apache's WSS4J].\n\nWSS4J implements the following standards:\n\n* OASIS Web Services Security: SOAP Message Security 1.0 Standard 200401, March 2004.\n* Username Token profile V1.0.\n* X.509 Token Profile V1.0.\n\nThis interceptor supports messages created by the `AxiomSoapMessageFactory` and the `SaajSoapMessageFactory`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `Wss4jSecurityInterceptor`", "heading_level": 2, "file_order": 5, "section_index": 28, "content_hash": "afc31fda60a25fd7a5bfe114fe820aec8d7e5b01f378314c09f6314682717978", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:e67a195d321803b0f973414ba10306eb3152b6ac2012ee8e04fbe8cb5b198721", "content": "WSS4J uses no external configuration file.\nThe interceptor is entirely configured by properties.\nThe validation and securement actions invoked by this interceptor are specified via `validationActions` and `securementActions` properties, respectively.\nActions are passed as a space-separated strings.\nThe following listing shows an example configuration:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor\">\n <property name=\"validationActions\" value=\"UsernameToken Encrypt\"/>\n ...\n <property name=\"securementActions\" value=\"Encrypt\"/>\n ...\n</bean>\n----\n====\n\nThe following table shows the available validation actions:\n\n[cols=\"2\", options=\"header\"]\n|===\n| Validation action\n| Description\n\n| `UsernameToken`\n| Validates username token\n\n| `Timestamp`\n| Validates the timestamp\n\n| `Encrypt`\n| Decrypts the message\n\n| `Signature`\n| Validates the signature\n\n| `NoSecurity`\n| No action performed\n|===\n\nThe following table shows the available securement actions:\n\n[cols=\"2\", options=\"header\"]\n|===\n| Securement action\n| Description\n\n| `UsernameToken`\n| Adds a username token\n\n| `UsernameTokenSignature`\n| Adds a username token and a signature username token secret key\n\n| `Timestamp`\n| Adds a timestamp\n\n| `Encrypt`\n| Encrypts the response\n\n| `Signature`\n| Signs the response\n\n| `NoSecurity`\n| No action performed\n|===\n\nThe order of the actions is significant and is enforced by the interceptor.\nIf its security actions were performed in a different order than the one specified by `validationActions`, the interceptor rejects an incoming SOAP message.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Configuring `Wss4jSecurityInterceptor`", "heading_level": 3, "file_order": 5, "section_index": 29, "content_hash": "e67a195d321803b0f973414ba10306eb3152b6ac2012ee8e04fbe8cb5b198721", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:86afc52eed1140ad9d6595474c11941797e576534d84ed19b221576aec3f47d0", "content": "For cryptographic operations that require interaction with a keystore or certificate handling (signature, encryption, and decryption operations), WSS4J requires an instance of `org.apache.ws.security.components.crypto.Crypto`.\n\n`Crypto` instances can be obtained from WSS4J's `CryptoFactory` or more conveniently with the Spring-WS `CryptoFactoryBean`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Handling Digital Certificates", "heading_level": 3, "file_order": 5, "section_index": 30, "content_hash": "86afc52eed1140ad9d6595474c11941797e576534d84ed19b221576aec3f47d0", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:58fcae5d4679fe2b17b4004d090d8ac6e4bc9e56cd16d5add2e9ff62bf026803", "content": "Spring-WS provides a convenient factory bean, `CryptoFactoryBean`, that constructs and configures `Crypto` instances through strongly typed properties (preferred) or through a `Properties` object.\n\nBy default, `CryptoFactoryBean` returns instances of `org.apache.ws.security.components.crypto.Merlin`.\nYou can change this by setting the `cryptoProvider` property (or its equivalent `org.apache.ws.security.crypto.provider` string property).\n\nThe following example configuration uses `CryptoFactoryBean`:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean\">\n <property name=\"keyStorePassword\" value=\"mypassword\"/>\n <property name=\"keyStoreLocation\" value=\"file:/path_to_keystore/keystore.jks\"/>\n</bean>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "CryptoFactoryBean", "heading_level": 4, "file_order": 5, "section_index": 31, "content_hash": "58fcae5d4679fe2b17b4004d090d8ac6e4bc9e56cd16d5add2e9ff62bf026803", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:1e1eeae7bca52623e839c284dd285728c983edf6b7e0e63df2572dd619931651", "content": "This section addresses how to do authentication with `Wss4jSecurityInterceptor`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Authentication", "heading_level": 3, "file_order": 5, "section_index": 32, "content_hash": "1e1eeae7bca52623e839c284dd285728c983edf6b7e0e63df2572dd619931651", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:43438d6051985c17fb025d9278ccfb09164831c99003ab741e8e0b99802ddccc", "content": "Spring-WS provides a set of callback handlers to integrate with Spring Security.\nAdditionally, a simple callback handler, `SimplePasswordValidationCallbackHandler`, is provided to configure users and passwords with an in-memory `Properties` object.\n\nCallback handlers are configured through the `validationCallbackHandler` of the `Wss4jSecurityInterceptor` property.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Validating Username Token", "heading_level": 4, "file_order": 5, "section_index": 33, "content_hash": "43438d6051985c17fb025d9278ccfb09164831c99003ab741e8e0b99802ddccc", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:31aba0a90906460b54e34e7291d4f35806b9ab29ea611eb3dac01be15008ce15", "content": "`SimplePasswordValidationCallbackHandler` validates plain text and digest username tokens against an in-memory `Properties` object.\nYou can configure it as follows:\n\n====\n[source,xml]\n----\n<bean id=\"callbackHandler\"\n class=\"org.springframework.ws.soap.security.wss4j.callback.SimplePasswordValidationCallbackHandler\">\n <property name=\"users\">\n <props>\n <prop key=\"Bert\">Ernie</prop>\n </props>\n </property>\n</bean>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `SimplePasswordValidationCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 34, "content_hash": "31aba0a90906460b54e34e7291d4f35806b9ab29ea611eb3dac01be15008ce15", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:897e6438506f58e6b4d27b32842e1729512b281ee47ff12c4da2142b0ea2b750", "content": "The `SpringSecurityPasswordValidationCallbackHandler` validates plain text and digest passwords by using a Spring Security `UserDetailService` to operate.\nIt uses this service to retrieve the password (or a digest of the password) of the user specified in the token.\nThe password (or a digest of the password) contained in this details object is then compared with the digest in the message.\nIf they are equal, the user has successfully authenticated, and a `UsernamePasswordAuthenticationToken` is stored in the `SecurityContextHolder`.\nYou can set the service by using the `userDetailsService`.\nAdditionally, you can set a `userCache` property, to cache loaded user details, as follows:\n\n====\n[source,xml]\n----\n<beans>\n <bean class=\"org.springframework.ws.soap.security.wss4j.callback.SpringDigestPasswordValidationCallbackHandler\">\n <property name=\"userDetailsService\" ref=\"userDetailsService\"/>\n </bean>\n\n <bean id=\"userDetailsService\" class=\"com.mycompany.app.dao.UserDetailService\" />\n ...\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Using `SpringSecurityPasswordValidationCallbackHandler`", "heading_level": 5, "file_order": 5, "section_index": 35, "content_hash": "897e6438506f58e6b4d27b32842e1729512b281ee47ff12c4da2142b0ea2b750", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:fe3d8c581b2e9459dca1bf0ac44203fcff7ef9f6b28f4a4e7c9f942758ff76ee", "content": "Adding a username token to an outgoing message is as simple as adding `UsernameToken` to the `securementActions` property of the `Wss4jSecurityInterceptor` and specifying `securementUsername` and `securementPassword`.\n\nThe password type can be set by setting the `securementPasswordType` property.\nPossible values are `PasswordText` for plain text passwords or `PasswordDigest` for digest passwords, which is the default.\n\nThe following example generates a username token with a digest password:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor\">\n <property name=\"securementActions\" value=\"UsernameToken\"/>\n <property name=\"securementUsername\" value=\"Ernie\"/>\n <property name=\"securementPassword\" value=\"Bert\"/>\n</bean>\n----\n====\n\nIf the plain text password type is chosen, it is possible to instruct the interceptor to add `Nonce` and `Created` elements by setting the `securementUsernameTokenElements` property.\nThe value must be a list that contains the desired elements' names separated by spaces (case-sensitive).\n\nThe following example generates a username token with a plain text password, a `Nonce`, and a `Created` element:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor\">\n <property name=\"securementActions\" value=\"UsernameToken\"/>\n <property name=\"securementUsername\" value=\"Ernie\"/>\n <property name=\"securementPassword\" value=\"Bert\"/>\n <property name=\"securementPasswordType\" value=\"PasswordText\"/>\n <property name=\"securementUsernameTokenElements\" value=\"Nonce Created\"/>\n</bean>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Adding Username Token", "heading_level": 4, "file_order": 5, "section_index": 36, "content_hash": "fe3d8c581b2e9459dca1bf0ac44203fcff7ef9f6b28f4a4e7c9f942758ff76ee", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:293554e05d9cae10ae2dca3d701eb67962656ef13278b93c1fbccb1f3356b09b", "content": "As certificate authentication is akin to digital signatures, WSS4J handles it as part of the signature validation and securement.\nSpecifically, the `securementSignatureKeyIdentifier` property must be set to `DirectReference` in order to instruct WSS4J to generate a `BinarySecurityToken` element containing the X509 certificate and to include it in the outgoing message.\nThe certificate's name and password are passed through the `securementUsername` and `securementPassword` properties, respectively, as the following example shows:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor\">\n <property name=\"securementActions\" value=\"Signature\"/>\n <property name=\"securementSignatureKeyIdentifier\" value=\"DirectReference\"/>\n <property name=\"securementUsername\" value=\"mycert\"/>\n <property name=\"securementPassword\" value=\"certpass\"/>\n <property name=\"securementSignatureCrypto\">\n <bean class=\"org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean\">\n <property name=\"keyStorePassword\" value=\"123456\"/>\n <property name=\"keyStoreLocation\" value=\"classpath:/keystore.jks\"/>\n </bean>\n </property>\n</bean>\n----\n====\n\nFor the certificate validation, regular signature validation applies:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor\">\n <property name=\"validationActions\" value=\"Signature\"/>\n <property name=\"validationSignatureCrypto\">\n <bean class=\"org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean\">\n <property name=\"keyStorePassword\" value=\"123456\"/>\n <property name=\"keyStoreLocation\" value=\"classpath:/keystore.jks\"/>\n </bean>\n </property>\n</bean>\n----\n====\n\nAt the end of the validation, the interceptor automatically verifies the validity of the certificate by delegating to the default WSS4J implementation.\nIf needed, you can change this behavior by redefining the `verifyCertificateTrust` method.\n\nFor more detail, see to <<security-wss4j-digital-signatures>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Certificate Authentication", "heading_level": 4, "file_order": 5, "section_index": 37, "content_hash": "293554e05d9cae10ae2dca3d701eb67962656ef13278b93c1fbccb1f3356b09b", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:dd6d9e4331b851ccb86c185a9785d175bdd41999bba1b1e5ba6e5a0ed49ca8b8", "content": "This section describes the various timestamp options available in the `Wss4jSecurityInterceptor`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Security Timestamps", "heading_level": 3, "file_order": 5, "section_index": 38, "content_hash": "dd6d9e4331b851ccb86c185a9785d175bdd41999bba1b1e5ba6e5a0ed49ca8b8", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:304abd88b6fd132b23e28347323b3043821605d2e5c7305d248e88fffe7f663b", "content": "To validate timestamps, add `Timestamp` to the `validationActions` property.\nYou can override timestamp semantics specified by the initiator of the SOAP message by setting `timestampStrict` to `true` and specifying a server-side time-to-live in seconds (default: 300) by setting the `timeToLive` property.\nThe interceptor always rejects already expired timestamps, whatever the value of `timeToLive` is.\n\nIn the following example, the interceptor limits the timestamp validity window to 10 seconds, rejecting any valid timestamp token outside that window:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor\">\n <property name=\"validationActions\" value=\"Timestamp\"/>\n <property name=\"timestampStrict\" value=\"true\"/>\n <property name=\"timeToLive\" value=\"10\"/>\n</bean>\n\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Validating Timestamps", "heading_level": 4, "file_order": 5, "section_index": 39, "content_hash": "304abd88b6fd132b23e28347323b3043821605d2e5c7305d248e88fffe7f663b", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:b312fb10473ab469d2c17a0e373884055d3c580c78486ed8614e32e1c5894a5c", "content": "Adding `Timestamp` to the `securementActions` property generates a timestamp header in outgoing messages.\nThe `timestampPrecisionInMilliseconds` property specifies whether the precision of the generated timestamp is in milliseconds.\nThe default value is `true`.\nThe following listing adds a timestamp:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor\">\n <property name=\"securementActions\" value=\"Timestamp\"/>\n <property name=\"timestampPrecisionInMilliseconds\" value=\"true\"/>\n</bean>\n----\n====\n\n[[security-wss4j-digital-signatures]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Adding Timestamps", "heading_level": 4, "file_order": 5, "section_index": 40, "content_hash": "b312fb10473ab469d2c17a0e373884055d3c580c78486ed8614e32e1c5894a5c", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:0f06343ebb1eaf61f60ee09a8cc30690418fc27cb040e3428372e0cafac29e69", "content": "This section describes the various signature options available in the `Wss4jSecurityInterceptor`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Digital Signatures", "heading_level": 3, "file_order": 5, "section_index": 41, "content_hash": "0f06343ebb1eaf61f60ee09a8cc30690418fc27cb040e3428372e0cafac29e69", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:f6c3016c6d56c79ed2070d71bca5438186fd30804d9b17ca676cb59a1e5ebd36", "content": "To instruct the `Wss4jSecurityInterceptor`, `validationActions` must contain the `Signature` action.\nAdditionally, the `validationSignatureCrypto` property must point to the keystore containing the public certificates of the initiator:\n\n====\n[source,xml]\n----\n<bean id=\"wsSecurityInterceptor\" class=\"org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor\">\n <property name=\"validationActions\" value=\"Signature\"/>\n <property name=\"validationSignatureCrypto\">\n <bean class=\"org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean\">\n <property name=\"keyStorePassword\" value=\"123456\"/>\n <property name=\"keyStoreLocation\" value=\"classpath:/keystore.jks\"/>\n </bean>\n </property>\n</bean>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Verifying Signatures", "heading_level": 4, "file_order": 5, "section_index": 42, "content_hash": "f6c3016c6d56c79ed2070d71bca5438186fd30804d9b17ca676cb59a1e5ebd36", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:bd209054f209a733dafc84a2b4e1948830170782f5f76f7f4af7e3998c14adf4", "content": "Signing outgoing messages is enabled by adding the `Signature` action to the `securementActions`.\nThe alias and the password of the private key to use are specified by the `securementUsername` and `securementPassword` properties, respectively. `securementSignatureCrypto` must point to the keystore that contains the private key:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor\">\n <property name=\"securementActions\" value=\"Signature\"/>\n <property name=\"securementUsername\" value=\"mykey\"/>\n <property name=\"securementPassword\" value=\"123456\"/>\n <property name=\"securementSignatureCrypto\">\n <bean class=\"org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean\">\n <property name=\"keyStorePassword\" value=\"123456\"/>\n <property name=\"keyStoreLocation\" value=\"classpath:/keystore.jks\"/>\n </bean>\n </property>\n</bean>\n----\n====\n\nFurthermore, you can define the signature algorithm by setting the `securementSignatureAlgorithm` property.\n\nYou can customize the key identifier type to use by setting the `securementSignatureKeyIdentifier` property.\nOnly `IssuerSerial` and `DirectReference` are valid for the signature.\n\nThe `securementSignatureParts` property controls which part of the message is signed.\nThe value of this property is a list of semicolon-separated element names that identify the elements to sign.\nThe general form of a signature part is `{}{namespace}Element`.\nNote that the first empty brackets are used for encryption parts only.\nThe default behavior is to sign the SOAP body.\n\nThe following example shows how to sign the `echoResponse` element in the Spring-WS echo sample:\n\n====\n[source,xml]\n----\n<property name=\"securementSignatureParts\"\n value=\"{}{http://www.springframework.org/spring-ws/samples/echo}echoResponse\"/>\n----\n====\n\nTo specify an element without a namespace, use the string, `Null` (case sensitive), as the namespace name.\n\nIf no other element in the request has a local name of `Body`, the SOAP namespace identifier can be empty (`{}`).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Signing Messages", "heading_level": 4, "file_order": 5, "section_index": 43, "content_hash": "bd209054f209a733dafc84a2b4e1948830170782f5f76f7f4af7e3998c14adf4", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:751d83879aa793b2187521bdb93cc2f67456a6b275a499f968da8f3060740613", "content": "Signature confirmation is enabled by setting `enableSignatureConfirmation` to `true`.\nNote that the signature confirmation action spans over the request and the response.\nThis implies that `secureResponse` and `validateRequest` must be set to `true` (which is the default value) even if there are no corresponding security actions.\nThe following example sets the `enableSignatureConfirmation` property to `true`:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor\">\n <property name=\"validationActions\" value=\"Signature\"/>\n <property name=\"enableSignatureConfirmation\" value=\"true\"/>\n <property name=\"validationSignatureCrypto\">\n <bean class=\"org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean\">\n <property name=\"keyStorePassword\" value=\"123456\"/>\n <property name=\"keyStoreLocation\" value=\"file:/keystore.jks\"/>\n </bean>\n </property>\n</bean>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Signature Confirmation", "heading_level": 4, "file_order": 5, "section_index": 44, "content_hash": "751d83879aa793b2187521bdb93cc2f67456a6b275a499f968da8f3060740613", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:8369d382df6efbd7397bcd1cdc7179e51c9afd26d39c8815d6d9e6cdac9f7815", "content": "This section describes the various decryption and encryption options available in the `Wss4jSecurityInterceptor`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Decryption and Encryption", "heading_level": 3, "file_order": 5, "section_index": 45, "content_hash": "8369d382df6efbd7397bcd1cdc7179e51c9afd26d39c8815d6d9e6cdac9f7815", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:8f0fcba069069ae8cf9394e32873e7ac31ce5fdbc36700aae551befb400f7761", "content": "Decryption of incoming SOAP messages requires that the `Encrypt` action be added to the `validationActions` property.\nThe rest of the configuration depends on the key information that appears in the message.\n(This is because WSS4J needs only a Crypto for encrypted keys, whereas embedded key name validation is delegated to a callback handler).\n\nTo decrypt messages with an embedded encrypted symmetric key (the `xenc:EncryptedKey` element), `validationDecryptionCrypto` needs to point to a keystore that contains the decryption private key.\nAdditionally, `validationCallbackHandler` has to be injected with a {spring-ws-api}/soap/security/wss4j2/callback/KeyStoreCallbackHandler.html[`KeyStoreCallbackHandler`] that specifies the key's password:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j2.Wss4jSecurityInterceptor\">\n <property name=\"validationActions\" value=\"Encrypt\"/>\n <property name=\"validationDecryptionCrypto\">\n <bean class=\"org.springframework.ws.soap.security.wss4j2.support.CryptoFactoryBean\">\n <property name=\"keyStorePassword\" value=\"123456\"/>\n <property name=\"keyStoreLocation\" value=\"classpath:/keystore.jks\"/>\n </bean>\n </property>\n <property name=\"validationCallbackHandler\">\n <bean class=\"org.springframework.ws.soap.security.wss4j2.callback.KeyStoreCallbackHandler\">\n <property name=\"privateKeyPassword\" value=\"mykeypass\"/>\n </bean>\n </property>\n</bean>\n----\n====\n\nTo support decryption of messages with an embedded key name ( `ds:KeyName` element), you can configure a `KeyStoreCallbackHandler` that points to the keystore with the symmetric secret key.\nThe `symmetricKeyPassword` property indicates the key's password, the key name being the one specified by `ds:KeyName` element:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j2.Wss4jSecurityInterceptor\">\n <property name=\"validationActions\" value=\"Encrypt\"/>\n <property name=\"validationCallbackHandler\">\n <bean class=\"org.springframework.ws.soap.security.wss4j2.callback.KeyStoreCallbackHandler\">\n <property name=\"keyStore\">\n <bean class=\"org.springframework.ws.soap.security.support.KeyStoreFactoryBean\">\n <property name=\"location\" value=\"classpath:keystore.jks\"/>\n <property name=\"type\" value=\"JCEKS\"/>\n <property name=\"password\" value=\"123456\"/>\n </bean>\n </property>\n <property name=\"symmetricKeyPassword\" value=\"mykeypass\"/>\n </bean>\n </property>\n</bean>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Decryption", "heading_level": 4, "file_order": 5, "section_index": 46, "content_hash": "8f0fcba069069ae8cf9394e32873e7ac31ce5fdbc36700aae551befb400f7761", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:026fbbea01762f247f8c12c80a28d41a7786917f433c7c7b6531fdce1bb58f92", "content": "Adding `Encrypt` to the `securementActions` enables encryption of outgoing messages.\nYou can set the certificate's alias to use for the encryption by setting the `securementEncryptionUser` property.\nThe keystore where the certificate resides is accessed through the `securementEncryptionCrypto` property.\nAs encryption relies on public certificates, no password needs to be passed.\nThe following example uses the `securementEncryptionCrypto` property:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j2.Wss4jSecurityInterceptor\">\n <property name=\"securementActions\" value=\"Encrypt\"/>\n <property name=\"securementEncryptionUser\" value=\"mycert\"/>\n <property name=\"securementEncryptionCrypto\">\n <bean class=\"org.springframework.ws.soap.security.wss4j2.support.CryptoFactoryBean\">\n <property name=\"keyStorePassword\" value=\"123456\"/>\n <property name=\"keyStoreLocation\" value=\"file:/keystore.jks\"/>\n </bean>\n </property>\n</bean>\n----\n====\n\nYou can customize encryption in several ways: The key identifier type to use is defined by the `securementEncryptionKeyIdentifier` property.\nPossible values are `IssuerSerial`,`X509KeyIdentifier`, `DirectReference`,`Thumbprint`, `SKIKeyIdentifier`, and `EmbeddedKeyName`.\n\nIf you choose the `EmbeddedKeyName` type, you need to specify the secret key to use for the encryption.\nThe alias of the key is set in the `securementEncryptionUser` property, as for the other key identifier types.\nHowever, WSS4J requires a callback handler to fetch the secret key.\nThus, you must provide `securementCallbackHandler` with a `KeyStoreCallbackHandler` that points to the appropriate keystore.\nBy default, the `ds:KeyName` element in the resulting WS-Security header takes the value of the `securementEncryptionUser` property.\nTo indicate a different name, you can set the `securementEncryptionEmbeddedKeyName` with the desired value.\nIn the next example, the outgoing message is encrypted with a key aliased `secretKey`, whereas `myKey` appears in `ds:KeyName` element:\n\n====\n[source,xml]\n----\n<bean class=\"org.springframework.ws.soap.security.wss4j2.Wss4jSecurityInterceptor\">\n <property name=\"securementActions\" value=\"Encrypt\"/>\n <property name=\"securementEncryptionKeyIdentifier\" value=\"EmbeddedKeyName\"/>\n <property name=\"securementEncryptionUser\" value=\"secretKey\"/>\n <property name=\"securementEncryptionEmbeddedKeyName\" value=\"myKey\"/>\n <property name=\"securementCallbackHandler\">\n <bean class=\"org.springframework.ws.soap.security.wss4j2.callback.KeyStoreCallbackHandler\">\n <property name=\"symmetricKeyPassword\" value=\"keypass\"/>\n <property name=\"keyStore\">\n <bean class=\"org.springframework.ws.soap.security.support.KeyStoreFactoryBean\">\n <property name=\"location\" value=\"file:/keystore.jks\"/>\n <property name=\"type\" value=\"jceks\"/>\n <property name=\"password\" value=\"123456\"/>\n </bean>\n </property>\n </bean>\n </property>\n</bean>\n----\n====\n\nThe `securementEncryptionKeyTransportAlgorithm` property defines which algorithm to use to encrypt the generated symmetric key.\nSupported values are `http://www.w3.org/2001/04/xmlenc#rsa-1_5`, which is the default, and `http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p`.\n\nYou can set the symmetric encryption algorithm to use by setting the `securementEncryptionSymAlgorithm` property.\nSupported values are `http://www.w3.org/2001/04/xmlenc#aes128-cbc` (default), `http://www.w3.org/2001/04/xmlenc#tripledes-cbc`, `http://www.w3.org/2001/04/xmlenc#aes256-cbc`, and `http://www.w3.org/2001/04/xmlenc#aes192-cbc`.\n\nFinally, the `securementEncryptionParts` property defines which parts of the message are encrypted.\nThe value of this property is a list of semicolon-separated element names that identify the elements to encrypt.\nAn encryption mode specifier and a namespace identification, each inside a pair of curly brackets, may precede each element name.\nThe encryption mode specifier is either `{Content}` or `{Element}` See the W3C XML Encryption specification about the differences between Element and Content encryption.\nThe following example identifies the `echoResponse` from the echo sample:\n\n====\n[source,xml]\n----\n<property name=\"securementEncryptionParts\"\n value=\"{Content}{http://www.springframework.org/spring-ws/samples/echo}echoResponse\"/>\n----\n====\n\nBe aware that the element name, the namespace identifier, and the encryption modifier are case-sensitive.\nYou can omit the encryption modifier and the namespace identifier.\nIf you do, the encryption mode defaults to `Content`, and the namespace is set to the SOAP namespace.\n\nTo specify an element without a namespace, use the value, `Null` (case sensitive), as the namespace name.\nIf no list is specified, the handler encrypts the SOAP Body in `Content` mode by default.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Encryption", "heading_level": 4, "file_order": 5, "section_index": 47, "content_hash": "026fbbea01762f247f8c12c80a28d41a7786917f433c7c7b6531fdce1bb58f92", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:6c81d9633c3b81dae94253a5b517d0fb33c66bf2ee9cf2a512de3d5f423b88f9", "content": "The exception handling of the `Wss4jSecurityInterceptor` is identical to that of the `XwsSecurityInterceptor`.\nSee <<security-xws-exception-handling>> for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/security.adoc", "title": "security", "heading": "Security Exception Handling", "heading_level": 3, "file_order": 5, "section_index": 48, "content_hash": "6c81d9633c3b81dae94253a5b517d0fb33c66bf2ee9cf2a512de3d5f423b88f9", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/security.adoc"}}
{"id": "sha256:a4efaf5927d5782c43fb714111436a6834236922c9eef47a84caa08d15612de3", "content": "[[server]]\n\nSpring-WS server-side support is designed around a `MessageDispatcher` that dispatches incoming messages to endpoints, with configurable endpoint mappings, response generation, and endpoint interception.\nEndpoints are typically annotated with the `@Endpoint` annotation and have one or more handling methods.\nThese methods handle incoming XML request messages by inspecting parts of the message (typically the payload) and create some sort of response.\nYou can annotate the method with another annotation, typically `@PayloadRoot`, to indicate what sort of messages it can handle.\n\nSpring-WS XML handling is extremely flexible.\nAn endpoint can choose from a large number of XML handling libraries supported by Spring-WS, including:\n\n* The DOM family: W3C DOM, JDOM, dom4j, and XOM.\n* SAX or StAX: For faster performance.\n* XPath: To extract information from the message.\n* Marshalling techniques (JAXB, Castor, XMLBeans, JiBX, or XStream): To convert the XML to objects and vice-versa.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "server", "heading_level": 1, "file_order": 6, "section_index": 0, "content_hash": "a4efaf5927d5782c43fb714111436a6834236922c9eef47a84caa08d15612de3", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:ba3990ba752b2e573edbe070ed52096644c03b9f7fcd96693df0ebef2888882b", "content": "The server-side of Spring-WS is designed around a central class that dispatches incoming XML messages to endpoints.\nSpring-WS `MessageDispatcher` is extremely flexible, letting you use any sort of class as an endpoint, as long as it can be configured in the Spring IoC container.\nIn a way, the message dispatcher resembles Spring's `DispatcherServlet`, the \"Front Controller\" used in Spring Web MVC.\n\nThe following sequence diagram shows the processing and dispatching flow of the `MessageDispatcher`:\n\nimage::images/sequence.png[align=\"center\"]\n\nWhen a `MessageDispatcher` is set up for use and a request comes in for that specific dispatcher, the `MessageDispatcher` starts processing the request.\nThe following process describes how `MessageDispatcher` handles a request:\n\n. The configured `EndpointMapping(s)` is searched for an appropriate endpoint.\nIf an endpoint is found, the invocation chain associated with the endpoint (pre-processors, post-processors, and endpoints) is invoked to create a response.\n. An appropriate adapter is found for the endpoint.\nThe `MessageDispatcher` delegates to this adapter to invoke the endpoint.\n. If a response is returned, it is sent on its way.\nIf no response is returned (which could be due to a pre- or post-processor intercepting the request, for example, for security reasons), no response is sent.\n\nExceptions that are thrown during the handling of the request get picked up by any of the endpoint exception resolvers that are declared in the application context.\nUsing these exception resolvers lets you define custom behaviors (such as returning a SOAP fault), in case such exceptions get thrown.\n\nThe `MessageDispatcher` has several properties for setting endpoint adapters, <<server-endpoint-mapping,mappings>>, <<server-endpoint-exception-resolver,exception resolvers>>.\nHowever, setting these properties is not required, since the dispatcher automatically detects all the types that are registered in the application context.\nYou should set these properties only when you need to override detection.\n\nThe message dispatcher operates on a <<message-context,message context>> and not on a transport-specific input stream and output stream.\nAs a result, transport-specific requests need to read into a `MessageContext`.\nFor HTTP, this is done with a `WebServiceMessageReceiverHandlerAdapter` (which is a Spring Web `HandlerInterceptor`) so that the `MessageDispatcher` can be wired in a standard `DispatcherServlet`.\nThere is a more convenient way to do this, however, which is shown in <<message-dispatcher-servlet>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "The `MessageDispatcher`", "heading_level": 2, "file_order": 6, "section_index": 1, "content_hash": "ba3990ba752b2e573edbe070ed52096644c03b9f7fcd96693df0ebef2888882b", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:1e18c3b6fd660b3c07fa77f113fd6356fee242675ffb33741b45c64590d3a3b6", "content": "Spring-WS supports multiple transport protocols.\nThe most common is the HTTP transport, for which a custom servlet is supplied, but you can also send messages over JMS and even email.\n\n[[message-dispatcher-servlet]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Transports", "heading_level": 2, "file_order": 6, "section_index": 2, "content_hash": "1e18c3b6fd660b3c07fa77f113fd6356fee242675ffb33741b45c64590d3a3b6", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:d189f69d05a7c7d5774440470b200d3f86a65c64c64a94766f3ef80abed7ca25", "content": "The `MessageDispatcherServlet` is a standard `Servlet` that conveniently extends from the standard Spring Web `DispatcherServlet` and wraps a `MessageDispatcher`.\nAs a result, it combines the attributes of these into one.\nAs a `MessageDispatcher`, it follows the same request handling flow as described in the previous section.\nAs a servlet, the `MessageDispatcherServlet` is configured in the `web.xml` of your web application.\nRequests that you want the `MessageDispatcherServlet` to handle must be mapped by a URL mapping in the same `web.xml` file.\nThis is standard JavaEE servlet configuration.\nThe following example shows such a `MessageDispatcherServlet` declaration and mapping:\n\n====\n[source,xml]\n----\n<web-app>\n\n <servlet>\n <servlet-name>spring-ws</servlet-name>\n <servlet-class>org.springframework.ws.transport.http.MessageDispatcherServlet</servlet-class>\n <load-on-startup>1</load-on-startup>\n </servlet>\n\n <servlet-mapping>\n <servlet-name>spring-ws</servlet-name>\n <url-pattern>/*</url-pattern>\n </servlet-mapping>\n\n</web-app>\n----\n====\n\nIn the preceding example, all requests are handled by the `spring-ws` `MessageDispatcherServlet`.\nThis is only the first step in setting up Spring-WS, because the various component beans used by the Spring-WS framework also need to be configured.\nThis configuration consists of standard Spring XML `<bean/>` definitions.\nBecause the `MessageDispatcherServlet` is a standard Spring `DispatcherServlet`, it looks for a file named `[servlet-name]-servlet.xml` in the `WEB-INF` directory of your web application and creates the beans defined there in a Spring container.\nIn the preceding example, it looks for `/WEB-INF/spring-ws-servlet.xml`.\nThis file contains all the Spring-WS beans, such as endpoints, marshallers, and so on.\n\nAs an alternative for `web.xml`, you can configure Spring-WS programmatically.\nFor this purpose, Spring-WS provides a number of abstract base classes that extend the `WebApplicationInitializer` interface found in the Spring Framework.\nIf you also use `@Configuration` classes for your bean definitions, you should extend the `AbstractAnnotationConfigMessageDispatcherServletInitializer`:\n\n====\n[source,java]\n----\npublic class MyServletInitializer\n extends AbstractAnnotationConfigMessageDispatcherServletInitializer {\n\n @Override\n protected Class<?>[] getRootConfigClasses() {\n return new Class[]{MyRootConfig.class};\n }\n\n @Override\n protected Class<?>[] getServletConfigClasses() {\n return new Class[]{MyEndpointConfig.class};\n }\n\n}\n----\n====\n\nIn the preceding example, we tell Spring that endpoint bean definitions can be found in the `MyEndpointConfig` class (which is a `@Configuration` class).\nOther bean definitions (typically services, repositories, and so on) can be found in the `MyRootConfig` class.\nBy default, the `AbstractAnnotationConfigMessageDispatcherServletInitializer` maps the servlet to two patterns: `/services` and `*.wsdl`, though you can change this by overriding the `getServletMappings()` method.\nFor more details on the programmatic configuration of the `MessageDispatcherServlet`, refer to the Javadoc of {spring-ws-api}/transport/http/support/AbstractMessageDispatcherServletInitializer.html[`AbstractMessageDispatcherServletInitializer`] and {spring-ws-api}/transport/http/support/AbstractAnnotationConfigMessageDispatcherServletInitializer.html[`AbstractAnnotationConfigMessageDispatcherServletInitializer`].\n\n[[server-automatic-wsdl-exposure]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "`MessageDispatcherServlet`", "heading_level": 3, "file_order": 6, "section_index": 3, "content_hash": "d189f69d05a7c7d5774440470b200d3f86a65c64c64a94766f3ef80abed7ca25", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:4e250386194a29beb71d3e069bd0b102e1d3357bf91dce2c4a0b8947742f0970", "content": "The `MessageDispatcherServlet` automatically detects any `WsdlDefinition` beans defined in its Spring container.\nAll the `WsdlDefinition` detected beans are also exposed through a `WsdlDefinitionHandlerAdapter`.\nThis is a convenient way to expose your WSDL to clients by defining some beans.\n\nBy way of an example, consider the following `<static-wsdl>` definition, defined in the Spring-WS configuration file (`/WEB-INF/[servlet-name]-servlet.xml`).\nTake notice of the value of the `id` attribute, because it is used when exposing the WSDL.\n\n====\n[source,xml]\n----\n<sws:static-wsdl id=\"orders\" location=\"orders.wsdl\"/>\n----\n====\n\nAlternatively, it can be a `@Bean` method in a `@Configuration` class:\n\n====\n[source,java]\n----\n@Bean\npublic SimpleWsdl11Definition ordersWsdl11Definition() {\n\treturn new SimpleWsdl11Definition(new ClassPathResource(\"orders.wsdl\"), \"orders\");\n}\n----\n====\n\nYou can access the WSDL defined in the `orders.wsdl` file on the classpath through `GET` requests to a URL of the following form (substitute the host, port and servlet context path as appropriate):\n\n====\n[source]\n----\nhttp://localhost:8080/spring-ws/orders.wsdl\n----\n====\n\n[NOTE]\n====\nAll `WsdlDefinition` bean definitions are exposed by the `MessageDispatcherServlet` under their name with a suffix of`.wsdl`.\nIf no name is provided by the definition, the name of the bean is used.\nFor example, if the name is `echo`, the host name is `server`, and the Servlet context (war name) is `spring-ws`, the WSDL can be found at `http://server/spring-ws/echo.wsdl`.\n====\n\nAnother nice feature of the `MessageDispatcherServlet` (or more correctly the `WsdlDefinitionHandlerAdapter`) is that it can transform the value of the `location` of all the WSDL that it exposes to reflect the URL of the incoming request.\n\nNote that this `location` transformation feature is off by default.\nTo switch this feature on, you need to specify an initialization parameter to the `MessageDispatcherServlet`:\n\n====\n[source,xml]\n----\n<web-app>\n\n <servlet>\n <servlet-name>spring-ws</servlet-name>\n <servlet-class>org.springframework.ws.transport.http.MessageDispatcherServlet</servlet-class>\n <init-param>\n <param-name>transformWsdlLocations</param-name>\n <param-value>true</param-value>\n </init-param>\n </servlet>\n\n <servlet-mapping>\n <servlet-name>spring-ws</servlet-name>\n <url-pattern>/*</url-pattern>\n </servlet-mapping>\n\n</web-app>\n----\n====\n\nIf you use `AbstractAnnotationConfigMessageDispatcherServletInitializer`, enabling transformation is as simple as overriding the `isTransformWsdlLocations()` method to return `true`.\n\nConsult the class-level Javadoc on the {spring-ws-api}/transport/http/WsdlDefinitionHandlerAdapter.html[`WsdlDefinitionHandlerAdapter`] class to learn more about the whole transformation process.\n\nAs an alternative to writing the WSDL by hand and exposing it with `<static-wsdl>`, Spring-WS can also generate a WSDL from an XSD schema.\nThis is the approach shown in <<tutorial-publishing-wsdl>>.\nThe next application context snippet shows how to create such a dynamic WSDL file:\n\n====\n[source,xml]\n----\n<sws:dynamic-wsdl id=\"orders\"\n portTypeName=\"Orders\"\n locationUri=\"http://localhost:8080/ordersService/\">\n <sws:xsd location=\"Orders.xsd\"/>\n</sws:dynamic-wsdl>\n----\n====\n\nAlternatively, you can use the Java `@Bean` method:\n\n====\n[source,java]\n----\n@Bean\npublic DefaultWsdl11Definition ordersWsdlDefinition() {\n DefaultWsdl11Definition definition = new DefaultWsdl11Definition();\n\tdefinition.setName(\"orders\");\n definition.setPortTypeName(\"Orders\");\n definition.setLocationUri(\"http://localhost:8080/ordersService/\");\n definition.setSchema(new SimpleXsdSchema(new ClassPathResource(\"Orders.xsd\")));\n return definition;\n}\n----\n====\n\nThe `<dynamic-wsdl>` element depends on the `DefaultWsdl11Definition` class.\nThis definition class uses WSDL providers in the {spring-ws-api}/wsdl/wsdl11/provider/package-summary.html[`org.springframework.ws.wsdl.wsdl11.provider`] package and the {spring-ws-api}/wsdl/wsdl11/ProviderBasedWsdl4jDefinition.html[`ProviderBasedWsdl4jDefinition`] class to generate a WSDL the first time it is requested.\nSee the class-level Javadoc of these classes to see how you can extend this mechanism, if necessary.\n\nThe `DefaultWsdl11Definition` (and therefore, the `<dynamic-wsdl>` tag) builds a WSDL from an XSD schema by using conventions.\nIt iterates over all `element` elements found in the schema and creates a `message` for all elements.\nNext, it creates a WSDL `operation` for all messages that end with the defined request or response suffix.\nThe default request suffix is `Request`.\nThe default response suffix is `Response`, though these can be changed by setting the `requestSuffix` and `responseSuffix` attributes on `<dynamic-wsdl />`, respectively.\nIt also builds a `portType`, `binding`, and `service` based on the operations.\n\nFor instance, if our `Orders.xsd` schema defines the `GetOrdersRequest` and `GetOrdersResponse` elements, `<dynamic-wsdl>` creates a `GetOrdersRequest` and `GetOrdersResponse` message and a `GetOrders` operation, which is put in a `Orders` port type.\n\nTo use multiple schemas, either by includes or imports, you can put Commons XMLSchema on the class path.\nIf Commons XMLSchema is on the class path, the `<dynamic-wsdl>` element follows all XSD imports and includes and inlines them in the WSDL as a single XSD.\nWith Java config, you can use `CommonsXsdSchemaCollection` as shown in the following example:\n\n[source,java]\n----\n@Bean\npublic DefaultWsdl11Definition ordersWsdlDefinition() throws Exception {\n DefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();\n\twsdl11Definition.setName(\"orders\");\n // ... configuration\n CommonsXsdSchemaCollection schemas = new CommonsXsdSchemaCollection(\n new ClassPathResource(\"xsd/order/main.xsd\"));\n schemas.setInline(true);\n wsdl11Definition.setSchemaCollection(schemas);\n return wsdl11Definition;\n}\n----\n\nThis greatly simplifies the deployment of the schemas, while still making it possible to edit them separately.\n\n[WARNING]\n====\nEven though it can be handy to create the WSDL at runtime from your XSDs, there are a couple of drawbacks to this approach.\nFirst, though we try to keep the WSDL generation process consistent between releases, there is still the possibility that it changes (slightly).\nSecond, the generation is a bit slow, though, once generated, the WSDL is cached for later reference.\n====\n\nTherefore, you should use `<dynamic-wsdl>` only during the development stages of your project.\nWe recommend using your browser to download the generated WSDL, store it in the project, and expose it with `<static-wsdl>`.\nThis is the only way to be really sure that the WSDL does not change over time.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Automatic WSDL exposure", "heading_level": 4, "file_order": 6, "section_index": 4, "content_hash": "4e250386194a29beb71d3e069bd0b102e1d3357bf91dce2c4a0b8947742f0970", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:5d3b13e7901ee40fd5222bf9c20ffbcdbdff0456d13cfc40dc4dc2dfd89ca278", "content": "As an alternative to the `MessageDispatcherServlet`, you can wire up a `MessageDispatcher` in a standard, Spring-Web MVC `DispatcherServlet`.\nBy default, the `DispatcherServlet` can delegate only to `Controllers`, but we can instruct it to delegate to a `MessageDispatcher` by adding a `WebServiceMessageReceiverHandlerAdapter` to the servlet's web application context:\n\n====\n[source,xml]\n----\n<beans>\n\n <bean class=\"org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter\"/>\n\n <bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n <property name=\"defaultHandler\" ref=\"messageDispatcher\"/>\n </bean>\n\n <bean id=\"messageDispatcher\" class=\"org.springframework.ws.soap.server.SoapMessageDispatcher\"/>\n\n ...\n\n <bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>\n\n</beans>\n----\n====\n\nNote that, by explicitly adding the `WebServiceMessageReceiverHandlerAdapter`, the dispatcher servlet does not load the default adapters and is unable to handle standard Spring-MVC `@Controllers`.\nTherefore, we add the `RequestMappingHandlerAdapter` at the end.\n\nIn a similar fashion, you can wire a `WsdlDefinitionHandlerAdapter` to make sure the `DispatcherServlet` can handle implementations of the `WsdlDefinition` interface:\n\n====\n[source,xml,subs=\"verbatim,+quotes,+macros\"]\n----\n<beans>\n\n <bean class=\"org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter\"/>\n\n *<bean class=\"org.springframework.ws.transport.http.WsdlDefinitionHandlerAdapter\"/>*\n\n <bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n <property name=\"mappings\">\n <props>\n **<prop key=\"$$*$$.wsdl\">myServiceDefinition</prop>**\n </props>\n </property>\n <property name=\"defaultHandler\" ref=\"messageDispatcher\"/>\n </bean>\n\n <bean id=\"messageDispatcher\" class=\"org.springframework.ws.soap.server.SoapMessageDispatcher\"/>\n\n *<bean id=\"myServiceDefinition\" class=\"org.springframework.ws.wsdl.wsdl11.SimpleWsdl11Definition\">\n <prop name=\"wsdl\" value=\"/WEB-INF/myServiceDefinition.wsdl\"/>\n </bean>*\n\n ...\n\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Wiring up Spring-WS in a `DispatcherServlet`", "heading_level": 3, "file_order": 6, "section_index": 5, "content_hash": "5d3b13e7901ee40fd5222bf9c20ffbcdbdff0456d13cfc40dc4dc2dfd89ca278", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:3f7b995de84b762c41d07b9e39203ef64687dea3f27a5578ede8fb530987ed6e", "content": "Spring-WS supports server-side JMS handling through the JMS functionality provided in the Spring framework.\nSpring-WS provides the `WebServiceMessageListener` to plug in to a `MessageListenerContainer`.\nThis message listener requires a `WebServiceMessageFactory` and `MessageDispatcher` to operate.\nThe following configuration example shows this:\n\n====\n[source,xml]\n----\n<beans>\n\n <bean id=\"connectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\">\n <property name=\"brokerURL\" value=\"vm://localhost?broker.persistent=false\"/>\n </bean>\n\n <bean id=\"messageFactory\" class=\"org.springframework.ws.soap.saaj.SaajSoapMessageFactory\"/>\n\n <bean class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\">\n <property name=\"connectionFactory\" ref=\"connectionFactory\"/>\n <property name=\"destinationName\" value=\"RequestQueue\"/>\n <property name=\"messageListener\">\n <bean class=\"org.springframework.ws.transport.jms.WebServiceMessageListener\">\n <property name=\"messageFactory\" ref=\"messageFactory\"/>\n <property name=\"messageReceiver\" ref=\"messageDispatcher\"/>\n </bean>\n </property>\n </bean>\n\n <bean id=\"messageDispatcher\" class=\"org.springframework.ws.soap.server.SoapMessageDispatcher\">\n <property name=\"endpointMappings\">\n <bean\n class=\"org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMapping\">\n <property name=\"defaultEndpoint\">\n <bean class=\"com.example.MyEndpoint\"/>\n </property>\n </bean>\n </property>\n </bean>\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "JMS transport", "heading_level": 3, "file_order": 6, "section_index": 6, "content_hash": "3f7b995de84b762c41d07b9e39203ef64687dea3f27a5578ede8fb530987ed6e", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:4ea1f1b94f09afcffa4c712680e55c7ae0dd352d94c54104c5cebac9638f4817", "content": "In addition to HTTP and JMS, Spring-WS also provides server-side email handling.\nThis functionality is provided through the `MailMessageReceiver` class.\nThis class monitors a POP3 or IMAP folder, converts the email to a `WebServiceMessage`, and sends any response by using SMTP.\nYou can configure the host names through the `storeUri`, which indicates the mail folder to monitor for requests (typically a POP3 or IMAP folder), and a `transportUri`, which indicates the server to use for sending responses (typically an SMTP server).\n\nYou can configure how the `MailMessageReceiver` monitors incoming messages with a pluggable strategy: the `MonitoringStrategy`.\nBy default, a polling strategy is used, where the incoming folder is polled for new messages every five minutes.\nYou can change this interval by setting the `pollingInterval` property on the strategy.\nBy default, all `MonitoringStrategy` implementations delete the handled messages.\nYou can change this setting by setting the `deleteMessages` property.\n\nAs an alternative to the polling approaches, which are quite inefficient, there is a monitoring strategy that uses IMAP IDLE.\nThe IDLE command is an optional expansion of the IMAP email protocol that lets the mail server send new message updates to the `MailMessageReceiver` asynchronously.\nIf you use an IMAP server that supports the IDLE command, you can plug the `ImapIdleMonitoringStrategy` into the `monitoringStrategy` property.\n\nThe following piece of configuration shows how to use the server-side email support, overriding the default polling interval to check every 30 seconds (30.000 milliseconds):\n\n====\n[source,xml]\n----\n<beans>\n\n <bean id=\"messageFactory\" class=\"org.springframework.ws.soap.saaj.SaajSoapMessageFactory\"/>\n\n <bean id=\"messagingReceiver\" class=\"org.springframework.ws.transport.mail.MailMessageReceiver\">\n <property name=\"messageFactory\" ref=\"messageFactory\"/>\n <property name=\"from\" value=\"Spring-WS SOAP Server &lt;server@example.com&gt;\"/>\n <property name=\"storeUri\" value=\"imap://server:s04p@imap.example.com/INBOX\"/>\n <property name=\"transportUri\" value=\"smtp://smtp.example.com\"/>\n <property name=\"messageReceiver\" ref=\"messageDispatcher\"/>\n <property name=\"monitoringStrategy\">\n <bean class=\"org.springframework.ws.transport.mail.monitor.PollingMonitoringStrategy\">\n <property name=\"pollingInterval\" value=\"30000\"/>\n </bean>\n </property>\n </bean>\n\n <bean id=\"messageDispatcher\" class=\"org.springframework.ws.soap.server.SoapMessageDispatcher\">\n <property name=\"endpointMappings\">\n <bean\n class=\"org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMapping\">\n <property name=\"defaultEndpoint\">\n <bean class=\"com.example.MyEndpoint\"/>\n </property>\n </bean>\n </property>\n </bean>\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Email Transport", "heading_level": 3, "file_order": 6, "section_index": 7, "content_hash": "4ea1f1b94f09afcffa4c712680e55c7ae0dd352d94c54104c5cebac9638f4817", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:7c52e7ba23244ef2cdbfc016a8c46b63bdaa548255f4568af81fe08662b63544", "content": "NOTE: This should only be used for testing purposes.\n\nSpring-WS provides a transport based on Sun's JRE http://java.sun.com/javase/6/docs/jre/api/net/httpserver/spec/index.html[HTTP server].\nThe embedded HTTP Server is a standalone server that is simple to configure.\nIt offers a lighter alternative to conventional servlet containers.\n\nWhen using the embedded HTTP server, you need no external deployment descriptor (`web.xml`).\nYou need only define an instance of the server and configure it to handle incoming requests.\n`SimpleHttpServerFactoryBean` wires things up, and the most important property is `contexts`, which maps context paths to corresponding `HttpHandler` instances.\n\nSpring-WS provides two implementations of the `HttpHandler` interface: {spring-ws-api}/transport/http/WsdlDefinitionHttpHandler.html[`WsdlDefinitionHttpHandler`] and {spring-ws-api}/transport/http/WebServiceMessageReceiverHttpHandler.html[`WebServiceMessageReceiverHttpHandler`].\nThe former maps an incoming GET request to a `WsdlDefinition`.\nThe latter is responsible for handling POST requests for web services messages and, thus, needs a `WebServiceMessageFactory` (typically a `SaajSoapMessageFactory`) and a `WebServiceMessageReceiver` (typically the `SoapMessageDispatcher`) to accomplish its task.\n\nTo draw parallels with the servlet world, the `contexts` property plays the role of servlet mappings in `web.xml` and the `WebServiceMessageReceiverHttpHandler` is the equivalent of a `MessageDispatcherServlet`.\n\nThe following snippet shows a configuration example of the HTTP server transport:\n\n====\n[source,xml]\n----\n<beans>\n\n <bean id=\"messageFactory\" class=\"org.springframework.ws.soap.saaj.SaajSoapMessageFactory\"/>\n\n <bean id=\"messageReceiver\" class=\"org.springframework.ws.soap.server.SoapMessageDispatcher\">\n <property name=\"endpointMappings\" ref=\"endpointMapping\"/>\n </bean>\n\n <bean id=\"endpointMapping\" class=\"org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMapping\">\n <property name=\"defaultEndpoint\" ref=\"stockEndpoint\"/>\n </bean>\n\n <bean id=\"httpServer\" class=\"org.springframework.ws.transport.http.SimpleHttpServerFactoryBean\">\n <property name=\"contexts\">\n <map>\n <entry key=\"/StockService.wsdl\" value-ref=\"wsdlHandler\"/>\n <entry key=\"/StockService\" value-ref=\"soapHandler\"/>\n </map>\n </property>\n </bean>\n\n <bean id=\"soapHandler\" class=\"org.springframework.ws.transport.http.WebServiceMessageReceiverHttpHandler\">\n <property name=\"messageFactory\" ref=\"messageFactory\"/>\n <property name=\"messageReceiver\" ref=\"messageReceiver\"/>\n </bean>\n\n <bean id=\"wsdlHandler\" class=\"org.springframework.ws.transport.http.WsdlDefinitionHttpHandler\">\n <property name=\"definition\" ref=\"wsdlDefinition\"/>\n </bean>\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Embedded HTTP Server transport", "heading_level": 3, "file_order": 6, "section_index": 8, "content_hash": "7c52e7ba23244ef2cdbfc016a8c46b63bdaa548255f4568af81fe08662b63544", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:2111107d35997fb4b9e0682e0e4c3caf9b95a9d81b1dcb9afa527493a26af4f8", "content": "Spring-WS has support for XMPP, otherwise known as Jabber.\nThe support is based on the https://www.igniterealtime.org/projects/smack/index.jsp[Smack] library.\n\nSpring-WS support for XMPP is very similar to the other transports: There is a a `XmppMessageSender` for the `WebServiceTemplate` and a `XmppMessageReceiver` to use with the `MessageDispatcher`.\n\nThe following example shows how to set up the server-side XMPP components:\n\n====\n[source,xml]\n----\n<beans>\n\n <bean id=\"messageFactory\" class=\"org.springframework.ws.soap.saaj.SaajSoapMessageFactory\"/>\n\n <bean id=\"connection\" class=\"org.springframework.ws.transport.xmpp.support.XmppConnectionFactoryBean\">\n <property name=\"host\" value=\"jabber.org\"/>\n <property name=\"username\" value=\"username\"/>\n <property name=\"password\" value=\"password\"/>\n </bean>\n\n <bean id=\"messagingReceiver\" class=\"org.springframework.ws.transport.xmpp.XmppMessageReceiver\">\n <property name=\"messageFactory\" ref=\"messageFactory\"/>\n <property name=\"connection\" ref=\"connection\"/>\n <property name=\"messageReceiver\" ref=\"messageDispatcher\"/>\n </bean>\n\n <bean id=\"messageDispatcher\" class=\"org.springframework.ws.soap.server.SoapMessageDispatcher\">\n <property name=\"endpointMappings\">\n <bean\n class=\"org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMapping\">\n <property name=\"defaultEndpoint\">\n <bean class=\"com.example.MyEndpoint\"/>\n </property>\n </bean>\n </property>\n </bean>\n\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "XMPP transport", "heading_level": 3, "file_order": 6, "section_index": 9, "content_hash": "2111107d35997fb4b9e0682e0e4c3caf9b95a9d81b1dcb9afa527493a26af4f8", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:655928affcbfb749dd86989ba7038166e26fb970dbab6615bc62e2cc0d6322a3", "content": "https://en.wikipedia.org/wiki/Message_Transmission_Optimization_Mechanism[MTOM] is the mechanism for sending binary data to and from Web Services.\nYou can look at how to implement this with Spring WS through the https://github.com/spring-projects/spring-ws-samples/tree/main/mtom[MTOM sample].\n\n[[server-endpoints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "MTOM", "heading_level": 3, "file_order": 6, "section_index": 10, "content_hash": "655928affcbfb749dd86989ba7038166e26fb970dbab6615bc62e2cc0d6322a3", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:5913642f96a4bec3751808e7a6aa91196d80f8f145aa2605743100bf65c13111", "content": "Endpoints are the central concept in Spring-WS server-side support.\nEndpoints provide access to the application behavior, which is typically defined by a business service interface.\nAn endpoint interprets the XML request message and uses that input to (typically) invoke a method on the business service.\nThe result of that service invocation is represented as a response message.\nSpring-WS has a wide variety of endpoints and uses various ways to handle the XML message and to create a response.\n\nYou can create an endpoint by annotating a class with the `@Endpoint` annotation.\nIn the class, you define one or more methods that handle the incoming XML request, by using a wide variety of parameter types (such as DOM elements, JAXB2 objects, and others).\nYou can indicate the sort of messages a method can handle by using another annotation (typically `@PayloadRoot`).\n\nConsider the following sample endpoint:\n\n====\n[source,java]\n----\npackage samples;\n\nimport org.w3c.dom.Element;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.ws.server.endpoint.annotation.Endpoint;\nimport org.springframework.ws.server.endpoint.annotation.PayloadRoot;\nimport org.springframework.ws.soap.SoapHeader;\n\n@Endpoint // <1>\npublic class AnnotationOrderEndpoint {\n\n private final OrderService orderService;\n\n public AnnotationOrderEndpoint(OrderService orderService) {\n this.orderService = orderService;\n }\n\n @PayloadRoot(localPart = \"order\", namespace = \"http://samples\") // <4>\n public void order(@RequestPayload Element orderElement) { // <2>\n Order order = createOrder(orderElement);\n orderService.createOrder(order);\n }\n\n @PayloadRoot(localPart = \"orderRequest\", namespace = \"http://samples\") // <4>\n @ResponsePayload\n public Order getOrder(@RequestPayload OrderRequest orderRequest, SoapHeader header) { // <3>\n checkSoapHeaderForSomething(header);\n return orderService.getOrder(orderRequest.getId());\n }\n\n}\n----\n\n<1> The class is annotated with `@Endpoint`, marking it as a Spring-WS endpoint.\n<2> The `order` method takes an `Element` (annotated with `@RequestPayload`) as a parameter.\nThis means that the payload of the message is passed on this method as a DOM element.\nThe method has a `void` return type, indicating that no response message is sent.\nFor more information about endpoint methods, see <<server-atEndpoint-methods>>.\n<3> The `getOrder` method takes an `OrderRequest` (also annotated with `@RequestPayload`) as a parameter.\nThis parameter is a JAXB2-supported object (it is annotated with `@XmlRootElement`).\nThis means that the payload of the message is passed to this method as a unmarshalled object.\nThe `SoapHeader` type is also given as a parameter.\nOn invocation, this parameter contains the SOAP header of the request message.\nThe method is also annotated with `@ResponsePayload`, indicating that the return value (the `Order`) is used as the payload of the response message.\nFor more information about endpoint methods, see <<server-atEndpoint-methods>>.\n<4> The two handling methods of this endpoint are marked with `@PayloadRoot`, indicating what sort of request messages can be handled by the method: the `getOrder` method is invoked for requests with a `orderRequest` local name and a `http://samples` namespace URI.\nThe order method is invoked for requests with a `order` local name.\nFor more information about `@PayloadRoot`, see <<server-endpoint-mapping>>.\n====\n\nTo enable the support for `@Endpoint` and related Spring-WS annotations, you need to add the following to your Spring application context:\n\n====\n[source,xml,subs=\"verbatim,quotes\"]\n----\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:sws=\"http://www.springframework.org/schema/web-services\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n http://www.springframework.org/schema/beans/spring-beans.xsd\n *http://www.springframework.org/schema/web-services\n http://www.springframework.org/schema/web-services/web-services.xsd\">\n\n <sws:annotation-driven />\n\n</beans>\n----\n====\n\nAlternatively, if you use `@Configuration` classes instead of Spring XML, you can annotate your configuration class with `@EnableWs`:\n\n====\n[source,java,subs=\"verbatim,quotes\"]\n----\n@EnableWs\n@Configuration\npublic class EchoConfig {\n\n // @Bean definitions go here\n\n}\n----\n====\n\nTo customize the `@EnableWs` configuration, you can implement `WsConfigurer` and override individual methods:\n\n====\n[source,java]\n----\n@Configuration\n@EnableWs\npublic class EchoConfig implements WsConfigurer {\n\n @Override\n public void addInterceptors(List<EndpointInterceptor> interceptors) {\n interceptors.add(new MyInterceptor());\n }\n\n @Override\n public void addArgumentResolvers(List<MethodArgumentResolver> argumentResolvers) {\n argumentResolvers.add(new MyArgumentResolver());\n }\n\n}\n----\n====\n\nIf `WsConfigurer` does not expose some more advanced setting that needs to be configured, consider removing `@EnableWs` and extending directly from `WsConfigurationSupport` or `DelegatingWsConfiguration`.\n\n====\n[source,java]\n----\n@Configuration\npublic class EchoConfig extends WsConfigurationSupport {\n\n @Override\n public void addInterceptors(List<EndpointInterceptor> interceptors) {\n interceptors.add(new MyInterceptor());\n }\n\n @Bean\n @Override\n public PayloadRootAnnotationMethodEndpointMapping payloadRootAnnotationMethodEndpointMapping() {\n // Create or delegate to \"super\" to create and\n // customize properties of PayloadRootAnnotationMethodEndpointMapping\n }\n\n}\n----\n====\n\nIn the next couple of sections, a more elaborate description of the `@Endpoint` programming model is given.\n\n[NOTE]\n====\nEndpoints, like any other Spring Bean, are scoped as a singleton by default.\nThat is, one instance of the bean definition is created per container.\nBeing a singleton implies that more than one thread can use it at the same time, so the endpoint has to be thread safe.\nIf you want to use a different scope, such as prototype, see the {spring-framework-docs}/core/beans/factory-scopes.html#beans-factory-scopes-other-injection[Spring Framework reference documentation].\n====\n\nNote that all abstract base classes provided in Spring-WS are thread safe, unless otherwise indicated in the class-level Javadoc.\n\n[[server-atEndpoint-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Endpoints", "heading_level": 2, "file_order": 6, "section_index": 11, "content_hash": "5913642f96a4bec3751808e7a6aa91196d80f8f145aa2605743100bf65c13111", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:d00fba057dcc1039ae244d0f0dc7c59c652a649d6289e330ae6bf787a26ebf83", "content": "For an endpoint to actually handle incoming XML messages, it needs to have one or more handling methods.\nHandling methods can take wide range of parameters and return types.\nHowever, they typically have one parameter that contains the message payload, and they return the payload of the response message (if any).\nThis section covers which parameter and return types are supported.\n\nTo indicate what sort of messages a method can handle, the method is typically annotated with either the `@PayloadRoot` or the `@SoapAction` annotation.\nYou can learn more about these annotations in <<server-endpoint-mapping>>.\n\nThe following example shows a handling method:\n\n====\n[source,java]\n----\n@PayloadRoot(localPart = \"order\", namespace = \"http://samples\")\npublic void order(@RequestPayload Element orderElement) {\n Order order = createOrder(orderElement);\n orderService.createOrder(order);\n}\n----\n====\n\nThe `order` method takes an `Element` (annotated with `@RequestPayload`) as a parameter.\nThis means that the payload of the message is passed on this method as a DOM element.\nThe method has a `void` return type, indicating that no response message is sent.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "`@Endpoint` handling methods", "heading_level": 2, "file_order": 6, "section_index": 12, "content_hash": "d00fba057dcc1039ae244d0f0dc7c59c652a649d6289e330ae6bf787a26ebf83", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:0e72707deb1a985947db7815f4087e95225c914fee928bc87cb3035321887808", "content": "The handling method typically has one or more parameters that refer to various parts of the incoming XML message.\nMost commonly, the handling method has a single parameter that maps to the payload of the message, but it can also map to other parts of the request message, such as a SOAP header.\nThis section describes the parameters you can use in your handling method signatures.\n\nTo map a parameter to the payload of the request message, you need to annotate this parameter with the `@RequestPayload` annotation.\nThis annotation tells Spring-WS that the parameter needs to be bound to the request payload.\n\nThe following table describes the supported parameter types.\nIt shows the supported types, whether the parameter should be annotated with `@RequestPayload`, and any additional notes.\n\n[cols=\"4\", options=\"header\"]\n|===\n| Name\n| Supported parameter types\n| `@RequestPayload` required?\n| Additional notes\n\n| TrAX\n| `javax.xml.transform.Source` and sub-interfaces (`DOMSource`, `SAXSource`, `StreamSource`, and `StAXSource`)\n| Yes\n| Enabled by default.\n\n| W3C DOM\n| `org.w3c.dom.Element`\n| Yes\n| Enabled by default\n\n| dom4j\n| `org.dom4j.Element`\n| Yes\n| Enabled when dom4j is on the classpath.\n\n| JDOM\n| `org.jdom.Element`\n| Yes\n| Enabled when JDOM is on the classpath.\n\n| XOM\n| `nu.xom.Element`\n| Yes\n| Enabled when XOM is on the classpath.\n\n| StAX\n| `javax.xml.stream.XMLStreamReader` and `javax.xml.stream.XMLEventReader`\n| Yes\n| Enabled when StAX is on the classpath.\n\n| XPath\n| Any boolean, double, `String`, `org.w3c.Node`, `org.w3c.dom.NodeList`, or type that can be converted from a `String` by a Spring {spring-framework-docs}/core/validation/convert.html#core-convert-ConversionService-API[conversion service], and that is annotated with `@XPathParam`.\n| No\n| Enabled by default, see <<server-xpath-param,the section called `XPathParam`>>.\n\n| Message context\n| `org.springframework.ws.context.MessageContext`\n| No\n| Enabled by default.\n\n| SOAP\n| `org.springframework.ws.soap.SoapMessage`, `org.springframework.ws.soap.SoapBody`, `org.springframework.ws.soap.SoapEnvelope`, `org.springframework.ws.soap.SoapHeader`, and `org.springframework.ws.soap.SoapHeaderElement`s when used in combination with the `@SoapHeader` annotation.\n| No\n| Enabled by default.\n\n| JAXB2\n| Any type that is annotated with `javax.xml.bind.annotation.XmlRootElement`, and `javax.xml.bind.JAXBElement`.\n| Yes\n| Enabled when JAXB2 is on the classpath.\n\n| OXM\n| Any type supported by a Spring OXM {spring-framework-docs}/data-access/oxm.html#oxm-marshaller-unmarshaller[`Unmarshaller`].\n| Yes\n| Enabled when the `unmarshaller` attribute of `<sws:annotation-driven/>` is specified.\n|===\n\nThe next few examples show possible method signatures.\nThe following method is invoked with the payload of the request message as a DOM `org.w3c.dom.Element`:\n\n====\n[source,java]\n----\npublic void handle(@RequestPayload Element element)\n----\n====\n\nThe following method is invoked with the payload of the request message as a `javax.xml.transform.dom.DOMSource`.\nThe `header` parameter is bound to the SOAP header of the request message.\n\n====\n[source,java]\n----\npublic void handle(@RequestPayload DOMSource domSource, SoapHeader header)\n----\n====\n\nThe following method is invoked with the payload of the request message unmarshalled into a `MyJaxb2Object` (which is annotated with `@XmlRootElement`).\nThe payload of the message is also given as a DOM `Element`.\nThe whole <<message-context,message context>> is passed on as the third parameter.\n\n====\n[source,java]\n----\npublic void handle(@RequestPayload MyJaxb2Object requestObject, @RequestPayload Element element, Message messageContext)\n----\n====\n\nAs you can see, there are a lot of possibilities when it comes to defining how to handle method signatures.\nYou can even extend this mechanism to support your own parameter types.\nSee the Javadoc of {spring-ws-api}/server/endpoint/adapter/DefaultMethodEndpointAdapter.html[`DefaultMethodEndpointAdapter`] and {spring-ws-api}/server/endpoint/adapter/method/MethodArgumentResolver.html[`MethodArgumentResolver`] to see how.\n\n[[server-xpath-param]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Handling Method Parameters", "heading_level": 3, "file_order": 6, "section_index": 13, "content_hash": "0e72707deb1a985947db7815f4087e95225c914fee928bc87cb3035321887808", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:3640f66da4ea7278d8441fe0b40040d53d7749e7b63d5c69cd6c02b675ceb880", "content": "One parameter type needs some extra explanation: `@XPathParam`.\nThe idea here is that you annotate one or more method parameters with an XPath expression and that each such annotated parameter is bound to the evaluation of the expression.\nThe following example shows how to do so:\n\n====\n[source,java,subs=\"verbatim,quotes\"]\n----\npackage samples;\n\nimport javax.xml.transform.Source;\n\nimport org.springframework.ws.server.endpoint.annotation.Endpoint;\nimport org.springframework.ws.server.endpoint.annotation.Namespace;\nimport org.springframework.ws.server.endpoint.annotation.PayloadRoot;\nimport org.springframework.ws.server.endpoint.annotation.XPathParam;\n\n@Endpoint\npublic class AnnotationOrderEndpoint {\n\n private final OrderService orderService;\n\n public AnnotationOrderEndpoint(OrderService orderService) {\n this.orderService = orderService;\n }\n\n @PayloadRoot(localPart = \"orderRequest\", namespace = \"http://samples\")\n @Namespace(prefix = \"s\", uri=\"http://samples\")\n public Order getOrder(@XPathParam(\"/s:orderRequest/@id\") int orderId) {\n Order order = orderService.getOrder(orderId);\n // create Source from order and return it\n }\n\n}\n----\n====\n\nSince we use the `s` prefix in our XPath expression, we must bind it to the `http://samples` namespace.\nThis is accomplished with the `@Namespace` annotation.\nAlternatively, we could have placed this annotation on the type-level to use the same namespace mapping for all handler methods or even the package-level (in `package-info.java`) to use it for multiple endpoints.\n\nBy using the `@XPathParam`, you can bind to all the data types supported by XPath:\n\n* `boolean` or `Boolean`.\n* `double` or `Double`.\n* `String`.\n* `Node`.\n* `NodeList`.\n\nIn addition to this list, you can use any type that can be converted from a `String` by a Spring {spring-framework-docs}/core/validation/convert.html#core-convert-ConversionService-API[conversion service].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "`@XPathParam`", "heading_level": 4, "file_order": 6, "section_index": 14, "content_hash": "3640f66da4ea7278d8441fe0b40040d53d7749e7b63d5c69cd6c02b675ceb880", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:3dc90d561eed29d6708e12172ca1c4946635806ca6bba1d395b503a74f30a347", "content": "To send a response message, the handling needs to specify a return type.\nIf no response message is required, the method can declare a `void` return type.\nMost commonly, the return type is used to create the payload of the response message.\nHowever, you can also map to other parts of the response message.\nThis section describes the return types you can use in your handling method signatures.\n\nTo map the return value to the payload of the response message, you need to annotate the method with the `@ResponsePayload` annotation.\nThis annotation tells Spring-WS that the return value needs to be bound to the response payload.\n\nThe following table describes the supported return types.\nIt shows the supported types, whether the parameter should be annotated with `@ResponsePayload`, and any additional notes.\n\n[cols=\"4\", options=\"header\"]\n|===\n| Name\n| Supported return types\n| `@ResponsePayload` required?\n| Additional notes\n\n| No response\n| `void`\n| No\n| Enabled by default.\n\n| TrAX\n| `javax.xml.transform.Source` and sub-interfaces (`DOMSource`, `SAXSource`, `StreamSource`, and `StAXSource`)\n| Yes\n| Enabled by default.\n\n| W3C DOM\n| `org.w3c.dom.Element`\n| Yes\n| Enabled by default\n\n| dom4j\n| `org.dom4j.Element`\n| Yes\n| Enabled when dom4j is on the classpath.\n\n| JDOM\n| `org.jdom.Element`\n| Yes\n| Enabled when JDOM is on the classpath.\n\n| XOM\n| `nu.xom.Element`\n| Yes\n| Enabled when XOM is on the classpath.\n\n| JAXB2\n| Any type that is annotated with `javax.xml.bind.annotation.XmlRootElement`, and `javax.xml.bind.JAXBElement`.\n| Yes\n| Enabled when JAXB2 is on the classpath.\n\n| OXM\n| Any type supported by a Spring OXM {spring-framework-docs}/data-access/oxm.html#oxm-marshaller-unmarshaller[`Marshaller`].\n| Yes\n| Enabled when the `marshaller` attribute of `<sws:annotation-driven/>` is specified.\n|===\n\nThere are a lot of possibilities when it comes to defining handling method signatures.\nIt is even possible to extend this mechanism to support your own parameter types.\nSee the class-level Javadoc of {spring-ws-api}/server/endpoint/adapter/DefaultMethodEndpointAdapter.html[`DefaultMethodEndpointAdapter`] and {spring-ws-api}/server/endpoint/adapter/method/MethodReturnValueHandler.html[`MethodReturnValueHandler`] to see how.\n\n[[server-endpoint-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Handling method return types", "heading_level": 3, "file_order": 6, "section_index": 15, "content_hash": "3dc90d561eed29d6708e12172ca1c4946635806ca6bba1d395b503a74f30a347", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:1baf922f9e50d39de0b4f684eb2db04990e30222c549802153e1a75a335e6d6e", "content": "The endpoint mapping is responsible for mapping incoming messages to appropriate endpoints.\nSome endpoint mappings are enabled by default -- for example, the `PayloadRootAnnotationMethodEndpointMapping` or the `SoapActionAnnotationMethodEndpointMapping`.\nHowever, we first need to examine the general concept of an `EndpointMapping`.\n\nAn `EndpointMapping` delivers a `EndpointInvocationChain`, which contains the endpoint that matches the incoming request and may also contain a list of endpoint interceptors that are applied to the request and response.\nWhen a request comes in, the `MessageDispatcher` hands it over to the endpoint mapping to let it inspect the request and come up with an appropriate `EndpointInvocationChain`.\nThen the `MessageDispatcher` invokes the endpoint and any interceptors in the chain.\n\nThe concept of configurable endpoint mappings that can optionally contain interceptors (which can, in turn, manipulate the request, the response, or both) is extremely powerful.\nA lot of supporting functionality can be built into custom `EndpointMapping` implementations.\nFor example, a custom endpoint mapping could choose an endpoint based not only on the contents of a message but also on a specific SOAP header (or, indeed, multiple SOAP headers).\n\nMost endpoint mappings inherit from the `AbstractEndpointMapping`, which offers an '`interceptors`' property, which is the list of interceptors to use.\n`EndpointInterceptors` are discussed in <<server-endpoint-interceptor>>.\n\nAs explained in <<server-endpoints>>, the `@Endpoint` style lets you handle multiple requests in one endpoint class.\nThis is the responsibility of the `MethodEndpointMapping`.\nThis mapping determines which method is to be invoked for an incoming request message.\n\nThere are two endpoint mappings that can direct requests to methods: the `PayloadRootAnnotationMethodEndpointMapping` and the `SoapActionAnnotationMethodEndpointMapping` You can enable both methods by using `<sws:annotation-driven/>` in your application context.\n\nThe `PayloadRootAnnotationMethodEndpointMapping` uses the `@PayloadRoot` annotation, with the `localPart` and `namespace` elements, to mark methods with a particular qualified name.\nWhenever a message comes in with this qualified name for the payload root element, the method is invoked.\n\nAlternatively, the `SoapActionAnnotationMethodEndpointMapping` uses the `@SoapAction` annotation to mark methods with a particular SOAP Action.\nWhenever a message comes in with this `SOAPAction` header, the method is invoked.\n\n`AbstractEndpointMapping` implementations provides a `defaultEndpoint` property that configures the endpoint to use when a configured mapping does not result in a matching endpoint.\n\n[[server-ws-addressing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Endpoint mappings", "heading_level": 2, "file_order": 6, "section_index": 16, "content_hash": "1baf922f9e50d39de0b4f684eb2db04990e30222c549802153e1a75a335e6d6e", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:8340ce9443b1bec8cf59b26ac31db052c384b9acb60f526801729202e274b8c8", "content": "WS-Addressing specifies a transport-neutral routing mechanism.\nIt is based on the `To` and `Action` SOAP headers, which indicate the destination and intent of the SOAP message, respectively.\nAdditionally, WS-Addressing lets you define a return address (for normal messages and for faults) and a unique message identifier, which can be used for correlation.\nFor more information on WS-Addressing, see https://en.wikipedia.org/wiki/WS-Addressing.\nThe following example shows a WS-Addressing message:\n\n====\n[source,xml]\n----\n<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://www.w3.org/2003/05/soap-envelope\"\n xmlns:wsa=\"http://www.w3.org/2005/08/addressing\">\n <SOAP-ENV:Header>\n <wsa:MessageID>urn:uuid:21363e0d-2645-4eb7-8afd-2f5ee1bb25cf</wsa:MessageID>\n <wsa:ReplyTo>\n <wsa:Address>http://example.com/business/client1</wsa:Address>\n </wsa:ReplyTo>\n <wsa:To S:mustUnderstand=\"true\">http://example/com/fabrikam</wsa:To>\n <wsa:Action>http://example.com/fabrikam/mail/Delete</wsa:Action>\n </SOAP-ENV:Header>\n <SOAP-ENV:Body>\n <f:Delete xmlns:f=\"http://example.com/fabrikam\">\n <f:maxCount>42</f:maxCount>\n </f:Delete>\n </SOAP-ENV:Body>\n</SOAP-ENV:Envelope>\n----\n====\n\nIn the preceding example, the destination is set to `http://example/com/fabrikam`, while the action is set to `http://example.com/fabrikam/mail/Delete`.\nAdditionally, there is a message identifier and a reply-to address.\nBy default, this address is the \"anonymous\" address, indicating that a response should be sent by using the same channel as the request (that is, the HTTP response), but it can also be another address, as indicated in this example.\n\nIn Spring-WS, WS-Addressing is implemented as an endpoint mapping.\nBy using this mapping, you associate WS-Addressing actions with endpoints, similar to the `SoapActionAnnotationMethodEndpointMapping` described earlier.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "WS-Addressing", "heading_level": 3, "file_order": 6, "section_index": 17, "content_hash": "8340ce9443b1bec8cf59b26ac31db052c384b9acb60f526801729202e274b8c8", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:baea1f66072774845b3d964c2592578f31fc855bfe697557f38939c12d96a0d6", "content": "The `AnnotationActionEndpointMapping` is similar to the `SoapActionAnnotationMethodEndpointMapping` but uses WS-Addressing headers instead of the SOAP Action transport header.\n\nTo use the `AnnotationActionEndpointMapping`, annotate the handling methods with the `@Action` annotation, similar to the `@PayloadRoot` and `@SoapAction` annotations described in <<server-atEndpoint-methods>> and <<server-endpoint-mapping>>.\nThe following example shows how to do so:\n\n====\n[source,java]\n----\npackage samples;\n\nimport org.springframework.ws.server.endpoint.annotation.Endpoint;\nimport org.springframework.ws.soap.addressing.server.annotation.Action\n\n@Endpoint\npublic class AnnotationOrderEndpoint {\n\n private final OrderService orderService;\n\n public AnnotationOrderEndpoint(OrderService orderService) {\n this.orderService = orderService;\n }\n\n @Action(\"http://samples/RequestOrder\")\n public Order getOrder(OrderRequest orderRequest) {\n return orderService.getOrder(orderRequest.getId());\n }\n\n @Action(\"http://samples/CreateOrder\")\n public void order(Order order) {\n orderService.createOrder(order);\n }\n\n}\n----\n====\n\nThe preceding mapping routes requests that have a WS-Addressing `Action` of `http://samples/RequestOrder` to the `getOrder` method.\nRequests with `http://samples/CreateOrder` are routed to the `order` method.\n\nBy default, the `AnnotationActionEndpointMapping` supports both the 1.0 (May 2006), and the August 2004 editions of WS-Addressing.\nThese two versions are most popular and are interoperable with Axis 1 and 2, JAX-WS, XFire, Windows Communication Foundation (WCF), and Windows Services Enhancements (WSE) 3.0.\nIf necessary, specific versions of the spec can be injected into the `versions` property.\n\nIn addition to the `@Action` annotation, you can annotate the class with the `@Address` annotation.\nIf set, the value is compared to the `To` header property of the incoming message.\n\nFinally, there is the `messageSenders` property, which is required for sending response messages to non-anonymous, out-of-bound addresses.\nYou can set `MessageSender` implementations in this property, the same as you would on the `WebServiceTemplate`.\nSee <<client-transports>>.\n\n[[server-endpoint-interceptor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Using `AnnotationActionEndpointMapping`", "heading_level": 4, "file_order": 6, "section_index": 18, "content_hash": "baea1f66072774845b3d964c2592578f31fc855bfe697557f38939c12d96a0d6", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:ccd8d6645fa7cbc3d36c14c8e8bfc75e897bb57b3ba78930e84f9fa056280fc8", "content": "The endpoint mapping mechanism has the notion of endpoint interceptors.\nThese can be extremely useful when you want to apply specific functionality to certain requests -- for example, dealing with security-related SOAP headers or the logging of request and response message.\n\nEndpoint interceptors are typically defined by using a `<sws:interceptors>` element in your application context.\nIn this element, you can define endpoint interceptor beans that apply to all endpoints defined in that application context.\nAlternatively, you can use `<sws:payloadRoot>` or `<sws:soapAction>` elements to specify for which payload root name or SOAP action the interceptor should apply.\nThe following example shows how to do so:\n\n====\n[source,xml]\n----\n<sws:interceptors>\n <bean class=\"samples.MyGlobalInterceptor\"/>\n <sws:payloadRoot namespaceUri=\"http://www.example.com\">\n <bean class=\"samples.MyPayloadRootInterceptor\"/>\n </sws:payloadRoot>\n <sws:soapAction value=\"http://www.example.com/SoapAction\">\n <bean class=\"samples.MySoapActionInterceptor1\"/>\n <ref bean=\"mySoapActionInterceptor2\"/>\n </sws:soapAction>\n</sws:interceptors>\n\n<bean id=\"mySoapActionInterceptor2\" class=\"samples.MySoapActionInterceptor2\"/>\n----\n====\n\nIn the preceding example, we define one \"`global`\" interceptor (`MyGlobalInterceptor`) that intercepts all requests and responses.\nWe also define an interceptor that applies only to XML messages that have the `http://www.example.com` as a payload root namespace.\nWe could have defined a `localPart` attribute in addition to the `namespaceUri` to further limit the messages to which the interceptor applies.\nFinally, we define two interceptors that apply when the message has a `http://www.example.com/SoapAction` SOAP action.\nNotice how the second interceptor is actually a reference to a bean definition outside the `<interceptors>` element.\nYou can use bean references anywhere inside the `<interceptors>` element.\n\nWhen you use `@Configuration` classes, you can implement `WsConfigurer` to add interceptors:\n\n====\n[source,java]\n----\n@Configuration\n@EnableWs\npublic class MyWsConfiguration implements WsConfigurer {\n\n @Override\n public void addInterceptors(List<EndpointInterceptor> interceptors) {\n interceptors.add(new MyPayloadRootInterceptor());\n }\n\n}\n----\n====\n\nInterceptors must implement {spring-ws-api}/server/EndpointInterceptor.html[`EndpointInterceptor`].\nThis interface defines three methods, one that can be used for handling the request message *before* the actual endpoint is processed, one that can be used for handling a normal response message, and one that can be used for handling fault messages.\nThe second two are called *after* the endpoint is processed.\nThese three methods should provide enough flexibility to do all kinds of pre- and post-processing.\n\nThe `handleRequest(..)` method on the interceptor returns a boolean value.\nYou can use this method to interrupt or continue the processing of the invocation chain.\nWhen this method returns `true`, the endpoint processing chain will continue.\nWhen it returns `false`, the `MessageDispatcher` interprets this to mean that the interceptor itself has taken care of things and does not continue processing the other interceptors and the actual endpoint in the invocation chain.\nThe `handleResponse(..)` and `handleFault(..)` methods also have a boolean return value.\nWhen these methods return `false`, the response will not be sent back to the client.\n\nThere are a number of standard `EndpointInterceptor` implementations that you can use in your Web service.\nAdditionally, there is the `XwsSecurityInterceptor`, which is described in <<security-xws-security-interceptor>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Intercepting Requests -- the `EndpointInterceptor` Interface", "heading_level": 3, "file_order": 6, "section_index": 19, "content_hash": "ccd8d6645fa7cbc3d36c14c8e8bfc75e897bb57b3ba78930e84f9fa056280fc8", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:138c3313a0f9cb6eb589882af7b88fe4c0398f4056de07a75d38868b31c26809", "content": "When developing a web service, it can be useful to log the incoming and outgoing XML messages.\nSpring WS facilitates this with the `PayloadLoggingInterceptor` and `SoapEnvelopeLoggingInterceptor` classes.\nThe former logs only the payload of the message.\nThe latter logs the entire SOAP envelope, including SOAP headers.\nThe following example shows how to define the `PayloadLoggingInterceptor` in an endpoint mapping:\n\n====\n[source,xml]\n----\n <sws:interceptors>\n <bean class=\"org.springframework.ws.server.endpoint.interceptor.PayloadLoggingInterceptor\"/>\n </sws:interceptors>\n----\n====\n\nBoth of these interceptors have two properties, `logRequest` and `logResponse`, which can be set to `false` to disable logging for either request or response messages.\n\nYou could use the `WsConfigurer` approach, as described earlier, for the `PayloadLoggingInterceptor` as well.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "`PayloadLoggingInterceptor` and `SoapEnvelopeLoggingInterceptor`", "heading_level": 4, "file_order": 6, "section_index": 20, "content_hash": "138c3313a0f9cb6eb589882af7b88fe4c0398f4056de07a75d38868b31c26809", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:fb6a3c04c26c880381d2d1132541e514813cb87e8bfd0ab72def256ca5a893ab", "content": "One of the benefits of using a contract-first development style is that we can use the schema to validate incoming and outgoing XML messages.\nSpring-WS facilitates this with the `PayloadValidatingInterceptor`.\nThis interceptor requires a reference to one or more W3C XML or RELAX NG schemas and can be set to validate requests, responses, or both.\n\n[NOTE]\n====\nWhile request validation may sound like a good idea, it makes the resulting Web service very strict.\nUsually, it is not really important whether the request validates, only if the endpoint can get sufficient information to fulfill a request.\nValidating the response is a good idea, because the endpoint should adhere to its schema.\nRemember Postel's Law: \"Be conservative in what you do; be liberal in what you accept from others.\"\n====\n\nThe following example uses the `PayloadValidatingInterceptor`.\nIn this example, we use the schema in `/WEB-INF/orders.xsd` to validate the response but not the request.\nNote that the `PayloadValidatingInterceptor` can also accept multiple schemas by setting the `schemas` property.\n\n====\n[source,xml]\n----\n<bean id=\"validatingInterceptor\"\n class=\"org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptor\">\n <property name=\"schema\" value=\"/WEB-INF/orders.xsd\"/>\n <property name=\"validateRequest\" value=\"false\"/>\n <property name=\"validateResponse\" value=\"true\"/>\n</bean>\n----\n====\n\nOf course, you could use the `WsConfigurer` approach, as described earlier, for the `PayloadValidatingInterceptor` as well.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "`PayloadValidatingInterceptor`", "heading_level": 4, "file_order": 6, "section_index": 21, "content_hash": "fb6a3c04c26c880381d2d1132541e514813cb87e8bfd0ab72def256ca5a893ab", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:fc4faa8561deab429b8b71a85f375427347af08283882e4ea692ff9ae5af5d34", "content": "To transform the payload to another XML format, Spring-WS offers the `PayloadTransformingInterceptor`.\nThis endpoint interceptor is based on XSLT style sheets and is especially useful when supporting multiple versions of a web service, because you can transform the older message format to the newer format.\nThe following example uses the `PayloadTransformingInterceptor`:\n\n====\n[source,xml]\n----\n<bean id=\"transformingInterceptor\"\n class=\"org.springframework.ws.server.endpoint.interceptor.PayloadTransformingInterceptor\">\n <property name=\"requestXslt\" value=\"/WEB-INF/oldRequests.xslt\"/>\n <property name=\"responseXslt\" value=\"/WEB-INF/oldResponses.xslt\"/>\n</bean>\n----\n====\n\nIn the preceding example, we transform requests by using `/WEB-INF/oldRequests.xslt` and response messages by using `/WEB-INF/oldResponses.xslt`.\nNote that, since endpoint interceptors are registered at the endpoint-mapping level, you can create an endpoint mapping that applies to the \"`old style`\" messages and add the interceptor to that mapping.\nHence, the transformation applies only to these \"`old style`\" message.\n\nYou could use the `WsConfigurer` approach, as described earlier, for the `PayloadTransformingInterceptor` as well.\n\n[[server-endpoint-exception-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Using `PayloadTransformingInterceptor`", "heading_level": 4, "file_order": 6, "section_index": 22, "content_hash": "fc4faa8561deab429b8b71a85f375427347af08283882e4ea692ff9ae5af5d34", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:691b1a1c2e0c68d000c43f49ebafbade50a25309fed9099adc6e4d671729c418", "content": "Spring-WS provides {spring-ws-api}/server/EndpointExceptionResolver.html[`EndpointExceptionResolver`] implementations to ease the pain of unexpected exceptions occurring while your message is being processed by an endpoint that matched the request.\nEndpoint exception resolvers somewhat resemble the exception mappings that can be defined in the web application descriptor `web.xml`.\nHowever, they provide a more flexible way to handle exceptions.\nThey provide information about what endpoint was invoked when the exception was thrown.\nFurthermore, a programmatic way of handling exceptions gives you many more options for how to respond appropriately.\nRather than expose the innards of your application by giving an exception and stack trace, you can handle the exception any way you want -- for example, by returning a SOAP fault with a specific fault code and string.\n\nEndpoint exception resolvers are automatically picked up by the `MessageDispatcher`, so no explicit configuration is necessary.\n\nBesides implementing the `EndpointExceptionResolver` interface, which is only a matter of implementing the `resolveException(MessageContext, endpoint, Exception)` method, you may also use one of the provided implementations.\n\nThe simplest implementation is the `SimpleSoapExceptionResolver`, which creates a SOAP 1.1 Server or SOAP 1.2 Receiver fault and uses the exception message as the fault string.\nYou can subclass it to customize the fault, as shown in the following example:\n\n[source,java]\n----\npublic class CustomSoapExceptionResolver extends SimpleSoapExceptionResolver {\n\n\tprivate final Transformer transformer;\n\n\tpublic CustomSoapExceptionResolver(Transformer transformer) {\n this.transformer = transformer;\n\t}\n\n\t@Override\n\tprotected void customizeFault(MessageContext messageContext, Object endpoint, Exception exception,\n SoapFault fault) {\n SoapFaultDetail faultDetail = fault.addFaultDetail();\n try {\n this.transformer.transform(new StringSource(\"\"\"\n <ns2:YourCustomException xmlns:ns2=\"http://serviceendpoint/\">\n <errorCode>Your custom error code</errorCode>\n <systemMessage>A system message</systemMessage>\n </ns2:YourCustomException >\n \"\"\"), faultDetail.getResult());\n }\n catch (TransformerException ex) {\n throw new IllegalArgumentException(\"Failed to write detail\", ex);\n }\n\n\t}\n}\n----\n\nThe `SimpleSoapExceptionResolver` is the default, but it can be overridden by explicitly adding another resolver.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Handling Exceptions", "heading_level": 2, "file_order": 6, "section_index": 23, "content_hash": "691b1a1c2e0c68d000c43f49ebafbade50a25309fed9099adc6e4d671729c418", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:7a78714d35ccaf3285185acee6f5086783bcdab79b0342a0140ccddb2889b786", "content": "The `SoapFaultMappingExceptionResolver` is a more sophisticated implementation.\nThis resolver lets you take the class name of any exception that might be thrown and map it to a SOAP Fault:\n\n====\n[source,xml]\n----\n<beans>\n <bean id=\"exceptionResolver\"\n class=\"org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver\">\n <property name=\"defaultFault\" value=\"SERVER\"/>\n <property name=\"exceptionMappings\">\n <value>\n org.springframework.oxm.ValidationFailureException=CLIENT,Invalid request\n </value>\n </property>\n </bean>\n</beans>\n----\n====\n\nThe key values and default endpoint use a format of `faultCode,faultString,locale`, where only the fault code is required.\nIf the fault string is not set, it defaults to the exception message.\nIf the language is not set, it defaults to English.\nThe preceding configuration maps exceptions of type `ValidationFailureException` to a client-side SOAP fault with a fault string of `Invalid request`, as follows:\n\n====\n[source,xml,subs=\"verbatim,+quotes\"]\n----\n<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\">\n <SOAP-ENV:Body>\n *<SOAP-ENV:Fault>\n <faultcode>SOAP-ENV:Client</faultcode>\n <faultstring>Invalid request</faultstring>\n </SOAP-ENV:Fault>*\n </SOAP-ENV:Body>\n</SOAP-ENV:Envelope>\n----\n====\n\nIf any other exception occurs, it returns the default fault: a server-side fault with the exception message as the fault string.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "`SoapFaultMappingExceptionResolver`", "heading_level": 3, "file_order": 6, "section_index": 24, "content_hash": "7a78714d35ccaf3285185acee6f5086783bcdab79b0342a0140ccddb2889b786", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:c18ea17c55a2ebe6491a8ac02ffacbae020776a0ffd401462ba15cfc2f7298d1", "content": "You can also annotate exception classes with the `@SoapFault` annotation, to indicate the SOAP fault that should be returned whenever that exception is thrown.\nFor these annotations to be picked up, you need to add the `SoapFaultAnnotationExceptionResolver` to your application context. The elements of the annotation include a fault code enumeration, fault string or reason, and language.\nThe following example shows such an exception:\n\n====\n[source,java]\n----\npackage samples;\n\nimport org.springframework.ws.soap.server.endpoint.annotation.FaultCode;\nimport org.springframework.ws.soap.server.endpoint.annotation.SoapFault;\n\n@SoapFault(faultCode = FaultCode.SERVER)\npublic class MyBusinessException extends Exception {\n\n public MyClientException(String message) {\n super(message);\n }\n}\n----\n====\n\nWhenever the `MyBusinessException` is thrown with the constructor string `\"Oops!\"` during endpoint invocation, it results in the following response:\n\n====\n[source,xml]\n----\n<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\">\n <SOAP-ENV:Body>\n <SOAP-ENV:Fault>\n <faultcode>SOAP-ENV:Server</faultcode>\n <faultstring>Oops!</faultstring>\n </SOAP-ENV:Fault>\n </SOAP-ENV:Body>\n</SOAP-ENV:Envelope>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Using `SoapFaultAnnotationExceptionResolver`", "heading_level": 3, "file_order": 6, "section_index": 25, "content_hash": "c18ea17c55a2ebe6491a8ac02ffacbae020776a0ffd401462ba15cfc2f7298d1", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:a9918a8680193393e9eadc3723f230c68764cd5374f179aa9058bf3cdc99b4d3", "content": "When it comes to testing your Web service endpoints, you have two possible approaches:\n\n* Write Unit Tests, where you provide (mock) arguments for your endpoint to consume.\nThe advantage of this approach is that it is quite easy to accomplish (especially for classes annotated with `@Endpoint`).\nThe disadvantage is that you are not really testing the exact content of the XML messages that are sent over the wire.\n* Write Integrations Tests, which do test the contents of the message.\n\nThe first approach can easily be accomplished with mocking frameworks such as Mockito, EasyMock, and others.\nThe next section focuses on writing integration tests.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Server-side Testing", "heading_level": 2, "file_order": 6, "section_index": 26, "content_hash": "a9918a8680193393e9eadc3723f230c68764cd5374f179aa9058bf3cdc99b4d3", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:60c69d963e2fadb16a23328f409a686d9cdc806e84e51800ac410f6c85be03ac", "content": "Spring-WS has support for creating endpoint integration tests.\nIn this context, an endpoint is a class that handles (SOAP) messages (see <<server-endpoints>>).\n\nThe integration test support lives in the `org.springframework.ws.test.server` package.\nThe core class in that package is the `MockWebServiceClient`.\nThe underlying idea is that this client creates a request message and then sends it over to the endpoints that are configured in a standard `MessageDispatcherServlet` application context (see <<message-dispatcher-servlet>>).\nThese endpoints handle the message and create a response.\nThe client then receives this response and verifies it against registered expectations.\n\nThe typical usage of the `MockWebServiceClient` is: .\n\n. Create a `MockWebServiceClient` instance by calling `MockWebServiceClient.createClient(ApplicationContext)` or `MockWebServiceClient.createClient(WebServiceMessageReceiver, WebServiceMessageFactory)`.\n. Send request messages by calling `sendRequest(RequestCreator)`, possibly by using the default `RequestCreator` implementations provided in `RequestCreators` (which can be statically imported).\n. Set up response expectations by calling `andExpect(ResponseMatcher)`, possibly by using the default `ResponseMatcher` implementations provided in `ResponseMatchers` (which can be statically imported).\nMultiple expectations can be set up by chaining `andExpect(ResponseMatcher)` calls.\n\n[NOTE]\n====\n`MockWebServiceClient` (and related classes) offers a \"`fluent`\" API, so you can typically use the code-completion features in your IDE to guide you through the process of setting up the mock server.\n====\n\n[NOTE]\n====\nYou can rely on the standard logging features available in Spring-WS in your unit tests.\nSometimes, it might be useful to inspect the request or response message to find out why a particular tests failed.\nSee <<logging>> for more information.\n====\n\nConsider, for example, the following web service endpoint class:\n\n====\n[source,java]\n----\nimport org.springframework.ws.server.endpoint.annotation.Endpoint;\nimport org.springframework.ws.server.endpoint.annotation.RequestPayload;\nimport org.springframework.ws.server.endpoint.annotation.ResponsePayload;\n\n@Endpoint // <1>\npublic class CustomerEndpoint {\n\n @ResponsePayload // <2>\n public CustomerCountResponse getCustomerCount(\n @RequestPayload CustomerCountRequest request) {\n CustomerCountResponse response = new CustomerCountResponse();\n response.setCustomerCount(10);\n return response;\n }\n\n}\n----\n\n<1> The `CustomerEndpoint` in annotated with `@Endpoint`.\nSee <<server-endpoints>>.\n<2> The `getCustomerCount()` method takes a `CustomerCountRequest` as its argument and returns a `CustomerCountResponse`.\nBoth of these classes are objects supported by a marshaller.\nFor instance, they can have a `@XmlRootElement` annotation to be supported by JAXB2.\n====\n\nThe following example shows a typical test for `CustomerEndpoint`:\n\n====\n[source,java]\n----\nimport javax.xml.transform.Source;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.xml.transform.StringSource;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport org.springframework.ws.test.server.MockWebServiceClient;\nimport static org.springframework.ws.test.server.RequestCreators.*;\nimport static org.springframework.ws.test.server.ResponseMatchers.*;\n\n@RunWith(SpringJUnit4ClassRunner.class) // <1>\n@ContextConfiguration(\"spring-ws-servlet.xml\")\npublic class CustomerEndpointIntegrationTest {\n\n @Autowired\n private ApplicationContext applicationContext; // <2>\n\n private MockWebServiceClient mockClient;\n\n @Before\n public void createClient() {\n mockClient = MockWebServiceClient.createClient(applicationContext); // <3>\n }\n\n @Test\n public void customerEndpoint() throws Exception {\n Source requestPayload = new StringSource(\"\"\"\n <customerCountRequest xmlns='http://springframework.org/spring-ws'>\n <customerName>John Doe</customerName>\n </customerCountRequest>\n \"\"\");\n Source responsePayload = new StringSource(\"\"\"\n <customerCountResponse xmlns='http://springframework.org/spring-ws'>\n <customerCount>10</customerCount>\n </customerCountResponse>\n \"\"\");\n\n mockClient.sendRequest(withPayload(requestPayload)). // <4>\n andExpect(payload(responsePayload));\n }\n}\n----\n\n<1> This test uses the standard testing facilities provided in the Spring Framework.\nThis is not required but is generally the easiest way to set up the test.\n<2> The application context is a standard Spring-WS application context (see <<message-dispatcher-servlet>>), read from `spring-ws-servlet.xml`.\nIn this case, the application context contains a bean definition for `CustomerEndpoint` (or perhaps a `<context:component-scan />` is used).\n<3> In a `@Before` method, we create a `MockWebServiceClient` by using the `createClient` factory method.\n<4> We send a request by calling `sendRequest()` with a `withPayload()` `RequestCreator` provided by the statically imported `RequestCreators` (see <<server-test-request-creator>>).\nWe also set up response expectations by calling `andExpect()` with a `payload()` `ResponseMatcher` provided by the statically imported `ResponseMatchers` (see <<server-test-response-matcher>>).\n\nThis part of the test might look a bit confusing, but the code completion features of your IDE are of great help.\nAfter typing `sendRequest(`, your IDE can provide you with a list of possible request creating strategies, provided you statically imported `RequestCreators`.\nThe same applies to `andExpect()`, provided you statically imported `ResponseMatchers`.\n====\n\n[[server-test-request-creator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Writing server-side integration tests", "heading_level": 3, "file_order": 6, "section_index": 27, "content_hash": "60c69d963e2fadb16a23328f409a686d9cdc806e84e51800ac410f6c85be03ac", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:8f63449e38e8475783906456a04aa4ae6c3e494c06fe60749f2d3376bacc2d3a", "content": "Initially, the `MockWebServiceClient` needs to create a request message for the endpoint to consume.\nThe client uses the `RequestCreator` strategy interface for this purpose:\n\n====\n[source,java]\n----\npublic interface RequestCreator {\n\n WebServiceMessage createRequest(WebServiceMessageFactory messageFactory)\n throws IOException;\n\n}\n----\n====\n\nYou can write your own implementations of this interface, creating a request message by using the message factory, but you certainly do not have to.\nThe `RequestCreators` class provides a way to create a `RequestCreator` based on a given payload in the `withPayload()` method.\nYou typically statically import `RequestCreators`.\n\n[[server-test-response-matcher]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Using `RequestCreator` and `RequestCreators`", "heading_level": 3, "file_order": 6, "section_index": 28, "content_hash": "8f63449e38e8475783906456a04aa4ae6c3e494c06fe60749f2d3376bacc2d3a", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:d02fdd49c06b44bf876cc5796a58fba5bfd3efd4565f2ee7f3fac9673a6a27d3", "content": "When the request message has been processed by the endpoint and a response has been received, the `MockWebServiceClient` can verify whether this response message meets certain expectations.\nThe client uses the `ResponseMatcher` strategy interface for this purpose:\n\n====\n[source,java]\n----\npublic interface ResponseMatcher {\n\n void match(WebServiceMessage request, WebServiceMessage response)\n throws IOException, AssertionError;\n\n}\n----\n====\n\nOnce again, you can write your own implementations of this interface, throwing `AssertionError` instances when the message does not meet your expectations, but you certainly do not have to, as the `ResponseMatchers` class provides standard `ResponseMatcher` implementations for you to use in your tests.\nYou typically statically import this class.\n\nThe `ResponseMatchers` class provides the following response matchers:\n\n[cols=\"2\", options=\"header\"]\n|===\n| `ResponseMatchers` method\n| Description\n\n| `payload()`\n| Expects a given response payload.\nMay include https://github.com/xmlunit/user-guide/wiki/Placeholders[XMLUnit Placeholders].\n\n| `validPayload()`\n| Expects the response payload to validate against given XSD schemas.\n\n| `xpath()`\n| Expects a given XPath expression to exist, not exist, or evaluate to a given value.\n\n| `soapHeader()`\n| Expects a given SOAP header to exist in the response message.\n\n| `soapEnvelope()`\n| Expects a given SOAP payload.\nMay include https://github.com/xmlunit/user-guide/wiki/Placeholders[XMLUnit Placeholders].\n\n| `noFault()`\n| Expects that the response message does not contain a SOAP Fault.\n\n| `mustUnderstandFault()`, `clientOrSenderFault()`, `serverOrReceiverFault()`, and `versionMismatchFault()`\n| Expects the response message to contain a specific SOAP Fault.\n|===\n\nYou can set up multiple response expectations by chaining `andExpect()` calls:\n\n====\n[source,java]\n----\nmockClient.sendRequest(...).\n andExpect(payload(expectedResponsePayload)).\n andExpect(validPayload(schemaResource));\n----\n====\n\nFor more information on the response matchers provided by `ResponseMatchers`, see the {spring-ws-api}/test/server/ResponseMatchers.html[Javadoc].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/server.adoc", "title": "server", "heading": "Using `ResponseMatcher` and `ResponseMatchers`", "heading_level": 3, "file_order": 6, "section_index": 29, "content_hash": "d02fdd49c06b44bf876cc5796a58fba5bfd3efd4565f2ee7f3fac9673a6a27d3", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/server.adoc"}}
{"id": "sha256:04d9c3f99b25f8e73731e5a910f38c498b4a828e80fab128e54f3dd0b1b58df2", "content": "[[tutorial]]\n\nThis tutorial shows you how to write <<why-contract-first,contract-first web services>> -- that is, how to develop web services that start with the XML Schema or WSDL contract first followed by the Java code second.\nSpring-WS focuses on this development style, and this tutorial should help you get started.\nNote that the first part of this tutorial contains almost no Spring-WS specific information.\nIt is mostly about XML, XSD, and WSDL.\nThe <<tutorial-creating-project,second part>> focuses on implementing this contract with Spring-WS .\n\nThe most important thing when doing contract-first web service development is to think in terms of XML.\nThis means that Java language concepts are of lesser importance.\nIt is the XML that is sent across the wire, and you should focus on that.\nJava being used to implement the web service is an implementation detail.\n\nIn this tutorial, we define a web service that is created by a Human Resources department.\nClients can send holiday request forms to this service to book a holiday.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "tutorial", "heading_level": 1, "file_order": 7, "section_index": 0, "content_hash": "04d9c3f99b25f8e73731e5a910f38c498b4a828e80fab128e54f3dd0b1b58df2", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:f2146f5b4a7a5257c2d56f525e2b9adfe0f3123466830d25d849e09be1f1db1f", "content": "In this section, we focus on the actual XML messages that are sent to and from the web service.\nWe start out by determining what these messages look like.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "Messages", "heading_level": 2, "file_order": 7, "section_index": 1, "content_hash": "f2146f5b4a7a5257c2d56f525e2b9adfe0f3123466830d25d849e09be1f1db1f", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:c3ab11a83c96d94b9ae3f83969b5f670581bf3f0b5d1ef8fc0549019c29bc10b", "content": "In the scenario, we have to deal with holiday requests, so it makes sense to determine what a holiday looks like in XML:\n\n====\n[source,xml]\n----\n<Holiday xmlns=\"http://mycompany.com/hr/schemas\">\n <StartDate>2006-07-03</StartDate>\n <EndDate>2006-07-07</EndDate>\n</Holiday>\n----\n====\n\nA holiday consists of a start date and an end date.\nWe have also decided to use the standard https://www.cl.cam.ac.uk/~mgk25/iso-time.html[ISO 8601] date format for the dates, because that saves a lot of parsing hassle.\nWe have also added a namespace to the element, to make sure our elements can be used within other XML documents.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "Holiday", "heading_level": 3, "file_order": 7, "section_index": 2, "content_hash": "c3ab11a83c96d94b9ae3f83969b5f670581bf3f0b5d1ef8fc0549019c29bc10b", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:d50694ec85a7019de93a38dc9dc34cfce3a27471904e92b38a878c78d8bcfef6", "content": "There is also the notion of an employee in the scenario.\nHere is what it looks like in XML:\n\n====\n[source,xml]\n----\n<Employee xmlns=\"http://mycompany.com/hr/schemas\">\n <Number>42</Number>\n <FirstName>Arjen</FirstName>\n <LastName>Poutsma</LastName>\n</Employee>\n----\n====\n\nWe have used the same namespace as before.\nIf this `<Employee/>` element could be used in other scenarios, it might make sense to use a different namespace, such as `http://example.com/employees/schemas`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "Employee", "heading_level": 3, "file_order": 7, "section_index": 3, "content_hash": "d50694ec85a7019de93a38dc9dc34cfce3a27471904e92b38a878c78d8bcfef6", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:c17fc742190536ccf6c911ac4ec8104022d5cfea4c2ea651d08763ad7c465af4", "content": "Both the `holiday` element and the `employee` element can be put in a `<HolidayRequest/>`:\n\n====\n[source,xml]\n----\n<HolidayRequest xmlns=\"http://mycompany.com/hr/schemas\">\n <Holiday>\n <StartDate>2006-07-03</StartDate>\n <EndDate>2006-07-07</EndDate>\n </Holiday>\n <Employee>\n <Number>42</Number>\n <FirstName>Arjen</FirstName>\n <LastName>Poutsma</LastName>\n </Employee>\n</HolidayRequest>\n----\n====\n\nThe order of the two elements does not matter: `<Employee/>` could have been the first element.\nWhat matters is that all the data is there.\nIn fact, the data is the only thing that is important: we take a data-driven approach.\n\n[[tutorial.xsd]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "HolidayRequest", "heading_level": 3, "file_order": 7, "section_index": 4, "content_hash": "c17fc742190536ccf6c911ac4ec8104022d5cfea4c2ea651d08763ad7c465af4", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:0821190fe7953a1c205b6b1785343d58a3ea35c055df481b9312c5fdbe098180", "content": "Now that we have seen some examples of the XML data that we can use, it makes sense to formalize this into a schema.\nThis data contract defines the message format we accept.\nThere are four different ways of defining such a contract for XML:\n\n* DTDs.\n* https://www.w3.org/XML/Schema[XML Schema (XSD)].\n* http://www.relaxng.org/[RELAX NG].\n* http://www.schematron.com/[Schematron].\n\nDTDs have limited namespace support, so they are not suitable for web services.\nRelax NG and Schematron are easier than XML Schema.\nUnfortunately, they are not so widely supported across platforms.\nAs a result, we use XML Schema.\n\nBy far, the easiest way to create an XSD is to infer it from sample documents.\nAny good XML editor or Java IDE offers this functionality.\nBasically, these tools use some sample XML documents to generate a schema that validates them all.\nThe end result certainly needs to be polished up, but it is a great starting point.\n\nUsing the sample described earlier, we end up with the following generated schema:\n\n====\n[source,xml]\n----\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n elementFormDefault=\"qualified\"\n targetNamespace=\"http://mycompany.com/hr/schemas\"\n xmlns:hr=\"http://mycompany.com/hr/schemas\">\n <xs:element name=\"HolidayRequest\">\n <xs:complexType>\n <xs:sequence>\n <xs:element ref=\"hr:Holiday\"/>\n <xs:element ref=\"hr:Employee\"/>\n </xs:sequence>\n </xs:complexType>\n </xs:element>\n <xs:element name=\"Holiday\">\n <xs:complexType>\n <xs:sequence>\n <xs:element ref=\"hr:StartDate\"/>\n <xs:element ref=\"hr:EndDate\"/>\n </xs:sequence>\n </xs:complexType>\n </xs:element>\n <xs:element name=\"StartDate\" type=\"xs:NMTOKEN\"/>\n <xs:element name=\"EndDate\" type=\"xs:NMTOKEN\"/>\n <xs:element name=\"Employee\">\n <xs:complexType>\n <xs:sequence>\n <xs:element ref=\"hr:Number\"/>\n <xs:element ref=\"hr:FirstName\"/>\n <xs:element ref=\"hr:LastName\"/>\n </xs:sequence>\n </xs:complexType>\n </xs:element>\n <xs:element name=\"Number\" type=\"xs:integer\"/>\n <xs:element name=\"FirstName\" type=\"xs:NCName\"/>\n <xs:element name=\"LastName\" type=\"xs:NCName\"/>\n</xs:schema>\n----\n====\n\nThis generated schema can be improved.\nThe first thing to notice is that every type has a root-level element declaration.\nThis means that the web service should be able to accept all of these elements as data.\nThis is not desirable: We want to accept only a `<HolidayRequest/>`.\nBy removing the wrapping element tags (thus keeping the types) and inlining the results, we can accomplish this, as follows:\n\n====\n[source,xml]\n----\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n xmlns:hr=\"http://mycompany.com/hr/schemas\"\n elementFormDefault=\"qualified\"\n targetNamespace=\"http://mycompany.com/hr/schemas\">\n <xs:element name=\"HolidayRequest\">\n <xs:complexType>\n <xs:sequence>\n <xs:element name=\"Holiday\" type=\"hr:HolidayType\"/>\n <xs:element name=\"Employee\" type=\"hr:EmployeeType\"/>\n </xs:sequence>\n </xs:complexType>\n </xs:element>\n <xs:complexType name=\"HolidayType\">\n <xs:sequence>\n <xs:element name=\"StartDate\" type=\"xs:NMTOKEN\"/>\n <xs:element name=\"EndDate\" type=\"xs:NMTOKEN\"/>\n </xs:sequence>\n </xs:complexType>\n <xs:complexType name=\"EmployeeType\">\n <xs:sequence>\n <xs:element name=\"Number\" type=\"xs:integer\"/>\n <xs:element name=\"FirstName\" type=\"xs:NCName\"/>\n <xs:element name=\"LastName\" type=\"xs:NCName\"/>\n </xs:sequence>\n </xs:complexType>\n</xs:schema>\n----\n====\n\nThe schema still has one problem: With a schema like this, you can expect the following message to validate:\n\n====\n[source,xml]\n----\n<HolidayRequest xmlns=\"http://mycompany.com/hr/schemas\">\n <Holiday>\n <StartDate>this is not a date</StartDate>\n <EndDate>neither is this</EndDate>\n </Holiday>\n PlainText Section qName:lineannotation level:4, chunks:[<, !-- ... --, >] attrs:[:]\n</HolidayRequest>\n----\n====\n\nClearly, we must make sure that the start and end date are really dates.\nXML Schema has an excellent built-in `date` type that we can use.\nWe also change the `NCName` s to `string` instances.\nFinally, we change the `sequence` in `<HolidayRequest/>` to `all`.\nThis tells the XML parser that the order of `<Holiday/>` and `<Employee/>` is not significant.\nOur final XSD now looks like the following listing:\n\n====\n[source,xml]\n----\n<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n xmlns:hr=\"http://mycompany.com/hr/schemas\"\n elementFormDefault=\"qualified\"\n targetNamespace=\"http://mycompany.com/hr/schemas\">\n <xs:element name=\"HolidayRequest\">\n <xs:complexType>\n <xs:all>\n <xs:element name=\"Holiday\" type=\"hr:HolidayType\"/> <!--1-->\n <xs:element name=\"Employee\" type=\"hr:EmployeeType\"/> <!--1-->\n </xs:all>\n </xs:complexType>\n </xs:element>\n <xs:complexType name=\"HolidayType\">\n <xs:sequence>\n <xs:element name=\"StartDate\" type=\"xs:date\"/> <!--2-->\n <xs:element name=\"EndDate\" type=\"xs:date\"/> <!--2-->\n </xs:sequence>\n </xs:complexType>\n <xs:complexType name=\"EmployeeType\">\n <xs:sequence>\n <xs:element name=\"Number\" type=\"xs:integer\"/>\n <xs:element name=\"FirstName\" type=\"xs:string\"/> <!--3-->\n <xs:element name=\"LastName\" type=\"xs:string\"/> <!--3-->\n </xs:sequence>\n </xs:complexType>\n</xs:schema>\n----\n\n<1> `all` tells the XML parser that the order of `<Holiday/>` and `<Employee/>` is not significant.\n<2> We use the `xs:date` data type (which consist of a year, a month, and a day) for `<StartDate/>` and `<EndDate/>`.\n<3> `xs:string` is used for the first and last names.\n====\n\nWe store this file as `hr.xsd`.\n\n[[tutorial-service-contract]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "Data Contract", "heading_level": 2, "file_order": 7, "section_index": 5, "content_hash": "0821190fe7953a1c205b6b1785343d58a3ea35c055df481b9312c5fdbe098180", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:71c93ba7c4b8d4fd1a3de21a365feab0a9f84b02903d6c39b9a880b56a04e0a4", "content": "A service contract is generally expressed as a https://www.w3.org/TR/wsdl[WSDL] file.\nNote that, in Spring-WS, writing the WSDL by hand is not required.\nBased on the XSD and some conventions, Spring-WS can create the WSDL for you, as explained in the section entitled <<tutorial-implementing-endpoint>>.\nThe remainder of this section shows how to write WSDL by hand.\nYou may want to skip to <<tutorial-creating-project,the next section>>.\n\nWe start our WSDL with the standard preamble and by importing our existing XSD.\nTo separate the schema from the definition, we use a separate namespace for the WSDL definitions: `http://mycompany.com/hr/definitions`.\nThe following listing shows the preamble:\n\n====\n[source,xml]\n----\n<wsdl:definitions xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\"\n xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\"\n xmlns:schema=\"http://mycompany.com/hr/schemas\"\n xmlns:tns=\"http://mycompany.com/hr/definitions\"\n targetNamespace=\"http://mycompany.com/hr/definitions\">\n <wsdl:types>\n <xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n <xsd:import namespace=\"http://mycompany.com/hr/schemas\" schemaLocation=\"hr.xsd\"/>\n </xsd:schema>\n </wsdl:types>\n----\n====\n\nNext, we add our messages based on the written schema types.\nWe only have one message, the `<HolidayRequest/>` we put in the schema:\n\n====\n[source,xml]\n----\n <wsdl:message name=\"HolidayRequest\">\n <wsdl:part element=\"schema:HolidayRequest\" name=\"HolidayRequest\"/>\n </wsdl:message>\n----\n====\n\nWe add the message to a port type as an operation:\n\n====\n[source,xml]\n----\n <wsdl:portType name=\"HumanResource\">\n <wsdl:operation name=\"Holiday\">\n <wsdl:input message=\"tns:HolidayRequest\" name=\"HolidayRequest\"/>\n </wsdl:operation>\n </wsdl:portType>\n----\n====\n\nThat message finishes the abstract part of the WSDL (the interface, as it were) and leaves the concrete part.\nThe concrete part consists of a `binding` (which tells the client how to invoke the operations you have just defined) and a `service` (which tells the client where to invoke it).\n\nAdding a concrete part is pretty standard.\nTo do so, refer to the abstract part you defined previously, make sure you use `document/literal` for the `soap:binding` elements (`rpc/encoded` is deprecated), pick a `soapAction` for the operation (in this case, `http://mycompany.com/RequestHoliday`, but any URI works), and determine the `location` URL where you want the request to arrive (in this case, `http://mycompany.com/humanresources`):\n\n====\n[source,xml]\n----\n<wsdl:definitions xmlns:wsdl=\"http://schemas.xmlsoap.org/wsdl/\"\n xmlns:soap=\"http://schemas.xmlsoap.org/wsdl/soap/\"\n xmlns:schema=\"http://mycompany.com/hr/schemas\"\n xmlns:tns=\"http://mycompany.com/hr/definitions\"\n targetNamespace=\"http://mycompany.com/hr/definitions\">\n <wsdl:types>\n <xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n <xsd:import namespace=\"http://mycompany.com/hr/schemas\" <!--1-->\n schemaLocation=\"hr.xsd\"/>\n </xsd:schema>\n </wsdl:types>\n <wsdl:message name=\"HolidayRequest\"> <!--2-->\n <wsdl:part element=\"schema:HolidayRequest\" name=\"HolidayRequest\"/> <!--3-->\n </wsdl:message>\n <wsdl:portType name=\"HumanResource\"> <!--4-->\n <wsdl:operation name=\"Holiday\">\n <wsdl:input message=\"tns:HolidayRequest\" name=\"HolidayRequest\"/> <!--2-->\n </wsdl:operation>\n </wsdl:portType>\n <wsdl:binding name=\"HumanResourceBinding\" type=\"tns:HumanResource\"> <!--4--><!--5-->\n <soap:binding style=\"document\" <!--6-->\n transport=\"http://schemas.xmlsoap.org/soap/http\"/> <!--7-->\n <wsdl:operation name=\"Holiday\">\n <soap:operation soapAction=\"http://mycompany.com/RequestHoliday\"/> <!--8-->\n <wsdl:input name=\"HolidayRequest\">\n <soap:body use=\"literal\"/> <!--6-->\n </wsdl:input>\n </wsdl:operation>\n </wsdl:binding>\n <wsdl:service name=\"HumanResourceService\">\n <wsdl:port binding=\"tns:HumanResourceBinding\" name=\"HumanResourcePort\"> <!--5-->\n <soap:address location=\"http://localhost:8080/holidayService/\"/> <!--9-->\n </wsdl:port>\n </wsdl:service>\n</wsdl:definitions>\n----\n\n<1> We import the schema defined in <<tutorial.xsd>>.\n<2> We define the `HolidayRequest` message, which gets used in the `portType`.\n<3> The `HolidayRequest` type is defined in the schema.\n<4> We define the `HumanResource` port type, which gets used in the `binding`.\n<5> We define the `HumanResourceBinding` binding, which gets used in the `port`.\n<6> We use a document/literal style.\n<7> The literal `http://schemas.xmlsoap.org/soap/http` signifies a HTTP transport.\n<8> The `soapAction` attribute signifies the `SOAPAction` HTTP header that will be sent with every request.\n<9> The `http://localhost:8080/holidayService/` address is the URL where the web service can be invoked.\n====\n\nThe preceding listing shows the final WSDL.\nWe describe how to implement the resulting schema and WSDL in the next section.\n\n[[tutorial-creating-project]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "Service Contract", "heading_level": 2, "file_order": 7, "section_index": 6, "content_hash": "71c93ba7c4b8d4fd1a3de21a365feab0a9f84b02903d6c39b9a880b56a04e0a4", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:cae29a95955903c0368b70f69a9ccea1f9554b055b96ba3ee7863281946a479a", "content": "In this section, we use https://maven.apache.org/[Maven] to create the initial project structure for us.\nDoing so is not required but greatly reduces the amount of code we have to write to set up our HolidayService.\n\nThe following command creates a Maven web application project for us by using the Spring-WS archetype (that is, project template):\n\n====\n----\nmvn archetype:create -DarchetypeGroupId=org.springframework.ws \\\n -DarchetypeArtifactId=spring-ws-archetype \\\n -DarchetypeVersion= \\\n -DgroupId=com.mycompany.hr \\\n -DartifactId=holidayService\n----\n====\n\nThe preceding command creates a new directory called `holidayService`.\nIn this directory is a `src/main/webapp` directory, which contains the root of the WAR file.\nYou can find the standard web application deployment descriptor (`WEB-INF/web.xml`) here, which defines a Spring-WS `MessageDispatcherServlet` and maps all incoming requests to this servlet:\n\n====\n[source,xml,subs=\"verbatim,quotes\"]\n----\n<web-app xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee\n http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"\n version=\"2.4\">\n\n <display-name>MyCompany HR Holiday Service</display-name>\n\n _<!-- take special notice of the name of this servlet -->_\n <servlet>\n <servlet-name>**__spring-ws__**</servlet-name>\n <servlet-class>org.springframework.ws.transport.http.MessageDispatcherServlet</servlet-class>\n </servlet>\n\n <servlet-mapping>\n <servlet-name>spring-ws</servlet-name>\n <url-pattern>/*</url-pattern>\n </servlet-mapping>\n\n</web-app>\n----\n====\n\nIn addition to the preceding `WEB-INF/web.xml` file, you also need another, Spring-WS-specific, configuration file, named `WEB-INF/spring-ws-servlet.xml`.\nThis file contains all the Spring-WS-specific beans, such as `EndPoints` and `WebServiceMessageReceivers` and is used to create a new Spring container.\nThe name of this file is derived from the name of the attendant servlet (in this case `'spring-ws'`) with `-servlet.xml` appended to it.\nSo if you define a `MessageDispatcherServlet` with the name `dynamite`, the name of the Spring-WS-specific configuration file becomes `WEB-INF/dynamite-servlet.xml`.\n\nOnce you had the project structure created, you can put the schema and the WSDL from the previous section into `WEB-INF/` folder.\n\n[[tutorial-implementing-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "Creating the project", "heading_level": 2, "file_order": 7, "section_index": 7, "content_hash": "cae29a95955903c0368b70f69a9ccea1f9554b055b96ba3ee7863281946a479a", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:097af65d090fac6f13ca37b78e1b71989b2540323ff8310b37a260157ca5ef5c", "content": "In Spring-WS, you implement endpoints to handle incoming XML messages.\nAn endpoint is typically created by annotating a class with the `@Endpoint` annotation.\nIn this endpoint class, you can create one or more methods that handle incoming request.\nThe method signatures can be quite flexible.\nYou can include almost any sort of parameter type related to the incoming XML message, as we explain later in this chapter.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "Implementing the Endpoint", "heading_level": 2, "file_order": 7, "section_index": 8, "content_hash": "097af65d090fac6f13ca37b78e1b71989b2540323ff8310b37a260157ca5ef5c", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:5a914075a267de082be5d757c574c743b5a359976b72de72e63032d098e16769", "content": "In this sample application, we use http://www.jdom.org/[JDom 2] to handle the XML message.\nWe also use https://www.w3.org/TR/xpath20/[XPath], because it lets us select particular parts of the XML JDOM tree without requiring strict schema conformance.\n\nThe following listing shows the class that defines our holiday endpoint:\n\n====\n[source,java]\n----\npackage com.mycompany.hr.ws;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Date;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.ws.server.endpoint.annotation.Endpoint;\nimport org.springframework.ws.server.endpoint.annotation.PayloadRoot;\nimport org.springframework.ws.server.endpoint.annotation.RequestPayload;\n\nimport com.mycompany.hr.service.HumanResourceService;\nimport org.jdom2.Element;\nimport org.jdom2.JDOMException;\nimport org.jdom2.Namespace;\nimport org.jdom2.filter.Filters;\nimport org.jdom2.xpath.XPathExpression;\nimport org.jdom2.xpath.XPathFactory;\n\n@Endpoint // <1>\npublic class HolidayEndpoint {\n\n private static final String NAMESPACE_URI = \"http://mycompany.com/hr/schemas\";\n\n private XPathExpression<Element> startDateExpression;\n\n private XPathExpression<Element> endDateExpression;\n\n private XPathExpression<Element> firstNameExpression;\n\n private XPathExpression<Element> lastNameExpression;\n\n private HumanResourceService humanResourceService;\n\n @Autowired // <2>\n public HolidayEndpoint(HumanResourceService humanResourceService) throws JDOMException {\n this.humanResourceService = humanResourceService;\n\n Namespace namespace = Namespace.getNamespace(\"hr\", NAMESPACE_URI);\n XPathFactory xPathFactory = XPathFactory.instance();\n startDateExpression = xPathFactory.compile(\"//hr:StartDate\", Filters.element(), null, namespace);\n endDateExpression = xPathFactory.compile(\"//hr:EndDate\", Filters.element(), null, namespace);\n firstNameExpression = xPathFactory.compile(\"//hr:FirstName\", Filters.element(), null, namespace);\n lastNameExpression = xPathFactory.compile(\"//hr:LastName\", Filters.element(), null, namespace);\n }\n\n @PayloadRoot(namespace = NAMESPACE_URI, localPart = \"HolidayRequest\") // <3>\n public void handleHolidayRequest(@RequestPayload Element holidayRequest) throws Exception {// <4>\n Date startDate = parseDate(startDateExpression, holidayRequest);\n Date endDate = parseDate(endDateExpression, holidayRequest);\n String name = firstNameExpression.evaluateFirst(holidayRequest).getText() + \" \" + lastNameExpression.evaluateFirst(holidayRequest).getText();\n\n humanResourceService.bookHoliday(startDate, endDate, name);\n }\n\n private Date parseDate(XPathExpression<Element> expression, Element element) throws ParseException {\n Element result = expression.evaluateFirst(element);\n if (result != null) {\n SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n return dateFormat.parse(result.getText());\n } else {\n throw new IllegalArgumentException(\"Could not evaluate [\" + expression + \"] on [\" + element + \"]\");\n }\n }\n\n}\n----\n\n<1> The `HolidayEndpoint` is annotated with `@Endpoint`.\nThis marks the class as a special sort of `@Component`, suitable for handling XML messages in Spring-WS, and also makes it eligible for suitable for component scanning.\n<2> The `HolidayEndpoint` requires the `HumanResourceService` business service to operate, so we inject the dependency in the constructor and annotate it with `@Autowired`.\nNext, we set up XPath expressions by using the JDOM2 API.\nThere are four expressions: `//hr:StartDate` for extracting the `<StartDate>` text value, `//hr:EndDate` for extracting the end date, and two for extracting the names of the employee.\n<3> The `@PayloadRoot` annotation tells Spring-WS that the `handleHolidayRequest` method is suitable for handling XML messages.\nThe sort of message that this method can handle is indicated by the annotation values.\nIn this case, it can handle XML elements that have the `HolidayRequest` local part and the `http://mycompany.com/hr/schemas` namespace.\nMore information about mapping messages to endpoints is provided in the next section.\n<4> The `handleHolidayRequest(..)` method is the main handling method, which gets passed the `<HolidayRequest/>` element from the incoming XML message.\nThe `@RequestPayload` annotation indicates that the `holidayRequest` parameter should be mapped to the payload of the request message.\nWe use the XPath expressions to extract the string values from the XML messages and convert these values to `Date` objects by using a `SimpleDateFormat` (the `parseData` method).\nWith these values, we invoke a method on the business service.\nTypically, this results in a database transaction being started and some records being altered in the database.\nFinally, we define a `void` return type, which indicates to Spring-WS that we do not want to send a response message.\nIf we want a response message, we could return a JDOM Element to represent the payload of the response message.\n====\n\nUsing JDOM is just one of the options to handle the XML.\nOther options include DOM, dom4j, XOM, SAX, and StAX, but also marshalling techniques like JAXB, Castor, XMLBeans, JiBX, and XStream, as explained in <<common,the next chapter>>.\nWe chose JDOM because it gives us access to the raw XML and because it is based on classes (not interfaces and factory methods as with W3C DOM and dom4j), which makes the code less verbose.\nWe use XPath because it is less fragile than marshalling technologies.\nWe do not need strict schema conformance as long as we can find the dates and the name.\n\nBecause we use JDOM, we must add some dependencies to the Maven `pom.xml`, which is in the root of our project directory.\nHere is the relevant section of the POM:\n\n====\n[source,xml]\n----\n<dependencies>\n <dependency>\n <groupId>org.springframework.ws</groupId>\n <artifactId>spring-ws-core</artifactId>\n <version></version>\n </dependency>\n <dependency>\n <groupId>jdom</groupId>\n <artifactId>jdom</artifactId>\n <version>2.0.1</version>\n </dependency>\n <dependency>\n <groupId>jaxen</groupId>\n <artifactId>jaxen</artifactId>\n <version>1.1</version>\n </dependency>\n</dependencies>\n----\n====\n\nHere is how we would configure these classes in our `spring-ws-servlet.xml` Spring XML configuration file by using component scanning.\nWe also instruct Spring-WS to use annotation-driven endpoints, with the `<sws:annotation-driven>` element.\n\n====\n[source,xml]\n----\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:context=\"http://www.springframework.org/schema/context\"\n xmlns:sws=\"http://www.springframework.org/schema/web-services\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\n http://www.springframework.org/schema/web-services http://www.springframework.org/schema/web-services/web-services-2.0.xsd\n http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\">\n\n <context:component-scan base-package=\"com.mycompany.hr\"/>\n\n <sws:annotation-driven/>\n\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "Handling the XML Message", "heading_level": 3, "file_order": 7, "section_index": 9, "content_hash": "5a914075a267de082be5d757c574c743b5a359976b72de72e63032d098e16769", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:bed5daa4cf54402b92b8a2c8df28ee5f3d9556ae0b4b462ee2ce2c03f1376681", "content": "As part of writing the endpoint, we also used the `@PayloadRoot` annotation to indicate which sort of messages can be handled by the `handleHolidayRequest` method.\nIn Spring-WS, this process is the responsibility of an `EndpointMapping`.\nHere, we route messages based on their content by using a `PayloadRootAnnotationMethodEndpointMapping`.\nThe following listing shows the annotation we used earlier:\n\n====\n[source,java]\n----\n@PayloadRoot(namespace = \"http://mycompany.com/hr/schemas\", localPart = \"HolidayRequest\")\n----\n====\n\nThe annotation shown in the preceding example basically means that whenever an XML message is received with the namespace `http://mycompany.com/hr/schemas` and the `HolidayRequest` local name, it is routed to the `handleHolidayRequest` method.\nBy using the `<sws:annotation-driven>` element in our configuration, we enable the detection of the `@PayloadRoot` annotations.\nIt is possible (and quite common) to have multiple, related handling methods in an endpoint, each of them handling different XML messages.\n\nThere are other ways to map endpoints to XML messages, which is described in <<common,the next chapter>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "Routing the Message to the Endpoint", "heading_level": 3, "file_order": 7, "section_index": 10, "content_hash": "bed5daa4cf54402b92b8a2c8df28ee5f3d9556ae0b4b462ee2ce2c03f1376681", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:9cdf8b27f54dcdf7765e833651d60252ae73d69ae2c5bdb3de27ffb3d474964d", "content": "Now that we have the endpoint, we need `HumanResourceService` and its implementation for use by `HolidayEndpoint`.\nThe following listing shows the `HumanResourceService` interface:\n\n====\n[source,java]\n----\npackage com.mycompany.hr.service;\n\nimport java.util.Date;\n\npublic interface HumanResourceService {\n void bookHoliday(Date startDate, Date endDate, String name);\n}\n----\n====\n\nFor tutorial purposes, we use a simple stub implementation of the `HumanResourceService`:\n\n====\n[source,java]\n----\npackage com.mycompany.hr.service;\n\nimport java.util.Date;\n\nimport org.springframework.stereotype.Service;\n\n@Service // <1>\npublic class StubHumanResourceService implements HumanResourceService {\n public void bookHoliday(Date startDate, Date endDate, String name) {\n System.out.println(\"Booking holiday for [\" + startDate + \"-\" + endDate + \"] for [\" + name + \"] \");\n }\n}\n----\n\n<1> The `StubHumanResourceService` is annotated with `@Service`.\nThis marks the class as a business facade, which makes this a candidate for injection by `@Autowired` in `HolidayEndpoint`.\n====\n\n[[tutorial-publishing-wsdl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "Providing the Service and Stub implementation", "heading_level": 3, "file_order": 7, "section_index": 11, "content_hash": "9cdf8b27f54dcdf7765e833651d60252ae73d69ae2c5bdb3de27ffb3d474964d", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:fe9993cf8b61f73cb266ec41abd3f2ef7da8057bd503609c0b45e6fb421f4236", "content": "Finally, we need to publish the WSDL.\nAs stated in <<tutorial-service-contract>>, we do not need to write a WSDL ourselves.\nSpring-WS can generate one based on some conventions.\nHere is how we define the generation:\n\n====\n[source,xml]\n----\n<sws:dynamic-wsdl id=\"holiday\" <!--1-->\n portTypeName=\"HumanResource\" <!--3-->\n locationUri=\"/holidayService/\" <!--4-->\n targetNamespace=\"http://mycompany.com/hr/definitions\"> <!--5-->\n <sws:xsd location=\"/WEB-INF/hr.xsd\"/> <!--2-->\n</sws:dynamic-wsdl>\n----\n\n<1> The `id` determines the URL where the WSDL can be retrieved.\nIn this case, the `id` is `holiday`, which means that the WSDL can be retrieved as `holiday.wsdl` in the servlet context.\nThe full URL is `http://localhost:8080/holidayService/holiday.wsdl`.\n<2> Next, we set the WSDL port type to be `HumanResource`.\n<3> We set the location where the service can be reached: `/holidayService/`.\nWe use a relative URI, and we instruct the framework to transform it dynamically to an absolute URI.\nHence, if the service is deployed to different contexts, we do not have to change the URI manually.\nFor more information, see <<server-automatic-wsdl-exposure,the section called \"`Automatic WSDL exposure`\">>.\nFor the location transformation to work, we need to add an init parameter to `spring-ws` servlet in `web.xml` (shown in the next listing).\n<4> We define the target namespace for the WSDL definition itself.\nSetting this attribute is not required.\nIf not set, the WSDL has the same namespace as the XSD schema.\n<5> The `xsd` element refers to the human resource schema we defined in <<tutorial.xsd>>.\nWe placed the schema in the `WEB-INF` directory of the application.\n====\n\nThe following listing shows how to add the init parameter:\n\n====\n[source,xml]\n----\n<init-param>\n <param-name>transformWsdlLocations</param-name>\n <param-value>true</param-value>\n</init-param>\n----\n====\n\nYou can create a WAR file by using `mvn install`.\nIf you deploy the application (to Tomcat, Jetty, and so on) and point your browser at http://localhost:8080/holidayService/holiday.wsdl[this location], you see the generated WSDL.\nThis WSDL is ready to be used by clients, such as http://www.soapui.org/[soapUI] or other SOAP frameworks.\n\nThat concludes this tutorial.\nThe tutorial code can be found in the full distribution of Spring-WS.\nIf you wish to continue, look at the echo sample application that is part of the distribution.\nAfter that, look at the airline sample, which is a bit more complicated, because it uses JAXB, WS-Security, Hibernate, and a transactional service layer.\nFinally, you can read the rest of the reference documentation.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/tutorial.adoc", "title": "tutorial", "heading": "Publishing the WSDL", "heading_level": 2, "file_order": 7, "section_index": 12, "content_hash": "fe9993cf8b61f73cb266ec41abd3f2ef7da8057bd503609c0b45e6fb421f4236", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/tutorial.adoc"}}
{"id": "sha256:7b2fbf5a4008ea0277a4c4863a0a6eef930caa14f97d5b9f0a026b8e83135a61", "content": "[[what-is-spring-ws]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc", "title": "what-is-spring-ws", "heading": "what-is-spring-ws", "heading_level": 1, "file_order": 8, "section_index": 0, "content_hash": "7b2fbf5a4008ea0277a4c4863a0a6eef930caa14f97d5b9f0a026b8e83135a61", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc"}}
{"id": "sha256:7dc84fdd43c3b284dc9376f67b566f27090d747983f93ae5676a1f2e226f618d", "content": "Spring Web Services (Spring-WS) is a product of the Spring community and is focused on creating document-driven web services.\nSpring Web Services aims to facilitate contract-first SOAP service development, allowing for the creation of flexible web services by using one of the many ways to manipulate XML payloads.\nThe product is based on Spring itself, which means you can use the Spring concepts (such as dependency injection) as an integral part of your web service.\n\nPeople use Spring-WS for many reasons, but most are drawn to it after finding alternative SOAP stacks lacking when it comes to following web service best practices.\nSpring-WS makes the best practice an easy practice.\nThis includes practices such as the WS-I basic profile, contract-first development, and having a loose coupling between contract and implementation.\nThe other key features of Spring-WS are:\n\n* <<features-powerful-mappings>>.\n* <<features-xml-api-support>>.\n* <<features-flexible-xml-marshalling>>.\n* <<features-reusing-your-spring-expertise>>.\n* <<features-support-for-ws-security>>.\n* <<features-integration-with-spring-security>>.\n* <<features-apache-license>>.\n\n[[features-powerful-mappings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc", "title": "what-is-spring-ws", "heading": "Introduction", "heading_level": 2, "file_order": 8, "section_index": 1, "content_hash": "7dc84fdd43c3b284dc9376f67b566f27090d747983f93ae5676a1f2e226f618d", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc"}}
{"id": "sha256:9efde1e869de796f22333a36c2d5b8642de0cb0658d0409240b4f0f8b87c469f", "content": "You can distribute incoming XML requests to any object, depending on message payload, SOAP Action header, or an XPath expression.\n\n[[features-xml-api-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc", "title": "what-is-spring-ws", "heading": "Powerful mappings", "heading_level": 3, "file_order": 8, "section_index": 2, "content_hash": "9efde1e869de796f22333a36c2d5b8642de0cb0658d0409240b4f0f8b87c469f", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc"}}
{"id": "sha256:8ee48c92d50f09b5d6599c69991e273e354fb8428765da677e331d68e5380eb6", "content": "Incoming XML messages can be handled not only with standard JAXP APIs such as DOM, SAX, and StAX, but also with JDOM, dom4j, XOM, or even marshalling technologies.\n\n[[features-flexible-xml-marshalling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc", "title": "what-is-spring-ws", "heading": "XML API support", "heading_level": 3, "file_order": 8, "section_index": 3, "content_hash": "8ee48c92d50f09b5d6599c69991e273e354fb8428765da677e331d68e5380eb6", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc"}}
{"id": "sha256:4655c6092d70a3c6c297328c51936b6602959ee4b3e5fe08fcc6f14bc8c2bb18", "content": "Spring-WS builds on the Object/XML Mapping module in the Spring Framework, which supports JAXB 1 and 2, Castor, XMLBeans, JiBX, and XStream.\n\n[[features-reusing-your-spring-expertise]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc", "title": "what-is-spring-ws", "heading": "Flexible XML Marshalling", "heading_level": 3, "file_order": 8, "section_index": 4, "content_hash": "4655c6092d70a3c6c297328c51936b6602959ee4b3e5fe08fcc6f14bc8c2bb18", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc"}}
{"id": "sha256:191c32ce33675245146de72bc4f0239440ff78f43c9aac61558ce21d3635ec54", "content": "Spring-WS uses Spring application contexts for all configuration, which should help Spring developers get up-to-speed quickly.\nAlso, the architecture of Spring-WS resembles that of Spring-MVC.\n\n[[features-support-for-ws-security]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc", "title": "what-is-spring-ws", "heading": "Reusing Your Spring expertise", "heading_level": 3, "file_order": 8, "section_index": 5, "content_hash": "191c32ce33675245146de72bc4f0239440ff78f43c9aac61558ce21d3635ec54", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc"}}
{"id": "sha256:6e2e1f51bb418335bf84326362e1a94d1e47ca878ab24155c476cf50458337b6", "content": "WS-Security lets you sign SOAP messages, encrypt and decrypt them, or authenticate against them.\n\n[[features-integration-with-spring-security]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc", "title": "what-is-spring-ws", "heading": "Support for WS-Security", "heading_level": 3, "file_order": 8, "section_index": 6, "content_hash": "6e2e1f51bb418335bf84326362e1a94d1e47ca878ab24155c476cf50458337b6", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc"}}
{"id": "sha256:0c3d2d22ee104bf08068e77d79c48f45f22f7203369db476aadf3afb3996e624", "content": "The WS-Security implementation of Spring-WS provides integration with Spring Security.\nThis means you can use your existing Spring Security configuration for your SOAP service as well.\n\n[[features-apache-license]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc", "title": "what-is-spring-ws", "heading": "Integration with Spring Security", "heading_level": 3, "file_order": 8, "section_index": 7, "content_hash": "0c3d2d22ee104bf08068e77d79c48f45f22f7203369db476aadf3afb3996e624", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc"}}
{"id": "sha256:3ca8572446654c441a404121372110be8f9cfd28061e7957015565563cc69e40", "content": "You can confidently use Spring-WS in your project.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc", "title": "what-is-spring-ws", "heading": "Apache license", "heading_level": 3, "file_order": 8, "section_index": 8, "content_hash": "3ca8572446654c441a404121372110be8f9cfd28061e7957015565563cc69e40", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc"}}
{"id": "sha256:e5d7c78ad079c8d5d4445289838961dae32d736dee53ade9d11ba52fa1e62acf", "content": "Spring-WS requires a standard Java 17 Runtime Environment.\nSpring-WS is built on Spring Framework 6.x.\n\nSpring-WS consists of a number of modules, which are described in the remainder of this section.\n\n* The XML module (`spring-xml`) contains various XML support classes for Spring-WS.\nThis module is mainly intended for the Spring-WS framework itself and not web service developers.\n* The Core module (`spring-ws-core`) is the central part of the Spring's web services functionality.\nIt provides the central <<web-service-messages,`WebServiceMessage`>> and <<soap-message,`SoapMessage`>> interfaces, the <<server,server-side>> framework (with powerful message dispatching), the various support classes for implementing web service endpoints, and the <<client,client-side>> `WebServiceTemplate`.\n* The Support module (`spring-ws-support`) contains additional transports (JMS, Email, and others).\n* The <<security,Security>> module (`spring-ws-security`) provides a WS-Security implementation that integrates with the core web service package.\nIt lets you sign, decrypt and encrypt, and add principal tokens to SOAP messages.\nAdditionally, it lets you use your existing Spring Security implementation for authentication and authorization.\n\nThe following figure shows and the dependencies between the Spring-WS modules.\nArrows indicate dependencies (that is, Spring-WS Core depends on Spring-XML and the Spring OXM).\n\nimage::images/spring-deps.png[align=\"center\"]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc", "title": "what-is-spring-ws", "heading": "Runtime environment", "heading_level": 2, "file_order": 8, "section_index": 9, "content_hash": "e5d7c78ad079c8d5d4445289838961dae32d736dee53ade9d11ba52fa1e62acf", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc"}}
{"id": "sha256:59cf1762ce3333d218bc7a10483c34e6aa21a44a3fd86c9ad14cfb06d571f553", "content": "Spring-WS supports the following standards:\n\n* SOAP 1.1 and 1.2.\n* WSDL 1.1 and 2.0 (XSD-based generation is supported only for WSDL 1.1).\n* WS-I Basic Profile 1.0, 1.1, 1.2, and 2.0.\n* WS-Addressing 1.0 and the August 2004 draft.\n* SOAP Message Security 1.1, Username Token Profile 1.1, X.509 Certificate Token Profile 1.1, SAML Token Profile 1.1, Kerberos Token Profile 1.1, Basic Security Profile 1.1.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc", "title": "what-is-spring-ws", "heading": "Supported standards", "heading_level": 2, "file_order": 8, "section_index": 10, "content_hash": "59cf1762ce3333d218bc7a10483c34e6aa21a44a3fd86c9ad14cfb06d571f553", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/what-is-spring-ws.adoc"}}
{"id": "sha256:b3a454724fa3fbf0aae3636d2b6190493fff52708791364f7a79fb015a379326", "content": "[[why-contract-first]]\n\nWhen creating web services, there are two development styles: contract-last and contract-first.\nWhen you use a contract-last approach, you start with the Java code and let the web service contract (in WSDL -- see sidebar) be generated from that.\nWhen using contract-first, you start with the WSDL contract and use Java to implement the contract.\n\n.What is WSDL?\n****\nWSDL stands for Web Service Description Language.\nA WSDL file is an XML document that describes a web service.\nIt specifies the location of the service and the operations (or methods) the service exposes.\nFor more information about WSDL, see the https://www.w3.org/TR/wsdl[WSDL specification].\n****\n\nSpring-WS supports only the contract-first development style, and this section explains why.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc", "title": "why-contract-first", "heading": "why-contract-first", "heading_level": 1, "file_order": 9, "section_index": 0, "content_hash": "b3a454724fa3fbf0aae3636d2b6190493fff52708791364f7a79fb015a379326", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc"}}
{"id": "sha256:3c6ca7d12a146005803c09f81dd67c976b07dc5db6d80435869726daf0a96343", "content": "Similar to the field of ORM, where we have an https://en.wikipedia.org/wiki/Object-Relational_impedance_mismatch[Object/Relational impedance mismatch], converting Java objects to XML has a similar problem.\nAt first glance, the O/X mapping problem appears simple: Create an XML element for each Java object to convert all Java properties and fields to sub-elements or attributes.\nHowever, things are not as simple as they appear, because there is a fundamental difference between hierarchical languages, such as XML (and especially XSD), and the graph model of Java.\n\nNOTE: Most of the contents in this section were inspired by <<alpine>> and <<effective-enterprise-java>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc", "title": "why-contract-first", "heading": "Object/XML Impedance Mismatch", "heading_level": 2, "file_order": 9, "section_index": 1, "content_hash": "3c6ca7d12a146005803c09f81dd67c976b07dc5db6d80435869726daf0a96343", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc"}}
{"id": "sha256:4991cc290fc62348fae4d5d3c24c33ac5777bc390ef80e680caf8c0d32b9ce98", "content": "In Java, the only way to change the behavior of a class is to subclass it to add the new behavior to that subclass.\nIn XSD, you can extend a data type by restricting it -- that is, constraining the valid values for the elements and attributes.\nFor instance, consider the following example:\n\n[source,xml]\n----\n<simpleType name=\"AirportCode\">\n <restriction base=\"string\">\n <pattern value=\"[A-Z][A-Z][A-Z]\"/>\n </restriction>\n</simpleType>\n----\n\nThis type restricts a XSD string by way of a regular expression, allowing only three upper case letters.\nIf this type is converted to Java, we end up with an ordinary `java.lang.String`.\nThe regular expression is lost in the conversion process, because Java does not allow for these sorts of extensions.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc", "title": "why-contract-first", "heading": "XSD Extensions", "heading_level": 3, "file_order": 9, "section_index": 2, "content_hash": "4991cc290fc62348fae4d5d3c24c33ac5777bc390ef80e680caf8c0d32b9ce98", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc"}}
{"id": "sha256:19c820468d16f846515834a904fc48e9e2f41a68d490e96a2c0616fd18759a41", "content": "One of the most important goals of a web service is to be interoperable: to support multiple platforms such as Java, .NET, Python, and others.\nBecause all of these languages have different class libraries, you must use some common, cross-language format to communicate between them.\nThat format is XML, which is supported by all of these languages.\n\nBecause of this conversion, you must make sure that you use portable types in your service implementation.\nConsider, for example, a service that returns a `java.util.TreeMap`:\n\n====\n[source,java]\n----\npublic Map getFlights() {\n // use a tree map, to make sure it's sorted\n TreeMap map = new TreeMap();\n map.put(\"KL1117\", \"Stockholm\");\n ...\n return map;\n}\n----\n====\n\nUndoubtedly, the contents of this map can be converted into some sort of XML, but since there is no standard way to describe a map in XML, it will be proprietary.\nAlso, even if it can be converted to XML, many platforms do not have a data structure similar to the `TreeMap`.\nSo when a .NET client accesses your web service, it probably ends up with a `System.Collections.Hashtable`, which has different semantics.\n\nThis problem is also present when working on the client side.\nConsider the following XSD snippet, which describes a service contract:\n\n====\n[source,xml]\n----\n<element name=\"GetFlightsRequest\">\n <complexType>\n <all>\n <element name=\"departureDate\" type=\"date\"/>\n <element name=\"from\" type=\"string\"/>\n <element name=\"to\" type=\"string\"/>\n </all>\n </complexType>\n</element>\n----\n====\n\nThis contract defines a request that takes an `date`, which is a XSD datatype representing a year, month, and day.\nIf we call this service from Java, we probably use either a `java.time.LocalDateTime` or `java.time.Instant`.\nHowever, both of these classes actually describe times, rather than dates.\nSo, we actually end up sending data that represents the fourth of April 2007 at midnight (`2007-04-04T00:00:00`), which is not the same as `2007-04-04`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc", "title": "why-contract-first", "heading": "Unportable Types", "heading_level": 3, "file_order": 9, "section_index": 3, "content_hash": "19c820468d16f846515834a904fc48e9e2f41a68d490e96a2c0616fd18759a41", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc"}}
{"id": "sha256:57a9238bd4011f86ae015773edcb0162fab6756306593b480c9b7f48e490e6b2", "content": "Imagine we have the following class structure:\n\n====\n[source,java]\n----\npublic class Flight {\n private String number;\n private List<Passenger> passengers;\n\n // getters and setters omitted\n}\n\npublic class Passenger {\n private String name;\n private Flight flight;\n\n // getters and setters omitted\n}\n----\n====\n\nThis is a cyclic graph: the `Flight` refers to the `Passenger`, which refers to the `Flight` again.\nCyclic graphs like these are quite common in Java.\nIf we take a naive approach to converting this to XML, we end up with something like:\n\n====\n[source,xml]\n----\n<flight number=\"KL1117\">\n <passengers>\n <passenger>\n <name>Arjen Poutsma</name>\n <flight number=\"KL1117\">\n <passengers>\n <passenger>\n <name>Arjen Poutsma</name>\n <flight number=\"KL1117\">\n <passengers>\n <passenger>\n <name>Arjen Poutsma</name>\n ...\n----\n====\n\nProcessing such a structure is likely to take a long time to finish, because there is no stop condition for this loop.\n\nOne way to solve this problem is to use references to objects that were already marshalled:\n\n====\n[source,xml]\n----\n<flight number=\"KL1117\">\n <passengers>\n <passenger>\n <name>Arjen Poutsma</name>\n <flight href=\"KL1117\" />\n </passenger>\n ...\n </passengers>\n</flight>\n----\n====\n\nThis solves the recursion problem but introduces new ones.\nFor one, you cannot use an XML validator to validate this structure.\nAnother issue is that the standard way to use these references in SOAP (RPC/encoded) has been deprecated in favor of document/literal (see the WS-I http://www.ws-i.org/Profiles/BasicProfile-1.1.html#SOAP_encodingStyle_Attribute[Basic Profile]).\n\nThese are just a few of the problems when dealing with O/X mapping.\nIt is important to respect these issues when writing web services.\nThe best way to respect them is to focus on the XML completely, while using Java as an implementation language.\nThis is what contract-first is all about.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc", "title": "why-contract-first", "heading": "Cyclic Graphs", "heading_level": 3, "file_order": 9, "section_index": 4, "content_hash": "57a9238bd4011f86ae015773edcb0162fab6756306593b480c9b7f48e490e6b2", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc"}}
{"id": "sha256:171aeb000cd9c0938f3db2aeb20dd5cb274c1aeca89d09fd5c74ce5ad5a5a496", "content": "Besides the Object/XML Mapping issues mentioned in the previous section, there are other reasons for preferring a contract-first development style.\n\n* <<contract-first-fragility>>.\n* <<contract-first-performance>>.\n* <<contract-first-reusability>>.\n* <<contract-first-versioning>>.\n\n[[contract-first-fragility]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc", "title": "why-contract-first", "heading": "Contract-first Versus Contract-last", "heading_level": 2, "file_order": 9, "section_index": 5, "content_hash": "171aeb000cd9c0938f3db2aeb20dd5cb274c1aeca89d09fd5c74ce5ad5a5a496", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc"}}
{"id": "sha256:427e1c2aa959410e083825b32814627287ac60bd985c18811104f903524239a0", "content": "As mentioned earlier, the contract-last development style results in your web service contract (WSDL and your XSD) being generated from your Java contract (usually an interface).\nIf you use this approach, you have no guarantee that the contract stays constant over time.\nEach time you change your Java contract and redeploy it, there might be subsequent changes to the web service contract.\n\nAdditionally, not all SOAP stacks generate the same web service contract from a Java contract.\nThis means that changing your current SOAP stack for a different one (for whatever reason) might also change your web service contract.\n\nWhen a web service contract changes, users of the contract have to be instructed to obtain the new contract and potentially change their code to accommodate for any changes in the contract.\n\nFor a contract to be useful, it must remain constant for as long as possible.\nIf a contract changes, you have to contact all the users of your service and instruct them to get the new version of the contract.\n\n[[contract-first-performance]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc", "title": "why-contract-first", "heading": "Fragility", "heading_level": 3, "file_order": 9, "section_index": 6, "content_hash": "427e1c2aa959410e083825b32814627287ac60bd985c18811104f903524239a0", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc"}}
{"id": "sha256:47c1a9716b24c62d18b9d28b12db0322387b4e7114fd1e8a672522143a115044", "content": "When a Java object is automatically transformed into XML, there is no way to be sure as to what is sent across the wire.\nAn object might reference another object, which refers to another, and so on.\nIn the end, half of the objects on the heap in your virtual machine might be converted into XML, which results in slow response times.\n\nWhen using contract-first, you explicitly describe what XML is sent where, thus making sure that it is exactly what you want.\n\n[[contract-first-reusability]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc", "title": "why-contract-first", "heading": "Performance", "heading_level": 3, "file_order": 9, "section_index": 7, "content_hash": "47c1a9716b24c62d18b9d28b12db0322387b4e7114fd1e8a672522143a115044", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc"}}
{"id": "sha256:36c44aac91986c8ab1bc62636b89e66bec96fec2f05d43feca458eba8e7bd763", "content": "Defining your schema in a separate file lets you reuse that file in different scenarios.\nConsider the definition of an `AirportCode` in a file called `airline.xsd`:\n\n====\n[source,xml]\n----\n<simpleType name=\"AirportCode\">\n <restriction base=\"string\">\n <pattern value=\"[A-Z][A-Z][A-Z]\"/>\n </restriction>\n</simpleType>\n----\n====\n\nYou can reuse this definition in other schemas, or even WSDL files, by using an `import` statement.\n\n[[contract-first-versioning]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc", "title": "why-contract-first", "heading": "Reusability", "heading_level": 3, "file_order": 9, "section_index": 8, "content_hash": "36c44aac91986c8ab1bc62636b89e66bec96fec2f05d43feca458eba8e7bd763", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc"}}
{"id": "sha256:1ac85e92b8b72b4e41ba35d1f56cfa2059ee9ee67f40012476e050750a651021", "content": "Even though a contract must remain constant for as long as possible, they do need to be changed sometimes.\nIn Java, this typically results in a new Java interface, such as `AirlineService2`, and a (new) implementation of that interface.\nOf course, the old service must be kept around, because there might be clients who have not yet migrated.\n\nIf using contract-first, we can have a looser coupling between contract and implementation.\nSuch a looser coupling lets us implement both versions of the contract in one class.\nWe could, for instance, use an XSLT stylesheet to convert any \"`old-style`\" messages to the \"`new-style`\" messages.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-ws", "path": "spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc", "title": "why-contract-first", "heading": "Versioning", "heading_level": 3, "file_order": 9, "section_index": 9, "content_hash": "1ac85e92b8b72b4e41ba35d1f56cfa2059ee9ee67f40012476e050750a651021", "source_url": "https://github.com/spring-projects/spring-ws/blob/d2e2d3f3d660b4c70537371ee909403383c11a32/spring-ws-docs/src/docs/asciidoc/why-contract-first.adoc"}}
